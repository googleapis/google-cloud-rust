// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Note kind that represents a logical attestation "role" or "authority". For
/// example, an organization might have one `Authority` for "QA" and one for
/// "build". This note is intended to act strictly as a grouping mechanism for
/// the attached occurrences (Attestations). This grouping mechanism also
/// provides a security boundary, since IAM ACLs gate the ability for a principle
/// to attach an occurrence to a given note. It also provides a single point of
/// lookup to find all attached attestation occurrences, even if they don't all
/// live in the same project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttestationNote {
    /// Hint hints at the purpose of the attestation authority.
    pub hint: std::option::Option<crate::model::attestation_note::Hint>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttestationNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hint][crate::model::AttestationNote::hint].
    pub fn set_hint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attestation_note::Hint>,
    {
        self.hint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hint][crate::model::AttestationNote::hint].
    pub fn set_or_clear_hint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attestation_note::Hint>,
    {
        self.hint = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AttestationNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.AttestationNote"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttestationNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttestationNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hint" => Ok(__FieldTag::__hint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttestationNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttestationNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hint => {
                            if !fields.insert(__FieldTag::__hint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hint",
                                ));
                            }
                            result.hint = map.next_value::<std::option::Option<crate::model::attestation_note::Hint>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttestationNote {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.hint.is_some() {
            state.serialize_entry("hint", &self.hint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AttestationNote].
pub mod attestation_note {
    #[allow(unused_imports)]
    use super::*;

    /// This submessage provides human-readable hints about the purpose of the
    /// authority. Because the name of a note acts as its resource reference, it is
    /// important to disambiguate the canonical name of the Note (which might be a
    /// UUID for security purposes) from "readable" names more suitable for debug
    /// output. Note that these hints should not be used to look up authorities in
    /// security sensitive contexts, such as when looking up attestations to
    /// verify.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Hint {
        /// Required. The human readable name of this attestation authority, for
        /// example "qa".
        pub human_readable_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Hint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [human_readable_name][crate::model::attestation_note::Hint::human_readable_name].
        pub fn set_human_readable_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.human_readable_name = v.into();
            self
        }
    }

    impl wkt::message::Message for Hint {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.AttestationNote.Hint"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Hint {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __human_readable_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Hint")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "humanReadableName" => Ok(__FieldTag::__human_readable_name),
                                "human_readable_name" => Ok(__FieldTag::__human_readable_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Hint;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Hint")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__human_readable_name => {
                                if !fields.insert(__FieldTag::__human_readable_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for human_readable_name",
                                    ));
                                }
                                result.human_readable_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Hint {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.human_readable_name.is_empty() {
                state.serialize_entry("humanReadableName", &self.human_readable_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Jwt {
    /// The compact encoding of a JWS, which is always three base64 encoded strings
    /// joined by periods. For details, see:
    /// <https://tools.ietf.org/html/rfc7515.html#section-3.1>
    pub compact_jwt: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Jwt {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [compact_jwt][crate::model::Jwt::compact_jwt].
    pub fn set_compact_jwt<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compact_jwt = v.into();
        self
    }
}

impl wkt::message::Message for Jwt {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Jwt"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Jwt {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __compact_jwt,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Jwt")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "compactJwt" => Ok(__FieldTag::__compact_jwt),
                            "compact_jwt" => Ok(__FieldTag::__compact_jwt),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Jwt;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Jwt")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__compact_jwt => {
                            if !fields.insert(__FieldTag::__compact_jwt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compact_jwt",
                                ));
                            }
                            result.compact_jwt = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Jwt {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.compact_jwt.is_empty() {
            state.serialize_entry("compactJwt", &self.compact_jwt)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Occurrence that represents a single "attestation". The authenticity of an
/// attestation can be verified using the attached signature. If the verifier
/// trusts the public key of the signer, then verifying the signature is
/// sufficient to establish trust. In this circumstance, the authority to which
/// this attestation is attached is primarily useful for lookup (how to find
/// this attestation if you already know the authority and artifact to be
/// verified) and intent (for which authority this attestation was intended to
/// sign.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttestationOccurrence {
    /// Required. The serialized payload that is verified by one or more
    /// `signatures`.
    pub serialized_payload: ::bytes::Bytes,

    /// One or more signatures over `serialized_payload`.  Verifier implementations
    /// should consider this attestation message verified if at least one
    /// `signature` verifies `serialized_payload`.  See `Signature` in common.proto
    /// for more details on signature structure and verification.
    pub signatures: std::vec::Vec<crate::model::Signature>,

    /// One or more JWTs encoding a self-contained attestation.
    /// Each JWT encodes the payload that it verifies within the JWT itself.
    /// Verifier implementation SHOULD ignore the `serialized_payload` field
    /// when verifying these JWTs.
    /// If only JWTs are present on this AttestationOccurrence, then the
    /// `serialized_payload` SHOULD be left empty.
    /// Each JWT SHOULD encode a claim specific to the `resource_uri` of this
    /// Occurrence, but this is not validated by Grafeas metadata API
    /// implementations.  The JWT itself is opaque to Grafeas.
    pub jwts: std::vec::Vec<crate::model::Jwt>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttestationOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [serialized_payload][crate::model::AttestationOccurrence::serialized_payload].
    pub fn set_serialized_payload<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.serialized_payload = v.into();
        self
    }

    /// Sets the value of [signatures][crate::model::AttestationOccurrence::signatures].
    pub fn set_signatures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Signature>,
    {
        use std::iter::Iterator;
        self.signatures = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jwts][crate::model::AttestationOccurrence::jwts].
    pub fn set_jwts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Jwt>,
    {
        use std::iter::Iterator;
        self.jwts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AttestationOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.AttestationOccurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttestationOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __serialized_payload,
            __signatures,
            __jwts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttestationOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serializedPayload" => Ok(__FieldTag::__serialized_payload),
                            "serialized_payload" => Ok(__FieldTag::__serialized_payload),
                            "signatures" => Ok(__FieldTag::__signatures),
                            "jwts" => Ok(__FieldTag::__jwts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttestationOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttestationOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__serialized_payload => {
                            if !fields.insert(__FieldTag::__serialized_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serialized_payload",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.serialized_payload =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__signatures => {
                            if !fields.insert(__FieldTag::__signatures) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signatures",
                                ));
                            }
                            result.signatures = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Signature>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__jwts => {
                            if !fields.insert(__FieldTag::__jwts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jwts",
                                ));
                            }
                            result.jwts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Jwt>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttestationOccurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.serialized_payload.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("serializedPayload", &__With(&self.serialized_payload))?;
        }
        if !self.signatures.is_empty() {
            state.serialize_entry("signatures", &self.signatures)?;
        }
        if !self.jwts.is_empty() {
            state.serialize_entry("jwts", &self.jwts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Note holding the version of the provider's builder and the signature of the
/// provenance message in the build details occurrence.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildNote {
    /// Required. Immutable. Version of the builder which produced this build.
    pub builder_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builder_version][crate::model::BuildNote::builder_version].
    pub fn set_builder_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.builder_version = v.into();
        self
    }
}

impl wkt::message::Message for BuildNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BuildNote"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BuildNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __builder_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "builderVersion" => Ok(__FieldTag::__builder_version),
                            "builder_version" => Ok(__FieldTag::__builder_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BuildNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__builder_version => {
                            if !fields.insert(__FieldTag::__builder_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builder_version",
                                ));
                            }
                            result.builder_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BuildNote {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.builder_version.is_empty() {
            state.serialize_entry("builderVersion", &self.builder_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details of a build occurrence.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildOccurrence {
    /// The actual provenance for the build.
    pub provenance: std::option::Option<crate::model::BuildProvenance>,

    /// Serialized JSON representation of the provenance, used in generating the
    /// build signature in the corresponding build note. After verifying the
    /// signature, `provenance_bytes` can be unmarshalled and compared to the
    /// provenance to confirm that it is unchanged. A base64-encoded string
    /// representation of the provenance bytes is used for the signature in order
    /// to interoperate with openssl which expects this format for signature
    /// verification.
    ///
    /// The serialized form is captured both to avoid ambiguity in how the
    /// provenance is marshalled to json as well to prevent incompatibilities with
    /// future changes.
    pub provenance_bytes: std::string::String,

    /// Deprecated. See InTotoStatement for the replacement.
    /// In-toto Provenance representation as defined in spec.
    pub intoto_provenance: std::option::Option<crate::model::InTotoProvenance>,

    /// In-toto Statement representation as defined in spec.
    /// The intoto_statement can contain any type of provenance. The serialized
    /// payload of the statement can be stored and signed in the Occurrence's
    /// envelope.
    pub intoto_statement: std::option::Option<crate::model::InTotoStatement>,

    /// In-Toto Slsa Provenance V1 represents a slsa provenance meeting the slsa
    /// spec, wrapped in an in-toto statement. This allows for direct
    /// jsonification of a to-spec in-toto slsa statement with a to-spec
    /// slsa provenance.
    pub in_toto_slsa_provenance_v1: std::option::Option<crate::model::InTotoSlsaProvenanceV1>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provenance][crate::model::BuildOccurrence::provenance].
    pub fn set_provenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuildProvenance>,
    {
        self.provenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provenance][crate::model::BuildOccurrence::provenance].
    pub fn set_or_clear_provenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuildProvenance>,
    {
        self.provenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provenance_bytes][crate::model::BuildOccurrence::provenance_bytes].
    pub fn set_provenance_bytes<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.provenance_bytes = v.into();
        self
    }

    /// Sets the value of [intoto_provenance][crate::model::BuildOccurrence::intoto_provenance].
    pub fn set_intoto_provenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InTotoProvenance>,
    {
        self.intoto_provenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intoto_provenance][crate::model::BuildOccurrence::intoto_provenance].
    pub fn set_or_clear_intoto_provenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InTotoProvenance>,
    {
        self.intoto_provenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [intoto_statement][crate::model::BuildOccurrence::intoto_statement].
    pub fn set_intoto_statement<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InTotoStatement>,
    {
        self.intoto_statement = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intoto_statement][crate::model::BuildOccurrence::intoto_statement].
    pub fn set_or_clear_intoto_statement<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InTotoStatement>,
    {
        self.intoto_statement = v.map(|x| x.into());
        self
    }

    /// Sets the value of [in_toto_slsa_provenance_v1][crate::model::BuildOccurrence::in_toto_slsa_provenance_v1].
    pub fn set_in_toto_slsa_provenance_v1<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InTotoSlsaProvenanceV1>,
    {
        self.in_toto_slsa_provenance_v1 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [in_toto_slsa_provenance_v1][crate::model::BuildOccurrence::in_toto_slsa_provenance_v1].
    pub fn set_or_clear_in_toto_slsa_provenance_v1<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InTotoSlsaProvenanceV1>,
    {
        self.in_toto_slsa_provenance_v1 = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BuildOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BuildOccurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BuildOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __provenance,
            __provenance_bytes,
            __intoto_provenance,
            __intoto_statement,
            __in_toto_slsa_provenance_v1,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "provenance" => Ok(__FieldTag::__provenance),
                            "provenanceBytes" => Ok(__FieldTag::__provenance_bytes),
                            "provenance_bytes" => Ok(__FieldTag::__provenance_bytes),
                            "intotoProvenance" => Ok(__FieldTag::__intoto_provenance),
                            "intoto_provenance" => Ok(__FieldTag::__intoto_provenance),
                            "intotoStatement" => Ok(__FieldTag::__intoto_statement),
                            "intoto_statement" => Ok(__FieldTag::__intoto_statement),
                            "inTotoSlsaProvenanceV1" => {
                                Ok(__FieldTag::__in_toto_slsa_provenance_v1)
                            }
                            "in_toto_slsa_provenance_v1" => {
                                Ok(__FieldTag::__in_toto_slsa_provenance_v1)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BuildOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__provenance => {
                            if !fields.insert(__FieldTag::__provenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provenance",
                                ));
                            }
                            result.provenance = map
                                .next_value::<std::option::Option<crate::model::BuildProvenance>>(
                                )?;
                        }
                        __FieldTag::__provenance_bytes => {
                            if !fields.insert(__FieldTag::__provenance_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provenance_bytes",
                                ));
                            }
                            result.provenance_bytes = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intoto_provenance => {
                            if !fields.insert(__FieldTag::__intoto_provenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intoto_provenance",
                                ));
                            }
                            result.intoto_provenance = map
                                .next_value::<std::option::Option<crate::model::InTotoProvenance>>(
                                )?;
                        }
                        __FieldTag::__intoto_statement => {
                            if !fields.insert(__FieldTag::__intoto_statement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intoto_statement",
                                ));
                            }
                            result.intoto_statement = map
                                .next_value::<std::option::Option<crate::model::InTotoStatement>>(
                                )?;
                        }
                        __FieldTag::__in_toto_slsa_provenance_v1 => {
                            if !fields.insert(__FieldTag::__in_toto_slsa_provenance_v1) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for in_toto_slsa_provenance_v1",
                                ));
                            }
                            result.in_toto_slsa_provenance_v1 = map.next_value::<std::option::Option<crate::model::InTotoSlsaProvenanceV1>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BuildOccurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.provenance.is_some() {
            state.serialize_entry("provenance", &self.provenance)?;
        }
        if !self.provenance_bytes.is_empty() {
            state.serialize_entry("provenanceBytes", &self.provenance_bytes)?;
        }
        if self.intoto_provenance.is_some() {
            state.serialize_entry("intotoProvenance", &self.intoto_provenance)?;
        }
        if self.intoto_statement.is_some() {
            state.serialize_entry("intotoStatement", &self.intoto_statement)?;
        }
        if self.in_toto_slsa_provenance_v1.is_some() {
            state.serialize_entry("inTotoSlsaProvenanceV1", &self.in_toto_slsa_provenance_v1)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for any related URL information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RelatedUrl {
    /// Specific URL associated with the resource.
    pub url: std::string::String,

    /// Label to describe usage of the URL.
    pub label: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedUrl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::RelatedUrl::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [label][crate::model::RelatedUrl::label].
    pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label = v.into();
        self
    }
}

impl wkt::message::Message for RelatedUrl {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.RelatedUrl"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RelatedUrl {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url,
            __label,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RelatedUrl")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "url" => Ok(__FieldTag::__url),
                            "label" => Ok(__FieldTag::__label),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RelatedUrl;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RelatedUrl")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__label => {
                            if !fields.insert(__FieldTag::__label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label",
                                ));
                            }
                            result.label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RelatedUrl {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.url.is_empty() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self.label.is_empty() {
            state.serialize_entry("label", &self.label)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Verifiers (e.g. Kritis implementations) MUST verify signatures
/// with respect to the trust anchors defined in policy (e.g. a Kritis policy).
/// Typically this means that the verifier has been configured with a map from
/// `public_key_id` to public key material (and any required parameters, e.g.
/// signing algorithm).
///
/// In particular, verification implementations MUST NOT treat the signature
/// `public_key_id` as anything more than a key lookup hint. The `public_key_id`
/// DOES NOT validate or authenticate a public key; it only provides a mechanism
/// for quickly selecting a public key ALREADY CONFIGURED on the verifier through
/// a trusted channel. Verification implementations MUST reject signatures in any
/// of the following circumstances:
///
/// * The `public_key_id` is not recognized by the verifier.
/// * The public key that `public_key_id` refers to does not verify the
///   signature with respect to the payload.
///
/// The `signature` contents SHOULD NOT be "attached" (where the payload is
/// included with the serialized `signature` bytes). Verifiers MUST ignore any
/// "attached" payload and only verify signatures with respect to explicitly
/// provided payload (e.g. a `payload` field on the proto message that holds
/// this Signature, or the canonical serialization of the proto message that
/// holds this signature).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Signature {
    /// The content of the signature, an opaque bytestring.
    /// The payload that this signature verifies MUST be unambiguously provided
    /// with the Signature during verification. A wrapper message might provide
    /// the payload explicitly. Alternatively, a message might have a canonical
    /// serialization that can always be unambiguously computed to derive the
    /// payload.
    pub signature: ::bytes::Bytes,

    /// The identifier for the public key that verifies this signature.
    ///
    /// * The `public_key_id` is required.
    /// * The `public_key_id` SHOULD be an RFC3986 conformant URI.
    /// * When possible, the `public_key_id` SHOULD be an immutable reference,
    ///   such as a cryptographic digest.
    ///
    /// Examples of valid `public_key_id`s:
    ///
    /// OpenPGP V4 public key fingerprint:
    ///
    /// * "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA"
    ///   See <https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr> for more
    ///   details on this scheme.
    ///
    /// RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
    /// serialization):
    ///
    /// * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU"
    /// * "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
    pub public_key_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Signature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [signature][crate::model::Signature::signature].
    pub fn set_signature<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.signature = v.into();
        self
    }

    /// Sets the value of [public_key_id][crate::model::Signature::public_key_id].
    pub fn set_public_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key_id = v.into();
        self
    }
}

impl wkt::message::Message for Signature {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Signature"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Signature {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __signature,
            __public_key_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Signature")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "signature" => Ok(__FieldTag::__signature),
                            "publicKeyId" => Ok(__FieldTag::__public_key_id),
                            "public_key_id" => Ok(__FieldTag::__public_key_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Signature;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Signature")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__signature => {
                            if !fields.insert(__FieldTag::__signature) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signature",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.signature = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__public_key_id => {
                            if !fields.insert(__FieldTag::__public_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key_id",
                                ));
                            }
                            result.public_key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Signature {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.signature.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("signature", &__With(&self.signature))?;
        }
        if !self.public_key_id.is_empty() {
            state.serialize_entry("publicKeyId", &self.public_key_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// MUST match
/// <https://github.com/secure-systems-lab/dsse/blob/master/envelope.proto>. An
/// authenticated message of arbitrary type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Envelope {
    pub payload: ::bytes::Bytes,

    pub payload_type: std::string::String,

    pub signatures: std::vec::Vec<crate::model::EnvelopeSignature>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Envelope {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [payload][crate::model::Envelope::payload].
    pub fn set_payload<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.payload = v.into();
        self
    }

    /// Sets the value of [payload_type][crate::model::Envelope::payload_type].
    pub fn set_payload_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload_type = v.into();
        self
    }

    /// Sets the value of [signatures][crate::model::Envelope::signatures].
    pub fn set_signatures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvelopeSignature>,
    {
        use std::iter::Iterator;
        self.signatures = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Envelope {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Envelope"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Envelope {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __payload,
            __payload_type,
            __signatures,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Envelope")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "payload" => Ok(__FieldTag::__payload),
                            "payloadType" => Ok(__FieldTag::__payload_type),
                            "payload_type" => Ok(__FieldTag::__payload_type),
                            "signatures" => Ok(__FieldTag::__signatures),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Envelope;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Envelope")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.payload = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__payload_type => {
                            if !fields.insert(__FieldTag::__payload_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload_type",
                                ));
                            }
                            result.payload_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__signatures => {
                            if !fields.insert(__FieldTag::__signatures) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signatures",
                                ));
                            }
                            result.signatures =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EnvelopeSignature>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Envelope {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.payload.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("payload", &__With(&self.payload))?;
        }
        if !self.payload_type.is_empty() {
            state.serialize_entry("payloadType", &self.payload_type)?;
        }
        if !self.signatures.is_empty() {
            state.serialize_entry("signatures", &self.signatures)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnvelopeSignature {
    pub sig: ::bytes::Bytes,

    pub keyid: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnvelopeSignature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sig][crate::model::EnvelopeSignature::sig].
    pub fn set_sig<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.sig = v.into();
        self
    }

    /// Sets the value of [keyid][crate::model::EnvelopeSignature::keyid].
    pub fn set_keyid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.keyid = v.into();
        self
    }
}

impl wkt::message::Message for EnvelopeSignature {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.EnvelopeSignature"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnvelopeSignature {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sig,
            __keyid,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnvelopeSignature")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sig" => Ok(__FieldTag::__sig),
                            "keyid" => Ok(__FieldTag::__keyid),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnvelopeSignature;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnvelopeSignature")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sig => {
                            if !fields.insert(__FieldTag::__sig) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sig",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sig = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__keyid => {
                            if !fields.insert(__FieldTag::__keyid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for keyid",
                                ));
                            }
                            result.keyid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnvelopeSignature {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sig.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sig", &__With(&self.sig))?;
        }
        if !self.keyid.is_empty() {
            state.serialize_entry("keyid", &self.keyid)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Indicates the location at which a package was found.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FileLocation {
    /// For jars that are contained inside .war files, this filepath
    /// can indicate the path to war file combined with the path to jar file.
    pub file_path: std::string::String,

    /// Each package found in a file should have its own layer metadata (that is,
    /// information from the origin layer of the package).
    pub layer_details: std::option::Option<crate::model::LayerDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_path][crate::model::FileLocation::file_path].
    pub fn set_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_path = v.into();
        self
    }

    /// Sets the value of [layer_details][crate::model::FileLocation::layer_details].
    pub fn set_layer_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LayerDetails>,
    {
        self.layer_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [layer_details][crate::model::FileLocation::layer_details].
    pub fn set_or_clear_layer_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LayerDetails>,
    {
        self.layer_details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FileLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.FileLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_path,
            __layer_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filePath" => Ok(__FieldTag::__file_path),
                            "file_path" => Ok(__FieldTag::__file_path),
                            "layerDetails" => Ok(__FieldTag::__layer_details),
                            "layer_details" => Ok(__FieldTag::__layer_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_path => {
                            if !fields.insert(__FieldTag::__file_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_path",
                                ));
                            }
                            result.file_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__layer_details => {
                            if !fields.insert(__FieldTag::__layer_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for layer_details",
                                ));
                            }
                            result.layer_details = map
                                .next_value::<std::option::Option<crate::model::LayerDetails>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_path.is_empty() {
            state.serialize_entry("filePath", &self.file_path)?;
        }
        if self.layer_details.is_some() {
            state.serialize_entry("layerDetails", &self.layer_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// BaseImage describes a base image of a container image.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BaseImage {
    /// The name of the base image.
    pub name: std::string::String,

    /// The repository name in which the base image is from.
    pub repository: std::string::String,

    /// The number of layers that the base image is composed of.
    pub layer_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BaseImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BaseImage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [repository][crate::model::BaseImage::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [layer_count][crate::model::BaseImage::layer_count].
    pub fn set_layer_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.layer_count = v.into();
        self
    }
}

impl wkt::message::Message for BaseImage {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BaseImage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BaseImage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __repository,
            __layer_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BaseImage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "repository" => Ok(__FieldTag::__repository),
                            "layerCount" => Ok(__FieldTag::__layer_count),
                            "layer_count" => Ok(__FieldTag::__layer_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BaseImage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BaseImage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            result.repository = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__layer_count => {
                            if !fields.insert(__FieldTag::__layer_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for layer_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.layer_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BaseImage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.repository.is_empty() {
            state.serialize_entry("repository", &self.repository)?;
        }
        if !wkt::internal::is_default(&self.layer_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("layerCount", &__With(&self.layer_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details about the layer a package was found in.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LayerDetails {
    /// The index of the layer in the container image.
    pub index: i32,

    /// The diff ID (typically a sha256 hash) of the layer in the container image.
    pub diff_id: std::string::String,

    /// The layer chain ID (sha256 hash) of the layer in the container image.
    /// <https://github.com/opencontainers/image-spec/blob/main/config.md#layer-chainid>
    pub chain_id: std::string::String,

    /// The layer build command that was used to build the layer. This may not be
    /// found in all layers depending on how the container image is built.
    pub command: std::string::String,

    /// The base images the layer is found within.
    pub base_images: std::vec::Vec<crate::model::BaseImage>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LayerDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index][crate::model::LayerDetails::index].
    pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [diff_id][crate::model::LayerDetails::diff_id].
    pub fn set_diff_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.diff_id = v.into();
        self
    }

    /// Sets the value of [chain_id][crate::model::LayerDetails::chain_id].
    pub fn set_chain_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.chain_id = v.into();
        self
    }

    /// Sets the value of [command][crate::model::LayerDetails::command].
    pub fn set_command<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.command = v.into();
        self
    }

    /// Sets the value of [base_images][crate::model::LayerDetails::base_images].
    pub fn set_base_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BaseImage>,
    {
        use std::iter::Iterator;
        self.base_images = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LayerDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.LayerDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LayerDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __index,
            __diff_id,
            __chain_id,
            __command,
            __base_images,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LayerDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "index" => Ok(__FieldTag::__index),
                            "diffId" => Ok(__FieldTag::__diff_id),
                            "diff_id" => Ok(__FieldTag::__diff_id),
                            "chainId" => Ok(__FieldTag::__chain_id),
                            "chain_id" => Ok(__FieldTag::__chain_id),
                            "command" => Ok(__FieldTag::__command),
                            "baseImages" => Ok(__FieldTag::__base_images),
                            "base_images" => Ok(__FieldTag::__base_images),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LayerDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LayerDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__index => {
                            if !fields.insert(__FieldTag::__index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.index = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__diff_id => {
                            if !fields.insert(__FieldTag::__diff_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diff_id",
                                ));
                            }
                            result.diff_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__chain_id => {
                            if !fields.insert(__FieldTag::__chain_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for chain_id",
                                ));
                            }
                            result.chain_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__command => {
                            if !fields.insert(__FieldTag::__command) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for command",
                                ));
                            }
                            result.command = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__base_images => {
                            if !fields.insert(__FieldTag::__base_images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_images",
                                ));
                            }
                            result.base_images = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BaseImage>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LayerDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("index", &__With(&self.index))?;
        }
        if !self.diff_id.is_empty() {
            state.serialize_entry("diffId", &self.diff_id)?;
        }
        if !self.chain_id.is_empty() {
            state.serialize_entry("chainId", &self.chain_id)?;
        }
        if !self.command.is_empty() {
            state.serialize_entry("command", &self.command)?;
        }
        if !self.base_images.is_empty() {
            state.serialize_entry("baseImages", &self.base_images)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// License information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct License {
    /// Often a single license can be used to represent the licensing terms.
    /// Sometimes it is necessary to include a choice of one or more licenses
    /// or some combination of license identifiers.
    /// Examples: "LGPL-2.1-only OR MIT", "LGPL-2.1-only AND MIT",
    /// "GPL-2.0-or-later WITH Bison-exception-2.2".
    pub expression: std::string::String,

    /// Comments
    pub comments: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl License {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expression][crate::model::License::expression].
    pub fn set_expression<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.expression = v.into();
        self
    }

    /// Sets the value of [comments][crate::model::License::comments].
    pub fn set_comments<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comments = v.into();
        self
    }
}

impl wkt::message::Message for License {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.License"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for License {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __expression,
            __comments,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for License")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "expression" => Ok(__FieldTag::__expression),
                            "comments" => Ok(__FieldTag::__comments),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = License;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct License")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__expression => {
                            if !fields.insert(__FieldTag::__expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expression",
                                ));
                            }
                            result.expression = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__comments => {
                            if !fields.insert(__FieldTag::__comments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for comments",
                                ));
                            }
                            result.comments = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for License {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.expression.is_empty() {
            state.serialize_entry("expression", &self.expression)?;
        }
        if !self.comments.is_empty() {
            state.serialize_entry("comments", &self.comments)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Digest information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Digest {
    /// `SHA1`, `SHA512` etc.
    pub algo: std::string::String,

    /// Value of the digest.
    pub digest_bytes: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Digest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [algo][crate::model::Digest::algo].
    pub fn set_algo<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.algo = v.into();
        self
    }

    /// Sets the value of [digest_bytes][crate::model::Digest::digest_bytes].
    pub fn set_digest_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.digest_bytes = v.into();
        self
    }
}

impl wkt::message::Message for Digest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Digest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Digest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __algo,
            __digest_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Digest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "algo" => Ok(__FieldTag::__algo),
                            "digestBytes" => Ok(__FieldTag::__digest_bytes),
                            "digest_bytes" => Ok(__FieldTag::__digest_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Digest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Digest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__algo => {
                            if !fields.insert(__FieldTag::__algo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for algo",
                                ));
                            }
                            result.algo = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest_bytes => {
                            if !fields.insert(__FieldTag::__digest_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest_bytes",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.digest_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Digest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.algo.is_empty() {
            state.serialize_entry("algo", &self.algo)?;
        }
        if !self.digest_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("digestBytes", &__With(&self.digest_bytes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComplianceNote {
    /// The title that identifies this compliance check.
    pub title: std::string::String,

    /// A description about this compliance check.
    pub description: std::string::String,

    /// The OS and config versions the benchmark applies to.
    pub version: std::vec::Vec<crate::model::ComplianceVersion>,

    /// A rationale for the existence of this compliance check.
    pub rationale: std::string::String,

    /// A description of remediation steps if the compliance check fails.
    pub remediation: std::string::String,

    /// Serialized scan instructions with a predefined format.
    pub scan_instructions: ::bytes::Bytes,

    pub compliance_type: std::option::Option<crate::model::compliance_note::ComplianceType>,

    /// Potential impact of the suggested remediation
    pub potential_impact: std::option::Option<crate::model::compliance_note::PotentialImpact>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [title][crate::model::ComplianceNote::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ComplianceNote::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [version][crate::model::ComplianceNote::version].
    pub fn set_version<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ComplianceVersion>,
    {
        use std::iter::Iterator;
        self.version = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rationale][crate::model::ComplianceNote::rationale].
    pub fn set_rationale<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rationale = v.into();
        self
    }

    /// Sets the value of [remediation][crate::model::ComplianceNote::remediation].
    pub fn set_remediation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remediation = v.into();
        self
    }

    /// Sets the value of [scan_instructions][crate::model::ComplianceNote::scan_instructions].
    pub fn set_scan_instructions<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.scan_instructions = v.into();
        self
    }

    /// Sets the value of [compliance_type][crate::model::ComplianceNote::compliance_type].
    ///
    /// Note that all the setters affecting `compliance_type` are mutually
    /// exclusive.
    pub fn set_compliance_type<
        T: std::convert::Into<std::option::Option<crate::model::compliance_note::ComplianceType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compliance_type = v.into();
        self
    }

    /// The value of [compliance_type][crate::model::ComplianceNote::compliance_type]
    /// if it holds a `CisBenchmark`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cis_benchmark(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::compliance_note::CisBenchmark>> {
        #[allow(unreachable_patterns)]
        self.compliance_type.as_ref().and_then(|v| match v {
            crate::model::compliance_note::ComplianceType::CisBenchmark(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compliance_type][crate::model::ComplianceNote::compliance_type]
    /// to hold a `CisBenchmark`.
    ///
    /// Note that all the setters affecting `compliance_type` are
    /// mutually exclusive.
    pub fn set_cis_benchmark<
        T: std::convert::Into<std::boxed::Box<crate::model::compliance_note::CisBenchmark>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compliance_type = std::option::Option::Some(
            crate::model::compliance_note::ComplianceType::CisBenchmark(v.into()),
        );
        self
    }

    /// Sets the value of [potential_impact][crate::model::ComplianceNote::potential_impact].
    ///
    /// Note that all the setters affecting `potential_impact` are mutually
    /// exclusive.
    pub fn set_potential_impact<
        T: std::convert::Into<std::option::Option<crate::model::compliance_note::PotentialImpact>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.potential_impact = v.into();
        self
    }

    /// The value of [potential_impact][crate::model::ComplianceNote::potential_impact]
    /// if it holds a `Impact`, `None` if the field is not set or
    /// holds a different branch.
    pub fn impact(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.potential_impact.as_ref().and_then(|v| match v {
            crate::model::compliance_note::PotentialImpact::Impact(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [potential_impact][crate::model::ComplianceNote::potential_impact]
    /// to hold a `Impact`.
    ///
    /// Note that all the setters affecting `potential_impact` are
    /// mutually exclusive.
    pub fn set_impact<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.potential_impact = std::option::Option::Some(
            crate::model::compliance_note::PotentialImpact::Impact(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ComplianceNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ComplianceNote"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComplianceNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __description,
            __version,
            __rationale,
            __remediation,
            __cis_benchmark,
            __scan_instructions,
            __impact,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComplianceNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "description" => Ok(__FieldTag::__description),
                            "version" => Ok(__FieldTag::__version),
                            "rationale" => Ok(__FieldTag::__rationale),
                            "remediation" => Ok(__FieldTag::__remediation),
                            "cisBenchmark" => Ok(__FieldTag::__cis_benchmark),
                            "cis_benchmark" => Ok(__FieldTag::__cis_benchmark),
                            "scanInstructions" => Ok(__FieldTag::__scan_instructions),
                            "scan_instructions" => Ok(__FieldTag::__scan_instructions),
                            "impact" => Ok(__FieldTag::__impact),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComplianceNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComplianceNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ComplianceVersion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rationale => {
                            if !fields.insert(__FieldTag::__rationale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rationale",
                                ));
                            }
                            result.rationale = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remediation => {
                            if !fields.insert(__FieldTag::__remediation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remediation",
                                ));
                            }
                            result.remediation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cis_benchmark => {
                            if !fields.insert(__FieldTag::__cis_benchmark) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cis_benchmark",
                                ));
                            }
                            if result.compliance_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compliance_type`, a oneof with full ID .grafeas.v1.ComplianceNote.cis_benchmark, latest field was cisBenchmark",
                                ));
                            }
                            result.compliance_type = std::option::Option::Some(
                                crate::model::compliance_note::ComplianceType::CisBenchmark(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::compliance_note::CisBenchmark,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__scan_instructions => {
                            if !fields.insert(__FieldTag::__scan_instructions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_instructions",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scan_instructions =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__impact => {
                            if !fields.insert(__FieldTag::__impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for impact",
                                ));
                            }
                            if result.potential_impact.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `potential_impact`, a oneof with full ID .grafeas.v1.ComplianceNote.impact, latest field was impact",
                                ));
                            }
                            result.potential_impact = std::option::Option::Some(
                                crate::model::compliance_note::PotentialImpact::Impact(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComplianceNote {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.rationale.is_empty() {
            state.serialize_entry("rationale", &self.rationale)?;
        }
        if !self.remediation.is_empty() {
            state.serialize_entry("remediation", &self.remediation)?;
        }
        if let Some(value) = self.cis_benchmark() {
            state.serialize_entry("cisBenchmark", value)?;
        }
        if !self.scan_instructions.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scanInstructions", &__With(&self.scan_instructions))?;
        }
        if let Some(value) = self.impact() {
            state.serialize_entry("impact", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ComplianceNote].
pub mod compliance_note {
    #[allow(unused_imports)]
    use super::*;

    /// A compliance check that is a CIS benchmark.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CisBenchmark {
        pub profile_level: i32,

        pub severity: crate::model::Severity,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CisBenchmark {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [profile_level][crate::model::compliance_note::CisBenchmark::profile_level].
        pub fn set_profile_level<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.profile_level = v.into();
            self
        }

        /// Sets the value of [severity][crate::model::compliance_note::CisBenchmark::severity].
        pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
            self.severity = v.into();
            self
        }
    }

    impl wkt::message::Message for CisBenchmark {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.ComplianceNote.CisBenchmark"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CisBenchmark {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __profile_level,
                __severity,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CisBenchmark")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "profileLevel" => Ok(__FieldTag::__profile_level),
                                "profile_level" => Ok(__FieldTag::__profile_level),
                                "severity" => Ok(__FieldTag::__severity),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CisBenchmark;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CisBenchmark")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__profile_level => {
                                if !fields.insert(__FieldTag::__profile_level) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for profile_level",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.profile_level =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__severity => {
                                if !fields.insert(__FieldTag::__severity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for severity",
                                    ));
                                }
                                result.severity = map
                                    .next_value::<std::option::Option<crate::model::Severity>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CisBenchmark {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.profile_level) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("profileLevel", &__With(&self.profile_level))?;
            }
            if !wkt::internal::is_default(&self.severity) {
                state.serialize_entry("severity", &self.severity)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ComplianceType {
        CisBenchmark(std::boxed::Box<crate::model::compliance_note::CisBenchmark>),
    }

    /// Potential impact of the suggested remediation
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PotentialImpact {
        Impact(std::string::String),
    }
}

/// Describes the CIS benchmark version that is applicable to a given OS and
/// os version.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComplianceVersion {
    /// The CPE URI (<https://cpe.mitre.org/specification/>) this benchmark is
    /// applicable to.
    pub cpe_uri: std::string::String,

    /// The name of the document that defines this benchmark, e.g. "CIS
    /// Container-Optimized OS".
    pub benchmark_document: std::string::String,

    /// The version of the benchmark. This is set to the version of the OS-specific
    /// CIS document the benchmark is defined in.
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpe_uri][crate::model::ComplianceVersion::cpe_uri].
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [benchmark_document][crate::model::ComplianceVersion::benchmark_document].
    pub fn set_benchmark_document<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.benchmark_document = v.into();
        self
    }

    /// Sets the value of [version][crate::model::ComplianceVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for ComplianceVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ComplianceVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComplianceVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpe_uri,
            __benchmark_document,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComplianceVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "benchmarkDocument" => Ok(__FieldTag::__benchmark_document),
                            "benchmark_document" => Ok(__FieldTag::__benchmark_document),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComplianceVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComplianceVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__benchmark_document => {
                            if !fields.insert(__FieldTag::__benchmark_document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for benchmark_document",
                                ));
                            }
                            result.benchmark_document = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComplianceVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cpe_uri.is_empty() {
            state.serialize_entry("cpeUri", &self.cpe_uri)?;
        }
        if !self.benchmark_document.is_empty() {
            state.serialize_entry("benchmarkDocument", &self.benchmark_document)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An indication that the compliance checks in the associated ComplianceNote
/// were not satisfied for particular resources or a specified reason.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComplianceOccurrence {
    pub non_compliant_files: std::vec::Vec<crate::model::NonCompliantFile>,

    pub non_compliance_reason: std::string::String,

    /// The OS and config version the benchmark was run on.
    pub version: std::option::Option<crate::model::ComplianceVersion>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [non_compliant_files][crate::model::ComplianceOccurrence::non_compliant_files].
    pub fn set_non_compliant_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NonCompliantFile>,
    {
        use std::iter::Iterator;
        self.non_compliant_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [non_compliance_reason][crate::model::ComplianceOccurrence::non_compliance_reason].
    pub fn set_non_compliance_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.non_compliance_reason = v.into();
        self
    }

    /// Sets the value of [version][crate::model::ComplianceOccurrence::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceVersion>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::ComplianceOccurrence::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceVersion>,
    {
        self.version = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComplianceOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ComplianceOccurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComplianceOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __non_compliant_files,
            __non_compliance_reason,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComplianceOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nonCompliantFiles" => Ok(__FieldTag::__non_compliant_files),
                            "non_compliant_files" => Ok(__FieldTag::__non_compliant_files),
                            "nonComplianceReason" => Ok(__FieldTag::__non_compliance_reason),
                            "non_compliance_reason" => Ok(__FieldTag::__non_compliance_reason),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComplianceOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComplianceOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__non_compliant_files => {
                            if !fields.insert(__FieldTag::__non_compliant_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for non_compliant_files",
                                ));
                            }
                            result.non_compliant_files =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NonCompliantFile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__non_compliance_reason => {
                            if !fields.insert(__FieldTag::__non_compliance_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for non_compliance_reason",
                                ));
                            }
                            result.non_compliance_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<crate::model::ComplianceVersion>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComplianceOccurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.non_compliant_files.is_empty() {
            state.serialize_entry("nonCompliantFiles", &self.non_compliant_files)?;
        }
        if !self.non_compliance_reason.is_empty() {
            state.serialize_entry("nonComplianceReason", &self.non_compliance_reason)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details about files that caused a compliance check to fail.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NonCompliantFile {
    /// Empty if `display_command` is set.
    pub path: std::string::String,

    /// Command to display the non-compliant files.
    pub display_command: std::string::String,

    /// Explains why a file is non compliant for a CIS check.
    pub reason: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NonCompliantFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::NonCompliantFile::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [display_command][crate::model::NonCompliantFile::display_command].
    pub fn set_display_command<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_command = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::NonCompliantFile::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }
}

impl wkt::message::Message for NonCompliantFile {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.NonCompliantFile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NonCompliantFile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            __display_command,
            __reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NonCompliantFile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            "displayCommand" => Ok(__FieldTag::__display_command),
                            "display_command" => Ok(__FieldTag::__display_command),
                            "reason" => Ok(__FieldTag::__reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NonCompliantFile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NonCompliantFile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_command => {
                            if !fields.insert(__FieldTag::__display_command) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_command",
                                ));
                            }
                            result.display_command = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            result.reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NonCompliantFile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.display_command.is_empty() {
            state.serialize_entry("displayCommand", &self.display_command)?;
        }
        if !self.reason.is_empty() {
            state.serialize_entry("reason", &self.reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Common Vulnerability Scoring System version 3.
/// For details, see <https://www.first.org/cvss/specification-document>
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CVSSv3 {
    /// The base score is a function of the base metric scores.
    pub base_score: f32,

    pub exploitability_score: f32,

    pub impact_score: f32,

    /// Base Metrics
    /// Represents the intrinsic characteristics of a vulnerability that are
    /// constant over time and across user environments.
    pub attack_vector: crate::model::cvs_sv_3::AttackVector,

    pub attack_complexity: crate::model::cvs_sv_3::AttackComplexity,

    pub privileges_required: crate::model::cvs_sv_3::PrivilegesRequired,

    pub user_interaction: crate::model::cvs_sv_3::UserInteraction,

    pub scope: crate::model::cvs_sv_3::Scope,

    pub confidentiality_impact: crate::model::cvs_sv_3::Impact,

    pub integrity_impact: crate::model::cvs_sv_3::Impact,

    pub availability_impact: crate::model::cvs_sv_3::Impact,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CVSSv3 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_score][crate::model::CVSSv3::base_score].
    pub fn set_base_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.base_score = v.into();
        self
    }

    /// Sets the value of [exploitability_score][crate::model::CVSSv3::exploitability_score].
    pub fn set_exploitability_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.exploitability_score = v.into();
        self
    }

    /// Sets the value of [impact_score][crate::model::CVSSv3::impact_score].
    pub fn set_impact_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.impact_score = v.into();
        self
    }

    /// Sets the value of [attack_vector][crate::model::CVSSv3::attack_vector].
    pub fn set_attack_vector<T: std::convert::Into<crate::model::cvs_sv_3::AttackVector>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_vector = v.into();
        self
    }

    /// Sets the value of [attack_complexity][crate::model::CVSSv3::attack_complexity].
    pub fn set_attack_complexity<
        T: std::convert::Into<crate::model::cvs_sv_3::AttackComplexity>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.attack_complexity = v.into();
        self
    }

    /// Sets the value of [privileges_required][crate::model::CVSSv3::privileges_required].
    pub fn set_privileges_required<
        T: std::convert::Into<crate::model::cvs_sv_3::PrivilegesRequired>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privileges_required = v.into();
        self
    }

    /// Sets the value of [user_interaction][crate::model::CVSSv3::user_interaction].
    pub fn set_user_interaction<T: std::convert::Into<crate::model::cvs_sv_3::UserInteraction>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_interaction = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::CVSSv3::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::cvs_sv_3::Scope>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [confidentiality_impact][crate::model::CVSSv3::confidentiality_impact].
    pub fn set_confidentiality_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.confidentiality_impact = v.into();
        self
    }

    /// Sets the value of [integrity_impact][crate::model::CVSSv3::integrity_impact].
    pub fn set_integrity_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.integrity_impact = v.into();
        self
    }

    /// Sets the value of [availability_impact][crate::model::CVSSv3::availability_impact].
    pub fn set_availability_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.availability_impact = v.into();
        self
    }
}

impl wkt::message::Message for CVSSv3 {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CVSSv3"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CVSSv3 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_score,
            __exploitability_score,
            __impact_score,
            __attack_vector,
            __attack_complexity,
            __privileges_required,
            __user_interaction,
            __scope,
            __confidentiality_impact,
            __integrity_impact,
            __availability_impact,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CVSSv3")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseScore" => Ok(__FieldTag::__base_score),
                            "base_score" => Ok(__FieldTag::__base_score),
                            "exploitabilityScore" => Ok(__FieldTag::__exploitability_score),
                            "exploitability_score" => Ok(__FieldTag::__exploitability_score),
                            "impactScore" => Ok(__FieldTag::__impact_score),
                            "impact_score" => Ok(__FieldTag::__impact_score),
                            "attackVector" => Ok(__FieldTag::__attack_vector),
                            "attack_vector" => Ok(__FieldTag::__attack_vector),
                            "attackComplexity" => Ok(__FieldTag::__attack_complexity),
                            "attack_complexity" => Ok(__FieldTag::__attack_complexity),
                            "privilegesRequired" => Ok(__FieldTag::__privileges_required),
                            "privileges_required" => Ok(__FieldTag::__privileges_required),
                            "userInteraction" => Ok(__FieldTag::__user_interaction),
                            "user_interaction" => Ok(__FieldTag::__user_interaction),
                            "scope" => Ok(__FieldTag::__scope),
                            "confidentialityImpact" => Ok(__FieldTag::__confidentiality_impact),
                            "confidentiality_impact" => Ok(__FieldTag::__confidentiality_impact),
                            "integrityImpact" => Ok(__FieldTag::__integrity_impact),
                            "integrity_impact" => Ok(__FieldTag::__integrity_impact),
                            "availabilityImpact" => Ok(__FieldTag::__availability_impact),
                            "availability_impact" => Ok(__FieldTag::__availability_impact),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CVSSv3;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CVSSv3")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_score => {
                            if !fields.insert(__FieldTag::__base_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.base_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__exploitability_score => {
                            if !fields.insert(__FieldTag::__exploitability_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exploitability_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.exploitability_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__impact_score => {
                            if !fields.insert(__FieldTag::__impact_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for impact_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.impact_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__attack_vector => {
                            if !fields.insert(__FieldTag::__attack_vector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_vector",
                                ));
                            }
                            result.attack_vector = map.next_value::<std::option::Option<crate::model::cvs_sv_3::AttackVector>>()?.unwrap_or_default();
                        }
                        __FieldTag::__attack_complexity => {
                            if !fields.insert(__FieldTag::__attack_complexity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_complexity",
                                ));
                            }
                            result.attack_complexity = map.next_value::<std::option::Option<crate::model::cvs_sv_3::AttackComplexity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__privileges_required => {
                            if !fields.insert(__FieldTag::__privileges_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privileges_required",
                                ));
                            }
                            result.privileges_required = map.next_value::<std::option::Option<crate::model::cvs_sv_3::PrivilegesRequired>>()?.unwrap_or_default();
                        }
                        __FieldTag::__user_interaction => {
                            if !fields.insert(__FieldTag::__user_interaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_interaction",
                                ));
                            }
                            result.user_interaction = map.next_value::<std::option::Option<crate::model::cvs_sv_3::UserInteraction>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Scope>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidentiality_impact => {
                            if !fields.insert(__FieldTag::__confidentiality_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidentiality_impact",
                                ));
                            }
                            result.confidentiality_impact = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Impact>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__integrity_impact => {
                            if !fields.insert(__FieldTag::__integrity_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integrity_impact",
                                ));
                            }
                            result.integrity_impact = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Impact>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__availability_impact => {
                            if !fields.insert(__FieldTag::__availability_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for availability_impact",
                                ));
                            }
                            result.availability_impact = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Impact>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CVSSv3 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.base_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("baseScore", &__With(&self.base_score))?;
        }
        if !wkt::internal::is_default(&self.exploitability_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("exploitabilityScore", &__With(&self.exploitability_score))?;
        }
        if !wkt::internal::is_default(&self.impact_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("impactScore", &__With(&self.impact_score))?;
        }
        if !wkt::internal::is_default(&self.attack_vector) {
            state.serialize_entry("attackVector", &self.attack_vector)?;
        }
        if !wkt::internal::is_default(&self.attack_complexity) {
            state.serialize_entry("attackComplexity", &self.attack_complexity)?;
        }
        if !wkt::internal::is_default(&self.privileges_required) {
            state.serialize_entry("privilegesRequired", &self.privileges_required)?;
        }
        if !wkt::internal::is_default(&self.user_interaction) {
            state.serialize_entry("userInteraction", &self.user_interaction)?;
        }
        if !wkt::internal::is_default(&self.scope) {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !wkt::internal::is_default(&self.confidentiality_impact) {
            state.serialize_entry("confidentialityImpact", &self.confidentiality_impact)?;
        }
        if !wkt::internal::is_default(&self.integrity_impact) {
            state.serialize_entry("integrityImpact", &self.integrity_impact)?;
        }
        if !wkt::internal::is_default(&self.availability_impact) {
            state.serialize_entry("availabilityImpact", &self.availability_impact)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CVSSv3].
pub mod cvs_sv_3 {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackVector {
        Unspecified,
        Network,
        Adjacent,
        Local,
        Physical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackVector::value] or
        /// [AttackVector::name].
        UnknownValue(attack_vector::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_vector {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackVector {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Network => std::option::Option::Some(1),
                Self::Adjacent => std::option::Option::Some(2),
                Self::Local => std::option::Option::Some(3),
                Self::Physical => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_VECTOR_UNSPECIFIED"),
                Self::Network => std::option::Option::Some("ATTACK_VECTOR_NETWORK"),
                Self::Adjacent => std::option::Option::Some("ATTACK_VECTOR_ADJACENT"),
                Self::Local => std::option::Option::Some("ATTACK_VECTOR_LOCAL"),
                Self::Physical => std::option::Option::Some("ATTACK_VECTOR_PHYSICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackVector {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackVector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackVector {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Network,
                2 => Self::Adjacent,
                3 => Self::Local,
                4 => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackVector {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_VECTOR_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_VECTOR_NETWORK" => Self::Network,
                "ATTACK_VECTOR_ADJACENT" => Self::Adjacent,
                "ATTACK_VECTOR_LOCAL" => Self::Local,
                "ATTACK_VECTOR_PHYSICAL" => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackVector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Network => serializer.serialize_i32(1),
                Self::Adjacent => serializer.serialize_i32(2),
                Self::Local => serializer.serialize_i32(3),
                Self::Physical => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackVector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackVector>::new(
                ".grafeas.v1.CVSSv3.AttackVector",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackComplexity {
        Unspecified,
        Low,
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackComplexity::value] or
        /// [AttackComplexity::name].
        UnknownValue(attack_complexity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_complexity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackComplexity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::High => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_COMPLEXITY_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("ATTACK_COMPLEXITY_LOW"),
                Self::High => std::option::Option::Some("ATTACK_COMPLEXITY_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackComplexity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackComplexity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackComplexity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::High,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackComplexity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_COMPLEXITY_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_COMPLEXITY_LOW" => Self::Low,
                "ATTACK_COMPLEXITY_HIGH" => Self::High,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackComplexity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::High => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackComplexity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackComplexity>::new(
                ".grafeas.v1.CVSSv3.AttackComplexity",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivilegesRequired {
        Unspecified,
        None,
        Low,
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivilegesRequired::value] or
        /// [PrivilegesRequired::name].
        UnknownValue(privileges_required::UnknownValue),
    }

    #[doc(hidden)]
    pub mod privileges_required {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PrivilegesRequired {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIVILEGES_REQUIRED_UNSPECIFIED"),
                Self::None => std::option::Option::Some("PRIVILEGES_REQUIRED_NONE"),
                Self::Low => std::option::Option::Some("PRIVILEGES_REQUIRED_LOW"),
                Self::High => std::option::Option::Some("PRIVILEGES_REQUIRED_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PrivilegesRequired {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PrivilegesRequired {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PrivilegesRequired {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Low,
                3 => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PrivilegesRequired {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIVILEGES_REQUIRED_UNSPECIFIED" => Self::Unspecified,
                "PRIVILEGES_REQUIRED_NONE" => Self::None,
                "PRIVILEGES_REQUIRED_LOW" => Self::Low,
                "PRIVILEGES_REQUIRED_HIGH" => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PrivilegesRequired {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PrivilegesRequired {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PrivilegesRequired>::new(
                ".grafeas.v1.CVSSv3.PrivilegesRequired",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserInteraction {
        Unspecified,
        None,
        Required,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserInteraction::value] or
        /// [UserInteraction::name].
        UnknownValue(user_interaction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_interaction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserInteraction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Required => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("USER_INTERACTION_UNSPECIFIED"),
                Self::None => std::option::Option::Some("USER_INTERACTION_NONE"),
                Self::Required => std::option::Option::Some("USER_INTERACTION_REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserInteraction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserInteraction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserInteraction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for UserInteraction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_INTERACTION_UNSPECIFIED" => Self::Unspecified,
                "USER_INTERACTION_NONE" => Self::None,
                "USER_INTERACTION_REQUIRED" => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for UserInteraction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Required => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserInteraction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserInteraction>::new(
                ".grafeas.v1.CVSSv3.UserInteraction",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        Unspecified,
        Unchanged,
        Changed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unchanged => std::option::Option::Some(1),
                Self::Changed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Unchanged => std::option::Option::Some("SCOPE_UNCHANGED"),
                Self::Changed => std::option::Option::Some("SCOPE_CHANGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unchanged,
                2 => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "SCOPE_UNCHANGED" => Self::Unchanged,
                "SCOPE_CHANGED" => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unchanged => serializer.serialize_i32(1),
                Self::Changed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".grafeas.v1.CVSSv3.Scope",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Impact {
        Unspecified,
        High,
        Low,
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Impact::value] or
        /// [Impact::name].
        UnknownValue(impact::UnknownValue),
    }

    #[doc(hidden)]
    pub mod impact {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Impact {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPACT_UNSPECIFIED"),
                Self::High => std::option::Option::Some("IMPACT_HIGH"),
                Self::Low => std::option::Option::Some("IMPACT_LOW"),
                Self::None => std::option::Option::Some("IMPACT_NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Impact {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Impact {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Impact {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Low,
                3 => Self::None,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Impact {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPACT_UNSPECIFIED" => Self::Unspecified,
                "IMPACT_HIGH" => Self::High,
                "IMPACT_LOW" => Self::Low,
                "IMPACT_NONE" => Self::None,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Impact {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Impact {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Impact>::new(
                ".grafeas.v1.CVSSv3.Impact",
            ))
        }
    }
}

/// Common Vulnerability Scoring System.
/// For details, see <https://www.first.org/cvss/specification-document>
/// This is a message we will try to use for storing various versions of CVSS
/// rather than making a separate proto for storing a specific version.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Cvss {
    /// The base score is a function of the base metric scores.
    pub base_score: f32,

    pub exploitability_score: f32,

    pub impact_score: f32,

    /// Base Metrics
    /// Represents the intrinsic characteristics of a vulnerability that are
    /// constant over time and across user environments.
    pub attack_vector: crate::model::cvss::AttackVector,

    pub attack_complexity: crate::model::cvss::AttackComplexity,

    pub authentication: crate::model::cvss::Authentication,

    pub privileges_required: crate::model::cvss::PrivilegesRequired,

    pub user_interaction: crate::model::cvss::UserInteraction,

    pub scope: crate::model::cvss::Scope,

    pub confidentiality_impact: crate::model::cvss::Impact,

    pub integrity_impact: crate::model::cvss::Impact,

    pub availability_impact: crate::model::cvss::Impact,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cvss {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_score][crate::model::Cvss::base_score].
    pub fn set_base_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.base_score = v.into();
        self
    }

    /// Sets the value of [exploitability_score][crate::model::Cvss::exploitability_score].
    pub fn set_exploitability_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.exploitability_score = v.into();
        self
    }

    /// Sets the value of [impact_score][crate::model::Cvss::impact_score].
    pub fn set_impact_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.impact_score = v.into();
        self
    }

    /// Sets the value of [attack_vector][crate::model::Cvss::attack_vector].
    pub fn set_attack_vector<T: std::convert::Into<crate::model::cvss::AttackVector>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_vector = v.into();
        self
    }

    /// Sets the value of [attack_complexity][crate::model::Cvss::attack_complexity].
    pub fn set_attack_complexity<T: std::convert::Into<crate::model::cvss::AttackComplexity>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_complexity = v.into();
        self
    }

    /// Sets the value of [authentication][crate::model::Cvss::authentication].
    pub fn set_authentication<T: std::convert::Into<crate::model::cvss::Authentication>>(
        mut self,
        v: T,
    ) -> Self {
        self.authentication = v.into();
        self
    }

    /// Sets the value of [privileges_required][crate::model::Cvss::privileges_required].
    pub fn set_privileges_required<
        T: std::convert::Into<crate::model::cvss::PrivilegesRequired>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privileges_required = v.into();
        self
    }

    /// Sets the value of [user_interaction][crate::model::Cvss::user_interaction].
    pub fn set_user_interaction<T: std::convert::Into<crate::model::cvss::UserInteraction>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_interaction = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::Cvss::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::cvss::Scope>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [confidentiality_impact][crate::model::Cvss::confidentiality_impact].
    pub fn set_confidentiality_impact<T: std::convert::Into<crate::model::cvss::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.confidentiality_impact = v.into();
        self
    }

    /// Sets the value of [integrity_impact][crate::model::Cvss::integrity_impact].
    pub fn set_integrity_impact<T: std::convert::Into<crate::model::cvss::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.integrity_impact = v.into();
        self
    }

    /// Sets the value of [availability_impact][crate::model::Cvss::availability_impact].
    pub fn set_availability_impact<T: std::convert::Into<crate::model::cvss::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.availability_impact = v.into();
        self
    }
}

impl wkt::message::Message for Cvss {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CVSS"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Cvss {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_score,
            __exploitability_score,
            __impact_score,
            __attack_vector,
            __attack_complexity,
            __authentication,
            __privileges_required,
            __user_interaction,
            __scope,
            __confidentiality_impact,
            __integrity_impact,
            __availability_impact,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cvss")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseScore" => Ok(__FieldTag::__base_score),
                            "base_score" => Ok(__FieldTag::__base_score),
                            "exploitabilityScore" => Ok(__FieldTag::__exploitability_score),
                            "exploitability_score" => Ok(__FieldTag::__exploitability_score),
                            "impactScore" => Ok(__FieldTag::__impact_score),
                            "impact_score" => Ok(__FieldTag::__impact_score),
                            "attackVector" => Ok(__FieldTag::__attack_vector),
                            "attack_vector" => Ok(__FieldTag::__attack_vector),
                            "attackComplexity" => Ok(__FieldTag::__attack_complexity),
                            "attack_complexity" => Ok(__FieldTag::__attack_complexity),
                            "authentication" => Ok(__FieldTag::__authentication),
                            "privilegesRequired" => Ok(__FieldTag::__privileges_required),
                            "privileges_required" => Ok(__FieldTag::__privileges_required),
                            "userInteraction" => Ok(__FieldTag::__user_interaction),
                            "user_interaction" => Ok(__FieldTag::__user_interaction),
                            "scope" => Ok(__FieldTag::__scope),
                            "confidentialityImpact" => Ok(__FieldTag::__confidentiality_impact),
                            "confidentiality_impact" => Ok(__FieldTag::__confidentiality_impact),
                            "integrityImpact" => Ok(__FieldTag::__integrity_impact),
                            "integrity_impact" => Ok(__FieldTag::__integrity_impact),
                            "availabilityImpact" => Ok(__FieldTag::__availability_impact),
                            "availability_impact" => Ok(__FieldTag::__availability_impact),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Cvss;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cvss")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_score => {
                            if !fields.insert(__FieldTag::__base_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.base_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__exploitability_score => {
                            if !fields.insert(__FieldTag::__exploitability_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exploitability_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.exploitability_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__impact_score => {
                            if !fields.insert(__FieldTag::__impact_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for impact_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.impact_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__attack_vector => {
                            if !fields.insert(__FieldTag::__attack_vector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_vector",
                                ));
                            }
                            result.attack_vector = map.next_value::<std::option::Option<crate::model::cvss::AttackVector>>()?.unwrap_or_default();
                        }
                        __FieldTag::__attack_complexity => {
                            if !fields.insert(__FieldTag::__attack_complexity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_complexity",
                                ));
                            }
                            result.attack_complexity = map.next_value::<std::option::Option<crate::model::cvss::AttackComplexity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__authentication => {
                            if !fields.insert(__FieldTag::__authentication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authentication",
                                ));
                            }
                            result.authentication = map.next_value::<std::option::Option<crate::model::cvss::Authentication>>()?.unwrap_or_default();
                        }
                        __FieldTag::__privileges_required => {
                            if !fields.insert(__FieldTag::__privileges_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privileges_required",
                                ));
                            }
                            result.privileges_required = map.next_value::<std::option::Option<crate::model::cvss::PrivilegesRequired>>()?.unwrap_or_default();
                        }
                        __FieldTag::__user_interaction => {
                            if !fields.insert(__FieldTag::__user_interaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_interaction",
                                ));
                            }
                            result.user_interaction = map.next_value::<std::option::Option<crate::model::cvss::UserInteraction>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<crate::model::cvss::Scope>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidentiality_impact => {
                            if !fields.insert(__FieldTag::__confidentiality_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidentiality_impact",
                                ));
                            }
                            result.confidentiality_impact = map
                                .next_value::<std::option::Option<crate::model::cvss::Impact>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__integrity_impact => {
                            if !fields.insert(__FieldTag::__integrity_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integrity_impact",
                                ));
                            }
                            result.integrity_impact = map
                                .next_value::<std::option::Option<crate::model::cvss::Impact>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__availability_impact => {
                            if !fields.insert(__FieldTag::__availability_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for availability_impact",
                                ));
                            }
                            result.availability_impact = map
                                .next_value::<std::option::Option<crate::model::cvss::Impact>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Cvss {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.base_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("baseScore", &__With(&self.base_score))?;
        }
        if !wkt::internal::is_default(&self.exploitability_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("exploitabilityScore", &__With(&self.exploitability_score))?;
        }
        if !wkt::internal::is_default(&self.impact_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("impactScore", &__With(&self.impact_score))?;
        }
        if !wkt::internal::is_default(&self.attack_vector) {
            state.serialize_entry("attackVector", &self.attack_vector)?;
        }
        if !wkt::internal::is_default(&self.attack_complexity) {
            state.serialize_entry("attackComplexity", &self.attack_complexity)?;
        }
        if !wkt::internal::is_default(&self.authentication) {
            state.serialize_entry("authentication", &self.authentication)?;
        }
        if !wkt::internal::is_default(&self.privileges_required) {
            state.serialize_entry("privilegesRequired", &self.privileges_required)?;
        }
        if !wkt::internal::is_default(&self.user_interaction) {
            state.serialize_entry("userInteraction", &self.user_interaction)?;
        }
        if !wkt::internal::is_default(&self.scope) {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !wkt::internal::is_default(&self.confidentiality_impact) {
            state.serialize_entry("confidentialityImpact", &self.confidentiality_impact)?;
        }
        if !wkt::internal::is_default(&self.integrity_impact) {
            state.serialize_entry("integrityImpact", &self.integrity_impact)?;
        }
        if !wkt::internal::is_default(&self.availability_impact) {
            state.serialize_entry("availabilityImpact", &self.availability_impact)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CVSS].
pub mod cvss {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackVector {
        Unspecified,
        Network,
        Adjacent,
        Local,
        Physical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackVector::value] or
        /// [AttackVector::name].
        UnknownValue(attack_vector::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_vector {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackVector {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Network => std::option::Option::Some(1),
                Self::Adjacent => std::option::Option::Some(2),
                Self::Local => std::option::Option::Some(3),
                Self::Physical => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_VECTOR_UNSPECIFIED"),
                Self::Network => std::option::Option::Some("ATTACK_VECTOR_NETWORK"),
                Self::Adjacent => std::option::Option::Some("ATTACK_VECTOR_ADJACENT"),
                Self::Local => std::option::Option::Some("ATTACK_VECTOR_LOCAL"),
                Self::Physical => std::option::Option::Some("ATTACK_VECTOR_PHYSICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackVector {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackVector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackVector {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Network,
                2 => Self::Adjacent,
                3 => Self::Local,
                4 => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackVector {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_VECTOR_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_VECTOR_NETWORK" => Self::Network,
                "ATTACK_VECTOR_ADJACENT" => Self::Adjacent,
                "ATTACK_VECTOR_LOCAL" => Self::Local,
                "ATTACK_VECTOR_PHYSICAL" => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackVector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Network => serializer.serialize_i32(1),
                Self::Adjacent => serializer.serialize_i32(2),
                Self::Local => serializer.serialize_i32(3),
                Self::Physical => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackVector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackVector>::new(
                ".grafeas.v1.CVSS.AttackVector",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackComplexity {
        Unspecified,
        Low,
        High,
        Medium,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackComplexity::value] or
        /// [AttackComplexity::name].
        UnknownValue(attack_complexity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_complexity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackComplexity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::High => std::option::Option::Some(2),
                Self::Medium => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_COMPLEXITY_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("ATTACK_COMPLEXITY_LOW"),
                Self::High => std::option::Option::Some("ATTACK_COMPLEXITY_HIGH"),
                Self::Medium => std::option::Option::Some("ATTACK_COMPLEXITY_MEDIUM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackComplexity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackComplexity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackComplexity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::High,
                3 => Self::Medium,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackComplexity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_COMPLEXITY_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_COMPLEXITY_LOW" => Self::Low,
                "ATTACK_COMPLEXITY_HIGH" => Self::High,
                "ATTACK_COMPLEXITY_MEDIUM" => Self::Medium,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackComplexity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::High => serializer.serialize_i32(2),
                Self::Medium => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackComplexity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackComplexity>::new(
                ".grafeas.v1.CVSS.AttackComplexity",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Authentication {
        Unspecified,
        Multiple,
        Single,
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Authentication::value] or
        /// [Authentication::name].
        UnknownValue(authentication::UnknownValue),
    }

    #[doc(hidden)]
    pub mod authentication {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Authentication {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Multiple => std::option::Option::Some(1),
                Self::Single => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUTHENTICATION_UNSPECIFIED"),
                Self::Multiple => std::option::Option::Some("AUTHENTICATION_MULTIPLE"),
                Self::Single => std::option::Option::Some("AUTHENTICATION_SINGLE"),
                Self::None => std::option::Option::Some("AUTHENTICATION_NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Authentication {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Authentication {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Authentication {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Multiple,
                2 => Self::Single,
                3 => Self::None,
                _ => Self::UnknownValue(authentication::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Authentication {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTHENTICATION_UNSPECIFIED" => Self::Unspecified,
                "AUTHENTICATION_MULTIPLE" => Self::Multiple,
                "AUTHENTICATION_SINGLE" => Self::Single,
                "AUTHENTICATION_NONE" => Self::None,
                _ => Self::UnknownValue(authentication::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Authentication {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Multiple => serializer.serialize_i32(1),
                Self::Single => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Authentication {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Authentication>::new(
                ".grafeas.v1.CVSS.Authentication",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivilegesRequired {
        Unspecified,
        None,
        Low,
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivilegesRequired::value] or
        /// [PrivilegesRequired::name].
        UnknownValue(privileges_required::UnknownValue),
    }

    #[doc(hidden)]
    pub mod privileges_required {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PrivilegesRequired {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIVILEGES_REQUIRED_UNSPECIFIED"),
                Self::None => std::option::Option::Some("PRIVILEGES_REQUIRED_NONE"),
                Self::Low => std::option::Option::Some("PRIVILEGES_REQUIRED_LOW"),
                Self::High => std::option::Option::Some("PRIVILEGES_REQUIRED_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PrivilegesRequired {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PrivilegesRequired {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PrivilegesRequired {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Low,
                3 => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PrivilegesRequired {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIVILEGES_REQUIRED_UNSPECIFIED" => Self::Unspecified,
                "PRIVILEGES_REQUIRED_NONE" => Self::None,
                "PRIVILEGES_REQUIRED_LOW" => Self::Low,
                "PRIVILEGES_REQUIRED_HIGH" => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PrivilegesRequired {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PrivilegesRequired {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PrivilegesRequired>::new(
                ".grafeas.v1.CVSS.PrivilegesRequired",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserInteraction {
        Unspecified,
        None,
        Required,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserInteraction::value] or
        /// [UserInteraction::name].
        UnknownValue(user_interaction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_interaction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserInteraction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Required => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("USER_INTERACTION_UNSPECIFIED"),
                Self::None => std::option::Option::Some("USER_INTERACTION_NONE"),
                Self::Required => std::option::Option::Some("USER_INTERACTION_REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserInteraction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserInteraction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserInteraction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for UserInteraction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_INTERACTION_UNSPECIFIED" => Self::Unspecified,
                "USER_INTERACTION_NONE" => Self::None,
                "USER_INTERACTION_REQUIRED" => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for UserInteraction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Required => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserInteraction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserInteraction>::new(
                ".grafeas.v1.CVSS.UserInteraction",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        Unspecified,
        Unchanged,
        Changed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unchanged => std::option::Option::Some(1),
                Self::Changed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Unchanged => std::option::Option::Some("SCOPE_UNCHANGED"),
                Self::Changed => std::option::Option::Some("SCOPE_CHANGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unchanged,
                2 => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "SCOPE_UNCHANGED" => Self::Unchanged,
                "SCOPE_CHANGED" => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unchanged => serializer.serialize_i32(1),
                Self::Changed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".grafeas.v1.CVSS.Scope",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Impact {
        Unspecified,
        High,
        Low,
        None,
        Partial,
        Complete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Impact::value] or
        /// [Impact::name].
        UnknownValue(impact::UnknownValue),
    }

    #[doc(hidden)]
    pub mod impact {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Impact {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::Partial => std::option::Option::Some(4),
                Self::Complete => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPACT_UNSPECIFIED"),
                Self::High => std::option::Option::Some("IMPACT_HIGH"),
                Self::Low => std::option::Option::Some("IMPACT_LOW"),
                Self::None => std::option::Option::Some("IMPACT_NONE"),
                Self::Partial => std::option::Option::Some("IMPACT_PARTIAL"),
                Self::Complete => std::option::Option::Some("IMPACT_COMPLETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Impact {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Impact {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Impact {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Low,
                3 => Self::None,
                4 => Self::Partial,
                5 => Self::Complete,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Impact {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPACT_UNSPECIFIED" => Self::Unspecified,
                "IMPACT_HIGH" => Self::High,
                "IMPACT_LOW" => Self::Low,
                "IMPACT_NONE" => Self::None,
                "IMPACT_PARTIAL" => Self::Partial,
                "IMPACT_COMPLETE" => Self::Complete,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Impact {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::Partial => serializer.serialize_i32(4),
                Self::Complete => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Impact {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Impact>::new(
                ".grafeas.v1.CVSS.Impact",
            ))
        }
    }
}

/// An artifact that can be deployed in some runtime.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeploymentNote {
    /// Required. Resource URI for the artifact being deployed.
    pub resource_uri: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeploymentNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_uri][crate::model::DeploymentNote::resource_uri].
    pub fn set_resource_uri<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_uri = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DeploymentNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DeploymentNote"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeploymentNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeploymentNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeploymentNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeploymentNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeploymentNote {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_uri.is_empty() {
            state.serialize_entry("resourceUri", &self.resource_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The period during which some deployable was active in a runtime.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeploymentOccurrence {
    /// Identity of the user that triggered this deployment.
    pub user_email: std::string::String,

    /// Required. Beginning of the lifetime of this deployment.
    pub deploy_time: std::option::Option<wkt::Timestamp>,

    /// End of the lifetime of this deployment.
    pub undeploy_time: std::option::Option<wkt::Timestamp>,

    /// Configuration used to create this deployment.
    pub config: std::string::String,

    /// Address of the runtime element hosting this deployment.
    pub address: std::string::String,

    /// Output only. Resource URI for the artifact being deployed taken from
    /// the deployable field with the same name.
    pub resource_uri: std::vec::Vec<std::string::String>,

    /// Platform hosting this deployment.
    pub platform: crate::model::deployment_occurrence::Platform,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeploymentOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_email][crate::model::DeploymentOccurrence::user_email].
    pub fn set_user_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_email = v.into();
        self
    }

    /// Sets the value of [deploy_time][crate::model::DeploymentOccurrence::deploy_time].
    pub fn set_deploy_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deploy_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deploy_time][crate::model::DeploymentOccurrence::deploy_time].
    pub fn set_or_clear_deploy_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deploy_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [undeploy_time][crate::model::DeploymentOccurrence::undeploy_time].
    pub fn set_undeploy_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.undeploy_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [undeploy_time][crate::model::DeploymentOccurrence::undeploy_time].
    pub fn set_or_clear_undeploy_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.undeploy_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config][crate::model::DeploymentOccurrence::config].
    pub fn set_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [address][crate::model::DeploymentOccurrence::address].
    pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.address = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::DeploymentOccurrence::resource_uri].
    pub fn set_resource_uri<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_uri = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [platform][crate::model::DeploymentOccurrence::platform].
    pub fn set_platform<T: std::convert::Into<crate::model::deployment_occurrence::Platform>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform = v.into();
        self
    }
}

impl wkt::message::Message for DeploymentOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DeploymentOccurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeploymentOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_email,
            __deploy_time,
            __undeploy_time,
            __config,
            __address,
            __resource_uri,
            __platform,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeploymentOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userEmail" => Ok(__FieldTag::__user_email),
                            "user_email" => Ok(__FieldTag::__user_email),
                            "deployTime" => Ok(__FieldTag::__deploy_time),
                            "deploy_time" => Ok(__FieldTag::__deploy_time),
                            "undeployTime" => Ok(__FieldTag::__undeploy_time),
                            "undeploy_time" => Ok(__FieldTag::__undeploy_time),
                            "config" => Ok(__FieldTag::__config),
                            "address" => Ok(__FieldTag::__address),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "platform" => Ok(__FieldTag::__platform),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeploymentOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeploymentOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_email => {
                            if !fields.insert(__FieldTag::__user_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_email",
                                ));
                            }
                            result.user_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deploy_time => {
                            if !fields.insert(__FieldTag::__deploy_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_time",
                                ));
                            }
                            result.deploy_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__undeploy_time => {
                            if !fields.insert(__FieldTag::__undeploy_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for undeploy_time",
                                ));
                            }
                            result.undeploy_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__address => {
                            if !fields.insert(__FieldTag::__address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for address",
                                ));
                            }
                            result.address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__platform => {
                            if !fields.insert(__FieldTag::__platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for platform",
                                ));
                            }
                            result.platform =
                                map.next_value::<std::option::Option<
                                    crate::model::deployment_occurrence::Platform,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeploymentOccurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_email.is_empty() {
            state.serialize_entry("userEmail", &self.user_email)?;
        }
        if self.deploy_time.is_some() {
            state.serialize_entry("deployTime", &self.deploy_time)?;
        }
        if self.undeploy_time.is_some() {
            state.serialize_entry("undeployTime", &self.undeploy_time)?;
        }
        if !self.config.is_empty() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.address.is_empty() {
            state.serialize_entry("address", &self.address)?;
        }
        if !self.resource_uri.is_empty() {
            state.serialize_entry("resourceUri", &self.resource_uri)?;
        }
        if !wkt::internal::is_default(&self.platform) {
            state.serialize_entry("platform", &self.platform)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DeploymentOccurrence].
pub mod deployment_occurrence {
    #[allow(unused_imports)]
    use super::*;

    /// Types of platforms.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Platform {
        /// Unknown.
        Unspecified,
        /// Google Container Engine.
        Gke,
        /// Google App Engine: Flexible Environment.
        Flex,
        /// Custom user-defined platform.
        Custom,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Platform::value] or
        /// [Platform::name].
        UnknownValue(platform::UnknownValue),
    }

    #[doc(hidden)]
    pub mod platform {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Platform {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gke => std::option::Option::Some(1),
                Self::Flex => std::option::Option::Some(2),
                Self::Custom => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PLATFORM_UNSPECIFIED"),
                Self::Gke => std::option::Option::Some("GKE"),
                Self::Flex => std::option::Option::Some("FLEX"),
                Self::Custom => std::option::Option::Some("CUSTOM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Platform {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Platform {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Platform {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Gke,
                2 => Self::Flex,
                3 => Self::Custom,
                _ => Self::UnknownValue(platform::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Platform {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PLATFORM_UNSPECIFIED" => Self::Unspecified,
                "GKE" => Self::Gke,
                "FLEX" => Self::Flex,
                "CUSTOM" => Self::Custom,
                _ => Self::UnknownValue(platform::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Platform {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gke => serializer.serialize_i32(1),
                Self::Flex => serializer.serialize_i32(2),
                Self::Custom => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Platform {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Platform>::new(
                ".grafeas.v1.DeploymentOccurrence.Platform",
            ))
        }
    }
}

/// A note that indicates a type of analysis a provider would perform. This note
/// exists in a provider's project. A `Discovery` occurrence is created in a
/// consumer's project at the start of analysis.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryNote {
    /// Required. Immutable. The kind of analysis that is handled by this
    /// discovery.
    pub analysis_kind: crate::model::NoteKind,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analysis_kind][crate::model::DiscoveryNote::analysis_kind].
    pub fn set_analysis_kind<T: std::convert::Into<crate::model::NoteKind>>(
        mut self,
        v: T,
    ) -> Self {
        self.analysis_kind = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DiscoveryNote"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __analysis_kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "analysisKind" => Ok(__FieldTag::__analysis_kind),
                            "analysis_kind" => Ok(__FieldTag::__analysis_kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__analysis_kind => {
                            if !fields.insert(__FieldTag::__analysis_kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_kind",
                                ));
                            }
                            result.analysis_kind = map
                                .next_value::<std::option::Option<crate::model::NoteKind>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryNote {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.analysis_kind) {
            state.serialize_entry("analysisKind", &self.analysis_kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Provides information about the analysis status of a discovered resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryOccurrence {
    /// Whether the resource is continuously analyzed.
    pub continuous_analysis: crate::model::discovery_occurrence::ContinuousAnalysis,

    /// The status of discovery for the resource.
    pub analysis_status: crate::model::discovery_occurrence::AnalysisStatus,

    pub analysis_completed:
        std::option::Option<crate::model::discovery_occurrence::AnalysisCompleted>,

    /// Indicates any errors encountered during analysis of a resource. There
    /// could be 0 or more of these errors.
    pub analysis_error: std::vec::Vec<rpc::model::Status>,

    /// When an error is encountered this will contain a LocalizedMessage under
    /// details to show to the user. The LocalizedMessage is output only and
    /// populated by the API.
    pub analysis_status_error: std::option::Option<rpc::model::Status>,

    /// The CPE of the resource being scanned.
    pub cpe: std::string::String,

    /// The last time this resource was scanned.
    pub last_scan_time: std::option::Option<wkt::Timestamp>,

    /// The time occurrences related to this discovery occurrence were archived.
    pub archive_time: std::option::Option<wkt::Timestamp>,

    /// The status of an SBOM generation.
    pub sbom_status: std::option::Option<crate::model::discovery_occurrence::SBOMStatus>,

    /// The status of an vulnerability attestation generation.
    pub vulnerability_attestation:
        std::option::Option<crate::model::discovery_occurrence::VulnerabilityAttestation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [continuous_analysis][crate::model::DiscoveryOccurrence::continuous_analysis].
    pub fn set_continuous_analysis<
        T: std::convert::Into<crate::model::discovery_occurrence::ContinuousAnalysis>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.continuous_analysis = v.into();
        self
    }

    /// Sets the value of [analysis_status][crate::model::DiscoveryOccurrence::analysis_status].
    pub fn set_analysis_status<
        T: std::convert::Into<crate::model::discovery_occurrence::AnalysisStatus>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.analysis_status = v.into();
        self
    }

    /// Sets the value of [analysis_completed][crate::model::DiscoveryOccurrence::analysis_completed].
    pub fn set_analysis_completed<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::discovery_occurrence::AnalysisCompleted>,
    {
        self.analysis_completed = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analysis_completed][crate::model::DiscoveryOccurrence::analysis_completed].
    pub fn set_or_clear_analysis_completed<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::discovery_occurrence::AnalysisCompleted>,
    {
        self.analysis_completed = v.map(|x| x.into());
        self
    }

    /// Sets the value of [analysis_error][crate::model::DiscoveryOccurrence::analysis_error].
    pub fn set_analysis_error<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.analysis_error = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [analysis_status_error][crate::model::DiscoveryOccurrence::analysis_status_error].
    pub fn set_analysis_status_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.analysis_status_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analysis_status_error][crate::model::DiscoveryOccurrence::analysis_status_error].
    pub fn set_or_clear_analysis_status_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.analysis_status_error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cpe][crate::model::DiscoveryOccurrence::cpe].
    pub fn set_cpe<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe = v.into();
        self
    }

    /// Sets the value of [last_scan_time][crate::model::DiscoveryOccurrence::last_scan_time].
    pub fn set_last_scan_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_scan_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_scan_time][crate::model::DiscoveryOccurrence::last_scan_time].
    pub fn set_or_clear_last_scan_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_scan_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [archive_time][crate::model::DiscoveryOccurrence::archive_time].
    pub fn set_archive_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.archive_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [archive_time][crate::model::DiscoveryOccurrence::archive_time].
    pub fn set_or_clear_archive_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.archive_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sbom_status][crate::model::DiscoveryOccurrence::sbom_status].
    pub fn set_sbom_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::discovery_occurrence::SBOMStatus>,
    {
        self.sbom_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sbom_status][crate::model::DiscoveryOccurrence::sbom_status].
    pub fn set_or_clear_sbom_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::discovery_occurrence::SBOMStatus>,
    {
        self.sbom_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vulnerability_attestation][crate::model::DiscoveryOccurrence::vulnerability_attestation].
    pub fn set_vulnerability_attestation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::discovery_occurrence::VulnerabilityAttestation>,
    {
        self.vulnerability_attestation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vulnerability_attestation][crate::model::DiscoveryOccurrence::vulnerability_attestation].
    pub fn set_or_clear_vulnerability_attestation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::discovery_occurrence::VulnerabilityAttestation>,
    {
        self.vulnerability_attestation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DiscoveryOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DiscoveryOccurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __continuous_analysis,
            __analysis_status,
            __analysis_completed,
            __analysis_error,
            __analysis_status_error,
            __cpe,
            __last_scan_time,
            __archive_time,
            __sbom_status,
            __vulnerability_attestation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "continuousAnalysis" => Ok(__FieldTag::__continuous_analysis),
                            "continuous_analysis" => Ok(__FieldTag::__continuous_analysis),
                            "analysisStatus" => Ok(__FieldTag::__analysis_status),
                            "analysis_status" => Ok(__FieldTag::__analysis_status),
                            "analysisCompleted" => Ok(__FieldTag::__analysis_completed),
                            "analysis_completed" => Ok(__FieldTag::__analysis_completed),
                            "analysisError" => Ok(__FieldTag::__analysis_error),
                            "analysis_error" => Ok(__FieldTag::__analysis_error),
                            "analysisStatusError" => Ok(__FieldTag::__analysis_status_error),
                            "analysis_status_error" => Ok(__FieldTag::__analysis_status_error),
                            "cpe" => Ok(__FieldTag::__cpe),
                            "lastScanTime" => Ok(__FieldTag::__last_scan_time),
                            "last_scan_time" => Ok(__FieldTag::__last_scan_time),
                            "archiveTime" => Ok(__FieldTag::__archive_time),
                            "archive_time" => Ok(__FieldTag::__archive_time),
                            "sbomStatus" => Ok(__FieldTag::__sbom_status),
                            "sbom_status" => Ok(__FieldTag::__sbom_status),
                            "vulnerabilityAttestation" => {
                                Ok(__FieldTag::__vulnerability_attestation)
                            }
                            "vulnerability_attestation" => {
                                Ok(__FieldTag::__vulnerability_attestation)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__continuous_analysis => {
                            if !fields.insert(__FieldTag::__continuous_analysis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for continuous_analysis",
                                ));
                            }
                            result.continuous_analysis = map
                                .next_value::<std::option::Option<
                                    crate::model::discovery_occurrence::ContinuousAnalysis,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__analysis_status => {
                            if !fields.insert(__FieldTag::__analysis_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_status",
                                ));
                            }
                            result.analysis_status = map
                                .next_value::<std::option::Option<
                                    crate::model::discovery_occurrence::AnalysisStatus,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__analysis_completed => {
                            if !fields.insert(__FieldTag::__analysis_completed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_completed",
                                ));
                            }
                            result.analysis_completed = map.next_value::<std::option::Option<
                                crate::model::discovery_occurrence::AnalysisCompleted,
                            >>()?;
                        }
                        __FieldTag::__analysis_error => {
                            if !fields.insert(__FieldTag::__analysis_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_error",
                                ));
                            }
                            result.analysis_error = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__analysis_status_error => {
                            if !fields.insert(__FieldTag::__analysis_status_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_status_error",
                                ));
                            }
                            result.analysis_status_error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__cpe => {
                            if !fields.insert(__FieldTag::__cpe) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe",
                                ));
                            }
                            result.cpe = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_scan_time => {
                            if !fields.insert(__FieldTag::__last_scan_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_scan_time",
                                ));
                            }
                            result.last_scan_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__archive_time => {
                            if !fields.insert(__FieldTag::__archive_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_time",
                                ));
                            }
                            result.archive_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__sbom_status => {
                            if !fields.insert(__FieldTag::__sbom_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sbom_status",
                                ));
                            }
                            result.sbom_status = map.next_value::<std::option::Option<
                                crate::model::discovery_occurrence::SBOMStatus,
                            >>()?;
                        }
                        __FieldTag::__vulnerability_attestation => {
                            if !fields.insert(__FieldTag::__vulnerability_attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability_attestation",
                                ));
                            }
                            result.vulnerability_attestation = map
                                .next_value::<std::option::Option<
                                    crate::model::discovery_occurrence::VulnerabilityAttestation,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryOccurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.continuous_analysis) {
            state.serialize_entry("continuousAnalysis", &self.continuous_analysis)?;
        }
        if !wkt::internal::is_default(&self.analysis_status) {
            state.serialize_entry("analysisStatus", &self.analysis_status)?;
        }
        if self.analysis_completed.is_some() {
            state.serialize_entry("analysisCompleted", &self.analysis_completed)?;
        }
        if !self.analysis_error.is_empty() {
            state.serialize_entry("analysisError", &self.analysis_error)?;
        }
        if self.analysis_status_error.is_some() {
            state.serialize_entry("analysisStatusError", &self.analysis_status_error)?;
        }
        if !self.cpe.is_empty() {
            state.serialize_entry("cpe", &self.cpe)?;
        }
        if self.last_scan_time.is_some() {
            state.serialize_entry("lastScanTime", &self.last_scan_time)?;
        }
        if self.archive_time.is_some() {
            state.serialize_entry("archiveTime", &self.archive_time)?;
        }
        if self.sbom_status.is_some() {
            state.serialize_entry("sbomStatus", &self.sbom_status)?;
        }
        if self.vulnerability_attestation.is_some() {
            state.serialize_entry("vulnerabilityAttestation", &self.vulnerability_attestation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryOccurrence].
pub mod discovery_occurrence {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates which analysis completed successfully. Multiple types of
    /// analysis can be performed on a single resource.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AnalysisCompleted {
        pub analysis_type: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnalysisCompleted {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [analysis_type][crate::model::discovery_occurrence::AnalysisCompleted::analysis_type].
        pub fn set_analysis_type<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.analysis_type = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for AnalysisCompleted {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.DiscoveryOccurrence.AnalysisCompleted"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AnalysisCompleted {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __analysis_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AnalysisCompleted")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "analysisType" => Ok(__FieldTag::__analysis_type),
                                "analysis_type" => Ok(__FieldTag::__analysis_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AnalysisCompleted;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AnalysisCompleted")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__analysis_type => {
                                if !fields.insert(__FieldTag::__analysis_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for analysis_type",
                                    ));
                                }
                                result.analysis_type = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AnalysisCompleted {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.analysis_type.is_empty() {
                state.serialize_entry("analysisType", &self.analysis_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The status of an SBOM generation.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SBOMStatus {
        /// The progress of the SBOM generation.
        pub sbom_state: crate::model::discovery_occurrence::sbom_status::SBOMState,

        /// If there was an error generating an SBOM, this will indicate what that
        /// error was.
        pub error: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SBOMStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sbom_state][crate::model::discovery_occurrence::SBOMStatus::sbom_state].
        pub fn set_sbom_state<
            T: std::convert::Into<crate::model::discovery_occurrence::sbom_status::SBOMState>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.sbom_state = v.into();
            self
        }

        /// Sets the value of [error][crate::model::discovery_occurrence::SBOMStatus::error].
        pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.error = v.into();
            self
        }
    }

    impl wkt::message::Message for SBOMStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.DiscoveryOccurrence.SBOMStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SBOMStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __sbom_state,
                __error,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SBOMStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sbomState" => Ok(__FieldTag::__sbom_state),
                                "sbom_state" => Ok(__FieldTag::__sbom_state),
                                "error" => Ok(__FieldTag::__error),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SBOMStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SBOMStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__sbom_state => {
                                if !fields.insert(__FieldTag::__sbom_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sbom_state",
                                    ));
                                }
                                result.sbom_state = map
                                    .next_value::<std::option::Option<
                                        crate::model::discovery_occurrence::sbom_status::SBOMState,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__error => {
                                if !fields.insert(__FieldTag::__error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error",
                                    ));
                                }
                                result.error = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SBOMStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.sbom_state) {
                state.serialize_entry("sbomState", &self.sbom_state)?;
            }
            if !self.error.is_empty() {
                state.serialize_entry("error", &self.error)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SBOMStatus].
    pub mod sbom_status {
        #[allow(unused_imports)]
        use super::*;

        /// An enum indicating the progress of the SBOM generation.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SBOMState {
            /// Default unknown state.
            Unspecified,
            /// SBOM scanning is pending.
            Pending,
            /// SBOM scanning has completed.
            Complete,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SBOMState::value] or
            /// [SBOMState::name].
            UnknownValue(sbom_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod sbom_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SBOMState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Pending => std::option::Option::Some(1),
                    Self::Complete => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SBOM_STATE_UNSPECIFIED"),
                    Self::Pending => std::option::Option::Some("PENDING"),
                    Self::Complete => std::option::Option::Some("COMPLETE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SBOMState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SBOMState {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SBOMState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Pending,
                    2 => Self::Complete,
                    _ => Self::UnknownValue(sbom_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SBOMState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SBOM_STATE_UNSPECIFIED" => Self::Unspecified,
                    "PENDING" => Self::Pending,
                    "COMPLETE" => Self::Complete,
                    _ => Self::UnknownValue(sbom_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SBOMState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Pending => serializer.serialize_i32(1),
                    Self::Complete => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SBOMState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SBOMState>::new(
                    ".grafeas.v1.DiscoveryOccurrence.SBOMStatus.SBOMState",
                ))
            }
        }
    }

    /// The status of an vulnerability attestation generation.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VulnerabilityAttestation {

        /// The last time we attempted to generate an attestation.
        pub last_attempt_time: std::option::Option<wkt::Timestamp>,

        /// The success/failure state of the latest attestation attempt.
        pub state: crate::model::discovery_occurrence::vulnerability_attestation::VulnerabilityAttestationState,

        /// If failure, the error reason for why the attestation generation failed.
        pub error: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VulnerabilityAttestation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [last_attempt_time][crate::model::discovery_occurrence::VulnerabilityAttestation::last_attempt_time].
        pub fn set_last_attempt_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_attempt_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [last_attempt_time][crate::model::discovery_occurrence::VulnerabilityAttestation::last_attempt_time].
        pub fn set_or_clear_last_attempt_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_attempt_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [state][crate::model::discovery_occurrence::VulnerabilityAttestation::state].
        pub fn set_state<T: std::convert::Into<crate::model::discovery_occurrence::vulnerability_attestation::VulnerabilityAttestationState>>(mut self, v: T) -> Self{
            self.state = v.into();
            self
        }

        /// Sets the value of [error][crate::model::discovery_occurrence::VulnerabilityAttestation::error].
        pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.error = v.into();
            self
        }
    }

    impl wkt::message::Message for VulnerabilityAttestation {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.DiscoveryOccurrence.VulnerabilityAttestation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VulnerabilityAttestation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __last_attempt_time,
                __state,
                __error,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VulnerabilityAttestation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "lastAttemptTime" => Ok(__FieldTag::__last_attempt_time),
                                "last_attempt_time" => Ok(__FieldTag::__last_attempt_time),
                                "state" => Ok(__FieldTag::__state),
                                "error" => Ok(__FieldTag::__error),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VulnerabilityAttestation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VulnerabilityAttestation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__last_attempt_time => {
                                if !fields.insert(__FieldTag::__last_attempt_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for last_attempt_time",
                                    ));
                                }
                                result.last_attempt_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::discovery_occurrence::vulnerability_attestation::VulnerabilityAttestationState>>()?.unwrap_or_default();
                            }
                            __FieldTag::__error => {
                                if !fields.insert(__FieldTag::__error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error",
                                    ));
                                }
                                result.error = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for VulnerabilityAttestation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.last_attempt_time.is_some() {
                state.serialize_entry("lastAttemptTime", &self.last_attempt_time)?;
            }
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.error.is_empty() {
                state.serialize_entry("error", &self.error)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [VulnerabilityAttestation].
    pub mod vulnerability_attestation {
        #[allow(unused_imports)]
        use super::*;

        /// An enum indicating the state of the attestation generation.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum VulnerabilityAttestationState {
            /// Default unknown state.
            Unspecified,
            /// Attestation was successfully generated and stored.
            Success,
            /// Attestation was unsuccessfully generated and stored.
            Failure,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [VulnerabilityAttestationState::value] or
            /// [VulnerabilityAttestationState::name].
            UnknownValue(vulnerability_attestation_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod vulnerability_attestation_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl VulnerabilityAttestationState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Success => std::option::Option::Some(1),
                    Self::Failure => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("VULNERABILITY_ATTESTATION_STATE_UNSPECIFIED")
                    }
                    Self::Success => std::option::Option::Some("SUCCESS"),
                    Self::Failure => std::option::Option::Some("FAILURE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for VulnerabilityAttestationState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for VulnerabilityAttestationState {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for VulnerabilityAttestationState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Success,
                    2 => Self::Failure,
                    _ => Self::UnknownValue(vulnerability_attestation_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for VulnerabilityAttestationState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "VULNERABILITY_ATTESTATION_STATE_UNSPECIFIED" => Self::Unspecified,
                    "SUCCESS" => Self::Success,
                    "FAILURE" => Self::Failure,
                    _ => Self::UnknownValue(vulnerability_attestation_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for VulnerabilityAttestationState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Success => serializer.serialize_i32(1),
                    Self::Failure => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for VulnerabilityAttestationState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<VulnerabilityAttestationState>::new(
                    ".grafeas.v1.DiscoveryOccurrence.VulnerabilityAttestation.VulnerabilityAttestationState"))
            }
        }
    }

    /// Whether the resource is continuously analyzed.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ContinuousAnalysis {
        /// Unknown.
        Unspecified,
        /// The resource is continuously analyzed.
        Active,
        /// The resource is ignored for continuous analysis.
        Inactive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ContinuousAnalysis::value] or
        /// [ContinuousAnalysis::name].
        UnknownValue(continuous_analysis::UnknownValue),
    }

    #[doc(hidden)]
    pub mod continuous_analysis {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ContinuousAnalysis {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Inactive => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONTINUOUS_ANALYSIS_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ContinuousAnalysis {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ContinuousAnalysis {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ContinuousAnalysis {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Inactive,
                _ => Self::UnknownValue(continuous_analysis::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ContinuousAnalysis {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONTINUOUS_ANALYSIS_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "INACTIVE" => Self::Inactive,
                _ => Self::UnknownValue(continuous_analysis::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ContinuousAnalysis {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Inactive => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ContinuousAnalysis {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContinuousAnalysis>::new(
                ".grafeas.v1.DiscoveryOccurrence.ContinuousAnalysis",
            ))
        }
    }

    /// Analysis status for a resource. Currently for initial analysis only (not
    /// updated in continuous analysis).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AnalysisStatus {
        /// Unknown.
        Unspecified,
        /// Resource is known but no action has been taken yet.
        Pending,
        /// Resource is being analyzed.
        Scanning,
        /// Analysis has finished successfully.
        FinishedSuccess,
        /// Analysis has completed.
        Complete,
        /// Analysis has finished unsuccessfully, the analysis itself is in a bad
        /// state.
        FinishedFailed,
        /// The resource is known not to be supported.
        FinishedUnsupported,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AnalysisStatus::value] or
        /// [AnalysisStatus::name].
        UnknownValue(analysis_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod analysis_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AnalysisStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Scanning => std::option::Option::Some(2),
                Self::FinishedSuccess => std::option::Option::Some(3),
                Self::Complete => std::option::Option::Some(3),
                Self::FinishedFailed => std::option::Option::Some(4),
                Self::FinishedUnsupported => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ANALYSIS_STATUS_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Scanning => std::option::Option::Some("SCANNING"),
                Self::FinishedSuccess => std::option::Option::Some("FINISHED_SUCCESS"),
                Self::Complete => std::option::Option::Some("COMPLETE"),
                Self::FinishedFailed => std::option::Option::Some("FINISHED_FAILED"),
                Self::FinishedUnsupported => std::option::Option::Some("FINISHED_UNSUPPORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AnalysisStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AnalysisStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AnalysisStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Scanning,
                3 => Self::Complete,
                4 => Self::FinishedFailed,
                5 => Self::FinishedUnsupported,
                _ => Self::UnknownValue(analysis_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AnalysisStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANALYSIS_STATUS_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "SCANNING" => Self::Scanning,
                "FINISHED_SUCCESS" => Self::FinishedSuccess,
                "COMPLETE" => Self::Complete,
                "FINISHED_FAILED" => Self::FinishedFailed,
                "FINISHED_UNSUPPORTED" => Self::FinishedUnsupported,
                _ => Self::UnknownValue(analysis_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AnalysisStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Scanning => serializer.serialize_i32(2),
                Self::FinishedSuccess => serializer.serialize_i32(3),
                Self::Complete => serializer.serialize_i32(3),
                Self::FinishedFailed => serializer.serialize_i32(4),
                Self::FinishedUnsupported => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AnalysisStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AnalysisStatus>::new(
                ".grafeas.v1.DiscoveryOccurrence.AnalysisStatus",
            ))
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DSSEAttestationNote {
    /// DSSEHint hints at the purpose of the attestation authority.
    pub hint: std::option::Option<crate::model::dsse_attestation_note::DSSEHint>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DSSEAttestationNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hint][crate::model::DSSEAttestationNote::hint].
    pub fn set_hint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::dsse_attestation_note::DSSEHint>,
    {
        self.hint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hint][crate::model::DSSEAttestationNote::hint].
    pub fn set_or_clear_hint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::dsse_attestation_note::DSSEHint>,
    {
        self.hint = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DSSEAttestationNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DSSEAttestationNote"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DSSEAttestationNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DSSEAttestationNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hint" => Ok(__FieldTag::__hint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DSSEAttestationNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DSSEAttestationNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hint => {
                            if !fields.insert(__FieldTag::__hint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hint",
                                ));
                            }
                            result.hint = map.next_value::<std::option::Option<
                                crate::model::dsse_attestation_note::DSSEHint,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DSSEAttestationNote {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.hint.is_some() {
            state.serialize_entry("hint", &self.hint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DSSEAttestationNote].
pub mod dsse_attestation_note {
    #[allow(unused_imports)]
    use super::*;

    /// This submessage provides human-readable hints about the purpose of the
    /// authority. Because the name of a note acts as its resource reference, it is
    /// important to disambiguate the canonical name of the Note (which might be a
    /// UUID for security purposes) from "readable" names more suitable for debug
    /// output. Note that these hints should not be used to look up authorities in
    /// security sensitive contexts, such as when looking up attestations to
    /// verify.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DSSEHint {
        /// Required. The human readable name of this attestation authority, for
        /// example "cloudbuild-prod".
        pub human_readable_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DSSEHint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [human_readable_name][crate::model::dsse_attestation_note::DSSEHint::human_readable_name].
        pub fn set_human_readable_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.human_readable_name = v.into();
            self
        }
    }

    impl wkt::message::Message for DSSEHint {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.DSSEAttestationNote.DSSEHint"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DSSEHint {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __human_readable_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DSSEHint")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "humanReadableName" => Ok(__FieldTag::__human_readable_name),
                                "human_readable_name" => Ok(__FieldTag::__human_readable_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DSSEHint;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DSSEHint")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__human_readable_name => {
                                if !fields.insert(__FieldTag::__human_readable_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for human_readable_name",
                                    ));
                                }
                                result.human_readable_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DSSEHint {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.human_readable_name.is_empty() {
                state.serialize_entry("humanReadableName", &self.human_readable_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Deprecated. Prefer to use a regular Occurrence, and populate the
/// Envelope at the top level of the Occurrence.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DSSEAttestationOccurrence {
    /// If doing something security critical, make sure to verify the signatures in
    /// this metadata.
    pub envelope: std::option::Option<crate::model::Envelope>,

    pub decoded_payload:
        std::option::Option<crate::model::dsse_attestation_occurrence::DecodedPayload>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DSSEAttestationOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [envelope][crate::model::DSSEAttestationOccurrence::envelope].
    pub fn set_envelope<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Envelope>,
    {
        self.envelope = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [envelope][crate::model::DSSEAttestationOccurrence::envelope].
    pub fn set_or_clear_envelope<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Envelope>,
    {
        self.envelope = v.map(|x| x.into());
        self
    }

    /// Sets the value of [decoded_payload][crate::model::DSSEAttestationOccurrence::decoded_payload].
    ///
    /// Note that all the setters affecting `decoded_payload` are mutually
    /// exclusive.
    pub fn set_decoded_payload<
        T: std::convert::Into<
                std::option::Option<crate::model::dsse_attestation_occurrence::DecodedPayload>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.decoded_payload = v.into();
        self
    }

    /// The value of [decoded_payload][crate::model::DSSEAttestationOccurrence::decoded_payload]
    /// if it holds a `Statement`, `None` if the field is not set or
    /// holds a different branch.
    pub fn statement(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InTotoStatement>> {
        #[allow(unreachable_patterns)]
        self.decoded_payload.as_ref().and_then(|v| match v {
            crate::model::dsse_attestation_occurrence::DecodedPayload::Statement(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [decoded_payload][crate::model::DSSEAttestationOccurrence::decoded_payload]
    /// to hold a `Statement`.
    ///
    /// Note that all the setters affecting `decoded_payload` are
    /// mutually exclusive.
    pub fn set_statement<T: std::convert::Into<std::boxed::Box<crate::model::InTotoStatement>>>(
        mut self,
        v: T,
    ) -> Self {
        self.decoded_payload = std::option::Option::Some(
            crate::model::dsse_attestation_occurrence::DecodedPayload::Statement(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DSSEAttestationOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DSSEAttestationOccurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DSSEAttestationOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __envelope,
            __statement,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DSSEAttestationOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "envelope" => Ok(__FieldTag::__envelope),
                            "statement" => Ok(__FieldTag::__statement),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DSSEAttestationOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DSSEAttestationOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__envelope => {
                            if !fields.insert(__FieldTag::__envelope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for envelope",
                                ));
                            }
                            result.envelope =
                                map.next_value::<std::option::Option<crate::model::Envelope>>()?;
                        }
                        __FieldTag::__statement => {
                            if !fields.insert(__FieldTag::__statement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statement",
                                ));
                            }
                            if result.decoded_payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `decoded_payload`, a oneof with full ID .grafeas.v1.DSSEAttestationOccurrence.statement, latest field was statement",
                                ));
                            }
                            result.decoded_payload = std::option::Option::Some(
                                crate::model::dsse_attestation_occurrence::DecodedPayload::Statement(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::InTotoStatement>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DSSEAttestationOccurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.envelope.is_some() {
            state.serialize_entry("envelope", &self.envelope)?;
        }
        if let Some(value) = self.statement() {
            state.serialize_entry("statement", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DSSEAttestationOccurrence].
pub mod dsse_attestation_occurrence {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DecodedPayload {
        Statement(std::boxed::Box<crate::model::InTotoStatement>),
    }
}

/// An instance of an analysis type that has been found on a resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Occurrence {
    /// Output only. The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    pub name: std::string::String,

    /// Required. Immutable. A URI that represents the resource for which the
    /// occurrence applies. For example,
    /// `<https://gcr.io/project/image@sha256:123abc>` for a Docker image.
    pub resource_uri: std::string::String,

    /// Required. Immutable. The analysis note associated with this occurrence, in
    /// the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
    /// used as a filter in list requests.
    pub note_name: std::string::String,

    /// Output only. This explicitly denotes which of the occurrence details are
    /// specified. This field can be used as a filter in list requests.
    pub kind: crate::model::NoteKind,

    /// A description of actions that can be taken to remedy the note.
    pub remediation: std::string::String,

    /// Output only. The time this occurrence was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this occurrence was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// <https://github.com/secure-systems-lab/dsse>
    pub envelope: std::option::Option<crate::model::Envelope>,

    /// Required. Immutable. Describes the details of the note kind found on this
    /// resource.
    pub details: std::option::Option<crate::model::occurrence::Details>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Occurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Occurrence::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::Occurrence::resource_uri].
    pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [note_name][crate::model::Occurrence::note_name].
    pub fn set_note_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.note_name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Occurrence::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::NoteKind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [remediation][crate::model::Occurrence::remediation].
    pub fn set_remediation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remediation = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Occurrence::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Occurrence::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Occurrence::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Occurrence::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [envelope][crate::model::Occurrence::envelope].
    pub fn set_envelope<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Envelope>,
    {
        self.envelope = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [envelope][crate::model::Occurrence::envelope].
    pub fn set_or_clear_envelope<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Envelope>,
    {
        self.envelope = v.map(|x| x.into());
        self
    }

    /// Sets the value of [details][crate::model::Occurrence::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::occurrence::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Vulnerability`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vulnerability(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VulnerabilityOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Vulnerability(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Vulnerability`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_vulnerability<
        T: std::convert::Into<std::boxed::Box<crate::model::VulnerabilityOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Vulnerability(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Build`, `None` if the field is not set or
    /// holds a different branch.
    pub fn build(&self) -> std::option::Option<&std::boxed::Box<crate::model::BuildOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Build(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Build`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_build<T: std::convert::Into<std::boxed::Box<crate::model::BuildOccurrence>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Build(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Image`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image(&self) -> std::option::Option<&std::boxed::Box<crate::model::ImageOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Image(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Image`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_image<T: std::convert::Into<std::boxed::Box<crate::model::ImageOccurrence>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Image(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Package`, `None` if the field is not set or
    /// holds a different branch.
    pub fn package(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PackageOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Package(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Package`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_package<T: std::convert::Into<std::boxed::Box<crate::model::PackageOccurrence>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Package(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Deployment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deployment(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeploymentOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Deployment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Deployment`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_deployment<
        T: std::convert::Into<std::boxed::Box<crate::model::DeploymentOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Deployment(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Discovery`, `None` if the field is not set or
    /// holds a different branch.
    pub fn discovery(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Discovery(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Discovery`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_discovery<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Discovery(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Attestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn attestation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AttestationOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Attestation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Attestation`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_attestation<
        T: std::convert::Into<std::boxed::Box<crate::model::AttestationOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Attestation(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Upgrade`, `None` if the field is not set or
    /// holds a different branch.
    pub fn upgrade(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpgradeOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Upgrade(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Upgrade`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_upgrade<T: std::convert::Into<std::boxed::Box<crate::model::UpgradeOccurrence>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Upgrade(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Compliance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compliance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComplianceOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Compliance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Compliance`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_compliance<
        T: std::convert::Into<std::boxed::Box<crate::model::ComplianceOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Compliance(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `DsseAttestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dsse_attestation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DSSEAttestationOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::DsseAttestation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `DsseAttestation`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_dsse_attestation<
        T: std::convert::Into<std::boxed::Box<crate::model::DSSEAttestationOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::DsseAttestation(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `SbomReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sbom_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SBOMReferenceOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::SbomReference(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `SbomReference`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_sbom_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::SBOMReferenceOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::SbomReference(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Secret`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret(&self) -> std::option::Option<&std::boxed::Box<crate::model::SecretOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Secret(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Secret`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_secret<T: std::convert::Into<std::boxed::Box<crate::model::SecretOccurrence>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Secret(v.into()));
        self
    }
}

impl wkt::message::Message for Occurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Occurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Occurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __resource_uri,
            __note_name,
            __kind,
            __remediation,
            __create_time,
            __update_time,
            __vulnerability,
            __build,
            __image,
            __package,
            __deployment,
            __discovery,
            __attestation,
            __upgrade,
            __compliance,
            __dsse_attestation,
            __sbom_reference,
            __secret,
            __envelope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Occurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "noteName" => Ok(__FieldTag::__note_name),
                            "note_name" => Ok(__FieldTag::__note_name),
                            "kind" => Ok(__FieldTag::__kind),
                            "remediation" => Ok(__FieldTag::__remediation),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "vulnerability" => Ok(__FieldTag::__vulnerability),
                            "build" => Ok(__FieldTag::__build),
                            "image" => Ok(__FieldTag::__image),
                            "package" => Ok(__FieldTag::__package),
                            "deployment" => Ok(__FieldTag::__deployment),
                            "discovery" => Ok(__FieldTag::__discovery),
                            "attestation" => Ok(__FieldTag::__attestation),
                            "upgrade" => Ok(__FieldTag::__upgrade),
                            "compliance" => Ok(__FieldTag::__compliance),
                            "dsseAttestation" => Ok(__FieldTag::__dsse_attestation),
                            "dsse_attestation" => Ok(__FieldTag::__dsse_attestation),
                            "sbomReference" => Ok(__FieldTag::__sbom_reference),
                            "sbom_reference" => Ok(__FieldTag::__sbom_reference),
                            "secret" => Ok(__FieldTag::__secret),
                            "envelope" => Ok(__FieldTag::__envelope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Occurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Occurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__note_name => {
                            if !fields.insert(__FieldTag::__note_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for note_name",
                                ));
                            }
                            result.note_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<crate::model::NoteKind>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remediation => {
                            if !fields.insert(__FieldTag::__remediation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remediation",
                                ));
                            }
                            result.remediation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__vulnerability => {
                            if !fields.insert(__FieldTag::__vulnerability) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.vulnerability, latest field was vulnerability",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Vulnerability(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VulnerabilityOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.build, latest field was build",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Build(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BuildOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.image, latest field was image",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Image(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ImageOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__package => {
                            if !fields.insert(__FieldTag::__package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.package, latest field was package",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Package(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PackageOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__deployment => {
                            if !fields.insert(__FieldTag::__deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.deployment, latest field was deployment",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Deployment(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeploymentOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__discovery => {
                            if !fields.insert(__FieldTag::__discovery) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.discovery, latest field was discovery",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Discovery(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DiscoveryOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__attestation => {
                            if !fields.insert(__FieldTag::__attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attestation",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.attestation, latest field was attestation",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Attestation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AttestationOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__upgrade => {
                            if !fields.insert(__FieldTag::__upgrade) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.upgrade, latest field was upgrade",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Upgrade(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UpgradeOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__compliance => {
                            if !fields.insert(__FieldTag::__compliance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliance",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.compliance, latest field was compliance",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Compliance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ComplianceOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dsse_attestation => {
                            if !fields.insert(__FieldTag::__dsse_attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dsse_attestation",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.dsse_attestation, latest field was dsseAttestation",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::DsseAttestation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DSSEAttestationOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sbom_reference => {
                            if !fields.insert(__FieldTag::__sbom_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sbom_reference",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.sbom_reference, latest field was sbomReference",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::SbomReference(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SBOMReferenceOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.secret, latest field was secret",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Secret(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SecretOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__envelope => {
                            if !fields.insert(__FieldTag::__envelope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for envelope",
                                ));
                            }
                            result.envelope =
                                map.next_value::<std::option::Option<crate::model::Envelope>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Occurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.resource_uri.is_empty() {
            state.serialize_entry("resourceUri", &self.resource_uri)?;
        }
        if !self.note_name.is_empty() {
            state.serialize_entry("noteName", &self.note_name)?;
        }
        if !wkt::internal::is_default(&self.kind) {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.remediation.is_empty() {
            state.serialize_entry("remediation", &self.remediation)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if let Some(value) = self.vulnerability() {
            state.serialize_entry("vulnerability", value)?;
        }
        if let Some(value) = self.build() {
            state.serialize_entry("build", value)?;
        }
        if let Some(value) = self.image() {
            state.serialize_entry("image", value)?;
        }
        if let Some(value) = self.package() {
            state.serialize_entry("package", value)?;
        }
        if let Some(value) = self.deployment() {
            state.serialize_entry("deployment", value)?;
        }
        if let Some(value) = self.discovery() {
            state.serialize_entry("discovery", value)?;
        }
        if let Some(value) = self.attestation() {
            state.serialize_entry("attestation", value)?;
        }
        if let Some(value) = self.upgrade() {
            state.serialize_entry("upgrade", value)?;
        }
        if let Some(value) = self.compliance() {
            state.serialize_entry("compliance", value)?;
        }
        if let Some(value) = self.dsse_attestation() {
            state.serialize_entry("dsseAttestation", value)?;
        }
        if let Some(value) = self.sbom_reference() {
            state.serialize_entry("sbomReference", value)?;
        }
        if let Some(value) = self.secret() {
            state.serialize_entry("secret", value)?;
        }
        if self.envelope.is_some() {
            state.serialize_entry("envelope", &self.envelope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Occurrence].
pub mod occurrence {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Immutable. Describes the details of the note kind found on this
    /// resource.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Details {
        /// Describes a security vulnerability.
        Vulnerability(std::boxed::Box<crate::model::VulnerabilityOccurrence>),
        /// Describes a verifiable build.
        Build(std::boxed::Box<crate::model::BuildOccurrence>),
        /// Describes how this resource derives from the basis in the associated
        /// note.
        Image(std::boxed::Box<crate::model::ImageOccurrence>),
        /// Describes the installation of a package on the linked resource.
        Package(std::boxed::Box<crate::model::PackageOccurrence>),
        /// Describes the deployment of an artifact on a runtime.
        Deployment(std::boxed::Box<crate::model::DeploymentOccurrence>),
        /// Describes when a resource was discovered.
        Discovery(std::boxed::Box<crate::model::DiscoveryOccurrence>),
        /// Describes an attestation of an artifact.
        Attestation(std::boxed::Box<crate::model::AttestationOccurrence>),
        /// Describes an available package upgrade on the linked resource.
        Upgrade(std::boxed::Box<crate::model::UpgradeOccurrence>),
        /// Describes a compliance violation on a linked resource.
        Compliance(std::boxed::Box<crate::model::ComplianceOccurrence>),
        /// Describes an attestation of an artifact using dsse.
        DsseAttestation(std::boxed::Box<crate::model::DSSEAttestationOccurrence>),
        /// Describes a specific SBOM reference occurrences.
        SbomReference(std::boxed::Box<crate::model::SBOMReferenceOccurrence>),
        /// Describes a secret.
        Secret(std::boxed::Box<crate::model::SecretOccurrence>),
    }
}

/// A type of analysis that can be done for a resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Note {
    /// Output only. The name of the note in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    pub name: std::string::String,

    /// A one sentence description of this note.
    pub short_description: std::string::String,

    /// A detailed description of this note.
    pub long_description: std::string::String,

    /// Output only. The type of analysis. This field can be used as a filter in
    /// list requests.
    pub kind: crate::model::NoteKind,

    /// URLs associated with this note.
    pub related_url: std::vec::Vec<crate::model::RelatedUrl>,

    /// Time of expiration for this note. Empty if note does not expire.
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this note was created. This field can be used as a
    /// filter in list requests.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this note was last updated. This field can be used as
    /// a filter in list requests.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Other notes related to this note.
    pub related_note_names: std::vec::Vec<std::string::String>,

    /// Required. Immutable. The type of analysis this note represents.
    pub r#type: std::option::Option<crate::model::note::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Note {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Note::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [short_description][crate::model::Note::short_description].
    pub fn set_short_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.short_description = v.into();
        self
    }

    /// Sets the value of [long_description][crate::model::Note::long_description].
    pub fn set_long_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.long_description = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Note::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::NoteKind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [related_url][crate::model::Note::related_url].
    pub fn set_related_url<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedUrl>,
    {
        use std::iter::Iterator;
        self.related_url = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [expiration_time][crate::model::Note::expiration_time].
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::Note::expiration_time].
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Note::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Note::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Note::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Note::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [related_note_names][crate::model::Note::related_note_names].
    pub fn set_related_note_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.related_note_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [r#type][crate::model::Note::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::note::Type>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Vulnerability`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vulnerability(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VulnerabilityNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Vulnerability(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Vulnerability`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_vulnerability<
        T: std::convert::Into<std::boxed::Box<crate::model::VulnerabilityNote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Vulnerability(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Build`, `None` if the field is not set or
    /// holds a different branch.
    pub fn build(&self) -> std::option::Option<&std::boxed::Box<crate::model::BuildNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Build(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Build`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_build<T: std::convert::Into<std::boxed::Box<crate::model::BuildNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Build(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Image`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image(&self) -> std::option::Option<&std::boxed::Box<crate::model::ImageNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Image(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Image`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_image<T: std::convert::Into<std::boxed::Box<crate::model::ImageNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Image(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Package`, `None` if the field is not set or
    /// holds a different branch.
    pub fn package(&self) -> std::option::Option<&std::boxed::Box<crate::model::PackageNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Package(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Package`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_package<T: std::convert::Into<std::boxed::Box<crate::model::PackageNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Package(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Deployment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deployment(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeploymentNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Deployment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Deployment`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_deployment<T: std::convert::Into<std::boxed::Box<crate::model::DeploymentNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Deployment(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Discovery`, `None` if the field is not set or
    /// holds a different branch.
    pub fn discovery(&self) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Discovery(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Discovery`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_discovery<T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Discovery(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Attestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn attestation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AttestationNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Attestation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Attestation`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_attestation<
        T: std::convert::Into<std::boxed::Box<crate::model::AttestationNote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Attestation(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Upgrade`, `None` if the field is not set or
    /// holds a different branch.
    pub fn upgrade(&self) -> std::option::Option<&std::boxed::Box<crate::model::UpgradeNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Upgrade(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Upgrade`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_upgrade<T: std::convert::Into<std::boxed::Box<crate::model::UpgradeNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Upgrade(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Compliance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compliance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComplianceNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Compliance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Compliance`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_compliance<T: std::convert::Into<std::boxed::Box<crate::model::ComplianceNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Compliance(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `DsseAttestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dsse_attestation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DSSEAttestationNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::DsseAttestation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `DsseAttestation`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_dsse_attestation<
        T: std::convert::Into<std::boxed::Box<crate::model::DSSEAttestationNote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::note::Type::DsseAttestation(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `VulnerabilityAssessment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vulnerability_assessment(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VulnerabilityAssessmentNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::VulnerabilityAssessment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `VulnerabilityAssessment`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_vulnerability_assessment<
        T: std::convert::Into<std::boxed::Box<crate::model::VulnerabilityAssessmentNote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::note::Type::VulnerabilityAssessment(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `SbomReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sbom_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SBOMReferenceNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::SbomReference(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `SbomReference`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_sbom_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::SBOMReferenceNote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::SbomReference(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Secret`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret(&self) -> std::option::Option<&std::boxed::Box<crate::model::SecretNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Secret(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Secret`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_secret<T: std::convert::Into<std::boxed::Box<crate::model::SecretNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Secret(v.into()));
        self
    }
}

impl wkt::message::Message for Note {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Note"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Note {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __short_description,
            __long_description,
            __kind,
            __related_url,
            __expiration_time,
            __create_time,
            __update_time,
            __related_note_names,
            __vulnerability,
            __build,
            __image,
            __package,
            __deployment,
            __discovery,
            __attestation,
            __upgrade,
            __compliance,
            __dsse_attestation,
            __vulnerability_assessment,
            __sbom_reference,
            __secret,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Note")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "shortDescription" => Ok(__FieldTag::__short_description),
                            "short_description" => Ok(__FieldTag::__short_description),
                            "longDescription" => Ok(__FieldTag::__long_description),
                            "long_description" => Ok(__FieldTag::__long_description),
                            "kind" => Ok(__FieldTag::__kind),
                            "relatedUrl" => Ok(__FieldTag::__related_url),
                            "related_url" => Ok(__FieldTag::__related_url),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "relatedNoteNames" => Ok(__FieldTag::__related_note_names),
                            "related_note_names" => Ok(__FieldTag::__related_note_names),
                            "vulnerability" => Ok(__FieldTag::__vulnerability),
                            "build" => Ok(__FieldTag::__build),
                            "image" => Ok(__FieldTag::__image),
                            "package" => Ok(__FieldTag::__package),
                            "deployment" => Ok(__FieldTag::__deployment),
                            "discovery" => Ok(__FieldTag::__discovery),
                            "attestation" => Ok(__FieldTag::__attestation),
                            "upgrade" => Ok(__FieldTag::__upgrade),
                            "compliance" => Ok(__FieldTag::__compliance),
                            "dsseAttestation" => Ok(__FieldTag::__dsse_attestation),
                            "dsse_attestation" => Ok(__FieldTag::__dsse_attestation),
                            "vulnerabilityAssessment" => Ok(__FieldTag::__vulnerability_assessment),
                            "vulnerability_assessment" => {
                                Ok(__FieldTag::__vulnerability_assessment)
                            }
                            "sbomReference" => Ok(__FieldTag::__sbom_reference),
                            "sbom_reference" => Ok(__FieldTag::__sbom_reference),
                            "secret" => Ok(__FieldTag::__secret),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Note;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Note")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__short_description => {
                            if !fields.insert(__FieldTag::__short_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for short_description",
                                ));
                            }
                            result.short_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__long_description => {
                            if !fields.insert(__FieldTag::__long_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for long_description",
                                ));
                            }
                            result.long_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<crate::model::NoteKind>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__related_url => {
                            if !fields.insert(__FieldTag::__related_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_url",
                                ));
                            }
                            result.related_url = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RelatedUrl>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            result.expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__related_note_names => {
                            if !fields.insert(__FieldTag::__related_note_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_note_names",
                                ));
                            }
                            result.related_note_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__vulnerability => {
                            if !fields.insert(__FieldTag::__vulnerability) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.vulnerability, latest field was vulnerability",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Vulnerability(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VulnerabilityNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.build, latest field was build",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Build(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BuildNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.image, latest field was image",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Image(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ImageNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__package => {
                            if !fields.insert(__FieldTag::__package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.package, latest field was package",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Package(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PackageNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__deployment => {
                            if !fields.insert(__FieldTag::__deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.deployment, latest field was deployment",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Deployment(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeploymentNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__discovery => {
                            if !fields.insert(__FieldTag::__discovery) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.discovery, latest field was discovery",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Discovery(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DiscoveryNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__attestation => {
                            if !fields.insert(__FieldTag::__attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attestation",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.attestation, latest field was attestation",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Attestation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AttestationNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__upgrade => {
                            if !fields.insert(__FieldTag::__upgrade) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.upgrade, latest field was upgrade",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Upgrade(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UpgradeNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__compliance => {
                            if !fields.insert(__FieldTag::__compliance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliance",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.compliance, latest field was compliance",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Compliance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ComplianceNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__dsse_attestation => {
                            if !fields.insert(__FieldTag::__dsse_attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dsse_attestation",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.dsse_attestation, latest field was dsseAttestation",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::note::Type::DsseAttestation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DSSEAttestationNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__vulnerability_assessment => {
                            if !fields.insert(__FieldTag::__vulnerability_assessment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability_assessment",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.vulnerability_assessment, latest field was vulnerabilityAssessment",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::note::Type::VulnerabilityAssessment(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VulnerabilityAssessmentNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sbom_reference => {
                            if !fields.insert(__FieldTag::__sbom_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sbom_reference",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.sbom_reference, latest field was sbomReference",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::SbomReference(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SBOMReferenceNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.secret, latest field was secret",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Secret(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SecretNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Note {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.short_description.is_empty() {
            state.serialize_entry("shortDescription", &self.short_description)?;
        }
        if !self.long_description.is_empty() {
            state.serialize_entry("longDescription", &self.long_description)?;
        }
        if !wkt::internal::is_default(&self.kind) {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.related_url.is_empty() {
            state.serialize_entry("relatedUrl", &self.related_url)?;
        }
        if self.expiration_time.is_some() {
            state.serialize_entry("expirationTime", &self.expiration_time)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.related_note_names.is_empty() {
            state.serialize_entry("relatedNoteNames", &self.related_note_names)?;
        }
        if let Some(value) = self.vulnerability() {
            state.serialize_entry("vulnerability", value)?;
        }
        if let Some(value) = self.build() {
            state.serialize_entry("build", value)?;
        }
        if let Some(value) = self.image() {
            state.serialize_entry("image", value)?;
        }
        if let Some(value) = self.package() {
            state.serialize_entry("package", value)?;
        }
        if let Some(value) = self.deployment() {
            state.serialize_entry("deployment", value)?;
        }
        if let Some(value) = self.discovery() {
            state.serialize_entry("discovery", value)?;
        }
        if let Some(value) = self.attestation() {
            state.serialize_entry("attestation", value)?;
        }
        if let Some(value) = self.upgrade() {
            state.serialize_entry("upgrade", value)?;
        }
        if let Some(value) = self.compliance() {
            state.serialize_entry("compliance", value)?;
        }
        if let Some(value) = self.dsse_attestation() {
            state.serialize_entry("dsseAttestation", value)?;
        }
        if let Some(value) = self.vulnerability_assessment() {
            state.serialize_entry("vulnerabilityAssessment", value)?;
        }
        if let Some(value) = self.sbom_reference() {
            state.serialize_entry("sbomReference", value)?;
        }
        if let Some(value) = self.secret() {
            state.serialize_entry("secret", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Note].
pub mod note {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Immutable. The type of analysis this note represents.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// A note describing a package vulnerability.
        Vulnerability(std::boxed::Box<crate::model::VulnerabilityNote>),
        /// A note describing build provenance for a verifiable build.
        Build(std::boxed::Box<crate::model::BuildNote>),
        /// A note describing a base image.
        Image(std::boxed::Box<crate::model::ImageNote>),
        /// A note describing a package hosted by various package managers.
        Package(std::boxed::Box<crate::model::PackageNote>),
        /// A note describing something that can be deployed.
        Deployment(std::boxed::Box<crate::model::DeploymentNote>),
        /// A note describing the initial analysis of a resource.
        Discovery(std::boxed::Box<crate::model::DiscoveryNote>),
        /// A note describing an attestation role.
        Attestation(std::boxed::Box<crate::model::AttestationNote>),
        /// A note describing available package upgrades.
        Upgrade(std::boxed::Box<crate::model::UpgradeNote>),
        /// A note describing a compliance check.
        Compliance(std::boxed::Box<crate::model::ComplianceNote>),
        /// A note describing a dsse attestation note.
        DsseAttestation(std::boxed::Box<crate::model::DSSEAttestationNote>),
        /// A note describing a vulnerability assessment.
        VulnerabilityAssessment(std::boxed::Box<crate::model::VulnerabilityAssessmentNote>),
        /// A note describing an SBOM reference.
        SbomReference(std::boxed::Box<crate::model::SBOMReferenceNote>),
        /// A note describing a secret.
        Secret(std::boxed::Box<crate::model::SecretNote>),
    }
}

/// Request to get an occurrence.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetOccurrenceRequest {
    /// The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOccurrenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOccurrenceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOccurrenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GetOccurrenceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetOccurrenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOccurrenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetOccurrenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOccurrenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetOccurrenceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to list occurrences.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOccurrencesRequest {
    /// The name of the project to list occurrences for in the form of
    /// `projects/[PROJECT_ID]`.
    pub parent: std::string::String,

    /// The filter expression.
    pub filter: std::string::String,

    /// Number of occurrences to return in the list. Must be positive. Max allowed
    /// page size is 1000. If not specified, page size defaults to 20.
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOccurrencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOccurrencesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOccurrencesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOccurrencesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOccurrencesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOccurrencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListOccurrencesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOccurrencesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOccurrencesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOccurrencesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOccurrencesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOccurrencesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for listing occurrences.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOccurrencesResponse {
    /// The occurrences requested.
    pub occurrences: std::vec::Vec<crate::model::Occurrence>,

    /// The next pagination token in the list response. It should be used as
    /// `page_token` for the following request. An empty value means no more
    /// results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOccurrencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [occurrences][crate::model::ListOccurrencesResponse::occurrences].
    pub fn set_occurrences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Occurrence>,
    {
        use std::iter::Iterator;
        self.occurrences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOccurrencesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOccurrencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListOccurrencesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOccurrencesResponse {
    type PageItem = crate::model::Occurrence;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.occurrences
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOccurrencesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __occurrences,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOccurrencesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "occurrences" => Ok(__FieldTag::__occurrences),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOccurrencesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOccurrencesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__occurrences => {
                            if !fields.insert(__FieldTag::__occurrences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for occurrences",
                                ));
                            }
                            result.occurrences = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Occurrence>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOccurrencesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.occurrences.is_empty() {
            state.serialize_entry("occurrences", &self.occurrences)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to delete an occurrence.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteOccurrenceRequest {
    /// The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteOccurrenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteOccurrenceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteOccurrenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DeleteOccurrenceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteOccurrenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteOccurrenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteOccurrenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteOccurrenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteOccurrenceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to create a new occurrence.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateOccurrenceRequest {
    /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
    /// the occurrence is to be created.
    pub parent: std::string::String,

    /// The occurrence to create.
    pub occurrence: std::option::Option<crate::model::Occurrence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateOccurrenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateOccurrenceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [occurrence][crate::model::CreateOccurrenceRequest::occurrence].
    pub fn set_occurrence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Occurrence>,
    {
        self.occurrence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [occurrence][crate::model::CreateOccurrenceRequest::occurrence].
    pub fn set_or_clear_occurrence<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Occurrence>,
    {
        self.occurrence = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateOccurrenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CreateOccurrenceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateOccurrenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __occurrence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateOccurrenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "occurrence" => Ok(__FieldTag::__occurrence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateOccurrenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateOccurrenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__occurrence => {
                            if !fields.insert(__FieldTag::__occurrence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for occurrence",
                                ));
                            }
                            result.occurrence =
                                map.next_value::<std::option::Option<crate::model::Occurrence>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateOccurrenceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.occurrence.is_some() {
            state.serialize_entry("occurrence", &self.occurrence)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to update an occurrence.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateOccurrenceRequest {
    /// The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    pub name: std::string::String,

    /// The updated occurrence.
    pub occurrence: std::option::Option<crate::model::Occurrence>,

    /// The fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateOccurrenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateOccurrenceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [occurrence][crate::model::UpdateOccurrenceRequest::occurrence].
    pub fn set_occurrence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Occurrence>,
    {
        self.occurrence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [occurrence][crate::model::UpdateOccurrenceRequest::occurrence].
    pub fn set_or_clear_occurrence<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Occurrence>,
    {
        self.occurrence = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateOccurrenceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateOccurrenceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateOccurrenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpdateOccurrenceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateOccurrenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __occurrence,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateOccurrenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "occurrence" => Ok(__FieldTag::__occurrence),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateOccurrenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateOccurrenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__occurrence => {
                            if !fields.insert(__FieldTag::__occurrence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for occurrence",
                                ));
                            }
                            result.occurrence =
                                map.next_value::<std::option::Option<crate::model::Occurrence>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateOccurrenceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.occurrence.is_some() {
            state.serialize_entry("occurrence", &self.occurrence)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to get a note.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNoteRequest {
    /// The name of the note in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNoteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GetNoteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetNoteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetNoteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetNoteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetNoteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetNoteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to get the note to which the specified occurrence is attached.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetOccurrenceNoteRequest {
    /// The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOccurrenceNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOccurrenceNoteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOccurrenceNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GetOccurrenceNoteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetOccurrenceNoteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOccurrenceNoteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetOccurrenceNoteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOccurrenceNoteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetOccurrenceNoteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to list notes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNotesRequest {
    /// The name of the project to list notes for in the form of
    /// `projects/[PROJECT_ID]`.
    pub parent: std::string::String,

    /// The filter expression.
    pub filter: std::string::String,

    /// Number of notes to return in the list. Must be positive. Max allowed page
    /// size is 1000. If not specified, page size defaults to 20.
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNotesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNotesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNotesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNotesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListNotesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNotesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNotesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNotesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNotesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNotesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for listing notes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNotesResponse {
    /// The notes requested.
    pub notes: std::vec::Vec<crate::model::Note>,

    /// The next pagination token in the list response. It should be used as
    /// `page_token` for the following request. An empty value means no more
    /// results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNotesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notes][crate::model::ListNotesResponse::notes].
    pub fn set_notes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Note>,
    {
        use std::iter::Iterator;
        self.notes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNotesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNotesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListNotesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNotesResponse {
    type PageItem = crate::model::Note;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.notes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNotesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __notes,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNotesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "notes" => Ok(__FieldTag::__notes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNotesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNotesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__notes => {
                            if !fields.insert(__FieldTag::__notes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notes",
                                ));
                            }
                            result.notes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Note>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNotesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.notes.is_empty() {
            state.serialize_entry("notes", &self.notes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to delete a note.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteNoteRequest {
    /// The name of the note in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNoteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DeleteNoteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteNoteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteNoteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteNoteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteNoteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteNoteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to create a new note.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateNoteRequest {
    /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
    /// the note is to be created.
    pub parent: std::string::String,

    /// The ID to use for this note.
    pub note_id: std::string::String,

    /// The note to create.
    pub note: std::option::Option<crate::model::Note>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNoteRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [note_id][crate::model::CreateNoteRequest::note_id].
    pub fn set_note_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.note_id = v.into();
        self
    }

    /// Sets the value of [note][crate::model::CreateNoteRequest::note].
    pub fn set_note<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Note>,
    {
        self.note = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [note][crate::model::CreateNoteRequest::note].
    pub fn set_or_clear_note<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Note>,
    {
        self.note = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CreateNoteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateNoteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __note_id,
            __note,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateNoteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "noteId" => Ok(__FieldTag::__note_id),
                            "note_id" => Ok(__FieldTag::__note_id),
                            "note" => Ok(__FieldTag::__note),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateNoteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateNoteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__note_id => {
                            if !fields.insert(__FieldTag::__note_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for note_id",
                                ));
                            }
                            result.note_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__note => {
                            if !fields.insert(__FieldTag::__note) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for note",
                                ));
                            }
                            result.note =
                                map.next_value::<std::option::Option<crate::model::Note>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateNoteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.note_id.is_empty() {
            state.serialize_entry("noteId", &self.note_id)?;
        }
        if self.note.is_some() {
            state.serialize_entry("note", &self.note)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to update a note.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateNoteRequest {
    /// The name of the note in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    pub name: std::string::String,

    /// The updated note.
    pub note: std::option::Option<crate::model::Note>,

    /// The fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateNoteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [note][crate::model::UpdateNoteRequest::note].
    pub fn set_note<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Note>,
    {
        self.note = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [note][crate::model::UpdateNoteRequest::note].
    pub fn set_or_clear_note<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Note>,
    {
        self.note = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNoteRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNoteRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpdateNoteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateNoteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __note,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateNoteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "note" => Ok(__FieldTag::__note),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateNoteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateNoteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__note => {
                            if !fields.insert(__FieldTag::__note) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for note",
                                ));
                            }
                            result.note =
                                map.next_value::<std::option::Option<crate::model::Note>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateNoteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.note.is_some() {
            state.serialize_entry("note", &self.note)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to list occurrences for a note.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNoteOccurrencesRequest {
    /// The name of the note to list occurrences for in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    pub name: std::string::String,

    /// The filter expression.
    pub filter: std::string::String,

    /// Number of occurrences to return in the list.
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNoteOccurrencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListNoteOccurrencesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNoteOccurrencesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNoteOccurrencesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNoteOccurrencesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNoteOccurrencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListNoteOccurrencesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNoteOccurrencesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNoteOccurrencesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNoteOccurrencesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNoteOccurrencesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNoteOccurrencesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for listing occurrences for a note.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNoteOccurrencesResponse {
    /// The occurrences attached to the specified note.
    pub occurrences: std::vec::Vec<crate::model::Occurrence>,

    /// Token to provide to skip to a particular spot in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNoteOccurrencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [occurrences][crate::model::ListNoteOccurrencesResponse::occurrences].
    pub fn set_occurrences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Occurrence>,
    {
        use std::iter::Iterator;
        self.occurrences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNoteOccurrencesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNoteOccurrencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListNoteOccurrencesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNoteOccurrencesResponse {
    type PageItem = crate::model::Occurrence;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.occurrences
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNoteOccurrencesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __occurrences,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNoteOccurrencesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "occurrences" => Ok(__FieldTag::__occurrences),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNoteOccurrencesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNoteOccurrencesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__occurrences => {
                            if !fields.insert(__FieldTag::__occurrences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for occurrences",
                                ));
                            }
                            result.occurrences = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Occurrence>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNoteOccurrencesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.occurrences.is_empty() {
            state.serialize_entry("occurrences", &self.occurrences)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to create notes in batch.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateNotesRequest {
    /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
    /// the notes are to be created.
    pub parent: std::string::String,

    /// The notes to create. Max allowed length is 1000.
    pub notes: std::collections::HashMap<std::string::String, crate::model::Note>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateNotesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateNotesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [notes][crate::model::BatchCreateNotesRequest::notes].
    pub fn set_notes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Note>,
    {
        use std::iter::Iterator;
        self.notes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateNotesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BatchCreateNotesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchCreateNotesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __notes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateNotesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "notes" => Ok(__FieldTag::__notes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchCreateNotesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateNotesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__notes => {
                            if !fields.insert(__FieldTag::__notes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notes",
                                ));
                            }
                            result.notes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::Note,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchCreateNotesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.notes.is_empty() {
            state.serialize_entry("notes", &self.notes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for creating notes in batch.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateNotesResponse {
    /// The notes that were created.
    pub notes: std::vec::Vec<crate::model::Note>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateNotesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notes][crate::model::BatchCreateNotesResponse::notes].
    pub fn set_notes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Note>,
    {
        use std::iter::Iterator;
        self.notes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateNotesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BatchCreateNotesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchCreateNotesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __notes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateNotesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "notes" => Ok(__FieldTag::__notes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchCreateNotesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateNotesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__notes => {
                            if !fields.insert(__FieldTag::__notes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notes",
                                ));
                            }
                            result.notes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Note>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchCreateNotesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.notes.is_empty() {
            state.serialize_entry("notes", &self.notes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to create occurrences in batch.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateOccurrencesRequest {
    /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
    /// the occurrences are to be created.
    pub parent: std::string::String,

    /// The occurrences to create. Max allowed length is 1000.
    pub occurrences: std::vec::Vec<crate::model::Occurrence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateOccurrencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateOccurrencesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [occurrences][crate::model::BatchCreateOccurrencesRequest::occurrences].
    pub fn set_occurrences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Occurrence>,
    {
        use std::iter::Iterator;
        self.occurrences = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateOccurrencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BatchCreateOccurrencesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchCreateOccurrencesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __occurrences,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateOccurrencesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "occurrences" => Ok(__FieldTag::__occurrences),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchCreateOccurrencesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateOccurrencesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__occurrences => {
                            if !fields.insert(__FieldTag::__occurrences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for occurrences",
                                ));
                            }
                            result.occurrences = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Occurrence>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchCreateOccurrencesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.occurrences.is_empty() {
            state.serialize_entry("occurrences", &self.occurrences)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for creating occurrences in batch.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateOccurrencesResponse {
    /// The occurrences that were created.
    pub occurrences: std::vec::Vec<crate::model::Occurrence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateOccurrencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [occurrences][crate::model::BatchCreateOccurrencesResponse::occurrences].
    pub fn set_occurrences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Occurrence>,
    {
        use std::iter::Iterator;
        self.occurrences = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateOccurrencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BatchCreateOccurrencesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchCreateOccurrencesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __occurrences,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateOccurrencesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "occurrences" => Ok(__FieldTag::__occurrences),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchCreateOccurrencesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateOccurrencesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__occurrences => {
                            if !fields.insert(__FieldTag::__occurrences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for occurrences",
                                ));
                            }
                            result.occurrences = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Occurrence>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchCreateOccurrencesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.occurrences.is_empty() {
            state.serialize_entry("occurrences", &self.occurrences)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Layer holds metadata specific to a layer of a Docker image.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Layer {
    /// Required. The recovered Dockerfile directive used to construct this layer.
    /// See <https://docs.docker.com/engine/reference/builder/> for more information.
    pub directive: std::string::String,

    /// The recovered arguments to the Dockerfile directive.
    pub arguments: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Layer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [directive][crate::model::Layer::directive].
    pub fn set_directive<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.directive = v.into();
        self
    }

    /// Sets the value of [arguments][crate::model::Layer::arguments].
    pub fn set_arguments<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.arguments = v.into();
        self
    }
}

impl wkt::message::Message for Layer {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Layer"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Layer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __directive,
            __arguments,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Layer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "directive" => Ok(__FieldTag::__directive),
                            "arguments" => Ok(__FieldTag::__arguments),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Layer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Layer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__directive => {
                            if !fields.insert(__FieldTag::__directive) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for directive",
                                ));
                            }
                            result.directive = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__arguments => {
                            if !fields.insert(__FieldTag::__arguments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arguments",
                                ));
                            }
                            result.arguments = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Layer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.directive.is_empty() {
            state.serialize_entry("directive", &self.directive)?;
        }
        if !self.arguments.is_empty() {
            state.serialize_entry("arguments", &self.arguments)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A set of properties that uniquely identify a given Docker image.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Fingerprint {
    /// Required. The layer ID of the final layer in the Docker image's v1
    /// representation.
    pub v1_name: std::string::String,

    /// Required. The ordered list of v2 blobs that represent a given image.
    pub v2_blob: std::vec::Vec<std::string::String>,

    /// Output only. The name of the image's v2 blobs computed via:
    /// [bottom] := v2_blob[bottom]
    /// [N] := sha256(v2_blob[N] + " " + v2_name[N+1])
    /// Only the name of the final blob is kept.
    pub v2_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Fingerprint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [v1_name][crate::model::Fingerprint::v1_name].
    pub fn set_v1_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.v1_name = v.into();
        self
    }

    /// Sets the value of [v2_blob][crate::model::Fingerprint::v2_blob].
    pub fn set_v2_blob<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.v2_blob = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [v2_name][crate::model::Fingerprint::v2_name].
    pub fn set_v2_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.v2_name = v.into();
        self
    }
}

impl wkt::message::Message for Fingerprint {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Fingerprint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Fingerprint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __v1_name,
            __v2_blob,
            __v2_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Fingerprint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "v1Name" => Ok(__FieldTag::__v1_name),
                            "v1_name" => Ok(__FieldTag::__v1_name),
                            "v2Blob" => Ok(__FieldTag::__v2_blob),
                            "v2_blob" => Ok(__FieldTag::__v2_blob),
                            "v2Name" => Ok(__FieldTag::__v2_name),
                            "v2_name" => Ok(__FieldTag::__v2_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Fingerprint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Fingerprint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__v1_name => {
                            if !fields.insert(__FieldTag::__v1_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for v1_name",
                                ));
                            }
                            result.v1_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__v2_blob => {
                            if !fields.insert(__FieldTag::__v2_blob) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for v2_blob",
                                ));
                            }
                            result.v2_blob = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__v2_name => {
                            if !fields.insert(__FieldTag::__v2_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for v2_name",
                                ));
                            }
                            result.v2_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Fingerprint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.v1_name.is_empty() {
            state.serialize_entry("v1Name", &self.v1_name)?;
        }
        if !self.v2_blob.is_empty() {
            state.serialize_entry("v2Blob", &self.v2_blob)?;
        }
        if !self.v2_name.is_empty() {
            state.serialize_entry("v2Name", &self.v2_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Basis describes the base image portion (Note) of the DockerImage
/// relationship. Linked occurrences are derived from this or an equivalent image
/// via:
/// FROM <Basis.resource_url>
/// Or an equivalent reference, e.g., a tag of the resource_url.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageNote {
    /// Required. Immutable. The resource_url for the resource representing the
    /// basis of associated occurrence images.
    pub resource_url: std::string::String,

    /// Required. Immutable. The fingerprint of the base image.
    pub fingerprint: std::option::Option<crate::model::Fingerprint>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_url][crate::model::ImageNote::resource_url].
    pub fn set_resource_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_url = v.into();
        self
    }

    /// Sets the value of [fingerprint][crate::model::ImageNote::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fingerprint>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::ImageNote::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fingerprint>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImageNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ImageNote"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImageNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_url,
            __fingerprint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceUrl" => Ok(__FieldTag::__resource_url),
                            "resource_url" => Ok(__FieldTag::__resource_url),
                            "fingerprint" => Ok(__FieldTag::__fingerprint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImageNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_url => {
                            if !fields.insert(__FieldTag::__resource_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_url",
                                ));
                            }
                            result.resource_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fingerprint => {
                            if !fields.insert(__FieldTag::__fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fingerprint",
                                ));
                            }
                            result.fingerprint =
                                map.next_value::<std::option::Option<crate::model::Fingerprint>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImageNote {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_url.is_empty() {
            state.serialize_entry("resourceUrl", &self.resource_url)?;
        }
        if self.fingerprint.is_some() {
            state.serialize_entry("fingerprint", &self.fingerprint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details of the derived image portion of the DockerImage relationship. This
/// image would be produced from a Dockerfile with FROM <DockerImage.Basis in
/// attached Note>.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageOccurrence {
    /// Required. The fingerprint of the derived image.
    pub fingerprint: std::option::Option<crate::model::Fingerprint>,

    /// Output only. The number of layers by which this image differs from the
    /// associated image basis.
    pub distance: i32,

    /// This contains layer-specific metadata, if populated it has length
    /// "distance" and is ordered with [distance] being the layer immediately
    /// following the base image and [1] being the final layer.
    pub layer_info: std::vec::Vec<crate::model::Layer>,

    /// Output only. This contains the base image URL for the derived image
    /// occurrence.
    pub base_resource_url: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fingerprint][crate::model::ImageOccurrence::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fingerprint>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::ImageOccurrence::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fingerprint>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [distance][crate::model::ImageOccurrence::distance].
    pub fn set_distance<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.distance = v.into();
        self
    }

    /// Sets the value of [layer_info][crate::model::ImageOccurrence::layer_info].
    pub fn set_layer_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Layer>,
    {
        use std::iter::Iterator;
        self.layer_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [base_resource_url][crate::model::ImageOccurrence::base_resource_url].
    pub fn set_base_resource_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.base_resource_url = v.into();
        self
    }
}

impl wkt::message::Message for ImageOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ImageOccurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImageOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fingerprint,
            __distance,
            __layer_info,
            __base_resource_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fingerprint" => Ok(__FieldTag::__fingerprint),
                            "distance" => Ok(__FieldTag::__distance),
                            "layerInfo" => Ok(__FieldTag::__layer_info),
                            "layer_info" => Ok(__FieldTag::__layer_info),
                            "baseResourceUrl" => Ok(__FieldTag::__base_resource_url),
                            "base_resource_url" => Ok(__FieldTag::__base_resource_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImageOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fingerprint => {
                            if !fields.insert(__FieldTag::__fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fingerprint",
                                ));
                            }
                            result.fingerprint =
                                map.next_value::<std::option::Option<crate::model::Fingerprint>>()?;
                        }
                        __FieldTag::__distance => {
                            if !fields.insert(__FieldTag::__distance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distance",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.distance = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__layer_info => {
                            if !fields.insert(__FieldTag::__layer_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for layer_info",
                                ));
                            }
                            result.layer_info = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Layer>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__base_resource_url => {
                            if !fields.insert(__FieldTag::__base_resource_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_resource_url",
                                ));
                            }
                            result.base_resource_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImageOccurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fingerprint.is_some() {
            state.serialize_entry("fingerprint", &self.fingerprint)?;
        }
        if !wkt::internal::is_default(&self.distance) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("distance", &__With(&self.distance))?;
        }
        if !self.layer_info.is_empty() {
            state.serialize_entry("layerInfo", &self.layer_info)?;
        }
        if !self.base_resource_url.is_empty() {
            state.serialize_entry("baseResourceUrl", &self.base_resource_url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Steps taken to build the artifact.
/// For a TaskRun, typically each container corresponds to one step in the
/// recipe.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Recipe {
    /// URI indicating what type of recipe was performed. It determines the meaning
    /// of recipe.entryPoint, recipe.arguments, recipe.environment, and materials.
    pub r#type: std::string::String,

    /// Index in materials containing the recipe steps that are not implied by
    /// recipe.type. For example, if the recipe type were "make", then this would
    /// point to the source containing the Makefile, not the make program itself.
    /// Set to -1 if the recipe doesn't come from a material, as zero is default
    /// unset value for int64.
    pub defined_in_material: i64,

    /// String identifying the entry point into the build.
    /// This is often a path to a configuration file and/or a target label within
    /// that file. The syntax and meaning are defined by recipe.type. For example,
    /// if the recipe type were "make", then this would reference the directory in
    /// which to run make as well as which target to use.
    pub entry_point: std::string::String,

    /// Collection of all external inputs that influenced the build on top of
    /// recipe.definedInMaterial and recipe.entryPoint. For example, if the recipe
    /// type were "make", then this might be the flags passed to make aside from
    /// the target, which is captured in recipe.entryPoint. Since the arguments
    /// field can greatly vary in structure, depending on the builder and recipe
    /// type, this is of form "Any".
    pub arguments: std::vec::Vec<wkt::Any>,

    /// Any other builder-controlled inputs necessary for correctly evaluating the
    /// recipe. Usually only needed for reproducing the build but not evaluated as
    /// part of policy. Since the environment field can greatly vary in structure,
    /// depending on the builder and recipe type, this is of form "Any".
    pub environment: std::vec::Vec<wkt::Any>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Recipe {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Recipe::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [defined_in_material][crate::model::Recipe::defined_in_material].
    pub fn set_defined_in_material<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.defined_in_material = v.into();
        self
    }

    /// Sets the value of [entry_point][crate::model::Recipe::entry_point].
    pub fn set_entry_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_point = v.into();
        self
    }

    /// Sets the value of [arguments][crate::model::Recipe::arguments].
    pub fn set_arguments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>,
    {
        use std::iter::Iterator;
        self.arguments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [environment][crate::model::Recipe::environment].
    pub fn set_environment<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>,
    {
        use std::iter::Iterator;
        self.environment = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Recipe {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Recipe"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Recipe {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __defined_in_material,
            __entry_point,
            __arguments,
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Recipe")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "definedInMaterial" => Ok(__FieldTag::__defined_in_material),
                            "defined_in_material" => Ok(__FieldTag::__defined_in_material),
                            "entryPoint" => Ok(__FieldTag::__entry_point),
                            "entry_point" => Ok(__FieldTag::__entry_point),
                            "arguments" => Ok(__FieldTag::__arguments),
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Recipe;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Recipe")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__defined_in_material => {
                            if !fields.insert(__FieldTag::__defined_in_material) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for defined_in_material",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.defined_in_material =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__entry_point => {
                            if !fields.insert(__FieldTag::__entry_point) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_point",
                                ));
                            }
                            result.entry_point = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__arguments => {
                            if !fields.insert(__FieldTag::__arguments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arguments",
                                ));
                            }
                            result.arguments = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Any>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Any>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Recipe {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.defined_in_material) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("definedInMaterial", &__With(&self.defined_in_material))?;
        }
        if !self.entry_point.is_empty() {
            state.serialize_entry("entryPoint", &self.entry_point)?;
        }
        if !self.arguments.is_empty() {
            state.serialize_entry("arguments", &self.arguments)?;
        }
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Indicates that the builder claims certain fields in this message to be
/// complete.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Completeness {
    /// If true, the builder claims that recipe.arguments is complete, meaning that
    /// all external inputs are properly captured in the recipe.
    pub arguments: bool,

    /// If true, the builder claims that recipe.environment is claimed to be
    /// complete.
    pub environment: bool,

    /// If true, the builder claims that materials are complete, usually through
    /// some controls to prevent network access. Sometimes called "hermetic".
    pub materials: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Completeness {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [arguments][crate::model::Completeness::arguments].
    pub fn set_arguments<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.arguments = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::Completeness::environment].
    pub fn set_environment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [materials][crate::model::Completeness::materials].
    pub fn set_materials<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.materials = v.into();
        self
    }
}

impl wkt::message::Message for Completeness {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Completeness"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Completeness {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __arguments,
            __environment,
            __materials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Completeness")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "arguments" => Ok(__FieldTag::__arguments),
                            "environment" => Ok(__FieldTag::__environment),
                            "materials" => Ok(__FieldTag::__materials),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Completeness;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Completeness")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__arguments => {
                            if !fields.insert(__FieldTag::__arguments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arguments",
                                ));
                            }
                            result.arguments = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__materials => {
                            if !fields.insert(__FieldTag::__materials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materials",
                                ));
                            }
                            result.materials = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Completeness {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.arguments) {
            state.serialize_entry("arguments", &self.arguments)?;
        }
        if !wkt::internal::is_default(&self.environment) {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !wkt::internal::is_default(&self.materials) {
            state.serialize_entry("materials", &self.materials)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Other properties of the build.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Metadata {
    /// Identifies the particular build invocation, which can be useful for finding
    /// associated logs or other ad-hoc analysis. The value SHOULD be globally
    /// unique, per in-toto Provenance spec.
    pub build_invocation_id: std::string::String,

    /// The timestamp of when the build started.
    pub build_started_on: std::option::Option<wkt::Timestamp>,

    /// The timestamp of when the build completed.
    pub build_finished_on: std::option::Option<wkt::Timestamp>,

    /// Indicates that the builder claims certain fields in this message to be
    /// complete.
    pub completeness: std::option::Option<crate::model::Completeness>,

    /// If true, the builder claims that running the recipe on materials will
    /// produce bit-for-bit identical output.
    pub reproducible: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Metadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build_invocation_id][crate::model::Metadata::build_invocation_id].
    pub fn set_build_invocation_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.build_invocation_id = v.into();
        self
    }

    /// Sets the value of [build_started_on][crate::model::Metadata::build_started_on].
    pub fn set_build_started_on<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.build_started_on = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_started_on][crate::model::Metadata::build_started_on].
    pub fn set_or_clear_build_started_on<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.build_started_on = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_finished_on][crate::model::Metadata::build_finished_on].
    pub fn set_build_finished_on<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.build_finished_on = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_finished_on][crate::model::Metadata::build_finished_on].
    pub fn set_or_clear_build_finished_on<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.build_finished_on = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completeness][crate::model::Metadata::completeness].
    pub fn set_completeness<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Completeness>,
    {
        self.completeness = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completeness][crate::model::Metadata::completeness].
    pub fn set_or_clear_completeness<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Completeness>,
    {
        self.completeness = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reproducible][crate::model::Metadata::reproducible].
    pub fn set_reproducible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reproducible = v.into();
        self
    }
}

impl wkt::message::Message for Metadata {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Metadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Metadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build_invocation_id,
            __build_started_on,
            __build_finished_on,
            __completeness,
            __reproducible,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Metadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "buildInvocationId" => Ok(__FieldTag::__build_invocation_id),
                            "build_invocation_id" => Ok(__FieldTag::__build_invocation_id),
                            "buildStartedOn" => Ok(__FieldTag::__build_started_on),
                            "build_started_on" => Ok(__FieldTag::__build_started_on),
                            "buildFinishedOn" => Ok(__FieldTag::__build_finished_on),
                            "build_finished_on" => Ok(__FieldTag::__build_finished_on),
                            "completeness" => Ok(__FieldTag::__completeness),
                            "reproducible" => Ok(__FieldTag::__reproducible),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Metadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Metadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build_invocation_id => {
                            if !fields.insert(__FieldTag::__build_invocation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_invocation_id",
                                ));
                            }
                            result.build_invocation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__build_started_on => {
                            if !fields.insert(__FieldTag::__build_started_on) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_started_on",
                                ));
                            }
                            result.build_started_on =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__build_finished_on => {
                            if !fields.insert(__FieldTag::__build_finished_on) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_finished_on",
                                ));
                            }
                            result.build_finished_on =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__completeness => {
                            if !fields.insert(__FieldTag::__completeness) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completeness",
                                ));
                            }
                            result.completeness = map
                                .next_value::<std::option::Option<crate::model::Completeness>>()?;
                        }
                        __FieldTag::__reproducible => {
                            if !fields.insert(__FieldTag::__reproducible) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reproducible",
                                ));
                            }
                            result.reproducible = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Metadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.build_invocation_id.is_empty() {
            state.serialize_entry("buildInvocationId", &self.build_invocation_id)?;
        }
        if self.build_started_on.is_some() {
            state.serialize_entry("buildStartedOn", &self.build_started_on)?;
        }
        if self.build_finished_on.is_some() {
            state.serialize_entry("buildFinishedOn", &self.build_finished_on)?;
        }
        if self.completeness.is_some() {
            state.serialize_entry("completeness", &self.completeness)?;
        }
        if !wkt::internal::is_default(&self.reproducible) {
            state.serialize_entry("reproducible", &self.reproducible)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BuilderConfig {
    pub id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuilderConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::BuilderConfig::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for BuilderConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BuilderConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BuilderConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuilderConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BuilderConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuilderConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BuilderConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InTotoProvenance {
    pub builder_config: std::option::Option<crate::model::BuilderConfig>,

    /// Identifies the configuration used for the build.
    /// When combined with materials, this SHOULD fully describe the build,
    /// such that re-running this recipe results in bit-for-bit identical output
    /// (if the build is reproducible).
    pub recipe: std::option::Option<crate::model::Recipe>,

    pub metadata: std::option::Option<crate::model::Metadata>,

    /// The collection of artifacts that influenced the build including sources,
    /// dependencies, build tools, base images, and so on. This is considered to be
    /// incomplete unless metadata.completeness.materials is true. Unset or null is
    /// equivalent to empty.
    pub materials: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InTotoProvenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builder_config][crate::model::InTotoProvenance::builder_config].
    pub fn set_builder_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuilderConfig>,
    {
        self.builder_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [builder_config][crate::model::InTotoProvenance::builder_config].
    pub fn set_or_clear_builder_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuilderConfig>,
    {
        self.builder_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recipe][crate::model::InTotoProvenance::recipe].
    pub fn set_recipe<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Recipe>,
    {
        self.recipe = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recipe][crate::model::InTotoProvenance::recipe].
    pub fn set_or_clear_recipe<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Recipe>,
    {
        self.recipe = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::InTotoProvenance::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::InTotoProvenance::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [materials][crate::model::InTotoProvenance::materials].
    pub fn set_materials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.materials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InTotoProvenance {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.InTotoProvenance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InTotoProvenance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __builder_config,
            __recipe,
            __metadata,
            __materials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InTotoProvenance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "builderConfig" => Ok(__FieldTag::__builder_config),
                            "builder_config" => Ok(__FieldTag::__builder_config),
                            "recipe" => Ok(__FieldTag::__recipe),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "materials" => Ok(__FieldTag::__materials),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InTotoProvenance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InTotoProvenance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__builder_config => {
                            if !fields.insert(__FieldTag::__builder_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builder_config",
                                ));
                            }
                            result.builder_config = map
                                .next_value::<std::option::Option<crate::model::BuilderConfig>>()?;
                        }
                        __FieldTag::__recipe => {
                            if !fields.insert(__FieldTag::__recipe) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recipe",
                                ));
                            }
                            result.recipe =
                                map.next_value::<std::option::Option<crate::model::Recipe>>()?;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata =
                                map.next_value::<std::option::Option<crate::model::Metadata>>()?;
                        }
                        __FieldTag::__materials => {
                            if !fields.insert(__FieldTag::__materials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materials",
                                ));
                            }
                            result.materials = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InTotoProvenance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.builder_config.is_some() {
            state.serialize_entry("builderConfig", &self.builder_config)?;
        }
        if self.recipe.is_some() {
            state.serialize_entry("recipe", &self.recipe)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.materials.is_empty() {
            state.serialize_entry("materials", &self.materials)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Spec defined at
/// <https://github.com/in-toto/attestation/tree/main/spec#statement> The
/// serialized InTotoStatement will be stored as Envelope.payload.
/// Envelope.payloadType is always "application/vnd.in-toto+json".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InTotoStatement {
    /// Always `<https://in-toto.io/Statement/v0.1>`.
    pub r#type: std::string::String,

    pub subject: std::vec::Vec<crate::model::Subject>,

    /// `<https://slsa.dev/provenance/v0.1>` for SlsaProvenance.
    pub predicate_type: std::string::String,

    pub predicate: std::option::Option<crate::model::in_toto_statement::Predicate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InTotoStatement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::InTotoStatement::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::InTotoStatement::subject].
    pub fn set_subject<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Subject>,
    {
        use std::iter::Iterator;
        self.subject = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [predicate_type][crate::model::InTotoStatement::predicate_type].
    pub fn set_predicate_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predicate_type = v.into();
        self
    }

    /// Sets the value of [predicate][crate::model::InTotoStatement::predicate].
    ///
    /// Note that all the setters affecting `predicate` are mutually
    /// exclusive.
    pub fn set_predicate<
        T: std::convert::Into<std::option::Option<crate::model::in_toto_statement::Predicate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predicate = v.into();
        self
    }

    /// The value of [predicate][crate::model::InTotoStatement::predicate]
    /// if it holds a `Provenance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn provenance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InTotoProvenance>> {
        #[allow(unreachable_patterns)]
        self.predicate.as_ref().and_then(|v| match v {
            crate::model::in_toto_statement::Predicate::Provenance(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [predicate][crate::model::InTotoStatement::predicate]
    /// to hold a `Provenance`.
    ///
    /// Note that all the setters affecting `predicate` are
    /// mutually exclusive.
    pub fn set_provenance<
        T: std::convert::Into<std::boxed::Box<crate::model::InTotoProvenance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predicate = std::option::Option::Some(
            crate::model::in_toto_statement::Predicate::Provenance(v.into()),
        );
        self
    }

    /// The value of [predicate][crate::model::InTotoStatement::predicate]
    /// if it holds a `SlsaProvenance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn slsa_provenance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SlsaProvenance>> {
        #[allow(unreachable_patterns)]
        self.predicate.as_ref().and_then(|v| match v {
            crate::model::in_toto_statement::Predicate::SlsaProvenance(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [predicate][crate::model::InTotoStatement::predicate]
    /// to hold a `SlsaProvenance`.
    ///
    /// Note that all the setters affecting `predicate` are
    /// mutually exclusive.
    pub fn set_slsa_provenance<
        T: std::convert::Into<std::boxed::Box<crate::model::SlsaProvenance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predicate = std::option::Option::Some(
            crate::model::in_toto_statement::Predicate::SlsaProvenance(v.into()),
        );
        self
    }

    /// The value of [predicate][crate::model::InTotoStatement::predicate]
    /// if it holds a `SlsaProvenanceZeroTwo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn slsa_provenance_zero_two(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SlsaProvenanceZeroTwo>> {
        #[allow(unreachable_patterns)]
        self.predicate.as_ref().and_then(|v| match v {
            crate::model::in_toto_statement::Predicate::SlsaProvenanceZeroTwo(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [predicate][crate::model::InTotoStatement::predicate]
    /// to hold a `SlsaProvenanceZeroTwo`.
    ///
    /// Note that all the setters affecting `predicate` are
    /// mutually exclusive.
    pub fn set_slsa_provenance_zero_two<
        T: std::convert::Into<std::boxed::Box<crate::model::SlsaProvenanceZeroTwo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predicate = std::option::Option::Some(
            crate::model::in_toto_statement::Predicate::SlsaProvenanceZeroTwo(v.into()),
        );
        self
    }
}

impl wkt::message::Message for InTotoStatement {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.InTotoStatement"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InTotoStatement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __subject,
            __predicate_type,
            __provenance,
            __slsa_provenance,
            __slsa_provenance_zero_two,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InTotoStatement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "_type" => Ok(__FieldTag::__type),
                            "type" => Ok(__FieldTag::__type),
                            "subject" => Ok(__FieldTag::__subject),
                            "predicateType" => Ok(__FieldTag::__predicate_type),
                            "predicate_type" => Ok(__FieldTag::__predicate_type),
                            "provenance" => Ok(__FieldTag::__provenance),
                            "slsaProvenance" => Ok(__FieldTag::__slsa_provenance),
                            "slsa_provenance" => Ok(__FieldTag::__slsa_provenance),
                            "slsaProvenanceZeroTwo" => Ok(__FieldTag::__slsa_provenance_zero_two),
                            "slsa_provenance_zero_two" => {
                                Ok(__FieldTag::__slsa_provenance_zero_two)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InTotoStatement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InTotoStatement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Subject>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__predicate_type => {
                            if !fields.insert(__FieldTag::__predicate_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predicate_type",
                                ));
                            }
                            result.predicate_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__provenance => {
                            if !fields.insert(__FieldTag::__provenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provenance",
                                ));
                            }
                            if result.predicate.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `predicate`, a oneof with full ID .grafeas.v1.InTotoStatement.provenance, latest field was provenance",
                                ));
                            }
                            result.predicate = std::option::Option::Some(
                                crate::model::in_toto_statement::Predicate::Provenance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InTotoProvenance>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__slsa_provenance => {
                            if !fields.insert(__FieldTag::__slsa_provenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slsa_provenance",
                                ));
                            }
                            if result.predicate.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `predicate`, a oneof with full ID .grafeas.v1.InTotoStatement.slsa_provenance, latest field was slsaProvenance",
                                ));
                            }
                            result.predicate = std::option::Option::Some(
                                crate::model::in_toto_statement::Predicate::SlsaProvenance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SlsaProvenance>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__slsa_provenance_zero_two => {
                            if !fields.insert(__FieldTag::__slsa_provenance_zero_two) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slsa_provenance_zero_two",
                                ));
                            }
                            if result.predicate.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `predicate`, a oneof with full ID .grafeas.v1.InTotoStatement.slsa_provenance_zero_two, latest field was slsaProvenanceZeroTwo",
                                ));
                            }
                            result.predicate = std::option::Option::Some(
                                crate::model::in_toto_statement::Predicate::SlsaProvenanceZeroTwo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SlsaProvenanceZeroTwo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InTotoStatement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("_type", &self.r#type)?;
        }
        if !self.subject.is_empty() {
            state.serialize_entry("subject", &self.subject)?;
        }
        if !self.predicate_type.is_empty() {
            state.serialize_entry("predicateType", &self.predicate_type)?;
        }
        if let Some(value) = self.provenance() {
            state.serialize_entry("provenance", value)?;
        }
        if let Some(value) = self.slsa_provenance() {
            state.serialize_entry("slsaProvenance", value)?;
        }
        if let Some(value) = self.slsa_provenance_zero_two() {
            state.serialize_entry("slsaProvenanceZeroTwo", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InTotoStatement].
pub mod in_toto_statement {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Predicate {
        Provenance(std::boxed::Box<crate::model::InTotoProvenance>),
        SlsaProvenance(std::boxed::Box<crate::model::SlsaProvenance>),
        SlsaProvenanceZeroTwo(std::boxed::Box<crate::model::SlsaProvenanceZeroTwo>),
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Subject {
    pub name: std::string::String,

    /// `"<ALGORITHM>": "<HEX_VALUE>"`
    /// Algorithms can be e.g. sha256, sha512
    /// See
    /// <https://github.com/in-toto/attestation/blob/main/spec/field_types.md#DigestSet>
    pub digest: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Subject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Subject::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [digest][crate::model::Subject::digest].
    pub fn set_digest<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Subject {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Subject"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Subject {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __digest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Subject")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "digest" => Ok(__FieldTag::__digest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Subject;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Subject")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Subject {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.digest.is_empty() {
            state.serialize_entry("digest", &self.digest)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InTotoSlsaProvenanceV1 {
    /// InToto spec defined at
    /// <https://github.com/in-toto/attestation/tree/main/spec#statement>
    pub r#type: std::string::String,

    pub subject: std::vec::Vec<crate::model::Subject>,

    pub predicate_type: std::string::String,

    pub predicate: std::option::Option<crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InTotoSlsaProvenanceV1 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::InTotoSlsaProvenanceV1::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::InTotoSlsaProvenanceV1::subject].
    pub fn set_subject<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Subject>,
    {
        use std::iter::Iterator;
        self.subject = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [predicate_type][crate::model::InTotoSlsaProvenanceV1::predicate_type].
    pub fn set_predicate_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predicate_type = v.into();
        self
    }

    /// Sets the value of [predicate][crate::model::InTotoSlsaProvenanceV1::predicate].
    pub fn set_predicate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1>,
    {
        self.predicate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [predicate][crate::model::InTotoSlsaProvenanceV1::predicate].
    pub fn set_or_clear_predicate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1>,
    {
        self.predicate = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InTotoSlsaProvenanceV1 {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InTotoSlsaProvenanceV1 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __subject,
            __predicate_type,
            __predicate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InTotoSlsaProvenanceV1")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "_type" => Ok(__FieldTag::__type),
                            "type" => Ok(__FieldTag::__type),
                            "subject" => Ok(__FieldTag::__subject),
                            "predicateType" => Ok(__FieldTag::__predicate_type),
                            "predicate_type" => Ok(__FieldTag::__predicate_type),
                            "predicate" => Ok(__FieldTag::__predicate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InTotoSlsaProvenanceV1;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InTotoSlsaProvenanceV1")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Subject>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__predicate_type => {
                            if !fields.insert(__FieldTag::__predicate_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predicate_type",
                                ));
                            }
                            result.predicate_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__predicate => {
                            if !fields.insert(__FieldTag::__predicate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predicate",
                                ));
                            }
                            result.predicate = map.next_value::<std::option::Option<
                                crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InTotoSlsaProvenanceV1 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("_type", &self.r#type)?;
        }
        if !self.subject.is_empty() {
            state.serialize_entry("subject", &self.subject)?;
        }
        if !self.predicate_type.is_empty() {
            state.serialize_entry("predicateType", &self.predicate_type)?;
        }
        if self.predicate.is_some() {
            state.serialize_entry("predicate", &self.predicate)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InTotoSlsaProvenanceV1].
pub mod in_toto_slsa_provenance_v_1 {
    #[allow(unused_imports)]
    use super::*;

    /// Keep in sync with schema at
    /// <https://github.com/slsa-framework/slsa/blob/main/docs/provenance/schema/v1/provenance.proto>
    /// Builder renamed to ProvenanceBuilder because of Java conflicts.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaProvenanceV1 {
        pub build_definition:
            std::option::Option<crate::model::in_toto_slsa_provenance_v_1::BuildDefinition>,

        pub run_details: std::option::Option<crate::model::in_toto_slsa_provenance_v_1::RunDetails>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaProvenanceV1 {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [build_definition][crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1::build_definition].
        pub fn set_build_definition<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::BuildDefinition>,
        {
            self.build_definition = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_definition][crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1::build_definition].
        pub fn set_or_clear_build_definition<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::BuildDefinition>,
        {
            self.build_definition = v.map(|x| x.into());
            self
        }

        /// Sets the value of [run_details][crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1::run_details].
        pub fn set_run_details<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::RunDetails>,
        {
            self.run_details = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [run_details][crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1::run_details].
        pub fn set_or_clear_run_details<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::RunDetails>,
        {
            self.run_details = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SlsaProvenanceV1 {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.SlsaProvenanceV1"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SlsaProvenanceV1 {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __build_definition,
                __run_details,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SlsaProvenanceV1")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "buildDefinition" => Ok(__FieldTag::__build_definition),
                                "build_definition" => Ok(__FieldTag::__build_definition),
                                "runDetails" => Ok(__FieldTag::__run_details),
                                "run_details" => Ok(__FieldTag::__run_details),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SlsaProvenanceV1;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SlsaProvenanceV1")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__build_definition => {
                                if !fields.insert(__FieldTag::__build_definition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for build_definition",
                                    ));
                                }
                                result.build_definition = map
                                    .next_value::<std::option::Option<
                                        crate::model::in_toto_slsa_provenance_v_1::BuildDefinition,
                                    >>()?;
                            }
                            __FieldTag::__run_details => {
                                if !fields.insert(__FieldTag::__run_details) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for run_details",
                                    ));
                                }
                                result.run_details = map.next_value::<std::option::Option<
                                    crate::model::in_toto_slsa_provenance_v_1::RunDetails,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SlsaProvenanceV1 {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.build_definition.is_some() {
                state.serialize_entry("buildDefinition", &self.build_definition)?;
            }
            if self.run_details.is_some() {
                state.serialize_entry("runDetails", &self.run_details)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BuildDefinition {
        pub build_type: std::string::String,

        pub external_parameters: std::option::Option<wkt::Struct>,

        pub internal_parameters: std::option::Option<wkt::Struct>,

        pub resolved_dependencies:
            std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BuildDefinition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [build_type][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::build_type].
        pub fn set_build_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.build_type = v.into();
            self
        }

        /// Sets the value of [external_parameters][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::external_parameters].
        pub fn set_external_parameters<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.external_parameters = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [external_parameters][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::external_parameters].
        pub fn set_or_clear_external_parameters<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.external_parameters = v.map(|x| x.into());
            self
        }

        /// Sets the value of [internal_parameters][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::internal_parameters].
        pub fn set_internal_parameters<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.internal_parameters = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [internal_parameters][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::internal_parameters].
        pub fn set_or_clear_internal_parameters<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.internal_parameters = v.map(|x| x.into());
            self
        }

        /// Sets the value of [resolved_dependencies][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::resolved_dependencies].
        pub fn set_resolved_dependencies<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,
        {
            use std::iter::Iterator;
            self.resolved_dependencies = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for BuildDefinition {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.BuildDefinition"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BuildDefinition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __build_type,
                __external_parameters,
                __internal_parameters,
                __resolved_dependencies,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BuildDefinition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "buildType" => Ok(__FieldTag::__build_type),
                                "build_type" => Ok(__FieldTag::__build_type),
                                "externalParameters" => Ok(__FieldTag::__external_parameters),
                                "external_parameters" => Ok(__FieldTag::__external_parameters),
                                "internalParameters" => Ok(__FieldTag::__internal_parameters),
                                "internal_parameters" => Ok(__FieldTag::__internal_parameters),
                                "resolvedDependencies" => Ok(__FieldTag::__resolved_dependencies),
                                "resolved_dependencies" => Ok(__FieldTag::__resolved_dependencies),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BuildDefinition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BuildDefinition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__build_type => {
                                if !fields.insert(__FieldTag::__build_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for build_type",
                                    ));
                                }
                                result.build_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__external_parameters => {
                                if !fields.insert(__FieldTag::__external_parameters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for external_parameters",
                                    ));
                                }
                                result.external_parameters =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::__internal_parameters => {
                                if !fields.insert(__FieldTag::__internal_parameters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for internal_parameters",
                                    ));
                                }
                                result.internal_parameters =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::__resolved_dependencies => {
                                if !fields.insert(__FieldTag::__resolved_dependencies) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resolved_dependencies",
                                    ));
                                }
                                result.resolved_dependencies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BuildDefinition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.build_type.is_empty() {
                state.serialize_entry("buildType", &self.build_type)?;
            }
            if self.external_parameters.is_some() {
                state.serialize_entry("externalParameters", &self.external_parameters)?;
            }
            if self.internal_parameters.is_some() {
                state.serialize_entry("internalParameters", &self.internal_parameters)?;
            }
            if !self.resolved_dependencies.is_empty() {
                state.serialize_entry("resolvedDependencies", &self.resolved_dependencies)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResourceDescriptor {
        pub name: std::string::String,

        pub uri: std::string::String,

        pub digest: std::collections::HashMap<std::string::String, std::string::String>,

        pub content: ::bytes::Bytes,

        pub download_location: std::string::String,

        pub media_type: std::string::String,

        pub annotations: std::collections::HashMap<std::string::String, wkt::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceDescriptor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [uri][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [digest][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::digest].
        pub fn set_digest<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [content][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::content].
        pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }

        /// Sets the value of [download_location][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::download_location].
        pub fn set_download_location<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.download_location = v.into();
            self
        }

        /// Sets the value of [media_type][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::media_type].
        pub fn set_media_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.media_type = v.into();
            self
        }

        /// Sets the value of [annotations][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::annotations].
        pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for ResourceDescriptor {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.ResourceDescriptor"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ResourceDescriptor {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __uri,
                __digest,
                __content,
                __download_location,
                __media_type,
                __annotations,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ResourceDescriptor")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "uri" => Ok(__FieldTag::__uri),
                                "digest" => Ok(__FieldTag::__digest),
                                "content" => Ok(__FieldTag::__content),
                                "downloadLocation" => Ok(__FieldTag::__download_location),
                                "download_location" => Ok(__FieldTag::__download_location),
                                "mediaType" => Ok(__FieldTag::__media_type),
                                "media_type" => Ok(__FieldTag::__media_type),
                                "annotations" => Ok(__FieldTag::__annotations),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ResourceDescriptor;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ResourceDescriptor")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__digest => {
                                if !fields.insert(__FieldTag::__digest) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for digest",
                                    ));
                                }
                                result.digest = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__content => {
                                if !fields.insert(__FieldTag::__content) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for content",
                                    ));
                                }
                                struct __With(std::option::Option<::bytes::Bytes>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<serde_with::base64::Base64>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.content = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__download_location => {
                                if !fields.insert(__FieldTag::__download_location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for download_location",
                                    ));
                                }
                                result.download_location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__media_type => {
                                if !fields.insert(__FieldTag::__media_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for media_type",
                                    ));
                                }
                                result.media_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__annotations => {
                                if !fields.insert(__FieldTag::__annotations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for annotations",
                                    ));
                                }
                                result.annotations = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<std::string::String, wkt::Value>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ResourceDescriptor {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self.digest.is_empty() {
                state.serialize_entry("digest", &self.digest)?;
            }
            if !self.content.is_empty() {
                struct __With<'a>(&'a ::bytes::Bytes);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("content", &__With(&self.content))?;
            }
            if !self.download_location.is_empty() {
                state.serialize_entry("downloadLocation", &self.download_location)?;
            }
            if !self.media_type.is_empty() {
                state.serialize_entry("mediaType", &self.media_type)?;
            }
            if !self.annotations.is_empty() {
                state.serialize_entry("annotations", &self.annotations)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RunDetails {
        pub builder:
            std::option::Option<crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder>,

        pub metadata: std::option::Option<crate::model::in_toto_slsa_provenance_v_1::BuildMetadata>,

        pub byproducts:
            std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RunDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [builder][crate::model::in_toto_slsa_provenance_v_1::RunDetails::builder].
        pub fn set_builder<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder>,
        {
            self.builder = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [builder][crate::model::in_toto_slsa_provenance_v_1::RunDetails::builder].
        pub fn set_or_clear_builder<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder>,
        {
            self.builder = v.map(|x| x.into());
            self
        }

        /// Sets the value of [metadata][crate::model::in_toto_slsa_provenance_v_1::RunDetails::metadata].
        pub fn set_metadata<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::BuildMetadata>,
        {
            self.metadata = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [metadata][crate::model::in_toto_slsa_provenance_v_1::RunDetails::metadata].
        pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::BuildMetadata>,
        {
            self.metadata = v.map(|x| x.into());
            self
        }

        /// Sets the value of [byproducts][crate::model::in_toto_slsa_provenance_v_1::RunDetails::byproducts].
        pub fn set_byproducts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,
        {
            use std::iter::Iterator;
            self.byproducts = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for RunDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.RunDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RunDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __builder,
                __metadata,
                __byproducts,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RunDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "builder" => Ok(__FieldTag::__builder),
                                "metadata" => Ok(__FieldTag::__metadata),
                                "byproducts" => Ok(__FieldTag::__byproducts),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RunDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RunDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__builder => {
                                if !fields.insert(__FieldTag::__builder) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for builder",
                                    ));
                                }
                                result.builder = map.next_value::<std::option::Option<
                                    crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder,
                                >>()?;
                            }
                            __FieldTag::__metadata => {
                                if !fields.insert(__FieldTag::__metadata) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metadata",
                                    ));
                                }
                                result.metadata = map.next_value::<std::option::Option<
                                    crate::model::in_toto_slsa_provenance_v_1::BuildMetadata,
                                >>()?;
                            }
                            __FieldTag::__byproducts => {
                                if !fields.insert(__FieldTag::__byproducts) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for byproducts",
                                    ));
                                }
                                result.byproducts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RunDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.builder.is_some() {
                state.serialize_entry("builder", &self.builder)?;
            }
            if self.metadata.is_some() {
                state.serialize_entry("metadata", &self.metadata)?;
            }
            if !self.byproducts.is_empty() {
                state.serialize_entry("byproducts", &self.byproducts)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ProvenanceBuilder {
        pub id: std::string::String,

        pub version: std::collections::HashMap<std::string::String, std::string::String>,

        pub builder_dependencies:
            std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ProvenanceBuilder {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [version][crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder::version].
        pub fn set_version<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.version = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [builder_dependencies][crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder::builder_dependencies].
        pub fn set_builder_dependencies<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,
        {
            use std::iter::Iterator;
            self.builder_dependencies = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ProvenanceBuilder {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.ProvenanceBuilder"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ProvenanceBuilder {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __version,
                __builder_dependencies,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ProvenanceBuilder")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "version" => Ok(__FieldTag::__version),
                                "builderDependencies" => Ok(__FieldTag::__builder_dependencies),
                                "builder_dependencies" => Ok(__FieldTag::__builder_dependencies),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ProvenanceBuilder;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ProvenanceBuilder")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__version => {
                                if !fields.insert(__FieldTag::__version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for version",
                                    ));
                                }
                                result.version = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__builder_dependencies => {
                                if !fields.insert(__FieldTag::__builder_dependencies) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for builder_dependencies",
                                    ));
                                }
                                result.builder_dependencies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ProvenanceBuilder {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.version.is_empty() {
                state.serialize_entry("version", &self.version)?;
            }
            if !self.builder_dependencies.is_empty() {
                state.serialize_entry("builderDependencies", &self.builder_dependencies)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BuildMetadata {
        pub invocation_id: std::string::String,

        pub started_on: std::option::Option<wkt::Timestamp>,

        pub finished_on: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BuildMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [invocation_id][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::invocation_id].
        pub fn set_invocation_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.invocation_id = v.into();
            self
        }

        /// Sets the value of [started_on][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::started_on].
        pub fn set_started_on<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.started_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [started_on][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::started_on].
        pub fn set_or_clear_started_on<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.started_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [finished_on][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::finished_on].
        pub fn set_finished_on<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.finished_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [finished_on][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::finished_on].
        pub fn set_or_clear_finished_on<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.finished_on = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for BuildMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.BuildMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BuildMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __invocation_id,
                __started_on,
                __finished_on,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BuildMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "invocationId" => Ok(__FieldTag::__invocation_id),
                                "invocation_id" => Ok(__FieldTag::__invocation_id),
                                "startedOn" => Ok(__FieldTag::__started_on),
                                "started_on" => Ok(__FieldTag::__started_on),
                                "finishedOn" => Ok(__FieldTag::__finished_on),
                                "finished_on" => Ok(__FieldTag::__finished_on),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BuildMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BuildMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__invocation_id => {
                                if !fields.insert(__FieldTag::__invocation_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for invocation_id",
                                    ));
                                }
                                result.invocation_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__started_on => {
                                if !fields.insert(__FieldTag::__started_on) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for started_on",
                                    ));
                                }
                                result.started_on =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__finished_on => {
                                if !fields.insert(__FieldTag::__finished_on) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for finished_on",
                                    ));
                                }
                                result.finished_on =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BuildMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.invocation_id.is_empty() {
                state.serialize_entry("invocationId", &self.invocation_id)?;
            }
            if self.started_on.is_some() {
                state.serialize_entry("startedOn", &self.started_on)?;
            }
            if self.finished_on.is_some() {
                state.serialize_entry("finishedOn", &self.finished_on)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// This represents a particular channel of distribution for a given package.
/// E.g., Debian's jessie-backports dpkg mirror.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Distribution {
    /// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/)
    /// denoting the package manager version distributing a package.
    pub cpe_uri: std::string::String,

    /// The CPU architecture for which packages in this distribution channel were
    /// built.
    pub architecture: crate::model::Architecture,

    /// The latest available version of this package in this distribution channel.
    pub latest_version: std::option::Option<crate::model::Version>,

    /// A freeform string denoting the maintainer of this package.
    pub maintainer: std::string::String,

    /// The distribution channel-specific homepage for this package.
    pub url: std::string::String,

    /// The distribution channel-specific description of this package.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Distribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpe_uri][crate::model::Distribution::cpe_uri].
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::Distribution::architecture].
    pub fn set_architecture<T: std::convert::Into<crate::model::Architecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }

    /// Sets the value of [latest_version][crate::model::Distribution::latest_version].
    pub fn set_latest_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.latest_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latest_version][crate::model::Distribution::latest_version].
    pub fn set_or_clear_latest_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.latest_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintainer][crate::model::Distribution::maintainer].
    pub fn set_maintainer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.maintainer = v.into();
        self
    }

    /// Sets the value of [url][crate::model::Distribution::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Distribution::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for Distribution {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Distribution"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Distribution {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpe_uri,
            __architecture,
            __latest_version,
            __maintainer,
            __url,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Distribution")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "architecture" => Ok(__FieldTag::__architecture),
                            "latestVersion" => Ok(__FieldTag::__latest_version),
                            "latest_version" => Ok(__FieldTag::__latest_version),
                            "maintainer" => Ok(__FieldTag::__maintainer),
                            "url" => Ok(__FieldTag::__url),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Distribution;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Distribution")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture = map
                                .next_value::<std::option::Option<crate::model::Architecture>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_version => {
                            if !fields.insert(__FieldTag::__latest_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_version",
                                ));
                            }
                            result.latest_version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__maintainer => {
                            if !fields.insert(__FieldTag::__maintainer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintainer",
                                ));
                            }
                            result.maintainer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Distribution {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cpe_uri.is_empty() {
            state.serialize_entry("cpeUri", &self.cpe_uri)?;
        }
        if !wkt::internal::is_default(&self.architecture) {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.latest_version.is_some() {
            state.serialize_entry("latestVersion", &self.latest_version)?;
        }
        if !self.maintainer.is_empty() {
            state.serialize_entry("maintainer", &self.maintainer)?;
        }
        if !self.url.is_empty() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An occurrence of a particular package installation found within a system's
/// filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Location {
    /// Deprecated.
    /// The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
    pub cpe_uri: std::string::String,

    /// Deprecated.
    /// The version installed at this location.
    pub version: std::option::Option<crate::model::Version>,

    /// The path from which we gathered that this package/version is installed.
    pub path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Location {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpe_uri][crate::model::Location::cpe_uri].
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Location::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::Location::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [path][crate::model::Location::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for Location {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Location"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Location {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpe_uri,
            __version,
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Location")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "version" => Ok(__FieldTag::__version),
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Location;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Location")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Location {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cpe_uri.is_empty() {
            state.serialize_entry("cpeUri", &self.cpe_uri)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// PackageNote represents a particular package version.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PackageNote {
    /// The name of the package.
    pub name: std::string::String,

    /// Deprecated.
    /// The various channels by which a package is distributed.
    pub distribution: std::vec::Vec<crate::model::Distribution>,

    /// The type of package; whether native or non native (e.g., ruby gems,
    /// node.js packages, etc.).
    pub package_type: std::string::String,

    /// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/)
    /// denoting the package manager version distributing a package.
    /// The cpe_uri will be blank for language packages.
    pub cpe_uri: std::string::String,

    /// The CPU architecture for which packages in this distribution channel were
    /// built. Architecture will be blank for language packages.
    pub architecture: crate::model::Architecture,

    /// The version of the package.
    pub version: std::option::Option<crate::model::Version>,

    /// A freeform text denoting the maintainer of this package.
    pub maintainer: std::string::String,

    /// The homepage for this package.
    pub url: std::string::String,

    /// The description of this package.
    pub description: std::string::String,

    /// Licenses that have been declared by the authors of the package.
    pub license: std::option::Option<crate::model::License>,

    /// Hash value, typically a file digest, that allows unique
    /// identification a specific package.
    pub digest: std::vec::Vec<crate::model::Digest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PackageNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PackageNote::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [distribution][crate::model::PackageNote::distribution].
    pub fn set_distribution<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Distribution>,
    {
        use std::iter::Iterator;
        self.distribution = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [package_type][crate::model::PackageNote::package_type].
    pub fn set_package_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_type = v.into();
        self
    }

    /// Sets the value of [cpe_uri][crate::model::PackageNote::cpe_uri].
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::PackageNote::architecture].
    pub fn set_architecture<T: std::convert::Into<crate::model::Architecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }

    /// Sets the value of [version][crate::model::PackageNote::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::PackageNote::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintainer][crate::model::PackageNote::maintainer].
    pub fn set_maintainer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.maintainer = v.into();
        self
    }

    /// Sets the value of [url][crate::model::PackageNote::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PackageNote::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [license][crate::model::PackageNote::license].
    pub fn set_license<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::License>,
    {
        self.license = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [license][crate::model::PackageNote::license].
    pub fn set_or_clear_license<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::License>,
    {
        self.license = v.map(|x| x.into());
        self
    }

    /// Sets the value of [digest][crate::model::PackageNote::digest].
    pub fn set_digest<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Digest>,
    {
        use std::iter::Iterator;
        self.digest = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PackageNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.PackageNote"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PackageNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __distribution,
            __package_type,
            __cpe_uri,
            __architecture,
            __version,
            __maintainer,
            __url,
            __description,
            __license,
            __digest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PackageNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "distribution" => Ok(__FieldTag::__distribution),
                            "packageType" => Ok(__FieldTag::__package_type),
                            "package_type" => Ok(__FieldTag::__package_type),
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "architecture" => Ok(__FieldTag::__architecture),
                            "version" => Ok(__FieldTag::__version),
                            "maintainer" => Ok(__FieldTag::__maintainer),
                            "url" => Ok(__FieldTag::__url),
                            "description" => Ok(__FieldTag::__description),
                            "license" => Ok(__FieldTag::__license),
                            "digest" => Ok(__FieldTag::__digest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PackageNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PackageNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__distribution => {
                            if !fields.insert(__FieldTag::__distribution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distribution",
                                ));
                            }
                            result.distribution = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Distribution>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__package_type => {
                            if !fields.insert(__FieldTag::__package_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_type",
                                ));
                            }
                            result.package_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture = map
                                .next_value::<std::option::Option<crate::model::Architecture>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__maintainer => {
                            if !fields.insert(__FieldTag::__maintainer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintainer",
                                ));
                            }
                            result.maintainer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license => {
                            if !fields.insert(__FieldTag::__license) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license",
                                ));
                            }
                            result.license =
                                map.next_value::<std::option::Option<crate::model::License>>()?;
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Digest>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PackageNote {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.distribution.is_empty() {
            state.serialize_entry("distribution", &self.distribution)?;
        }
        if !self.package_type.is_empty() {
            state.serialize_entry("packageType", &self.package_type)?;
        }
        if !self.cpe_uri.is_empty() {
            state.serialize_entry("cpeUri", &self.cpe_uri)?;
        }
        if !wkt::internal::is_default(&self.architecture) {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.maintainer.is_empty() {
            state.serialize_entry("maintainer", &self.maintainer)?;
        }
        if !self.url.is_empty() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.license.is_some() {
            state.serialize_entry("license", &self.license)?;
        }
        if !self.digest.is_empty() {
            state.serialize_entry("digest", &self.digest)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details on how a particular software package was installed on a system.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PackageOccurrence {
    /// The name of the installed package.
    pub name: std::string::String,

    /// All of the places within the filesystem versions of this package
    /// have been found.
    pub location: std::vec::Vec<crate::model::Location>,

    /// The type of package; whether native or non native (e.g., ruby gems,
    /// node.js packages, etc.).
    pub package_type: std::string::String,

    /// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/)
    /// denoting the package manager version distributing a package.
    /// The cpe_uri will be blank for language packages.
    pub cpe_uri: std::string::String,

    /// The CPU architecture for which packages in this distribution channel were
    /// built. Architecture will be blank for language packages.
    pub architecture: crate::model::Architecture,

    /// Licenses that have been declared by the authors of the package.
    pub license: std::option::Option<crate::model::License>,

    /// The version of the package.
    pub version: std::option::Option<crate::model::Version>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PackageOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PackageOccurrence::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [location][crate::model::PackageOccurrence::location].
    pub fn set_location<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Location>,
    {
        use std::iter::Iterator;
        self.location = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [package_type][crate::model::PackageOccurrence::package_type].
    pub fn set_package_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_type = v.into();
        self
    }

    /// Sets the value of [cpe_uri][crate::model::PackageOccurrence::cpe_uri].
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::PackageOccurrence::architecture].
    pub fn set_architecture<T: std::convert::Into<crate::model::Architecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }

    /// Sets the value of [license][crate::model::PackageOccurrence::license].
    pub fn set_license<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::License>,
    {
        self.license = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [license][crate::model::PackageOccurrence::license].
    pub fn set_or_clear_license<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::License>,
    {
        self.license = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version][crate::model::PackageOccurrence::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::PackageOccurrence::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PackageOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.PackageOccurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PackageOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __location,
            __package_type,
            __cpe_uri,
            __architecture,
            __license,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PackageOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "location" => Ok(__FieldTag::__location),
                            "packageType" => Ok(__FieldTag::__package_type),
                            "package_type" => Ok(__FieldTag::__package_type),
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "architecture" => Ok(__FieldTag::__architecture),
                            "license" => Ok(__FieldTag::__license),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PackageOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PackageOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Location>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__package_type => {
                            if !fields.insert(__FieldTag::__package_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_type",
                                ));
                            }
                            result.package_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture = map
                                .next_value::<std::option::Option<crate::model::Architecture>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license => {
                            if !fields.insert(__FieldTag::__license) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license",
                                ));
                            }
                            result.license =
                                map.next_value::<std::option::Option<crate::model::License>>()?;
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PackageOccurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.package_type.is_empty() {
            state.serialize_entry("packageType", &self.package_type)?;
        }
        if !self.cpe_uri.is_empty() {
            state.serialize_entry("cpeUri", &self.cpe_uri)?;
        }
        if !wkt::internal::is_default(&self.architecture) {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.license.is_some() {
            state.serialize_entry("license", &self.license)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Version contains structured information about the version of a package.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Version {
    /// Used to correct mistakes in the version numbering scheme.
    pub epoch: i32,

    /// Required only when version kind is NORMAL. The main part of the version
    /// name.
    pub name: std::string::String,

    /// The iteration of the package build from the above version.
    pub revision: std::string::String,

    /// Whether this version is specifying part of an inclusive range. Grafeas
    /// does not have the capability to specify version ranges; instead we have
    /// fields that specify start version and end versions. At times this is
    /// insufficient - we also need to specify whether the version is included in
    /// the range or is excluded from the range. This boolean is expected to be set
    /// to true when the version is included in a range.
    pub inclusive: bool,

    /// Required. Distinguishes between sentinel MIN/MAX versions and normal
    /// versions.
    pub kind: crate::model::version::VersionKind,

    /// Human readable version string. This string is of the form
    /// \<epoch\>:\<name\>-\<revision\> and is only set when kind is NORMAL.
    pub full_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Version {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [epoch][crate::model::Version::epoch].
    pub fn set_epoch<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.epoch = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Version::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::Version::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [inclusive][crate::model::Version::inclusive].
    pub fn set_inclusive<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.inclusive = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Version::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::version::VersionKind>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [full_name][crate::model::Version::full_name].
    pub fn set_full_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_name = v.into();
        self
    }
}

impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Version"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Version {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __epoch,
            __name,
            __revision,
            __inclusive,
            __kind,
            __full_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Version")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "epoch" => Ok(__FieldTag::__epoch),
                            "name" => Ok(__FieldTag::__name),
                            "revision" => Ok(__FieldTag::__revision),
                            "inclusive" => Ok(__FieldTag::__inclusive),
                            "kind" => Ok(__FieldTag::__kind),
                            "fullName" => Ok(__FieldTag::__full_name),
                            "full_name" => Ok(__FieldTag::__full_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Version;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Version")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__epoch => {
                            if !fields.insert(__FieldTag::__epoch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for epoch",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.epoch = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            result.revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inclusive => {
                            if !fields.insert(__FieldTag::__inclusive) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inclusive",
                                ));
                            }
                            result.inclusive = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map.next_value::<std::option::Option<crate::model::version::VersionKind>>()?.unwrap_or_default();
                        }
                        __FieldTag::__full_name => {
                            if !fields.insert(__FieldTag::__full_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_name",
                                ));
                            }
                            result.full_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Version {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.epoch) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("epoch", &__With(&self.epoch))?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.revision.is_empty() {
            state.serialize_entry("revision", &self.revision)?;
        }
        if !wkt::internal::is_default(&self.inclusive) {
            state.serialize_entry("inclusive", &self.inclusive)?;
        }
        if !wkt::internal::is_default(&self.kind) {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.full_name.is_empty() {
            state.serialize_entry("fullName", &self.full_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Version].
pub mod version {
    #[allow(unused_imports)]
    use super::*;

    /// Whether this is an ordinary package version or a sentinel MIN/MAX version.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VersionKind {
        /// Unknown.
        Unspecified,
        /// A standard package version.
        Normal,
        /// A special version representing negative infinity.
        Minimum,
        /// A special version representing positive infinity.
        Maximum,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VersionKind::value] or
        /// [VersionKind::name].
        UnknownValue(version_kind::UnknownValue),
    }

    #[doc(hidden)]
    pub mod version_kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VersionKind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Normal => std::option::Option::Some(1),
                Self::Minimum => std::option::Option::Some(2),
                Self::Maximum => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VERSION_KIND_UNSPECIFIED"),
                Self::Normal => std::option::Option::Some("NORMAL"),
                Self::Minimum => std::option::Option::Some("MINIMUM"),
                Self::Maximum => std::option::Option::Some("MAXIMUM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VersionKind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VersionKind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VersionKind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Normal,
                2 => Self::Minimum,
                3 => Self::Maximum,
                _ => Self::UnknownValue(version_kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VersionKind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VERSION_KIND_UNSPECIFIED" => Self::Unspecified,
                "NORMAL" => Self::Normal,
                "MINIMUM" => Self::Minimum,
                "MAXIMUM" => Self::Maximum,
                _ => Self::UnknownValue(version_kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VersionKind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Normal => serializer.serialize_i32(1),
                Self::Minimum => serializer.serialize_i32(2),
                Self::Maximum => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VersionKind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VersionKind>::new(
                ".grafeas.v1.Version.VersionKind",
            ))
        }
    }
}

/// Provenance of a build. Contains all information needed to verify the full
/// details about the build from source to completion.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildProvenance {
    /// Required. Unique identifier of the build.
    pub id: std::string::String,

    /// ID of the project.
    pub project_id: std::string::String,

    /// Commands requested by the build.
    pub commands: std::vec::Vec<crate::model::Command>,

    /// Output of the build.
    pub built_artifacts: std::vec::Vec<crate::model::Artifact>,

    /// Time at which the build was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time at which execution of the build was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Time at which execution of the build was finished.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// E-mail address of the user who initiated this build. Note that this was the
    /// user's e-mail address at the time the build was initiated; this address may
    /// not represent the same end-user for all time.
    pub creator: std::string::String,

    /// URI where any logs for this provenance were written.
    pub logs_uri: std::string::String,

    /// Details of the Source input to the build.
    pub source_provenance: std::option::Option<crate::model::Source>,

    /// Trigger identifier if the build was triggered automatically; empty if not.
    pub trigger_id: std::string::String,

    /// Special options applied to this build. This is a catch-all field where
    /// build providers can enter any desired additional details.
    pub build_options: std::collections::HashMap<std::string::String, std::string::String>,

    /// Version string of the builder at the time this build was executed.
    pub builder_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildProvenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::BuildProvenance::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::BuildProvenance::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [commands][crate::model::BuildProvenance::commands].
    pub fn set_commands<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Command>,
    {
        use std::iter::Iterator;
        self.commands = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [built_artifacts][crate::model::BuildProvenance::built_artifacts].
    pub fn set_built_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Artifact>,
    {
        use std::iter::Iterator;
        self.built_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::BuildProvenance::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BuildProvenance::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::BuildProvenance::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::BuildProvenance::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BuildProvenance::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BuildProvenance::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creator][crate::model::BuildProvenance::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [logs_uri][crate::model::BuildProvenance::logs_uri].
    pub fn set_logs_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.logs_uri = v.into();
        self
    }

    /// Sets the value of [source_provenance][crate::model::BuildProvenance::source_provenance].
    pub fn set_source_provenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source_provenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_provenance][crate::model::BuildProvenance::source_provenance].
    pub fn set_or_clear_source_provenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source_provenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [trigger_id][crate::model::BuildProvenance::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [build_options][crate::model::BuildProvenance::build_options].
    pub fn set_build_options<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.build_options = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [builder_version][crate::model::BuildProvenance::builder_version].
    pub fn set_builder_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.builder_version = v.into();
        self
    }
}

impl wkt::message::Message for BuildProvenance {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BuildProvenance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BuildProvenance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __project_id,
            __commands,
            __built_artifacts,
            __create_time,
            __start_time,
            __end_time,
            __creator,
            __logs_uri,
            __source_provenance,
            __trigger_id,
            __build_options,
            __builder_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildProvenance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "commands" => Ok(__FieldTag::__commands),
                            "builtArtifacts" => Ok(__FieldTag::__built_artifacts),
                            "built_artifacts" => Ok(__FieldTag::__built_artifacts),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "creator" => Ok(__FieldTag::__creator),
                            "logsUri" => Ok(__FieldTag::__logs_uri),
                            "logs_uri" => Ok(__FieldTag::__logs_uri),
                            "sourceProvenance" => Ok(__FieldTag::__source_provenance),
                            "source_provenance" => Ok(__FieldTag::__source_provenance),
                            "triggerId" => Ok(__FieldTag::__trigger_id),
                            "trigger_id" => Ok(__FieldTag::__trigger_id),
                            "buildOptions" => Ok(__FieldTag::__build_options),
                            "build_options" => Ok(__FieldTag::__build_options),
                            "builderVersion" => Ok(__FieldTag::__builder_version),
                            "builder_version" => Ok(__FieldTag::__builder_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BuildProvenance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildProvenance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__commands => {
                            if !fields.insert(__FieldTag::__commands) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commands",
                                ));
                            }
                            result.commands = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Command>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__built_artifacts => {
                            if !fields.insert(__FieldTag::__built_artifacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for built_artifacts",
                                ));
                            }
                            result.built_artifacts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Artifact>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__creator => {
                            if !fields.insert(__FieldTag::__creator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creator",
                                ));
                            }
                            result.creator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logs_uri => {
                            if !fields.insert(__FieldTag::__logs_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logs_uri",
                                ));
                            }
                            result.logs_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_provenance => {
                            if !fields.insert(__FieldTag::__source_provenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_provenance",
                                ));
                            }
                            result.source_provenance =
                                map.next_value::<std::option::Option<crate::model::Source>>()?;
                        }
                        __FieldTag::__trigger_id => {
                            if !fields.insert(__FieldTag::__trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_id",
                                ));
                            }
                            result.trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__build_options => {
                            if !fields.insert(__FieldTag::__build_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_options",
                                ));
                            }
                            result.build_options = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__builder_version => {
                            if !fields.insert(__FieldTag::__builder_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builder_version",
                                ));
                            }
                            result.builder_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BuildProvenance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.commands.is_empty() {
            state.serialize_entry("commands", &self.commands)?;
        }
        if !self.built_artifacts.is_empty() {
            state.serialize_entry("builtArtifacts", &self.built_artifacts)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.creator.is_empty() {
            state.serialize_entry("creator", &self.creator)?;
        }
        if !self.logs_uri.is_empty() {
            state.serialize_entry("logsUri", &self.logs_uri)?;
        }
        if self.source_provenance.is_some() {
            state.serialize_entry("sourceProvenance", &self.source_provenance)?;
        }
        if !self.trigger_id.is_empty() {
            state.serialize_entry("triggerId", &self.trigger_id)?;
        }
        if !self.build_options.is_empty() {
            state.serialize_entry("buildOptions", &self.build_options)?;
        }
        if !self.builder_version.is_empty() {
            state.serialize_entry("builderVersion", &self.builder_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Source describes the location of the source used for the build.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Source {
    /// If provided, the input binary artifacts for the build came from this
    /// location.
    pub artifact_storage_source_uri: std::string::String,

    /// Hash(es) of the build source, which can be used to verify that the original
    /// source integrity was maintained in the build.
    ///
    /// The keys to this map are file paths used as build source and the values
    /// contain the hash values for those files.
    ///
    /// If the build source came in a single package such as a gzipped tarfile
    /// (.tar.gz), the FileHash will be for the single path to that file.
    pub file_hashes: std::collections::HashMap<std::string::String, crate::model::FileHashes>,

    /// If provided, the source code used for the build came from this location.
    pub context: std::option::Option<crate::model::SourceContext>,

    /// If provided, some of the source code used for the build may be found in
    /// these locations, in the case where the source repository had multiple
    /// remotes or submodules. This list will not include the context specified in
    /// the context field.
    pub additional_contexts: std::vec::Vec<crate::model::SourceContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Source {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact_storage_source_uri][crate::model::Source::artifact_storage_source_uri].
    pub fn set_artifact_storage_source_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_storage_source_uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::Source::file_hashes].
    pub fn set_file_hashes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FileHashes>,
    {
        use std::iter::Iterator;
        self.file_hashes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [context][crate::model::Source::context].
    pub fn set_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceContext>,
    {
        self.context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [context][crate::model::Source::context].
    pub fn set_or_clear_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceContext>,
    {
        self.context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_contexts][crate::model::Source::additional_contexts].
    pub fn set_additional_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SourceContext>,
    {
        use std::iter::Iterator;
        self.additional_contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Source {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Source"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Source {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __artifact_storage_source_uri,
            __file_hashes,
            __context,
            __additional_contexts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Source")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "artifactStorageSourceUri" => {
                                Ok(__FieldTag::__artifact_storage_source_uri)
                            }
                            "artifact_storage_source_uri" => {
                                Ok(__FieldTag::__artifact_storage_source_uri)
                            }
                            "fileHashes" => Ok(__FieldTag::__file_hashes),
                            "file_hashes" => Ok(__FieldTag::__file_hashes),
                            "context" => Ok(__FieldTag::__context),
                            "additionalContexts" => Ok(__FieldTag::__additional_contexts),
                            "additional_contexts" => Ok(__FieldTag::__additional_contexts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Source;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Source")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__artifact_storage_source_uri => {
                            if !fields.insert(__FieldTag::__artifact_storage_source_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_storage_source_uri",
                                ));
                            }
                            result.artifact_storage_source_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_hashes => {
                            if !fields.insert(__FieldTag::__file_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hashes",
                                ));
                            }
                            result.file_hashes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::FileHashes,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context => {
                            if !fields.insert(__FieldTag::__context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context",
                                ));
                            }
                            result.context = map
                                .next_value::<std::option::Option<crate::model::SourceContext>>()?;
                        }
                        __FieldTag::__additional_contexts => {
                            if !fields.insert(__FieldTag::__additional_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_contexts",
                                ));
                            }
                            result.additional_contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SourceContext>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Source {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.artifact_storage_source_uri.is_empty() {
            state.serialize_entry(
                "artifactStorageSourceUri",
                &self.artifact_storage_source_uri,
            )?;
        }
        if !self.file_hashes.is_empty() {
            state.serialize_entry("fileHashes", &self.file_hashes)?;
        }
        if self.context.is_some() {
            state.serialize_entry("context", &self.context)?;
        }
        if !self.additional_contexts.is_empty() {
            state.serialize_entry("additionalContexts", &self.additional_contexts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Container message for hashes of byte content of files, used in source
/// messages to verify integrity of source input to the build.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FileHashes {
    /// Required. Collection of file hashes.
    pub file_hash: std::vec::Vec<crate::model::Hash>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileHashes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_hash][crate::model::FileHashes::file_hash].
    pub fn set_file_hash<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Hash>,
    {
        use std::iter::Iterator;
        self.file_hash = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileHashes {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.FileHashes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileHashes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_hash,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileHashes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileHash" => Ok(__FieldTag::__file_hash),
                            "file_hash" => Ok(__FieldTag::__file_hash),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileHashes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileHashes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_hash => {
                            if !fields.insert(__FieldTag::__file_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hash",
                                ));
                            }
                            result.file_hash = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Hash>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileHashes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_hash.is_empty() {
            state.serialize_entry("fileHash", &self.file_hash)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Container message for hash values.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Hash {
    /// Required. The type of hash that was performed, e.g. "SHA-256".
    pub r#type: std::string::String,

    /// Required. The hash value.
    pub value: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Hash {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Hash::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Hash::value].
    pub fn set_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Hash {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Hash"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Hash {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Hash")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Hash;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Hash")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Hash {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.value.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Command describes a step performed as part of the build pipeline.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Command {
    /// Required. Name of the command, as presented on the command line, or if the
    /// command is packaged as a Docker container, as presented to `docker pull`.
    pub name: std::string::String,

    /// Environment variables set before running this command.
    pub env: std::vec::Vec<std::string::String>,

    /// Command-line arguments used when executing this command.
    pub args: std::vec::Vec<std::string::String>,

    /// Working directory (relative to project source root) used when running this
    /// command.
    pub dir: std::string::String,

    /// Optional unique identifier for this command, used in wait_for to reference
    /// this command as a dependency.
    pub id: std::string::String,

    /// The ID(s) of the command(s) that this command depends on.
    pub wait_for: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Command {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Command::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [env][crate::model::Command::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::Command::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dir][crate::model::Command::dir].
    pub fn set_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dir = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Command::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [wait_for][crate::model::Command::wait_for].
    pub fn set_wait_for<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.wait_for = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Command {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Command"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Command {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __env,
            __args,
            __dir,
            __id,
            __wait_for,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Command")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "env" => Ok(__FieldTag::__env),
                            "args" => Ok(__FieldTag::__args),
                            "dir" => Ok(__FieldTag::__dir),
                            "id" => Ok(__FieldTag::__id),
                            "waitFor" => Ok(__FieldTag::__wait_for),
                            "wait_for" => Ok(__FieldTag::__wait_for),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Command;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Command")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__env => {
                            if !fields.insert(__FieldTag::__env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env",
                                ));
                            }
                            result.env = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__dir => {
                            if !fields.insert(__FieldTag::__dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dir",
                                ));
                            }
                            result.dir = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__wait_for => {
                            if !fields.insert(__FieldTag::__wait_for) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait_for",
                                ));
                            }
                            result.wait_for = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Command {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.env.is_empty() {
            state.serialize_entry("env", &self.env)?;
        }
        if !self.args.is_empty() {
            state.serialize_entry("args", &self.args)?;
        }
        if !self.dir.is_empty() {
            state.serialize_entry("dir", &self.dir)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.wait_for.is_empty() {
            state.serialize_entry("waitFor", &self.wait_for)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Artifact describes a build product.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Artifact {
    /// Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
    /// container.
    pub checksum: std::string::String,

    /// Artifact ID, if any; for container images, this will be a URL by digest
    /// like `gcr.io/projectID/imagename@sha256:123456`.
    pub id: std::string::String,

    /// Related artifact names. This may be the path to a binary or jar file, or in
    /// the case of a container build, the name used to push the container image to
    /// Google Container Registry, as presented to `docker push`. Note that a
    /// single Artifact ID can have multiple names, for example if two tags are
    /// applied to one image.
    pub names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Artifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [checksum][crate::model::Artifact::checksum].
    pub fn set_checksum<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.checksum = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Artifact::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [names][crate::model::Artifact::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Artifact {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Artifact"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Artifact {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __checksum,
            __id,
            __names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Artifact")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "checksum" => Ok(__FieldTag::__checksum),
                            "id" => Ok(__FieldTag::__id),
                            "names" => Ok(__FieldTag::__names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Artifact;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Artifact")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__checksum => {
                            if !fields.insert(__FieldTag::__checksum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for checksum",
                                ));
                            }
                            result.checksum = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__names => {
                            if !fields.insert(__FieldTag::__names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for names",
                                ));
                            }
                            result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Artifact {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.checksum.is_empty() {
            state.serialize_entry("checksum", &self.checksum)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A SourceContext is a reference to a tree of files. A SourceContext together
/// with a path point to a unique revision of a single file or directory.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceContext {
    /// Labels with user defined metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A SourceContext can refer any one of the following types of repositories.
    pub context: std::option::Option<crate::model::source_context::Context>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [labels][crate::model::SourceContext::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [context][crate::model::SourceContext::context].
    ///
    /// Note that all the setters affecting `context` are mutually
    /// exclusive.
    pub fn set_context<
        T: std::convert::Into<std::option::Option<crate::model::source_context::Context>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// The value of [context][crate::model::SourceContext::context]
    /// if it holds a `CloudRepo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_repo(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudRepoSourceContext>> {
        #[allow(unreachable_patterns)]
        self.context.as_ref().and_then(|v| match v {
            crate::model::source_context::Context::CloudRepo(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [context][crate::model::SourceContext::context]
    /// to hold a `CloudRepo`.
    ///
    /// Note that all the setters affecting `context` are
    /// mutually exclusive.
    pub fn set_cloud_repo<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudRepoSourceContext>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.context =
            std::option::Option::Some(crate::model::source_context::Context::CloudRepo(v.into()));
        self
    }

    /// The value of [context][crate::model::SourceContext::context]
    /// if it holds a `Gerrit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gerrit(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GerritSourceContext>> {
        #[allow(unreachable_patterns)]
        self.context.as_ref().and_then(|v| match v {
            crate::model::source_context::Context::Gerrit(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [context][crate::model::SourceContext::context]
    /// to hold a `Gerrit`.
    ///
    /// Note that all the setters affecting `context` are
    /// mutually exclusive.
    pub fn set_gerrit<T: std::convert::Into<std::boxed::Box<crate::model::GerritSourceContext>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context =
            std::option::Option::Some(crate::model::source_context::Context::Gerrit(v.into()));
        self
    }

    /// The value of [context][crate::model::SourceContext::context]
    /// if it holds a `Git`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git(&self) -> std::option::Option<&std::boxed::Box<crate::model::GitSourceContext>> {
        #[allow(unreachable_patterns)]
        self.context.as_ref().and_then(|v| match v {
            crate::model::source_context::Context::Git(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [context][crate::model::SourceContext::context]
    /// to hold a `Git`.
    ///
    /// Note that all the setters affecting `context` are
    /// mutually exclusive.
    pub fn set_git<T: std::convert::Into<std::boxed::Box<crate::model::GitSourceContext>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context =
            std::option::Option::Some(crate::model::source_context::Context::Git(v.into()));
        self
    }
}

impl wkt::message::Message for SourceContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SourceContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SourceContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_repo,
            __gerrit,
            __git,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudRepo" => Ok(__FieldTag::__cloud_repo),
                            "cloud_repo" => Ok(__FieldTag::__cloud_repo),
                            "gerrit" => Ok(__FieldTag::__gerrit),
                            "git" => Ok(__FieldTag::__git),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SourceContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_repo => {
                            if !fields.insert(__FieldTag::__cloud_repo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_repo",
                                ));
                            }
                            if result.context.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `context`, a oneof with full ID .grafeas.v1.SourceContext.cloud_repo, latest field was cloudRepo",
                                ));
                            }
                            result.context = std::option::Option::Some(
                                crate::model::source_context::Context::CloudRepo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudRepoSourceContext>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gerrit => {
                            if !fields.insert(__FieldTag::__gerrit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gerrit",
                                ));
                            }
                            if result.context.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `context`, a oneof with full ID .grafeas.v1.SourceContext.gerrit, latest field was gerrit",
                                ));
                            }
                            result.context = std::option::Option::Some(
                                crate::model::source_context::Context::Gerrit(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GerritSourceContext>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__git => {
                            if !fields.insert(__FieldTag::__git) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git",
                                ));
                            }
                            if result.context.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `context`, a oneof with full ID .grafeas.v1.SourceContext.git, latest field was git",
                                ));
                            }
                            result.context = std::option::Option::Some(
                                crate::model::source_context::Context::Git(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GitSourceContext>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SourceContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cloud_repo() {
            state.serialize_entry("cloudRepo", value)?;
        }
        if let Some(value) = self.gerrit() {
            state.serialize_entry("gerrit", value)?;
        }
        if let Some(value) = self.git() {
            state.serialize_entry("git", value)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SourceContext].
pub mod source_context {
    #[allow(unused_imports)]
    use super::*;

    /// A SourceContext can refer any one of the following types of repositories.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Context {
        /// A SourceContext referring to a revision in a Google Cloud Source Repo.
        CloudRepo(std::boxed::Box<crate::model::CloudRepoSourceContext>),
        /// A SourceContext referring to a Gerrit project.
        Gerrit(std::boxed::Box<crate::model::GerritSourceContext>),
        /// A SourceContext referring to any third party Git repo (e.g., GitHub).
        Git(std::boxed::Box<crate::model::GitSourceContext>),
    }
}

/// An alias to a repo revision.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AliasContext {
    /// The alias kind.
    pub kind: crate::model::alias_context::Kind,

    /// The alias name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AliasContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::AliasContext::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::alias_context::Kind>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AliasContext::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AliasContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.AliasContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AliasContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AliasContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AliasContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AliasContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map.next_value::<std::option::Option<crate::model::alias_context::Kind>>()?.unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AliasContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.kind) {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AliasContext].
pub mod alias_context {
    #[allow(unused_imports)]
    use super::*;

    /// The type of an alias.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// Unknown.
        Unspecified,
        /// Git tag.
        Fixed,
        /// Git branch.
        Movable,
        /// Used to specify non-standard aliases. For example, if a Git repo has a
        /// ref named "refs/foo/bar".
        Other,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Kind::value] or
        /// [Kind::name].
        UnknownValue(kind::UnknownValue),
    }

    #[doc(hidden)]
    pub mod kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Kind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Fixed => std::option::Option::Some(1),
                Self::Movable => std::option::Option::Some(2),
                Self::Other => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KIND_UNSPECIFIED"),
                Self::Fixed => std::option::Option::Some("FIXED"),
                Self::Movable => std::option::Option::Some("MOVABLE"),
                Self::Other => std::option::Option::Some("OTHER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Kind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Kind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Kind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Fixed,
                2 => Self::Movable,
                4 => Self::Other,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Kind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KIND_UNSPECIFIED" => Self::Unspecified,
                "FIXED" => Self::Fixed,
                "MOVABLE" => Self::Movable,
                "OTHER" => Self::Other,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Kind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Fixed => serializer.serialize_i32(1),
                Self::Movable => serializer.serialize_i32(2),
                Self::Other => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Kind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Kind>::new(
                ".grafeas.v1.AliasContext.Kind",
            ))
        }
    }
}

/// A CloudRepoSourceContext denotes a particular revision in a Google Cloud
/// Source Repo.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudRepoSourceContext {
    /// The ID of the repo.
    pub repo_id: std::option::Option<crate::model::RepoId>,

    /// A revision in a Cloud Repo can be identified by either its revision ID or
    /// its alias.
    pub revision: std::option::Option<crate::model::cloud_repo_source_context::Revision>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRepoSourceContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repo_id][crate::model::CloudRepoSourceContext::repo_id].
    pub fn set_repo_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RepoId>,
    {
        self.repo_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [repo_id][crate::model::CloudRepoSourceContext::repo_id].
    pub fn set_or_clear_repo_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RepoId>,
    {
        self.repo_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [revision][crate::model::CloudRepoSourceContext::revision].
    ///
    /// Note that all the setters affecting `revision` are mutually
    /// exclusive.
    pub fn set_revision<
        T: std::convert::Into<std::option::Option<crate::model::cloud_repo_source_context::Revision>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.revision = v.into();
        self
    }

    /// The value of [revision][crate::model::CloudRepoSourceContext::revision]
    /// if it holds a `RevisionId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn revision_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::cloud_repo_source_context::Revision::RevisionId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::CloudRepoSourceContext::revision]
    /// to hold a `RevisionId`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = std::option::Option::Some(
            crate::model::cloud_repo_source_context::Revision::RevisionId(v.into()),
        );
        self
    }

    /// The value of [revision][crate::model::CloudRepoSourceContext::revision]
    /// if it holds a `AliasContext`, `None` if the field is not set or
    /// holds a different branch.
    pub fn alias_context(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AliasContext>> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::cloud_repo_source_context::Revision::AliasContext(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::CloudRepoSourceContext::revision]
    /// to hold a `AliasContext`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_alias_context<T: std::convert::Into<std::boxed::Box<crate::model::AliasContext>>>(
        mut self,
        v: T,
    ) -> Self {
        self.revision = std::option::Option::Some(
            crate::model::cloud_repo_source_context::Revision::AliasContext(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloudRepoSourceContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CloudRepoSourceContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudRepoSourceContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __repo_id,
            __revision_id,
            __alias_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRepoSourceContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "repoId" => Ok(__FieldTag::__repo_id),
                            "repo_id" => Ok(__FieldTag::__repo_id),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "aliasContext" => Ok(__FieldTag::__alias_context),
                            "alias_context" => Ok(__FieldTag::__alias_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudRepoSourceContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRepoSourceContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__repo_id => {
                            if !fields.insert(__FieldTag::__repo_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repo_id",
                                ));
                            }
                            result.repo_id =
                                map.next_value::<std::option::Option<crate::model::RepoId>>()?;
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .grafeas.v1.CloudRepoSourceContext.revision_id, latest field was revisionId",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::cloud_repo_source_context::Revision::RevisionId(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__alias_context => {
                            if !fields.insert(__FieldTag::__alias_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alias_context",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .grafeas.v1.CloudRepoSourceContext.alias_context, latest field was aliasContext",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::cloud_repo_source_context::Revision::AliasContext(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AliasContext>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudRepoSourceContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.repo_id.is_some() {
            state.serialize_entry("repoId", &self.repo_id)?;
        }
        if let Some(value) = self.revision_id() {
            state.serialize_entry("revisionId", value)?;
        }
        if let Some(value) = self.alias_context() {
            state.serialize_entry("aliasContext", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CloudRepoSourceContext].
pub mod cloud_repo_source_context {
    #[allow(unused_imports)]
    use super::*;

    /// A revision in a Cloud Repo can be identified by either its revision ID or
    /// its alias.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Revision {
        /// A revision ID.
        RevisionId(std::string::String),
        /// An alias, which may be a branch or tag.
        AliasContext(std::boxed::Box<crate::model::AliasContext>),
    }
}

/// A SourceContext referring to a Gerrit project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GerritSourceContext {
    /// The URI of a running Gerrit instance.
    pub host_uri: std::string::String,

    /// The full project name within the host. Projects may be nested, so
    /// "project/subproject" is a valid project name. The "repo name" is the
    /// hostURI/project.
    pub gerrit_project: std::string::String,

    /// A revision in a Gerrit project can be identified by either its revision ID
    /// or its alias.
    pub revision: std::option::Option<crate::model::gerrit_source_context::Revision>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GerritSourceContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_uri][crate::model::GerritSourceContext::host_uri].
    pub fn set_host_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_uri = v.into();
        self
    }

    /// Sets the value of [gerrit_project][crate::model::GerritSourceContext::gerrit_project].
    pub fn set_gerrit_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gerrit_project = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::GerritSourceContext::revision].
    ///
    /// Note that all the setters affecting `revision` are mutually
    /// exclusive.
    pub fn set_revision<
        T: std::convert::Into<std::option::Option<crate::model::gerrit_source_context::Revision>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.revision = v.into();
        self
    }

    /// The value of [revision][crate::model::GerritSourceContext::revision]
    /// if it holds a `RevisionId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn revision_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::gerrit_source_context::Revision::RevisionId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::GerritSourceContext::revision]
    /// to hold a `RevisionId`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = std::option::Option::Some(
            crate::model::gerrit_source_context::Revision::RevisionId(v.into()),
        );
        self
    }

    /// The value of [revision][crate::model::GerritSourceContext::revision]
    /// if it holds a `AliasContext`, `None` if the field is not set or
    /// holds a different branch.
    pub fn alias_context(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AliasContext>> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::gerrit_source_context::Revision::AliasContext(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::GerritSourceContext::revision]
    /// to hold a `AliasContext`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_alias_context<T: std::convert::Into<std::boxed::Box<crate::model::AliasContext>>>(
        mut self,
        v: T,
    ) -> Self {
        self.revision = std::option::Option::Some(
            crate::model::gerrit_source_context::Revision::AliasContext(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GerritSourceContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GerritSourceContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GerritSourceContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __host_uri,
            __gerrit_project,
            __revision_id,
            __alias_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GerritSourceContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostUri" => Ok(__FieldTag::__host_uri),
                            "host_uri" => Ok(__FieldTag::__host_uri),
                            "gerritProject" => Ok(__FieldTag::__gerrit_project),
                            "gerrit_project" => Ok(__FieldTag::__gerrit_project),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "aliasContext" => Ok(__FieldTag::__alias_context),
                            "alias_context" => Ok(__FieldTag::__alias_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GerritSourceContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GerritSourceContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__host_uri => {
                            if !fields.insert(__FieldTag::__host_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_uri",
                                ));
                            }
                            result.host_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gerrit_project => {
                            if !fields.insert(__FieldTag::__gerrit_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gerrit_project",
                                ));
                            }
                            result.gerrit_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .grafeas.v1.GerritSourceContext.revision_id, latest field was revisionId",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::gerrit_source_context::Revision::RevisionId(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__alias_context => {
                            if !fields.insert(__FieldTag::__alias_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alias_context",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .grafeas.v1.GerritSourceContext.alias_context, latest field was aliasContext",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::gerrit_source_context::Revision::AliasContext(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AliasContext>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GerritSourceContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.host_uri.is_empty() {
            state.serialize_entry("hostUri", &self.host_uri)?;
        }
        if !self.gerrit_project.is_empty() {
            state.serialize_entry("gerritProject", &self.gerrit_project)?;
        }
        if let Some(value) = self.revision_id() {
            state.serialize_entry("revisionId", value)?;
        }
        if let Some(value) = self.alias_context() {
            state.serialize_entry("aliasContext", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GerritSourceContext].
pub mod gerrit_source_context {
    #[allow(unused_imports)]
    use super::*;

    /// A revision in a Gerrit project can be identified by either its revision ID
    /// or its alias.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Revision {
        /// A revision (commit) ID.
        RevisionId(std::string::String),
        /// An alias, which may be a branch or tag.
        AliasContext(std::boxed::Box<crate::model::AliasContext>),
    }
}

/// A GitSourceContext denotes a particular revision in a third party Git
/// repository (e.g., GitHub).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GitSourceContext {
    /// Git repository URL.
    pub url: std::string::String,

    /// Git commit hash.
    pub revision_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitSourceContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::GitSourceContext::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::GitSourceContext::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }
}

impl wkt::message::Message for GitSourceContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GitSourceContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitSourceContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url,
            __revision_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitSourceContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "url" => Ok(__FieldTag::__url),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitSourceContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitSourceContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitSourceContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.url.is_empty() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self.revision_id.is_empty() {
            state.serialize_entry("revisionId", &self.revision_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A unique identifier for a Cloud Repo.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RepoId {
    /// A cloud repo can be identified by either its project ID and repository name
    /// combination, or its globally unique identifier.
    pub id: std::option::Option<crate::model::repo_id::Id>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepoId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::RepoId::id].
    ///
    /// Note that all the setters affecting `id` are mutually
    /// exclusive.
    pub fn set_id<T: std::convert::Into<std::option::Option<crate::model::repo_id::Id>>>(
        mut self,
        v: T,
    ) -> Self {
        self.id = v.into();
        self
    }

    /// The value of [id][crate::model::RepoId::id]
    /// if it holds a `ProjectRepoId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn project_repo_id(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ProjectRepoId>> {
        #[allow(unreachable_patterns)]
        self.id.as_ref().and_then(|v| match v {
            crate::model::repo_id::Id::ProjectRepoId(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [id][crate::model::RepoId::id]
    /// to hold a `ProjectRepoId`.
    ///
    /// Note that all the setters affecting `id` are
    /// mutually exclusive.
    pub fn set_project_repo_id<
        T: std::convert::Into<std::boxed::Box<crate::model::ProjectRepoId>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.id = std::option::Option::Some(crate::model::repo_id::Id::ProjectRepoId(v.into()));
        self
    }

    /// The value of [id][crate::model::RepoId::id]
    /// if it holds a `Uid`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uid(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.id.as_ref().and_then(|v| match v {
            crate::model::repo_id::Id::Uid(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [id][crate::model::RepoId::id]
    /// to hold a `Uid`.
    ///
    /// Note that all the setters affecting `id` are
    /// mutually exclusive.
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = std::option::Option::Some(crate::model::repo_id::Id::Uid(v.into()));
        self
    }
}

impl wkt::message::Message for RepoId {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.RepoId"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RepoId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_repo_id,
            __uid,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepoId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectRepoId" => Ok(__FieldTag::__project_repo_id),
                            "project_repo_id" => Ok(__FieldTag::__project_repo_id),
                            "uid" => Ok(__FieldTag::__uid),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RepoId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepoId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_repo_id => {
                            if !fields.insert(__FieldTag::__project_repo_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_repo_id",
                                ));
                            }
                            if result.id.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `id`, a oneof with full ID .grafeas.v1.RepoId.project_repo_id, latest field was projectRepoId",
                                ));
                            }
                            result.id = std::option::Option::Some(
                                crate::model::repo_id::Id::ProjectRepoId(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ProjectRepoId>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            if result.id.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `id`, a oneof with full ID .grafeas.v1.RepoId.uid, latest field was uid",
                                ));
                            }
                            result.id = std::option::Option::Some(crate::model::repo_id::Id::Uid(
                                map.next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default(),
                            ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RepoId {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.project_repo_id() {
            state.serialize_entry("projectRepoId", value)?;
        }
        if let Some(value) = self.uid() {
            state.serialize_entry("uid", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RepoId].
pub mod repo_id {
    #[allow(unused_imports)]
    use super::*;

    /// A cloud repo can be identified by either its project ID and repository name
    /// combination, or its globally unique identifier.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Id {
        /// A combination of a project ID and a repo name.
        ProjectRepoId(std::boxed::Box<crate::model::ProjectRepoId>),
        /// A server-assigned, globally unique identifier.
        Uid(std::string::String),
    }
}

/// Selects a repo using a Google Cloud Platform project ID (e.g.,
/// winged-cargo-31) and a repo name within that project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ProjectRepoId {
    /// The ID of the project.
    pub project_id: std::string::String,

    /// The name of the repo. Leave empty for the default repo.
    pub repo_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProjectRepoId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ProjectRepoId::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [repo_name][crate::model::ProjectRepoId::repo_name].
    pub fn set_repo_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repo_name = v.into();
        self
    }
}

impl wkt::message::Message for ProjectRepoId {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ProjectRepoId"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProjectRepoId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __repo_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProjectRepoId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "repoName" => Ok(__FieldTag::__repo_name),
                            "repo_name" => Ok(__FieldTag::__repo_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProjectRepoId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProjectRepoId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repo_name => {
                            if !fields.insert(__FieldTag::__repo_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repo_name",
                                ));
                            }
                            result.repo_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProjectRepoId {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.repo_name.is_empty() {
            state.serialize_entry("repoName", &self.repo_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The note representing an SBOM reference.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SBOMReferenceNote {
    /// The format that SBOM takes. E.g. may be spdx, cyclonedx, etc...
    pub format: std::string::String,

    /// The version of the format that the SBOM takes. E.g. if the format
    /// is spdx, the version may be 2.3.
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SBOMReferenceNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [format][crate::model::SBOMReferenceNote::format].
    pub fn set_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [version][crate::model::SBOMReferenceNote::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for SBOMReferenceNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SBOMReferenceNote"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SBOMReferenceNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __format,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SBOMReferenceNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "format" => Ok(__FieldTag::__format),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SBOMReferenceNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SBOMReferenceNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SBOMReferenceNote {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.format.is_empty() {
            state.serialize_entry("format", &self.format)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The occurrence representing an SBOM reference as applied to a specific
/// resource. The occurrence follows the DSSE specification. See
/// <https://github.com/secure-systems-lab/dsse/blob/master/envelope.md> for more
/// details.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SBOMReferenceOccurrence {
    /// The actual payload that contains the SBOM reference data.
    pub payload: std::option::Option<crate::model::SbomReferenceIntotoPayload>,

    /// The kind of payload that SbomReferenceIntotoPayload takes. Since it's in
    /// the intoto format, this value is expected to be
    /// 'application/vnd.in-toto+json'.
    pub payload_type: std::string::String,

    /// The signatures over the payload.
    pub signatures: std::vec::Vec<crate::model::EnvelopeSignature>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SBOMReferenceOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [payload][crate::model::SBOMReferenceOccurrence::payload].
    pub fn set_payload<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SbomReferenceIntotoPayload>,
    {
        self.payload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [payload][crate::model::SBOMReferenceOccurrence::payload].
    pub fn set_or_clear_payload<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SbomReferenceIntotoPayload>,
    {
        self.payload = v.map(|x| x.into());
        self
    }

    /// Sets the value of [payload_type][crate::model::SBOMReferenceOccurrence::payload_type].
    pub fn set_payload_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload_type = v.into();
        self
    }

    /// Sets the value of [signatures][crate::model::SBOMReferenceOccurrence::signatures].
    pub fn set_signatures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvelopeSignature>,
    {
        use std::iter::Iterator;
        self.signatures = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SBOMReferenceOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SBOMReferenceOccurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SBOMReferenceOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __payload,
            __payload_type,
            __signatures,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SBOMReferenceOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "payload" => Ok(__FieldTag::__payload),
                            "payloadType" => Ok(__FieldTag::__payload_type),
                            "payload_type" => Ok(__FieldTag::__payload_type),
                            "signatures" => Ok(__FieldTag::__signatures),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SBOMReferenceOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SBOMReferenceOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            result.payload = map.next_value::<std::option::Option<crate::model::SbomReferenceIntotoPayload>>()?
                                ;
                        }
                        __FieldTag::__payload_type => {
                            if !fields.insert(__FieldTag::__payload_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload_type",
                                ));
                            }
                            result.payload_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__signatures => {
                            if !fields.insert(__FieldTag::__signatures) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signatures",
                                ));
                            }
                            result.signatures =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EnvelopeSignature>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SBOMReferenceOccurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if !self.payload_type.is_empty() {
            state.serialize_entry("payloadType", &self.payload_type)?;
        }
        if !self.signatures.is_empty() {
            state.serialize_entry("signatures", &self.signatures)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The actual payload that contains the SBOM Reference data.
/// The payload follows the intoto statement specification. See
/// <https://github.com/in-toto/attestation/blob/main/spec/v1.0/statement.md>
/// for more details.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SbomReferenceIntotoPayload {
    /// Identifier for the schema of the Statement.
    pub r#type: std::string::String,

    /// URI identifying the type of the Predicate.
    pub predicate_type: std::string::String,

    /// Set of software artifacts that the attestation applies to. Each element
    /// represents a single software artifact.
    pub subject: std::vec::Vec<crate::model::Subject>,

    /// Additional parameters of the Predicate. Includes the actual data about the
    /// SBOM.
    pub predicate: std::option::Option<crate::model::SbomReferenceIntotoPredicate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SbomReferenceIntotoPayload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::SbomReferenceIntotoPayload::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [predicate_type][crate::model::SbomReferenceIntotoPayload::predicate_type].
    pub fn set_predicate_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predicate_type = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::SbomReferenceIntotoPayload::subject].
    pub fn set_subject<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Subject>,
    {
        use std::iter::Iterator;
        self.subject = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [predicate][crate::model::SbomReferenceIntotoPayload::predicate].
    pub fn set_predicate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SbomReferenceIntotoPredicate>,
    {
        self.predicate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [predicate][crate::model::SbomReferenceIntotoPayload::predicate].
    pub fn set_or_clear_predicate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SbomReferenceIntotoPredicate>,
    {
        self.predicate = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SbomReferenceIntotoPayload {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SbomReferenceIntotoPayload"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SbomReferenceIntotoPayload {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __predicate_type,
            __subject,
            __predicate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SbomReferenceIntotoPayload")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "_type" => Ok(__FieldTag::__type),
                            "type" => Ok(__FieldTag::__type),
                            "predicateType" => Ok(__FieldTag::__predicate_type),
                            "predicate_type" => Ok(__FieldTag::__predicate_type),
                            "subject" => Ok(__FieldTag::__subject),
                            "predicate" => Ok(__FieldTag::__predicate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SbomReferenceIntotoPayload;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SbomReferenceIntotoPayload")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__predicate_type => {
                            if !fields.insert(__FieldTag::__predicate_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predicate_type",
                                ));
                            }
                            result.predicate_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Subject>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__predicate => {
                            if !fields.insert(__FieldTag::__predicate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predicate",
                                ));
                            }
                            result.predicate = map.next_value::<std::option::Option<crate::model::SbomReferenceIntotoPredicate>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SbomReferenceIntotoPayload {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("_type", &self.r#type)?;
        }
        if !self.predicate_type.is_empty() {
            state.serialize_entry("predicateType", &self.predicate_type)?;
        }
        if !self.subject.is_empty() {
            state.serialize_entry("subject", &self.subject)?;
        }
        if self.predicate.is_some() {
            state.serialize_entry("predicate", &self.predicate)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A predicate which describes the SBOM being referenced.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SbomReferenceIntotoPredicate {
    /// The person or system referring this predicate to the consumer.
    pub referrer_id: std::string::String,

    /// The location of the SBOM.
    pub location: std::string::String,

    /// The mime type of the SBOM.
    pub mime_type: std::string::String,

    /// A map of algorithm to digest of the contents of the SBOM.
    pub digest: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SbomReferenceIntotoPredicate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [referrer_id][crate::model::SbomReferenceIntotoPredicate::referrer_id].
    pub fn set_referrer_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.referrer_id = v.into();
        self
    }

    /// Sets the value of [location][crate::model::SbomReferenceIntotoPredicate::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::SbomReferenceIntotoPredicate::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [digest][crate::model::SbomReferenceIntotoPredicate::digest].
    pub fn set_digest<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SbomReferenceIntotoPredicate {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SbomReferenceIntotoPredicate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SbomReferenceIntotoPredicate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __referrer_id,
            __location,
            __mime_type,
            __digest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SbomReferenceIntotoPredicate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "referrerId" => Ok(__FieldTag::__referrer_id),
                            "referrer_id" => Ok(__FieldTag::__referrer_id),
                            "location" => Ok(__FieldTag::__location),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "digest" => Ok(__FieldTag::__digest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SbomReferenceIntotoPredicate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SbomReferenceIntotoPredicate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__referrer_id => {
                            if !fields.insert(__FieldTag::__referrer_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referrer_id",
                                ));
                            }
                            result.referrer_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SbomReferenceIntotoPredicate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.referrer_id.is_empty() {
            state.serialize_entry("referrerId", &self.referrer_id)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.digest.is_empty() {
            state.serialize_entry("digest", &self.digest)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The note representing a secret.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretNote {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SecretNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SecretNote"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecretNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecretNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecretNote {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The occurrence provides details of a secret.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretOccurrence {
    /// Type of secret.
    pub kind: crate::model::SecretKind,

    /// Locations where the secret is detected.
    pub locations: std::vec::Vec<crate::model::SecretLocation>,

    /// Status of the secret.
    pub statuses: std::vec::Vec<crate::model::SecretStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SecretOccurrence::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::SecretKind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [locations][crate::model::SecretOccurrence::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecretLocation>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [statuses][crate::model::SecretOccurrence::statuses].
    pub fn set_statuses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecretStatus>,
    {
        use std::iter::Iterator;
        self.statuses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SecretOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SecretOccurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecretOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __locations,
            __statuses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "locations" => Ok(__FieldTag::__locations),
                            "statuses" => Ok(__FieldTag::__statuses),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecretOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<crate::model::SecretKind>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locations",
                                ));
                            }
                            result.locations =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SecretLocation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__statuses => {
                            if !fields.insert(__FieldTag::__statuses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statuses",
                                ));
                            }
                            result.statuses = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SecretStatus>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecretOccurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.kind) {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if !self.statuses.is_empty() {
            state.serialize_entry("statuses", &self.statuses)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The location of the secret.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretLocation {
    /// The detailed location of the secret.
    pub location: std::option::Option<crate::model::secret_location::Location>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::SecretLocation::location].
    ///
    /// Note that all the setters affecting `location` are mutually
    /// exclusive.
    pub fn set_location<
        T: std::convert::Into<std::option::Option<crate::model::secret_location::Location>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::SecretLocation::location]
    /// if it holds a `FileLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn file_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FileLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::secret_location::Location::FileLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::SecretLocation::location]
    /// to hold a `FileLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_file_location<T: std::convert::Into<std::boxed::Box<crate::model::FileLocation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::secret_location::Location::FileLocation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SecretLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SecretLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecretLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileLocation" => Ok(__FieldTag::__file_location),
                            "file_location" => Ok(__FieldTag::__file_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecretLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_location => {
                            if !fields.insert(__FieldTag::__file_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_location",
                                ));
                            }
                            if result.location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location`, a oneof with full ID .grafeas.v1.SecretLocation.file_location, latest field was fileLocation",
                                ));
                            }
                            result.location = std::option::Option::Some(
                                crate::model::secret_location::Location::FileLocation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FileLocation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecretLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.file_location() {
            state.serialize_entry("fileLocation", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SecretLocation].
pub mod secret_location {
    #[allow(unused_imports)]
    use super::*;

    /// The detailed location of the secret.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Location {
        /// The secret is found from a file.
        FileLocation(std::boxed::Box<crate::model::FileLocation>),
    }
}

/// The status of the secret with a timestamp.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretStatus {
    /// The status of the secret.
    pub status: crate::model::secret_status::Status,

    /// The time the secret status was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional message about the status code.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::SecretStatus::status].
    pub fn set_status<T: std::convert::Into<crate::model::secret_status::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::SecretStatus::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::SecretStatus::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message][crate::model::SecretStatus::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for SecretStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SecretStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecretStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __status,
            __update_time,
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "status" => Ok(__FieldTag::__status),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecretStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::secret_status::Status>>()?.unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecretStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SecretStatus].
pub mod secret_status {
    #[allow(unused_imports)]
    use super::*;

    /// The status of the secret.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Unspecified
        Unspecified,
        /// The status of the secret is unknown.
        Unknown,
        /// The secret is valid.
        Valid,
        /// The secret is invalid.
        Invalid,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(1),
                Self::Valid => std::option::Option::Some(2),
                Self::Invalid => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Valid => std::option::Option::Some("VALID"),
                Self::Invalid => std::option::Option::Some("INVALID"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unknown,
                2 => Self::Valid,
                3 => Self::Invalid,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN" => Self::Unknown,
                "VALID" => Self::Valid,
                "INVALID" => Self::Invalid,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(1),
                Self::Valid => serializer.serialize_i32(2),
                Self::Invalid => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".grafeas.v1.SecretStatus.Status",
            ))
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SlsaProvenance {
    pub builder: std::option::Option<crate::model::slsa_provenance::SlsaBuilder>,

    /// Identifies the configuration used for the build.
    /// When combined with materials, this SHOULD fully describe the build,
    /// such that re-running this recipe results in bit-for-bit identical output
    /// (if the build is reproducible).
    pub recipe: std::option::Option<crate::model::slsa_provenance::SlsaRecipe>,

    pub metadata: std::option::Option<crate::model::slsa_provenance::SlsaMetadata>,

    /// The collection of artifacts that influenced the build including sources,
    /// dependencies, build tools, base images, and so on. This is considered to be
    /// incomplete unless metadata.completeness.materials is true. Unset or null is
    /// equivalent to empty.
    pub materials: std::vec::Vec<crate::model::slsa_provenance::Material>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SlsaProvenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builder][crate::model::SlsaProvenance::builder].
    pub fn set_builder<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance::SlsaBuilder>,
    {
        self.builder = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [builder][crate::model::SlsaProvenance::builder].
    pub fn set_or_clear_builder<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance::SlsaBuilder>,
    {
        self.builder = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recipe][crate::model::SlsaProvenance::recipe].
    pub fn set_recipe<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance::SlsaRecipe>,
    {
        self.recipe = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recipe][crate::model::SlsaProvenance::recipe].
    pub fn set_or_clear_recipe<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance::SlsaRecipe>,
    {
        self.recipe = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::SlsaProvenance::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance::SlsaMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::SlsaProvenance::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance::SlsaMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [materials][crate::model::SlsaProvenance::materials].
    pub fn set_materials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::slsa_provenance::Material>,
    {
        use std::iter::Iterator;
        self.materials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SlsaProvenance {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SlsaProvenance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SlsaProvenance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __builder,
            __recipe,
            __metadata,
            __materials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaProvenance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "builder" => Ok(__FieldTag::__builder),
                            "recipe" => Ok(__FieldTag::__recipe),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "materials" => Ok(__FieldTag::__materials),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SlsaProvenance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaProvenance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__builder => {
                            if !fields.insert(__FieldTag::__builder) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builder",
                                ));
                            }
                            result.builder = map.next_value::<std::option::Option<crate::model::slsa_provenance::SlsaBuilder>>()?
                                ;
                        }
                        __FieldTag::__recipe => {
                            if !fields.insert(__FieldTag::__recipe) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recipe",
                                ));
                            }
                            result.recipe = map.next_value::<std::option::Option<crate::model::slsa_provenance::SlsaRecipe>>()?
                                ;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata =
                                map.next_value::<std::option::Option<
                                    crate::model::slsa_provenance::SlsaMetadata,
                                >>()?;
                        }
                        __FieldTag::__materials => {
                            if !fields.insert(__FieldTag::__materials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materials",
                                ));
                            }
                            result.materials = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::slsa_provenance::Material>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SlsaProvenance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.builder.is_some() {
            state.serialize_entry("builder", &self.builder)?;
        }
        if self.recipe.is_some() {
            state.serialize_entry("recipe", &self.recipe)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.materials.is_empty() {
            state.serialize_entry("materials", &self.materials)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SlsaProvenance].
pub mod slsa_provenance {
    #[allow(unused_imports)]
    use super::*;

    /// Steps taken to build the artifact.
    /// For a TaskRun, typically each container corresponds to one step in the
    /// recipe.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaRecipe {
        /// URI indicating what type of recipe was performed. It determines the
        /// meaning of recipe.entryPoint, recipe.arguments, recipe.environment, and
        /// materials.
        pub r#type: std::string::String,

        /// Index in materials containing the recipe steps that are not implied by
        /// recipe.type. For example, if the recipe type were "make", then this would
        /// point to the source containing the Makefile, not the make program itself.
        /// Set to -1 if the recipe doesn't come from a material, as zero is default
        /// unset value for int64.
        pub defined_in_material: i64,

        /// String identifying the entry point into the build.
        /// This is often a path to a configuration file and/or a target label within
        /// that file. The syntax and meaning are defined by recipe.type. For
        /// example, if the recipe type were "make", then this would reference the
        /// directory in which to run make as well as which target to use.
        pub entry_point: std::string::String,

        /// Collection of all external inputs that influenced the build on top of
        /// recipe.definedInMaterial and recipe.entryPoint. For example, if the
        /// recipe type were "make", then this might be the flags passed to make
        /// aside from the target, which is captured in recipe.entryPoint. Depending
        /// on the recipe Type, the structure may be different.
        pub arguments: std::option::Option<wkt::Any>,

        /// Any other builder-controlled inputs necessary for correctly evaluating
        /// the recipe. Usually only needed for reproducing the build but not
        /// evaluated as part of policy. Depending on the recipe Type, the structure
        /// may be different.
        pub environment: std::option::Option<wkt::Any>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaRecipe {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::slsa_provenance::SlsaRecipe::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [defined_in_material][crate::model::slsa_provenance::SlsaRecipe::defined_in_material].
        pub fn set_defined_in_material<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.defined_in_material = v.into();
            self
        }

        /// Sets the value of [entry_point][crate::model::slsa_provenance::SlsaRecipe::entry_point].
        pub fn set_entry_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entry_point = v.into();
            self
        }

        /// Sets the value of [arguments][crate::model::slsa_provenance::SlsaRecipe::arguments].
        pub fn set_arguments<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Any>,
        {
            self.arguments = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [arguments][crate::model::slsa_provenance::SlsaRecipe::arguments].
        pub fn set_or_clear_arguments<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Any>,
        {
            self.arguments = v.map(|x| x.into());
            self
        }

        /// Sets the value of [environment][crate::model::slsa_provenance::SlsaRecipe::environment].
        pub fn set_environment<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Any>,
        {
            self.environment = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [environment][crate::model::slsa_provenance::SlsaRecipe::environment].
        pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Any>,
        {
            self.environment = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SlsaRecipe {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.SlsaRecipe"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SlsaRecipe {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                __defined_in_material,
                __entry_point,
                __arguments,
                __environment,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SlsaRecipe")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                "definedInMaterial" => Ok(__FieldTag::__defined_in_material),
                                "defined_in_material" => Ok(__FieldTag::__defined_in_material),
                                "entryPoint" => Ok(__FieldTag::__entry_point),
                                "entry_point" => Ok(__FieldTag::__entry_point),
                                "arguments" => Ok(__FieldTag::__arguments),
                                "environment" => Ok(__FieldTag::__environment),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SlsaRecipe;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SlsaRecipe")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__defined_in_material => {
                                if !fields.insert(__FieldTag::__defined_in_material) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for defined_in_material",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.defined_in_material =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__entry_point => {
                                if !fields.insert(__FieldTag::__entry_point) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entry_point",
                                    ));
                                }
                                result.entry_point = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__arguments => {
                                if !fields.insert(__FieldTag::__arguments) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for arguments",
                                    ));
                                }
                                result.arguments =
                                    map.next_value::<std::option::Option<wkt::Any>>()?;
                            }
                            __FieldTag::__environment => {
                                if !fields.insert(__FieldTag::__environment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for environment",
                                    ));
                                }
                                result.environment =
                                    map.next_value::<std::option::Option<wkt::Any>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SlsaRecipe {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !wkt::internal::is_default(&self.defined_in_material) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("definedInMaterial", &__With(&self.defined_in_material))?;
            }
            if !self.entry_point.is_empty() {
                state.serialize_entry("entryPoint", &self.entry_point)?;
            }
            if self.arguments.is_some() {
                state.serialize_entry("arguments", &self.arguments)?;
            }
            if self.environment.is_some() {
                state.serialize_entry("environment", &self.environment)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Indicates that the builder claims certain fields in this message to be
    /// complete.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaCompleteness {
        /// If true, the builder claims that recipe.arguments is complete, meaning
        /// that all external inputs are properly captured in the recipe.
        pub arguments: bool,

        /// If true, the builder claims that recipe.environment is claimed to be
        /// complete.
        pub environment: bool,

        /// If true, the builder claims that materials are complete, usually through
        /// some controls to prevent network access. Sometimes called "hermetic".
        pub materials: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaCompleteness {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [arguments][crate::model::slsa_provenance::SlsaCompleteness::arguments].
        pub fn set_arguments<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.arguments = v.into();
            self
        }

        /// Sets the value of [environment][crate::model::slsa_provenance::SlsaCompleteness::environment].
        pub fn set_environment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.environment = v.into();
            self
        }

        /// Sets the value of [materials][crate::model::slsa_provenance::SlsaCompleteness::materials].
        pub fn set_materials<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.materials = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaCompleteness {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.SlsaCompleteness"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SlsaCompleteness {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __arguments,
                __environment,
                __materials,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SlsaCompleteness")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "arguments" => Ok(__FieldTag::__arguments),
                                "environment" => Ok(__FieldTag::__environment),
                                "materials" => Ok(__FieldTag::__materials),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SlsaCompleteness;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SlsaCompleteness")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__arguments => {
                                if !fields.insert(__FieldTag::__arguments) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for arguments",
                                    ));
                                }
                                result.arguments = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__environment => {
                                if !fields.insert(__FieldTag::__environment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for environment",
                                    ));
                                }
                                result.environment = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__materials => {
                                if !fields.insert(__FieldTag::__materials) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for materials",
                                    ));
                                }
                                result.materials = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SlsaCompleteness {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.arguments) {
                state.serialize_entry("arguments", &self.arguments)?;
            }
            if !wkt::internal::is_default(&self.environment) {
                state.serialize_entry("environment", &self.environment)?;
            }
            if !wkt::internal::is_default(&self.materials) {
                state.serialize_entry("materials", &self.materials)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Other properties of the build.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaMetadata {
        /// Identifies the particular build invocation, which can be useful for
        /// finding associated logs or other ad-hoc analysis. The value SHOULD be
        /// globally unique, per in-toto Provenance spec.
        pub build_invocation_id: std::string::String,

        /// The timestamp of when the build started.
        pub build_started_on: std::option::Option<wkt::Timestamp>,

        /// The timestamp of when the build completed.
        pub build_finished_on: std::option::Option<wkt::Timestamp>,

        /// Indicates that the builder claims certain fields in this message to be
        /// complete.
        pub completeness: std::option::Option<crate::model::slsa_provenance::SlsaCompleteness>,

        /// If true, the builder claims that running the recipe on materials will
        /// produce bit-for-bit identical output.
        pub reproducible: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [build_invocation_id][crate::model::slsa_provenance::SlsaMetadata::build_invocation_id].
        pub fn set_build_invocation_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.build_invocation_id = v.into();
            self
        }

        /// Sets the value of [build_started_on][crate::model::slsa_provenance::SlsaMetadata::build_started_on].
        pub fn set_build_started_on<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_started_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_started_on][crate::model::slsa_provenance::SlsaMetadata::build_started_on].
        pub fn set_or_clear_build_started_on<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_started_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [build_finished_on][crate::model::slsa_provenance::SlsaMetadata::build_finished_on].
        pub fn set_build_finished_on<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_finished_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_finished_on][crate::model::slsa_provenance::SlsaMetadata::build_finished_on].
        pub fn set_or_clear_build_finished_on<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_finished_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [completeness][crate::model::slsa_provenance::SlsaMetadata::completeness].
        pub fn set_completeness<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::slsa_provenance::SlsaCompleteness>,
        {
            self.completeness = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [completeness][crate::model::slsa_provenance::SlsaMetadata::completeness].
        pub fn set_or_clear_completeness<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::slsa_provenance::SlsaCompleteness>,
        {
            self.completeness = v.map(|x| x.into());
            self
        }

        /// Sets the value of [reproducible][crate::model::slsa_provenance::SlsaMetadata::reproducible].
        pub fn set_reproducible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.reproducible = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.SlsaMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SlsaMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __build_invocation_id,
                __build_started_on,
                __build_finished_on,
                __completeness,
                __reproducible,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SlsaMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "buildInvocationId" => Ok(__FieldTag::__build_invocation_id),
                                "build_invocation_id" => Ok(__FieldTag::__build_invocation_id),
                                "buildStartedOn" => Ok(__FieldTag::__build_started_on),
                                "build_started_on" => Ok(__FieldTag::__build_started_on),
                                "buildFinishedOn" => Ok(__FieldTag::__build_finished_on),
                                "build_finished_on" => Ok(__FieldTag::__build_finished_on),
                                "completeness" => Ok(__FieldTag::__completeness),
                                "reproducible" => Ok(__FieldTag::__reproducible),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SlsaMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SlsaMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__build_invocation_id => {
                                if !fields.insert(__FieldTag::__build_invocation_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for build_invocation_id",
                                    ));
                                }
                                result.build_invocation_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__build_started_on => {
                                if !fields.insert(__FieldTag::__build_started_on) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for build_started_on",
                                    ));
                                }
                                result.build_started_on =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__build_finished_on => {
                                if !fields.insert(__FieldTag::__build_finished_on) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for build_finished_on",
                                    ));
                                }
                                result.build_finished_on =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__completeness => {
                                if !fields.insert(__FieldTag::__completeness) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for completeness",
                                    ));
                                }
                                result.completeness = map.next_value::<std::option::Option<
                                    crate::model::slsa_provenance::SlsaCompleteness,
                                >>()?;
                            }
                            __FieldTag::__reproducible => {
                                if !fields.insert(__FieldTag::__reproducible) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for reproducible",
                                    ));
                                }
                                result.reproducible = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SlsaMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.build_invocation_id.is_empty() {
                state.serialize_entry("buildInvocationId", &self.build_invocation_id)?;
            }
            if self.build_started_on.is_some() {
                state.serialize_entry("buildStartedOn", &self.build_started_on)?;
            }
            if self.build_finished_on.is_some() {
                state.serialize_entry("buildFinishedOn", &self.build_finished_on)?;
            }
            if self.completeness.is_some() {
                state.serialize_entry("completeness", &self.completeness)?;
            }
            if !wkt::internal::is_default(&self.reproducible) {
                state.serialize_entry("reproducible", &self.reproducible)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaBuilder {
        pub id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaBuilder {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::slsa_provenance::SlsaBuilder::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaBuilder {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.SlsaBuilder"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SlsaBuilder {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SlsaBuilder")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SlsaBuilder;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SlsaBuilder")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SlsaBuilder {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Material {
        pub uri: std::string::String,

        pub digest: std::collections::HashMap<std::string::String, std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Material {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::slsa_provenance::Material::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [digest][crate::model::slsa_provenance::Material::digest].
        pub fn set_digest<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for Material {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.Material"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Material {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uri,
                __digest,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Material")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uri" => Ok(__FieldTag::__uri),
                                "digest" => Ok(__FieldTag::__digest),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Material;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Material")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__digest => {
                                if !fields.insert(__FieldTag::__digest) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for digest",
                                    ));
                                }
                                result.digest = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Material {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self.digest.is_empty() {
                state.serialize_entry("digest", &self.digest)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SlsaProvenanceZeroTwo {
    pub builder: std::option::Option<crate::model::slsa_provenance_zero_two::SlsaBuilder>,

    pub build_type: std::string::String,

    pub invocation: std::option::Option<crate::model::slsa_provenance_zero_two::SlsaInvocation>,

    pub build_config: std::option::Option<wkt::Struct>,

    pub metadata: std::option::Option<crate::model::slsa_provenance_zero_two::SlsaMetadata>,

    pub materials: std::vec::Vec<crate::model::slsa_provenance_zero_two::SlsaMaterial>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SlsaProvenanceZeroTwo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builder][crate::model::SlsaProvenanceZeroTwo::builder].
    pub fn set_builder<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaBuilder>,
    {
        self.builder = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [builder][crate::model::SlsaProvenanceZeroTwo::builder].
    pub fn set_or_clear_builder<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaBuilder>,
    {
        self.builder = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_type][crate::model::SlsaProvenanceZeroTwo::build_type].
    pub fn set_build_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build_type = v.into();
        self
    }

    /// Sets the value of [invocation][crate::model::SlsaProvenanceZeroTwo::invocation].
    pub fn set_invocation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaInvocation>,
    {
        self.invocation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [invocation][crate::model::SlsaProvenanceZeroTwo::invocation].
    pub fn set_or_clear_invocation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaInvocation>,
    {
        self.invocation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_config][crate::model::SlsaProvenanceZeroTwo::build_config].
    pub fn set_build_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.build_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_config][crate::model::SlsaProvenanceZeroTwo::build_config].
    pub fn set_or_clear_build_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.build_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::SlsaProvenanceZeroTwo::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::SlsaProvenanceZeroTwo::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [materials][crate::model::SlsaProvenanceZeroTwo::materials].
    pub fn set_materials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaMaterial>,
    {
        use std::iter::Iterator;
        self.materials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SlsaProvenanceZeroTwo {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SlsaProvenanceZeroTwo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __builder,
            __build_type,
            __invocation,
            __build_config,
            __metadata,
            __materials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaProvenanceZeroTwo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "builder" => Ok(__FieldTag::__builder),
                            "buildType" => Ok(__FieldTag::__build_type),
                            "build_type" => Ok(__FieldTag::__build_type),
                            "invocation" => Ok(__FieldTag::__invocation),
                            "buildConfig" => Ok(__FieldTag::__build_config),
                            "build_config" => Ok(__FieldTag::__build_config),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "materials" => Ok(__FieldTag::__materials),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SlsaProvenanceZeroTwo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaProvenanceZeroTwo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__builder => {
                            if !fields.insert(__FieldTag::__builder) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builder",
                                ));
                            }
                            result.builder = map.next_value::<std::option::Option<
                                crate::model::slsa_provenance_zero_two::SlsaBuilder,
                            >>()?;
                        }
                        __FieldTag::__build_type => {
                            if !fields.insert(__FieldTag::__build_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_type",
                                ));
                            }
                            result.build_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invocation => {
                            if !fields.insert(__FieldTag::__invocation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invocation",
                                ));
                            }
                            result.invocation = map.next_value::<std::option::Option<
                                crate::model::slsa_provenance_zero_two::SlsaInvocation,
                            >>()?;
                        }
                        __FieldTag::__build_config => {
                            if !fields.insert(__FieldTag::__build_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_config",
                                ));
                            }
                            result.build_config =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map.next_value::<std::option::Option<
                                crate::model::slsa_provenance_zero_two::SlsaMetadata,
                            >>()?;
                        }
                        __FieldTag::__materials => {
                            if !fields.insert(__FieldTag::__materials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materials",
                                ));
                            }
                            result.materials = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::slsa_provenance_zero_two::SlsaMaterial,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SlsaProvenanceZeroTwo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.builder.is_some() {
            state.serialize_entry("builder", &self.builder)?;
        }
        if !self.build_type.is_empty() {
            state.serialize_entry("buildType", &self.build_type)?;
        }
        if self.invocation.is_some() {
            state.serialize_entry("invocation", &self.invocation)?;
        }
        if self.build_config.is_some() {
            state.serialize_entry("buildConfig", &self.build_config)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.materials.is_empty() {
            state.serialize_entry("materials", &self.materials)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SlsaProvenanceZeroTwo].
pub mod slsa_provenance_zero_two {
    #[allow(unused_imports)]
    use super::*;

    /// Identifies the entity that executed the recipe, which is trusted to have
    /// correctly performed the operation and populated this provenance.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaBuilder {
        pub id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaBuilder {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::slsa_provenance_zero_two::SlsaBuilder::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaBuilder {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaBuilder"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SlsaBuilder {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SlsaBuilder")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SlsaBuilder;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SlsaBuilder")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SlsaBuilder {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The collection of artifacts that influenced the build including sources,
    /// dependencies, build tools, base images, and so on.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaMaterial {
        pub uri: std::string::String,

        pub digest: std::collections::HashMap<std::string::String, std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaMaterial {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::slsa_provenance_zero_two::SlsaMaterial::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [digest][crate::model::slsa_provenance_zero_two::SlsaMaterial::digest].
        pub fn set_digest<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for SlsaMaterial {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaMaterial"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SlsaMaterial {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uri,
                __digest,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SlsaMaterial")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uri" => Ok(__FieldTag::__uri),
                                "digest" => Ok(__FieldTag::__digest),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SlsaMaterial;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SlsaMaterial")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__digest => {
                                if !fields.insert(__FieldTag::__digest) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for digest",
                                    ));
                                }
                                result.digest = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SlsaMaterial {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self.digest.is_empty() {
                state.serialize_entry("digest", &self.digest)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Identifies the event that kicked off the build.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaInvocation {
        pub config_source:
            std::option::Option<crate::model::slsa_provenance_zero_two::SlsaConfigSource>,

        pub parameters: std::option::Option<wkt::Struct>,

        pub environment: std::option::Option<wkt::Struct>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaInvocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [config_source][crate::model::slsa_provenance_zero_two::SlsaInvocation::config_source].
        pub fn set_config_source<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaConfigSource>,
        {
            self.config_source = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [config_source][crate::model::slsa_provenance_zero_two::SlsaInvocation::config_source].
        pub fn set_or_clear_config_source<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaConfigSource>,
        {
            self.config_source = v.map(|x| x.into());
            self
        }

        /// Sets the value of [parameters][crate::model::slsa_provenance_zero_two::SlsaInvocation::parameters].
        pub fn set_parameters<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.parameters = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [parameters][crate::model::slsa_provenance_zero_two::SlsaInvocation::parameters].
        pub fn set_or_clear_parameters<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.parameters = v.map(|x| x.into());
            self
        }

        /// Sets the value of [environment][crate::model::slsa_provenance_zero_two::SlsaInvocation::environment].
        pub fn set_environment<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.environment = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [environment][crate::model::slsa_provenance_zero_two::SlsaInvocation::environment].
        pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.environment = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SlsaInvocation {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaInvocation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SlsaInvocation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __config_source,
                __parameters,
                __environment,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SlsaInvocation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "configSource" => Ok(__FieldTag::__config_source),
                                "config_source" => Ok(__FieldTag::__config_source),
                                "parameters" => Ok(__FieldTag::__parameters),
                                "environment" => Ok(__FieldTag::__environment),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SlsaInvocation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SlsaInvocation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__config_source => {
                                if !fields.insert(__FieldTag::__config_source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for config_source",
                                    ));
                                }
                                result.config_source = map.next_value::<std::option::Option<
                                    crate::model::slsa_provenance_zero_two::SlsaConfigSource,
                                >>()?;
                            }
                            __FieldTag::__parameters => {
                                if !fields.insert(__FieldTag::__parameters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parameters",
                                    ));
                                }
                                result.parameters =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::__environment => {
                                if !fields.insert(__FieldTag::__environment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for environment",
                                    ));
                                }
                                result.environment =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SlsaInvocation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.config_source.is_some() {
                state.serialize_entry("configSource", &self.config_source)?;
            }
            if self.parameters.is_some() {
                state.serialize_entry("parameters", &self.parameters)?;
            }
            if self.environment.is_some() {
                state.serialize_entry("environment", &self.environment)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Describes where the config file that kicked off the build came from.
    /// This is effectively a pointer to the source where buildConfig came from.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaConfigSource {
        pub uri: std::string::String,

        pub digest: std::collections::HashMap<std::string::String, std::string::String>,

        pub entry_point: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaConfigSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::slsa_provenance_zero_two::SlsaConfigSource::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [digest][crate::model::slsa_provenance_zero_two::SlsaConfigSource::digest].
        pub fn set_digest<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [entry_point][crate::model::slsa_provenance_zero_two::SlsaConfigSource::entry_point].
        pub fn set_entry_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entry_point = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaConfigSource {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaConfigSource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SlsaConfigSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uri,
                __digest,
                __entry_point,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SlsaConfigSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uri" => Ok(__FieldTag::__uri),
                                "digest" => Ok(__FieldTag::__digest),
                                "entryPoint" => Ok(__FieldTag::__entry_point),
                                "entry_point" => Ok(__FieldTag::__entry_point),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SlsaConfigSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SlsaConfigSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__digest => {
                                if !fields.insert(__FieldTag::__digest) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for digest",
                                    ));
                                }
                                result.digest = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__entry_point => {
                                if !fields.insert(__FieldTag::__entry_point) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entry_point",
                                    ));
                                }
                                result.entry_point = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SlsaConfigSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self.digest.is_empty() {
                state.serialize_entry("digest", &self.digest)?;
            }
            if !self.entry_point.is_empty() {
                state.serialize_entry("entryPoint", &self.entry_point)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Other properties of the build.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaMetadata {
        pub build_invocation_id: std::string::String,

        pub build_started_on: std::option::Option<wkt::Timestamp>,

        pub build_finished_on: std::option::Option<wkt::Timestamp>,

        pub completeness:
            std::option::Option<crate::model::slsa_provenance_zero_two::SlsaCompleteness>,

        pub reproducible: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [build_invocation_id][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_invocation_id].
        pub fn set_build_invocation_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.build_invocation_id = v.into();
            self
        }

        /// Sets the value of [build_started_on][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_started_on].
        pub fn set_build_started_on<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_started_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_started_on][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_started_on].
        pub fn set_or_clear_build_started_on<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_started_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [build_finished_on][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_finished_on].
        pub fn set_build_finished_on<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_finished_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_finished_on][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_finished_on].
        pub fn set_or_clear_build_finished_on<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_finished_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [completeness][crate::model::slsa_provenance_zero_two::SlsaMetadata::completeness].
        pub fn set_completeness<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaCompleteness>,
        {
            self.completeness = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [completeness][crate::model::slsa_provenance_zero_two::SlsaMetadata::completeness].
        pub fn set_or_clear_completeness<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaCompleteness>,
        {
            self.completeness = v.map(|x| x.into());
            self
        }

        /// Sets the value of [reproducible][crate::model::slsa_provenance_zero_two::SlsaMetadata::reproducible].
        pub fn set_reproducible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.reproducible = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SlsaMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __build_invocation_id,
                __build_started_on,
                __build_finished_on,
                __completeness,
                __reproducible,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SlsaMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "buildInvocationId" => Ok(__FieldTag::__build_invocation_id),
                                "build_invocation_id" => Ok(__FieldTag::__build_invocation_id),
                                "buildStartedOn" => Ok(__FieldTag::__build_started_on),
                                "build_started_on" => Ok(__FieldTag::__build_started_on),
                                "buildFinishedOn" => Ok(__FieldTag::__build_finished_on),
                                "build_finished_on" => Ok(__FieldTag::__build_finished_on),
                                "completeness" => Ok(__FieldTag::__completeness),
                                "reproducible" => Ok(__FieldTag::__reproducible),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SlsaMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SlsaMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__build_invocation_id => {
                                if !fields.insert(__FieldTag::__build_invocation_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for build_invocation_id",
                                    ));
                                }
                                result.build_invocation_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__build_started_on => {
                                if !fields.insert(__FieldTag::__build_started_on) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for build_started_on",
                                    ));
                                }
                                result.build_started_on =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__build_finished_on => {
                                if !fields.insert(__FieldTag::__build_finished_on) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for build_finished_on",
                                    ));
                                }
                                result.build_finished_on =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__completeness => {
                                if !fields.insert(__FieldTag::__completeness) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for completeness",
                                    ));
                                }
                                result.completeness = map.next_value::<std::option::Option<
                                    crate::model::slsa_provenance_zero_two::SlsaCompleteness,
                                >>()?;
                            }
                            __FieldTag::__reproducible => {
                                if !fields.insert(__FieldTag::__reproducible) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for reproducible",
                                    ));
                                }
                                result.reproducible = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SlsaMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.build_invocation_id.is_empty() {
                state.serialize_entry("buildInvocationId", &self.build_invocation_id)?;
            }
            if self.build_started_on.is_some() {
                state.serialize_entry("buildStartedOn", &self.build_started_on)?;
            }
            if self.build_finished_on.is_some() {
                state.serialize_entry("buildFinishedOn", &self.build_finished_on)?;
            }
            if self.completeness.is_some() {
                state.serialize_entry("completeness", &self.completeness)?;
            }
            if !wkt::internal::is_default(&self.reproducible) {
                state.serialize_entry("reproducible", &self.reproducible)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Indicates that the builder claims certain fields in this message to be
    /// complete.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaCompleteness {
        pub parameters: bool,

        pub environment: bool,

        pub materials: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaCompleteness {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parameters][crate::model::slsa_provenance_zero_two::SlsaCompleteness::parameters].
        pub fn set_parameters<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.parameters = v.into();
            self
        }

        /// Sets the value of [environment][crate::model::slsa_provenance_zero_two::SlsaCompleteness::environment].
        pub fn set_environment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.environment = v.into();
            self
        }

        /// Sets the value of [materials][crate::model::slsa_provenance_zero_two::SlsaCompleteness::materials].
        pub fn set_materials<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.materials = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaCompleteness {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaCompleteness"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SlsaCompleteness {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __parameters,
                __environment,
                __materials,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SlsaCompleteness")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "parameters" => Ok(__FieldTag::__parameters),
                                "environment" => Ok(__FieldTag::__environment),
                                "materials" => Ok(__FieldTag::__materials),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SlsaCompleteness;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SlsaCompleteness")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__parameters => {
                                if !fields.insert(__FieldTag::__parameters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parameters",
                                    ));
                                }
                                result.parameters = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__environment => {
                                if !fields.insert(__FieldTag::__environment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for environment",
                                    ));
                                }
                                result.environment = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__materials => {
                                if !fields.insert(__FieldTag::__materials) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for materials",
                                    ));
                                }
                                result.materials = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SlsaCompleteness {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.parameters) {
                state.serialize_entry("parameters", &self.parameters)?;
            }
            if !wkt::internal::is_default(&self.environment) {
                state.serialize_entry("environment", &self.environment)?;
            }
            if !wkt::internal::is_default(&self.materials) {
                state.serialize_entry("materials", &self.materials)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// An Upgrade Note represents a potential upgrade of a package to a given
/// version. For each package version combination (i.e. bash 4.0, bash 4.1,
/// bash 4.1.2), there will be an Upgrade Note. For Windows, windows_update field
/// represents the information related to the update.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeNote {
    /// Required for non-Windows OS. The package this Upgrade is for.
    pub package: std::string::String,

    /// Required for non-Windows OS. The version of the package in machine + human
    /// readable form.
    pub version: std::option::Option<crate::model::Version>,

    /// Metadata about the upgrade for each specific operating system.
    pub distributions: std::vec::Vec<crate::model::UpgradeDistribution>,

    /// Required for Windows OS. Represents the metadata about the Windows update.
    pub windows_update: std::option::Option<crate::model::WindowsUpdate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package][crate::model::UpgradeNote::package].
    pub fn set_package<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package = v.into();
        self
    }

    /// Sets the value of [version][crate::model::UpgradeNote::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::UpgradeNote::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [distributions][crate::model::UpgradeNote::distributions].
    pub fn set_distributions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UpgradeDistribution>,
    {
        use std::iter::Iterator;
        self.distributions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [windows_update][crate::model::UpgradeNote::windows_update].
    pub fn set_windows_update<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WindowsUpdate>,
    {
        self.windows_update = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [windows_update][crate::model::UpgradeNote::windows_update].
    pub fn set_or_clear_windows_update<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WindowsUpdate>,
    {
        self.windows_update = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpgradeNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpgradeNote"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __package,
            __version,
            __distributions,
            __windows_update,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "package" => Ok(__FieldTag::__package),
                            "version" => Ok(__FieldTag::__version),
                            "distributions" => Ok(__FieldTag::__distributions),
                            "windowsUpdate" => Ok(__FieldTag::__windows_update),
                            "windows_update" => Ok(__FieldTag::__windows_update),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__package => {
                            if !fields.insert(__FieldTag::__package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package",
                                ));
                            }
                            result.package = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__distributions => {
                            if !fields.insert(__FieldTag::__distributions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distributions",
                                ));
                            }
                            result.distributions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UpgradeDistribution>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__windows_update => {
                            if !fields.insert(__FieldTag::__windows_update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_update",
                                ));
                            }
                            result.windows_update = map
                                .next_value::<std::option::Option<crate::model::WindowsUpdate>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeNote {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.package.is_empty() {
            state.serialize_entry("package", &self.package)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.distributions.is_empty() {
            state.serialize_entry("distributions", &self.distributions)?;
        }
        if self.windows_update.is_some() {
            state.serialize_entry("windowsUpdate", &self.windows_update)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The Upgrade Distribution represents metadata about the Upgrade for each
/// operating system (CPE). Some distributions have additional metadata around
/// updates, classifying them into various categories and severities.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeDistribution {
    /// Required - The specific operating system this metadata applies to. See
    /// <https://cpe.mitre.org/specification/>.
    pub cpe_uri: std::string::String,

    /// The operating system classification of this Upgrade, as specified by the
    /// upstream operating system upgrade feed. For Windows the classification is
    /// one of the category_ids listed at
    /// <https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ff357803>(v=vs.85)
    pub classification: std::string::String,

    /// The severity as specified by the upstream operating system.
    pub severity: std::string::String,

    /// The cve tied to this Upgrade.
    pub cve: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeDistribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpe_uri][crate::model::UpgradeDistribution::cpe_uri].
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [classification][crate::model::UpgradeDistribution::classification].
    pub fn set_classification<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.classification = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::UpgradeDistribution::severity].
    pub fn set_severity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [cve][crate::model::UpgradeDistribution::cve].
    pub fn set_cve<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.cve = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UpgradeDistribution {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpgradeDistribution"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeDistribution {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpe_uri,
            __classification,
            __severity,
            __cve,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeDistribution")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "classification" => Ok(__FieldTag::__classification),
                            "severity" => Ok(__FieldTag::__severity),
                            "cve" => Ok(__FieldTag::__cve),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeDistribution;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeDistribution")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__classification => {
                            if !fields.insert(__FieldTag::__classification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for classification",
                                ));
                            }
                            result.classification = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cve => {
                            if !fields.insert(__FieldTag::__cve) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cve",
                                ));
                            }
                            result.cve = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeDistribution {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cpe_uri.is_empty() {
            state.serialize_entry("cpeUri", &self.cpe_uri)?;
        }
        if !self.classification.is_empty() {
            state.serialize_entry("classification", &self.classification)?;
        }
        if !self.severity.is_empty() {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.cve.is_empty() {
            state.serialize_entry("cve", &self.cve)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Windows Update represents the metadata about the update for the Windows
/// operating system. The fields in this message come from the Windows Update API
/// documented at
/// <https://docs.microsoft.com/en-us/windows/win32/api/wuapi/nn-wuapi-iupdate>.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WindowsUpdate {
    /// Required - The unique identifier for the update.
    pub identity: std::option::Option<crate::model::windows_update::Identity>,

    /// The localized title of the update.
    pub title: std::string::String,

    /// The localized description of the update.
    pub description: std::string::String,

    /// The list of categories to which the update belongs.
    pub categories: std::vec::Vec<crate::model::windows_update::Category>,

    /// The Microsoft Knowledge Base article IDs that are associated with the
    /// update.
    pub kb_article_ids: std::vec::Vec<std::string::String>,

    /// The hyperlink to the support information for the update.
    pub support_url: std::string::String,

    /// The last published timestamp of the update.
    pub last_published_timestamp: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WindowsUpdate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [identity][crate::model::WindowsUpdate::identity].
    pub fn set_identity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::windows_update::Identity>,
    {
        self.identity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [identity][crate::model::WindowsUpdate::identity].
    pub fn set_or_clear_identity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::windows_update::Identity>,
    {
        self.identity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [title][crate::model::WindowsUpdate::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::WindowsUpdate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [categories][crate::model::WindowsUpdate::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::windows_update::Category>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kb_article_ids][crate::model::WindowsUpdate::kb_article_ids].
    pub fn set_kb_article_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.kb_article_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [support_url][crate::model::WindowsUpdate::support_url].
    pub fn set_support_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.support_url = v.into();
        self
    }

    /// Sets the value of [last_published_timestamp][crate::model::WindowsUpdate::last_published_timestamp].
    pub fn set_last_published_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_published_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_published_timestamp][crate::model::WindowsUpdate::last_published_timestamp].
    pub fn set_or_clear_last_published_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_published_timestamp = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WindowsUpdate {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.WindowsUpdate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WindowsUpdate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __identity,
            __title,
            __description,
            __categories,
            __kb_article_ids,
            __support_url,
            __last_published_timestamp,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WindowsUpdate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "identity" => Ok(__FieldTag::__identity),
                            "title" => Ok(__FieldTag::__title),
                            "description" => Ok(__FieldTag::__description),
                            "categories" => Ok(__FieldTag::__categories),
                            "kbArticleIds" => Ok(__FieldTag::__kb_article_ids),
                            "kb_article_ids" => Ok(__FieldTag::__kb_article_ids),
                            "supportUrl" => Ok(__FieldTag::__support_url),
                            "support_url" => Ok(__FieldTag::__support_url),
                            "lastPublishedTimestamp" => Ok(__FieldTag::__last_published_timestamp),
                            "last_published_timestamp" => {
                                Ok(__FieldTag::__last_published_timestamp)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WindowsUpdate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WindowsUpdate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__identity => {
                            if !fields.insert(__FieldTag::__identity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity",
                                ));
                            }
                            result.identity = map.next_value::<std::option::Option<crate::model::windows_update::Identity>>()?
                                ;
                        }
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__categories => {
                            if !fields.insert(__FieldTag::__categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for categories",
                                ));
                            }
                            result.categories = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::windows_update::Category>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kb_article_ids => {
                            if !fields.insert(__FieldTag::__kb_article_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kb_article_ids",
                                ));
                            }
                            result.kb_article_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__support_url => {
                            if !fields.insert(__FieldTag::__support_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for support_url",
                                ));
                            }
                            result.support_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_published_timestamp => {
                            if !fields.insert(__FieldTag::__last_published_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_published_timestamp",
                                ));
                            }
                            result.last_published_timestamp =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WindowsUpdate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.identity.is_some() {
            state.serialize_entry("identity", &self.identity)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.categories.is_empty() {
            state.serialize_entry("categories", &self.categories)?;
        }
        if !self.kb_article_ids.is_empty() {
            state.serialize_entry("kbArticleIds", &self.kb_article_ids)?;
        }
        if !self.support_url.is_empty() {
            state.serialize_entry("supportUrl", &self.support_url)?;
        }
        if self.last_published_timestamp.is_some() {
            state.serialize_entry("lastPublishedTimestamp", &self.last_published_timestamp)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WindowsUpdate].
pub mod windows_update {
    #[allow(unused_imports)]
    use super::*;

    /// The unique identifier of the update.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Identity {
        /// The revision independent identifier of the update.
        pub update_id: std::string::String,

        /// The revision number of the update.
        pub revision: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Identity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [update_id][crate::model::windows_update::Identity::update_id].
        pub fn set_update_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.update_id = v.into();
            self
        }

        /// Sets the value of [revision][crate::model::windows_update::Identity::revision].
        pub fn set_revision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.revision = v.into();
            self
        }
    }

    impl wkt::message::Message for Identity {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.WindowsUpdate.Identity"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Identity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __update_id,
                __revision,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Identity")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "updateId" => Ok(__FieldTag::__update_id),
                                "update_id" => Ok(__FieldTag::__update_id),
                                "revision" => Ok(__FieldTag::__revision),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Identity;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Identity")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__update_id => {
                                if !fields.insert(__FieldTag::__update_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_id",
                                    ));
                                }
                                result.update_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__revision => {
                                if !fields.insert(__FieldTag::__revision) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for revision",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.revision = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Identity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.update_id.is_empty() {
                state.serialize_entry("updateId", &self.update_id)?;
            }
            if !wkt::internal::is_default(&self.revision) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("revision", &__With(&self.revision))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The category to which the update belongs.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Category {
        /// The identifier of the category.
        pub category_id: std::string::String,

        /// The localized name of the category.
        pub name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Category {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [category_id][crate::model::windows_update::Category::category_id].
        pub fn set_category_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.category_id = v.into();
            self
        }

        /// Sets the value of [name][crate::model::windows_update::Category::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    impl wkt::message::Message for Category {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.WindowsUpdate.Category"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Category {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __category_id,
                __name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Category")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "categoryId" => Ok(__FieldTag::__category_id),
                                "category_id" => Ok(__FieldTag::__category_id),
                                "name" => Ok(__FieldTag::__name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Category;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Category")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__category_id => {
                                if !fields.insert(__FieldTag::__category_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for category_id",
                                    ));
                                }
                                result.category_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Category {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.category_id.is_empty() {
                state.serialize_entry("categoryId", &self.category_id)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// An Upgrade Occurrence represents that a specific resource_url could install a
/// specific upgrade. This presence is supplied via local sources (i.e. it is
/// present in the mirror and the running system has noticed its availability).
/// For Windows, both distribution and windows_update contain information for the
/// Windows update.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeOccurrence {
    /// Required for non-Windows OS. The package this Upgrade is for.
    pub package: std::string::String,

    /// Required for non-Windows OS. The version of the package in a machine +
    /// human readable form.
    pub parsed_version: std::option::Option<crate::model::Version>,

    /// Metadata about the upgrade for available for the specific operating system
    /// for the resource_url. This allows efficient filtering, as well as
    /// making it easier to use the occurrence.
    pub distribution: std::option::Option<crate::model::UpgradeDistribution>,

    /// Required for Windows OS. Represents the metadata about the Windows update.
    pub windows_update: std::option::Option<crate::model::WindowsUpdate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package][crate::model::UpgradeOccurrence::package].
    pub fn set_package<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package = v.into();
        self
    }

    /// Sets the value of [parsed_version][crate::model::UpgradeOccurrence::parsed_version].
    pub fn set_parsed_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.parsed_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parsed_version][crate::model::UpgradeOccurrence::parsed_version].
    pub fn set_or_clear_parsed_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.parsed_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [distribution][crate::model::UpgradeOccurrence::distribution].
    pub fn set_distribution<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UpgradeDistribution>,
    {
        self.distribution = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [distribution][crate::model::UpgradeOccurrence::distribution].
    pub fn set_or_clear_distribution<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UpgradeDistribution>,
    {
        self.distribution = v.map(|x| x.into());
        self
    }

    /// Sets the value of [windows_update][crate::model::UpgradeOccurrence::windows_update].
    pub fn set_windows_update<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WindowsUpdate>,
    {
        self.windows_update = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [windows_update][crate::model::UpgradeOccurrence::windows_update].
    pub fn set_or_clear_windows_update<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WindowsUpdate>,
    {
        self.windows_update = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpgradeOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpgradeOccurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __package,
            __parsed_version,
            __distribution,
            __windows_update,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "package" => Ok(__FieldTag::__package),
                            "parsedVersion" => Ok(__FieldTag::__parsed_version),
                            "parsed_version" => Ok(__FieldTag::__parsed_version),
                            "distribution" => Ok(__FieldTag::__distribution),
                            "windowsUpdate" => Ok(__FieldTag::__windows_update),
                            "windows_update" => Ok(__FieldTag::__windows_update),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__package => {
                            if !fields.insert(__FieldTag::__package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package",
                                ));
                            }
                            result.package = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parsed_version => {
                            if !fields.insert(__FieldTag::__parsed_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parsed_version",
                                ));
                            }
                            result.parsed_version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__distribution => {
                            if !fields.insert(__FieldTag::__distribution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distribution",
                                ));
                            }
                            result.distribution = map.next_value::<std::option::Option<crate::model::UpgradeDistribution>>()?
                                ;
                        }
                        __FieldTag::__windows_update => {
                            if !fields.insert(__FieldTag::__windows_update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_update",
                                ));
                            }
                            result.windows_update = map
                                .next_value::<std::option::Option<crate::model::WindowsUpdate>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeOccurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.package.is_empty() {
            state.serialize_entry("package", &self.package)?;
        }
        if self.parsed_version.is_some() {
            state.serialize_entry("parsedVersion", &self.parsed_version)?;
        }
        if self.distribution.is_some() {
            state.serialize_entry("distribution", &self.distribution)?;
        }
        if self.windows_update.is_some() {
            state.serialize_entry("windowsUpdate", &self.windows_update)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A single VulnerabilityAssessmentNote represents
/// one particular product's vulnerability assessment for one CVE.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VulnerabilityAssessmentNote {
    /// The title of the note. E.g. `Vex-Debian-11.4`
    pub title: std::string::String,

    /// A one sentence description of this Vex.
    pub short_description: std::string::String,

    /// A detailed description of this Vex.
    pub long_description: std::string::String,

    /// Identifies the language used by this document,
    /// corresponding to IETF BCP 47 / RFC 5646.
    pub language_code: std::string::String,

    /// Publisher details of this Note.
    pub publisher: std::option::Option<crate::model::vulnerability_assessment_note::Publisher>,

    /// The product affected by this vex.
    pub product: std::option::Option<crate::model::vulnerability_assessment_note::Product>,

    /// Represents a vulnerability assessment for the product.
    pub assessment: std::option::Option<crate::model::vulnerability_assessment_note::Assessment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerabilityAssessmentNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [title][crate::model::VulnerabilityAssessmentNote::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [short_description][crate::model::VulnerabilityAssessmentNote::short_description].
    pub fn set_short_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.short_description = v.into();
        self
    }

    /// Sets the value of [long_description][crate::model::VulnerabilityAssessmentNote::long_description].
    pub fn set_long_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.long_description = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::VulnerabilityAssessmentNote::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [publisher][crate::model::VulnerabilityAssessmentNote::publisher].
    pub fn set_publisher<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_assessment_note::Publisher>,
    {
        self.publisher = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [publisher][crate::model::VulnerabilityAssessmentNote::publisher].
    pub fn set_or_clear_publisher<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_assessment_note::Publisher>,
    {
        self.publisher = v.map(|x| x.into());
        self
    }

    /// Sets the value of [product][crate::model::VulnerabilityAssessmentNote::product].
    pub fn set_product<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_assessment_note::Product>,
    {
        self.product = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [product][crate::model::VulnerabilityAssessmentNote::product].
    pub fn set_or_clear_product<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_assessment_note::Product>,
    {
        self.product = v.map(|x| x.into());
        self
    }

    /// Sets the value of [assessment][crate::model::VulnerabilityAssessmentNote::assessment].
    pub fn set_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_assessment_note::Assessment>,
    {
        self.assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assessment][crate::model::VulnerabilityAssessmentNote::assessment].
    pub fn set_or_clear_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_assessment_note::Assessment>,
    {
        self.assessment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VulnerabilityAssessmentNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VulnerabilityAssessmentNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __short_description,
            __long_description,
            __language_code,
            __publisher,
            __product,
            __assessment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VulnerabilityAssessmentNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "shortDescription" => Ok(__FieldTag::__short_description),
                            "short_description" => Ok(__FieldTag::__short_description),
                            "longDescription" => Ok(__FieldTag::__long_description),
                            "long_description" => Ok(__FieldTag::__long_description),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "publisher" => Ok(__FieldTag::__publisher),
                            "product" => Ok(__FieldTag::__product),
                            "assessment" => Ok(__FieldTag::__assessment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VulnerabilityAssessmentNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VulnerabilityAssessmentNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__short_description => {
                            if !fields.insert(__FieldTag::__short_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for short_description",
                                ));
                            }
                            result.short_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__long_description => {
                            if !fields.insert(__FieldTag::__long_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for long_description",
                                ));
                            }
                            result.long_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__publisher => {
                            if !fields.insert(__FieldTag::__publisher) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publisher",
                                ));
                            }
                            result.publisher = map.next_value::<std::option::Option<
                                crate::model::vulnerability_assessment_note::Publisher,
                            >>()?;
                        }
                        __FieldTag::__product => {
                            if !fields.insert(__FieldTag::__product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product",
                                ));
                            }
                            result.product = map.next_value::<std::option::Option<
                                crate::model::vulnerability_assessment_note::Product,
                            >>()?;
                        }
                        __FieldTag::__assessment => {
                            if !fields.insert(__FieldTag::__assessment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assessment",
                                ));
                            }
                            result.assessment = map.next_value::<std::option::Option<
                                crate::model::vulnerability_assessment_note::Assessment,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VulnerabilityAssessmentNote {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.short_description.is_empty() {
            state.serialize_entry("shortDescription", &self.short_description)?;
        }
        if !self.long_description.is_empty() {
            state.serialize_entry("longDescription", &self.long_description)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.publisher.is_some() {
            state.serialize_entry("publisher", &self.publisher)?;
        }
        if self.product.is_some() {
            state.serialize_entry("product", &self.product)?;
        }
        if self.assessment.is_some() {
            state.serialize_entry("assessment", &self.assessment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VulnerabilityAssessmentNote].
pub mod vulnerability_assessment_note {
    #[allow(unused_imports)]
    use super::*;

    /// Publisher contains information about the publisher of
    /// this Note.
    /// (-- api-linter: core::0123::resource-annotation=disabled
    /// aip.dev/not-precedent: Publisher is not a separate resource. --)
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Publisher {
        /// Name of the publisher.
        /// Examples: 'Google', 'Google Cloud Platform'.
        pub name: std::string::String,

        /// Provides information about the authority of the issuing party to
        /// release the document, in particular, the party's constituency and
        /// responsibilities or other obligations.
        pub issuing_authority: std::string::String,

        /// The context or namespace.
        /// Contains a URL which is under control of the issuing party and can
        /// be used as a globally unique identifier for that issuing party.
        /// Example: <https://csaf.io>
        pub publisher_namespace: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Publisher {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::vulnerability_assessment_note::Publisher::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [issuing_authority][crate::model::vulnerability_assessment_note::Publisher::issuing_authority].
        pub fn set_issuing_authority<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.issuing_authority = v.into();
            self
        }

        /// Sets the value of [publisher_namespace][crate::model::vulnerability_assessment_note::Publisher::publisher_namespace].
        pub fn set_publisher_namespace<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.publisher_namespace = v.into();
            self
        }
    }

    impl wkt::message::Message for Publisher {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Publisher"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Publisher {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __issuing_authority,
                __publisher_namespace,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Publisher")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "issuingAuthority" => Ok(__FieldTag::__issuing_authority),
                                "issuing_authority" => Ok(__FieldTag::__issuing_authority),
                                "publisherNamespace" => Ok(__FieldTag::__publisher_namespace),
                                "publisher_namespace" => Ok(__FieldTag::__publisher_namespace),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Publisher;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Publisher")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__issuing_authority => {
                                if !fields.insert(__FieldTag::__issuing_authority) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for issuing_authority",
                                    ));
                                }
                                result.issuing_authority = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__publisher_namespace => {
                                if !fields.insert(__FieldTag::__publisher_namespace) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for publisher_namespace",
                                    ));
                                }
                                result.publisher_namespace = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Publisher {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.issuing_authority.is_empty() {
                state.serialize_entry("issuingAuthority", &self.issuing_authority)?;
            }
            if !self.publisher_namespace.is_empty() {
                state.serialize_entry("publisherNamespace", &self.publisher_namespace)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Product contains information about a product and how to uniquely identify
    /// it.
    /// (-- api-linter: core::0123::resource-annotation=disabled
    /// aip.dev/not-precedent: Product is not a separate resource. --)
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Product {
        /// Name of the product.
        pub name: std::string::String,

        /// Token that identifies a product so that it can be referred to from other
        /// parts in the document. There is no predefined format as long as it
        /// uniquely identifies a group in the context of the current document.
        pub id: std::string::String,

        pub identifier:
            std::option::Option<crate::model::vulnerability_assessment_note::product::Identifier>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Product {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::vulnerability_assessment_note::Product::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [id][crate::model::vulnerability_assessment_note::Product::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [identifier][crate::model::vulnerability_assessment_note::Product::identifier].
        ///
        /// Note that all the setters affecting `identifier` are mutually
        /// exclusive.
        pub fn set_identifier<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::vulnerability_assessment_note::product::Identifier,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.identifier = v.into();
            self
        }

        /// The value of [identifier][crate::model::vulnerability_assessment_note::Product::identifier]
        /// if it holds a `GenericUri`, `None` if the field is not set or
        /// holds a different branch.
        pub fn generic_uri(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.identifier.as_ref().and_then(|v| match v {
                crate::model::vulnerability_assessment_note::product::Identifier::GenericUri(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [identifier][crate::model::vulnerability_assessment_note::Product::identifier]
        /// to hold a `GenericUri`.
        ///
        /// Note that all the setters affecting `identifier` are
        /// mutually exclusive.
        pub fn set_generic_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.identifier = std::option::Option::Some(
                crate::model::vulnerability_assessment_note::product::Identifier::GenericUri(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for Product {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Product"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Product {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __id,
                __generic_uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Product")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "id" => Ok(__FieldTag::__id),
                                "genericUri" => Ok(__FieldTag::__generic_uri),
                                "generic_uri" => Ok(__FieldTag::__generic_uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Product;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Product")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__generic_uri => {
                                if !fields.insert(__FieldTag::__generic_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for generic_uri",
                                    ));
                                }
                                if result.identifier.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `identifier`, a oneof with full ID .grafeas.v1.VulnerabilityAssessmentNote.Product.generic_uri, latest field was genericUri",
                                    ));
                                }
                                result.identifier = std::option::Option::Some(
                                    crate::model::vulnerability_assessment_note::product::Identifier::GenericUri(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Product {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if let Some(value) = self.generic_uri() {
                state.serialize_entry("genericUri", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Product].
    pub mod product {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Identifier {
            /// Contains a URI which is vendor-specific.
            /// Example: The artifact repository URL of an image.
            GenericUri(std::string::String),
        }
    }

    /// Assessment provides all information that is related to a single
    /// vulnerability for this product.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Assessment {
        /// Holds the MITRE standard Common Vulnerabilities and Exposures (CVE)
        /// tracking number for the vulnerability.
        /// Deprecated: Use vulnerability_id instead to denote CVEs.
        #[deprecated]
        pub cve: std::string::String,

        /// The vulnerability identifier for this Assessment. Will hold one of
        /// common identifiers e.g. CVE, GHSA etc.
        pub vulnerability_id: std::string::String,

        /// A one sentence description of this Vex.
        pub short_description: std::string::String,

        /// A detailed description of this Vex.
        pub long_description: std::string::String,

        /// Holds a list of references associated with this vulnerability item and
        /// assessment. These uris have additional information about the
        /// vulnerability and the assessment itself. E.g. Link to a document which
        /// details how this assessment concluded the state of this vulnerability.
        pub related_uris: std::vec::Vec<crate::model::RelatedUrl>,

        /// Provides the state of this Vulnerability assessment.
        pub state: crate::model::vulnerability_assessment_note::assessment::State,

        /// Contains information about the impact of this vulnerability,
        /// this will change with time.
        pub impacts: std::vec::Vec<std::string::String>,

        /// Justification provides the justification when the state of the
        /// assessment if NOT_AFFECTED.
        pub justification: std::option::Option<
            crate::model::vulnerability_assessment_note::assessment::Justification,
        >,

        /// Specifies details on how to handle (and presumably, fix) a vulnerability.
        pub remediations:
            std::vec::Vec<crate::model::vulnerability_assessment_note::assessment::Remediation>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Assessment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cve][crate::model::vulnerability_assessment_note::Assessment::cve].
        #[deprecated]
        pub fn set_cve<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cve = v.into();
            self
        }

        /// Sets the value of [vulnerability_id][crate::model::vulnerability_assessment_note::Assessment::vulnerability_id].
        pub fn set_vulnerability_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.vulnerability_id = v.into();
            self
        }

        /// Sets the value of [short_description][crate::model::vulnerability_assessment_note::Assessment::short_description].
        pub fn set_short_description<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.short_description = v.into();
            self
        }

        /// Sets the value of [long_description][crate::model::vulnerability_assessment_note::Assessment::long_description].
        pub fn set_long_description<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.long_description = v.into();
            self
        }

        /// Sets the value of [related_uris][crate::model::vulnerability_assessment_note::Assessment::related_uris].
        pub fn set_related_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::RelatedUrl>,
        {
            use std::iter::Iterator;
            self.related_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [state][crate::model::vulnerability_assessment_note::Assessment::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [impacts][crate::model::vulnerability_assessment_note::Assessment::impacts].
        pub fn set_impacts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.impacts = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [justification][crate::model::vulnerability_assessment_note::Assessment::justification].
        pub fn set_justification<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::vulnerability_assessment_note::assessment::Justification,
                >,
        {
            self.justification = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [justification][crate::model::vulnerability_assessment_note::Assessment::justification].
        pub fn set_or_clear_justification<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::vulnerability_assessment_note::assessment::Justification,
                >,
        {
            self.justification = v.map(|x| x.into());
            self
        }

        /// Sets the value of [remediations][crate::model::vulnerability_assessment_note::Assessment::remediations].
        pub fn set_remediations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::vulnerability_assessment_note::assessment::Remediation,
                >,
        {
            use std::iter::Iterator;
            self.remediations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Assessment {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Assessment"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Assessment {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cve,
                __vulnerability_id,
                __short_description,
                __long_description,
                __related_uris,
                __state,
                __impacts,
                __justification,
                __remediations,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Assessment")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cve" => Ok(__FieldTag::__cve),
                                "vulnerabilityId" => Ok(__FieldTag::__vulnerability_id),
                                "vulnerability_id" => Ok(__FieldTag::__vulnerability_id),
                                "shortDescription" => Ok(__FieldTag::__short_description),
                                "short_description" => Ok(__FieldTag::__short_description),
                                "longDescription" => Ok(__FieldTag::__long_description),
                                "long_description" => Ok(__FieldTag::__long_description),
                                "relatedUris" => Ok(__FieldTag::__related_uris),
                                "related_uris" => Ok(__FieldTag::__related_uris),
                                "state" => Ok(__FieldTag::__state),
                                "impacts" => Ok(__FieldTag::__impacts),
                                "justification" => Ok(__FieldTag::__justification),
                                "remediations" => Ok(__FieldTag::__remediations),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Assessment;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Assessment")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cve => {
                                if !fields.insert(__FieldTag::__cve) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cve",
                                    ));
                                }
                                result.cve = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__vulnerability_id => {
                                if !fields.insert(__FieldTag::__vulnerability_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vulnerability_id",
                                    ));
                                }
                                result.vulnerability_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__short_description => {
                                if !fields.insert(__FieldTag::__short_description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for short_description",
                                    ));
                                }
                                result.short_description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__long_description => {
                                if !fields.insert(__FieldTag::__long_description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for long_description",
                                    ));
                                }
                                result.long_description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__related_uris => {
                                if !fields.insert(__FieldTag::__related_uris) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for related_uris",
                                    ));
                                }
                                result.related_uris =
                                    map.next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::RelatedUrl>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::vulnerability_assessment_note::assessment::State>>()?.unwrap_or_default();
                            }
                            __FieldTag::__impacts => {
                                if !fields.insert(__FieldTag::__impacts) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for impacts",
                                    ));
                                }
                                result.impacts = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__justification => {
                                if !fields.insert(__FieldTag::__justification) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for justification",
                                    ));
                                }
                                result.justification = map.next_value::<std::option::Option<crate::model::vulnerability_assessment_note::assessment::Justification>>()?
                                    ;
                            }
                            __FieldTag::__remediations => {
                                if !fields.insert(__FieldTag::__remediations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for remediations",
                                    ));
                                }
                                result.remediations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::vulnerability_assessment_note::assessment::Remediation>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Assessment {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.cve.is_empty() {
                state.serialize_entry("cve", &self.cve)?;
            }
            if !self.vulnerability_id.is_empty() {
                state.serialize_entry("vulnerabilityId", &self.vulnerability_id)?;
            }
            if !self.short_description.is_empty() {
                state.serialize_entry("shortDescription", &self.short_description)?;
            }
            if !self.long_description.is_empty() {
                state.serialize_entry("longDescription", &self.long_description)?;
            }
            if !self.related_uris.is_empty() {
                state.serialize_entry("relatedUris", &self.related_uris)?;
            }
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.impacts.is_empty() {
                state.serialize_entry("impacts", &self.impacts)?;
            }
            if self.justification.is_some() {
                state.serialize_entry("justification", &self.justification)?;
            }
            if !self.remediations.is_empty() {
                state.serialize_entry("remediations", &self.remediations)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Assessment].
    pub mod assessment {
        #[allow(unused_imports)]
        use super::*;

        /// Justification provides the justification when the state of the
        /// assessment if NOT_AFFECTED.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Justification {

            /// The justification type for this vulnerability.
            pub justification_type: crate::model::vulnerability_assessment_note::assessment::justification::JustificationType,

            /// Additional details on why this justification was chosen.
            pub details: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Justification {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [justification_type][crate::model::vulnerability_assessment_note::assessment::Justification::justification_type].
            pub fn set_justification_type<T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::justification::JustificationType>>(mut self, v: T) -> Self{
                self.justification_type = v.into();
                self
            }

            /// Sets the value of [details][crate::model::vulnerability_assessment_note::assessment::Justification::details].
            pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.details = v.into();
                self
            }
        }

        impl wkt::message::Message for Justification {
            fn typename() -> &'static str {
                "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Assessment.Justification"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Justification {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __justification_type,
                    __details,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Justification")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "justificationType" => Ok(__FieldTag::__justification_type),
                                    "justification_type" => Ok(__FieldTag::__justification_type),
                                    "details" => Ok(__FieldTag::__details),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Justification;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Justification")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__justification_type => {
                                    if !fields.insert(__FieldTag::__justification_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for justification_type",
                                            ),
                                        );
                                    }
                                    result.justification_type = map.next_value::<std::option::Option<crate::model::vulnerability_assessment_note::assessment::justification::JustificationType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__details => {
                                    if !fields.insert(__FieldTag::__details) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for details",
                                            ),
                                        );
                                    }
                                    result.details = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Justification {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.justification_type) {
                    state.serialize_entry("justificationType", &self.justification_type)?;
                }
                if !self.details.is_empty() {
                    state.serialize_entry("details", &self.details)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Justification].
        pub mod justification {
            #[allow(unused_imports)]
            use super::*;

            /// Provides the type of justification.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum JustificationType {
                /// JUSTIFICATION_TYPE_UNSPECIFIED.
                Unspecified,
                /// The vulnerable component is not present in the product.
                ComponentNotPresent,
                /// The vulnerable code is not present. Typically this case
                /// occurs when source code is configured or built in a way that excludes
                /// the vulnerable code.
                VulnerableCodeNotPresent,
                /// The vulnerable code can not be executed.
                /// Typically this case occurs when the product includes the vulnerable
                /// code but does not call or use the vulnerable code.
                VulnerableCodeNotInExecutePath,
                /// The vulnerable code cannot be controlled by an attacker to exploit
                /// the vulnerability.
                VulnerableCodeCannotBeControlledByAdversary,
                /// The product includes built-in protections or features that prevent
                /// exploitation of the vulnerability. These built-in protections cannot
                /// be subverted by the attacker and cannot be configured or disabled by
                /// the user. These mitigations completely prevent exploitation based on
                /// known attack vectors.
                InlineMitigationsAlreadyExist,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [JustificationType::value] or
                /// [JustificationType::name].
                UnknownValue(justification_type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod justification_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl JustificationType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::ComponentNotPresent => std::option::Option::Some(1),
                        Self::VulnerableCodeNotPresent => std::option::Option::Some(2),
                        Self::VulnerableCodeNotInExecutePath => std::option::Option::Some(3),
                        Self::VulnerableCodeCannotBeControlledByAdversary => {
                            std::option::Option::Some(4)
                        }
                        Self::InlineMitigationsAlreadyExist => std::option::Option::Some(5),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("JUSTIFICATION_TYPE_UNSPECIFIED")
                        }
                        Self::ComponentNotPresent => {
                            std::option::Option::Some("COMPONENT_NOT_PRESENT")
                        }
                        Self::VulnerableCodeNotPresent => {
                            std::option::Option::Some("VULNERABLE_CODE_NOT_PRESENT")
                        }
                        Self::VulnerableCodeNotInExecutePath => {
                            std::option::Option::Some("VULNERABLE_CODE_NOT_IN_EXECUTE_PATH")
                        }
                        Self::VulnerableCodeCannotBeControlledByAdversary => {
                            std::option::Option::Some(
                                "VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY",
                            )
                        }
                        Self::InlineMitigationsAlreadyExist => {
                            std::option::Option::Some("INLINE_MITIGATIONS_ALREADY_EXIST")
                        }
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for JustificationType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for JustificationType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for JustificationType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::ComponentNotPresent,
                        2 => Self::VulnerableCodeNotPresent,
                        3 => Self::VulnerableCodeNotInExecutePath,
                        4 => Self::VulnerableCodeCannotBeControlledByAdversary,
                        5 => Self::InlineMitigationsAlreadyExist,
                        _ => Self::UnknownValue(justification_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for JustificationType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "JUSTIFICATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "COMPONENT_NOT_PRESENT" => Self::ComponentNotPresent,
                        "VULNERABLE_CODE_NOT_PRESENT" => Self::VulnerableCodeNotPresent,
                        "VULNERABLE_CODE_NOT_IN_EXECUTE_PATH" => {
                            Self::VulnerableCodeNotInExecutePath
                        }
                        "VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY" => {
                            Self::VulnerableCodeCannotBeControlledByAdversary
                        }
                        "INLINE_MITIGATIONS_ALREADY_EXIST" => Self::InlineMitigationsAlreadyExist,
                        _ => Self::UnknownValue(justification_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for JustificationType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::ComponentNotPresent => serializer.serialize_i32(1),
                        Self::VulnerableCodeNotPresent => serializer.serialize_i32(2),
                        Self::VulnerableCodeNotInExecutePath => serializer.serialize_i32(3),
                        Self::VulnerableCodeCannotBeControlledByAdversary => {
                            serializer.serialize_i32(4)
                        }
                        Self::InlineMitigationsAlreadyExist => serializer.serialize_i32(5),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for JustificationType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<JustificationType>::new(
                        ".grafeas.v1.VulnerabilityAssessmentNote.Assessment.Justification.JustificationType"))
                }
            }
        }

        /// Specifies details on how to handle (and presumably, fix) a vulnerability.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Remediation {

            /// The type of remediation that can be applied.
            pub remediation_type: crate::model::vulnerability_assessment_note::assessment::remediation::RemediationType,

            /// Contains a comprehensive human-readable discussion of the remediation.
            pub details: std::string::String,

            /// Contains the URL where to obtain the remediation.
            pub remediation_uri: std::option::Option<crate::model::RelatedUrl>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Remediation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [remediation_type][crate::model::vulnerability_assessment_note::assessment::Remediation::remediation_type].
            pub fn set_remediation_type<T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::remediation::RemediationType>>(mut self, v: T) -> Self{
                self.remediation_type = v.into();
                self
            }

            /// Sets the value of [details][crate::model::vulnerability_assessment_note::assessment::Remediation::details].
            pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.details = v.into();
                self
            }

            /// Sets the value of [remediation_uri][crate::model::vulnerability_assessment_note::assessment::Remediation::remediation_uri].
            pub fn set_remediation_uri<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::RelatedUrl>,
            {
                self.remediation_uri = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [remediation_uri][crate::model::vulnerability_assessment_note::assessment::Remediation::remediation_uri].
            pub fn set_or_clear_remediation_uri<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::RelatedUrl>,
            {
                self.remediation_uri = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Remediation {
            fn typename() -> &'static str {
                "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Assessment.Remediation"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Remediation {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __remediation_type,
                    __details,
                    __remediation_uri,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Remediation")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "remediationType" => Ok(__FieldTag::__remediation_type),
                                    "remediation_type" => Ok(__FieldTag::__remediation_type),
                                    "details" => Ok(__FieldTag::__details),
                                    "remediationUri" => Ok(__FieldTag::__remediation_uri),
                                    "remediation_uri" => Ok(__FieldTag::__remediation_uri),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Remediation;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Remediation")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__remediation_type => {
                                    if !fields.insert(__FieldTag::__remediation_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for remediation_type",
                                            ),
                                        );
                                    }
                                    result.remediation_type = map.next_value::<std::option::Option<crate::model::vulnerability_assessment_note::assessment::remediation::RemediationType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__details => {
                                    if !fields.insert(__FieldTag::__details) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for details",
                                            ),
                                        );
                                    }
                                    result.details = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__remediation_uri => {
                                    if !fields.insert(__FieldTag::__remediation_uri) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for remediation_uri",
                                            ),
                                        );
                                    }
                                    result.remediation_uri = map.next_value::<std::option::Option<crate::model::RelatedUrl>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Remediation {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.remediation_type) {
                    state.serialize_entry("remediationType", &self.remediation_type)?;
                }
                if !self.details.is_empty() {
                    state.serialize_entry("details", &self.details)?;
                }
                if self.remediation_uri.is_some() {
                    state.serialize_entry("remediationUri", &self.remediation_uri)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Remediation].
        pub mod remediation {
            #[allow(unused_imports)]
            use super::*;

            /// The type of remediation that can be applied.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum RemediationType {
                /// No remediation type specified.
                Unspecified,
                /// A MITIGATION is available.
                Mitigation,
                /// No fix is planned.
                NoFixPlanned,
                /// Not available.
                NoneAvailable,
                /// A vendor fix is available.
                VendorFix,
                /// A workaround is available.
                Workaround,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [RemediationType::value] or
                /// [RemediationType::name].
                UnknownValue(remediation_type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod remediation_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl RemediationType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Mitigation => std::option::Option::Some(1),
                        Self::NoFixPlanned => std::option::Option::Some(2),
                        Self::NoneAvailable => std::option::Option::Some(3),
                        Self::VendorFix => std::option::Option::Some(4),
                        Self::Workaround => std::option::Option::Some(5),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("REMEDIATION_TYPE_UNSPECIFIED")
                        }
                        Self::Mitigation => std::option::Option::Some("MITIGATION"),
                        Self::NoFixPlanned => std::option::Option::Some("NO_FIX_PLANNED"),
                        Self::NoneAvailable => std::option::Option::Some("NONE_AVAILABLE"),
                        Self::VendorFix => std::option::Option::Some("VENDOR_FIX"),
                        Self::Workaround => std::option::Option::Some("WORKAROUND"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for RemediationType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for RemediationType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for RemediationType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Mitigation,
                        2 => Self::NoFixPlanned,
                        3 => Self::NoneAvailable,
                        4 => Self::VendorFix,
                        5 => Self::Workaround,
                        _ => Self::UnknownValue(remediation_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for RemediationType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "REMEDIATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "MITIGATION" => Self::Mitigation,
                        "NO_FIX_PLANNED" => Self::NoFixPlanned,
                        "NONE_AVAILABLE" => Self::NoneAvailable,
                        "VENDOR_FIX" => Self::VendorFix,
                        "WORKAROUND" => Self::Workaround,
                        _ => Self::UnknownValue(remediation_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for RemediationType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Mitigation => serializer.serialize_i32(1),
                        Self::NoFixPlanned => serializer.serialize_i32(2),
                        Self::NoneAvailable => serializer.serialize_i32(3),
                        Self::VendorFix => serializer.serialize_i32(4),
                        Self::Workaround => serializer.serialize_i32(5),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for RemediationType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<RemediationType>::new(
                        ".grafeas.v1.VulnerabilityAssessmentNote.Assessment.Remediation.RemediationType"))
                }
            }
        }

        /// Provides the state of this Vulnerability assessment.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// No state is specified.
            Unspecified,
            /// This product is known to be affected by this vulnerability.
            Affected,
            /// This product is known to be not affected by this vulnerability.
            NotAffected,
            /// This product contains a fix for this vulnerability.
            Fixed,
            /// It is not known yet whether these versions are or are not affected
            /// by the vulnerability. However, it is still under investigation.
            UnderInvestigation,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Affected => std::option::Option::Some(1),
                    Self::NotAffected => std::option::Option::Some(2),
                    Self::Fixed => std::option::Option::Some(3),
                    Self::UnderInvestigation => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Affected => std::option::Option::Some("AFFECTED"),
                    Self::NotAffected => std::option::Option::Some("NOT_AFFECTED"),
                    Self::Fixed => std::option::Option::Some("FIXED"),
                    Self::UnderInvestigation => std::option::Option::Some("UNDER_INVESTIGATION"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Affected,
                    2 => Self::NotAffected,
                    3 => Self::Fixed,
                    4 => Self::UnderInvestigation,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "AFFECTED" => Self::Affected,
                    "NOT_AFFECTED" => Self::NotAffected,
                    "FIXED" => Self::Fixed,
                    "UNDER_INVESTIGATION" => Self::UnderInvestigation,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Affected => serializer.serialize_i32(1),
                    Self::NotAffected => serializer.serialize_i32(2),
                    Self::Fixed => serializer.serialize_i32(3),
                    Self::UnderInvestigation => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".grafeas.v1.VulnerabilityAssessmentNote.Assessment.State",
                ))
            }
        }
    }
}

/// A security vulnerability that can be found in resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VulnerabilityNote {
    /// The CVSS score of this vulnerability. CVSS score is on a scale of 0 - 10
    /// where 0 indicates low severity and 10 indicates high severity.
    pub cvss_score: f32,

    /// The note provider assigned severity of this vulnerability.
    pub severity: crate::model::Severity,

    /// Details of all known distros and packages affected by this vulnerability.
    pub details: std::vec::Vec<crate::model::vulnerability_note::Detail>,

    /// The full description of the CVSSv3 for this vulnerability.
    pub cvss_v3: std::option::Option<crate::model::CVSSv3>,

    /// Windows details get their own format because the information format and
    /// model don't match a normal detail. Specifically Windows updates are done as
    /// patches, thus Windows vulnerabilities really are a missing package, rather
    /// than a package being at an incorrect version.
    pub windows_details: std::vec::Vec<crate::model::vulnerability_note::WindowsDetail>,

    /// The time this information was last changed at the source. This is an
    /// upstream timestamp from the underlying information source - e.g. Ubuntu
    /// security tracker.
    pub source_update_time: std::option::Option<wkt::Timestamp>,

    /// CVSS version used to populate cvss_score and severity.
    pub cvss_version: crate::model::CVSSVersion,

    /// The full description of the v2 CVSS for this vulnerability.
    pub cvss_v2: std::option::Option<crate::model::Cvss>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerabilityNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cvss_score][crate::model::VulnerabilityNote::cvss_score].
    pub fn set_cvss_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.cvss_score = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::VulnerabilityNote::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [details][crate::model::VulnerabilityNote::details].
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerability_note::Detail>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cvss_v3][crate::model::VulnerabilityNote::cvss_v3].
    pub fn set_cvss_v3<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CVSSv3>,
    {
        self.cvss_v3 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cvss_v3][crate::model::VulnerabilityNote::cvss_v3].
    pub fn set_or_clear_cvss_v3<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CVSSv3>,
    {
        self.cvss_v3 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [windows_details][crate::model::VulnerabilityNote::windows_details].
    pub fn set_windows_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerability_note::WindowsDetail>,
    {
        use std::iter::Iterator;
        self.windows_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_update_time][crate::model::VulnerabilityNote::source_update_time].
    pub fn set_source_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.source_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_update_time][crate::model::VulnerabilityNote::source_update_time].
    pub fn set_or_clear_source_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.source_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cvss_version][crate::model::VulnerabilityNote::cvss_version].
    pub fn set_cvss_version<T: std::convert::Into<crate::model::CVSSVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.cvss_version = v.into();
        self
    }

    /// Sets the value of [cvss_v2][crate::model::VulnerabilityNote::cvss_v2].
    pub fn set_cvss_v2<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cvss>,
    {
        self.cvss_v2 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cvss_v2][crate::model::VulnerabilityNote::cvss_v2].
    pub fn set_or_clear_cvss_v2<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cvss>,
    {
        self.cvss_v2 = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VulnerabilityNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.VulnerabilityNote"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VulnerabilityNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cvss_score,
            __severity,
            __details,
            __cvss_v3,
            __windows_details,
            __source_update_time,
            __cvss_version,
            __cvss_v2,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VulnerabilityNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cvssScore" => Ok(__FieldTag::__cvss_score),
                            "cvss_score" => Ok(__FieldTag::__cvss_score),
                            "severity" => Ok(__FieldTag::__severity),
                            "details" => Ok(__FieldTag::__details),
                            "cvssV3" => Ok(__FieldTag::__cvss_v3),
                            "cvss_v3" => Ok(__FieldTag::__cvss_v3),
                            "windowsDetails" => Ok(__FieldTag::__windows_details),
                            "windows_details" => Ok(__FieldTag::__windows_details),
                            "sourceUpdateTime" => Ok(__FieldTag::__source_update_time),
                            "source_update_time" => Ok(__FieldTag::__source_update_time),
                            "cvssVersion" => Ok(__FieldTag::__cvss_version),
                            "cvss_version" => Ok(__FieldTag::__cvss_version),
                            "cvssV2" => Ok(__FieldTag::__cvss_v2),
                            "cvss_v2" => Ok(__FieldTag::__cvss_v2),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VulnerabilityNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VulnerabilityNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cvss_score => {
                            if !fields.insert(__FieldTag::__cvss_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cvss_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<crate::model::Severity>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::vulnerability_note::Detail>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cvss_v3 => {
                            if !fields.insert(__FieldTag::__cvss_v3) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_v3",
                                ));
                            }
                            result.cvss_v3 =
                                map.next_value::<std::option::Option<crate::model::CVSSv3>>()?;
                        }
                        __FieldTag::__windows_details => {
                            if !fields.insert(__FieldTag::__windows_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_details",
                                ));
                            }
                            result.windows_details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::vulnerability_note::WindowsDetail>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_update_time => {
                            if !fields.insert(__FieldTag::__source_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_update_time",
                                ));
                            }
                            result.source_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cvss_version => {
                            if !fields.insert(__FieldTag::__cvss_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_version",
                                ));
                            }
                            result.cvss_version = map
                                .next_value::<std::option::Option<crate::model::CVSSVersion>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cvss_v2 => {
                            if !fields.insert(__FieldTag::__cvss_v2) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_v2",
                                ));
                            }
                            result.cvss_v2 =
                                map.next_value::<std::option::Option<crate::model::Cvss>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VulnerabilityNote {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cvss_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cvssScore", &__With(&self.cvss_score))?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.details.is_empty() {
            state.serialize_entry("details", &self.details)?;
        }
        if self.cvss_v3.is_some() {
            state.serialize_entry("cvssV3", &self.cvss_v3)?;
        }
        if !self.windows_details.is_empty() {
            state.serialize_entry("windowsDetails", &self.windows_details)?;
        }
        if self.source_update_time.is_some() {
            state.serialize_entry("sourceUpdateTime", &self.source_update_time)?;
        }
        if !wkt::internal::is_default(&self.cvss_version) {
            state.serialize_entry("cvssVersion", &self.cvss_version)?;
        }
        if self.cvss_v2.is_some() {
            state.serialize_entry("cvssV2", &self.cvss_v2)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VulnerabilityNote].
pub mod vulnerability_note {
    #[allow(unused_imports)]
    use super::*;

    /// A detail for a distro and package affected by this vulnerability and its
    /// associated fix (if one is available).
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Detail {
        /// The distro assigned severity of this vulnerability.
        pub severity_name: std::string::String,

        /// A vendor-specific description of this vulnerability.
        pub description: std::string::String,

        /// The type of package; whether native or non native (e.g., ruby gems,
        /// node.js packages, etc.).
        pub package_type: std::string::String,

        /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
        /// vulnerability affects.
        pub affected_cpe_uri: std::string::String,

        /// Required. The package this vulnerability affects.
        pub affected_package: std::string::String,

        /// The version number at the start of an interval in which this
        /// vulnerability exists. A vulnerability can affect a package between
        /// version numbers that are disjoint sets of intervals (example:
        /// [1.0.0-1.1.0], [2.4.6-2.4.8] and [4.5.6-4.6.8]) each of which will be
        /// represented in its own Detail. If a specific affected version is provided
        /// by a vulnerability database, affected_version_start and
        /// affected_version_end will be the same in that Detail.
        pub affected_version_start: std::option::Option<crate::model::Version>,

        /// The version number at the end of an interval in which this vulnerability
        /// exists. A vulnerability can affect a package between version numbers
        /// that are disjoint sets of intervals (example: [1.0.0-1.1.0],
        /// [2.4.6-2.4.8] and [4.5.6-4.6.8]) each of which will be represented in its
        /// own Detail. If a specific affected version is provided by a vulnerability
        /// database, affected_version_start and affected_version_end will be the
        /// same in that Detail.
        pub affected_version_end: std::option::Option<crate::model::Version>,

        /// The distro recommended [CPE URI](https://cpe.mitre.org/specification/)
        /// to update to that contains a fix for this vulnerability. It is possible
        /// for this to be different from the affected_cpe_uri.
        pub fixed_cpe_uri: std::string::String,

        /// The distro recommended package to update to that contains a fix for this
        /// vulnerability. It is possible for this to be different from the
        /// affected_package.
        pub fixed_package: std::string::String,

        /// The distro recommended version to update to that contains a
        /// fix for this vulnerability. Setting this to VersionKind.MAXIMUM means no
        /// such version is yet available.
        pub fixed_version: std::option::Option<crate::model::Version>,

        /// Whether this detail is obsolete. Occurrences are expected not to point to
        /// obsolete details.
        pub is_obsolete: bool,

        /// The time this information was last changed at the source. This is an
        /// upstream timestamp from the underlying information source - e.g. Ubuntu
        /// security tracker.
        pub source_update_time: std::option::Option<wkt::Timestamp>,

        /// The source from which the information in this Detail was obtained.
        pub source: std::string::String,

        /// The name of the vendor of the product.
        pub vendor: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Detail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [severity_name][crate::model::vulnerability_note::Detail::severity_name].
        pub fn set_severity_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.severity_name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::vulnerability_note::Detail::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [package_type][crate::model::vulnerability_note::Detail::package_type].
        pub fn set_package_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.package_type = v.into();
            self
        }

        /// Sets the value of [affected_cpe_uri][crate::model::vulnerability_note::Detail::affected_cpe_uri].
        pub fn set_affected_cpe_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.affected_cpe_uri = v.into();
            self
        }

        /// Sets the value of [affected_package][crate::model::vulnerability_note::Detail::affected_package].
        pub fn set_affected_package<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.affected_package = v.into();
            self
        }

        /// Sets the value of [affected_version_start][crate::model::vulnerability_note::Detail::affected_version_start].
        pub fn set_affected_version_start<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.affected_version_start = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [affected_version_start][crate::model::vulnerability_note::Detail::affected_version_start].
        pub fn set_or_clear_affected_version_start<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.affected_version_start = v.map(|x| x.into());
            self
        }

        /// Sets the value of [affected_version_end][crate::model::vulnerability_note::Detail::affected_version_end].
        pub fn set_affected_version_end<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.affected_version_end = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [affected_version_end][crate::model::vulnerability_note::Detail::affected_version_end].
        pub fn set_or_clear_affected_version_end<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.affected_version_end = v.map(|x| x.into());
            self
        }

        /// Sets the value of [fixed_cpe_uri][crate::model::vulnerability_note::Detail::fixed_cpe_uri].
        pub fn set_fixed_cpe_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.fixed_cpe_uri = v.into();
            self
        }

        /// Sets the value of [fixed_package][crate::model::vulnerability_note::Detail::fixed_package].
        pub fn set_fixed_package<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.fixed_package = v.into();
            self
        }

        /// Sets the value of [fixed_version][crate::model::vulnerability_note::Detail::fixed_version].
        pub fn set_fixed_version<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.fixed_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [fixed_version][crate::model::vulnerability_note::Detail::fixed_version].
        pub fn set_or_clear_fixed_version<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.fixed_version = v.map(|x| x.into());
            self
        }

        /// Sets the value of [is_obsolete][crate::model::vulnerability_note::Detail::is_obsolete].
        pub fn set_is_obsolete<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.is_obsolete = v.into();
            self
        }

        /// Sets the value of [source_update_time][crate::model::vulnerability_note::Detail::source_update_time].
        pub fn set_source_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.source_update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [source_update_time][crate::model::vulnerability_note::Detail::source_update_time].
        pub fn set_or_clear_source_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.source_update_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [source][crate::model::vulnerability_note::Detail::source].
        pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source = v.into();
            self
        }

        /// Sets the value of [vendor][crate::model::vulnerability_note::Detail::vendor].
        pub fn set_vendor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.vendor = v.into();
            self
        }
    }

    impl wkt::message::Message for Detail {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityNote.Detail"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Detail {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __severity_name,
                __description,
                __package_type,
                __affected_cpe_uri,
                __affected_package,
                __affected_version_start,
                __affected_version_end,
                __fixed_cpe_uri,
                __fixed_package,
                __fixed_version,
                __is_obsolete,
                __source_update_time,
                __source,
                __vendor,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Detail")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "severityName" => Ok(__FieldTag::__severity_name),
                                "severity_name" => Ok(__FieldTag::__severity_name),
                                "description" => Ok(__FieldTag::__description),
                                "packageType" => Ok(__FieldTag::__package_type),
                                "package_type" => Ok(__FieldTag::__package_type),
                                "affectedCpeUri" => Ok(__FieldTag::__affected_cpe_uri),
                                "affected_cpe_uri" => Ok(__FieldTag::__affected_cpe_uri),
                                "affectedPackage" => Ok(__FieldTag::__affected_package),
                                "affected_package" => Ok(__FieldTag::__affected_package),
                                "affectedVersionStart" => Ok(__FieldTag::__affected_version_start),
                                "affected_version_start" => {
                                    Ok(__FieldTag::__affected_version_start)
                                }
                                "affectedVersionEnd" => Ok(__FieldTag::__affected_version_end),
                                "affected_version_end" => Ok(__FieldTag::__affected_version_end),
                                "fixedCpeUri" => Ok(__FieldTag::__fixed_cpe_uri),
                                "fixed_cpe_uri" => Ok(__FieldTag::__fixed_cpe_uri),
                                "fixedPackage" => Ok(__FieldTag::__fixed_package),
                                "fixed_package" => Ok(__FieldTag::__fixed_package),
                                "fixedVersion" => Ok(__FieldTag::__fixed_version),
                                "fixed_version" => Ok(__FieldTag::__fixed_version),
                                "isObsolete" => Ok(__FieldTag::__is_obsolete),
                                "is_obsolete" => Ok(__FieldTag::__is_obsolete),
                                "sourceUpdateTime" => Ok(__FieldTag::__source_update_time),
                                "source_update_time" => Ok(__FieldTag::__source_update_time),
                                "source" => Ok(__FieldTag::__source),
                                "vendor" => Ok(__FieldTag::__vendor),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Detail;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Detail")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__severity_name => {
                                if !fields.insert(__FieldTag::__severity_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for severity_name",
                                    ));
                                }
                                result.severity_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__package_type => {
                                if !fields.insert(__FieldTag::__package_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for package_type",
                                    ));
                                }
                                result.package_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__affected_cpe_uri => {
                                if !fields.insert(__FieldTag::__affected_cpe_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for affected_cpe_uri",
                                    ));
                                }
                                result.affected_cpe_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__affected_package => {
                                if !fields.insert(__FieldTag::__affected_package) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for affected_package",
                                    ));
                                }
                                result.affected_package = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__affected_version_start => {
                                if !fields.insert(__FieldTag::__affected_version_start) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for affected_version_start",
                                    ));
                                }
                                result.affected_version_start =
                                    map.next_value::<std::option::Option<crate::model::Version>>()?;
                            }
                            __FieldTag::__affected_version_end => {
                                if !fields.insert(__FieldTag::__affected_version_end) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for affected_version_end",
                                    ));
                                }
                                result.affected_version_end =
                                    map.next_value::<std::option::Option<crate::model::Version>>()?;
                            }
                            __FieldTag::__fixed_cpe_uri => {
                                if !fields.insert(__FieldTag::__fixed_cpe_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fixed_cpe_uri",
                                    ));
                                }
                                result.fixed_cpe_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__fixed_package => {
                                if !fields.insert(__FieldTag::__fixed_package) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fixed_package",
                                    ));
                                }
                                result.fixed_package = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__fixed_version => {
                                if !fields.insert(__FieldTag::__fixed_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fixed_version",
                                    ));
                                }
                                result.fixed_version =
                                    map.next_value::<std::option::Option<crate::model::Version>>()?;
                            }
                            __FieldTag::__is_obsolete => {
                                if !fields.insert(__FieldTag::__is_obsolete) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for is_obsolete",
                                    ));
                                }
                                result.is_obsolete = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__source_update_time => {
                                if !fields.insert(__FieldTag::__source_update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_update_time",
                                    ));
                                }
                                result.source_update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__source => {
                                if !fields.insert(__FieldTag::__source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source",
                                    ));
                                }
                                result.source = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__vendor => {
                                if !fields.insert(__FieldTag::__vendor) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vendor",
                                    ));
                                }
                                result.vendor = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Detail {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.severity_name.is_empty() {
                state.serialize_entry("severityName", &self.severity_name)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !self.package_type.is_empty() {
                state.serialize_entry("packageType", &self.package_type)?;
            }
            if !self.affected_cpe_uri.is_empty() {
                state.serialize_entry("affectedCpeUri", &self.affected_cpe_uri)?;
            }
            if !self.affected_package.is_empty() {
                state.serialize_entry("affectedPackage", &self.affected_package)?;
            }
            if self.affected_version_start.is_some() {
                state.serialize_entry("affectedVersionStart", &self.affected_version_start)?;
            }
            if self.affected_version_end.is_some() {
                state.serialize_entry("affectedVersionEnd", &self.affected_version_end)?;
            }
            if !self.fixed_cpe_uri.is_empty() {
                state.serialize_entry("fixedCpeUri", &self.fixed_cpe_uri)?;
            }
            if !self.fixed_package.is_empty() {
                state.serialize_entry("fixedPackage", &self.fixed_package)?;
            }
            if self.fixed_version.is_some() {
                state.serialize_entry("fixedVersion", &self.fixed_version)?;
            }
            if !wkt::internal::is_default(&self.is_obsolete) {
                state.serialize_entry("isObsolete", &self.is_obsolete)?;
            }
            if self.source_update_time.is_some() {
                state.serialize_entry("sourceUpdateTime", &self.source_update_time)?;
            }
            if !self.source.is_empty() {
                state.serialize_entry("source", &self.source)?;
            }
            if !self.vendor.is_empty() {
                state.serialize_entry("vendor", &self.vendor)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WindowsDetail {
        /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
        /// vulnerability affects.
        pub cpe_uri: std::string::String,

        /// Required. The name of this vulnerability.
        pub name: std::string::String,

        /// The description of this vulnerability.
        pub description: std::string::String,

        /// Required. The names of the KBs which have hotfixes to mitigate this
        /// vulnerability. Note that there may be multiple hotfixes (and thus
        /// multiple KBs) that mitigate a given vulnerability. Currently any listed
        /// KBs presence is considered a fix.
        pub fixing_kbs:
            std::vec::Vec<crate::model::vulnerability_note::windows_detail::KnowledgeBase>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WindowsDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpe_uri][crate::model::vulnerability_note::WindowsDetail::cpe_uri].
        pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cpe_uri = v.into();
            self
        }

        /// Sets the value of [name][crate::model::vulnerability_note::WindowsDetail::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::vulnerability_note::WindowsDetail::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [fixing_kbs][crate::model::vulnerability_note::WindowsDetail::fixing_kbs].
        pub fn set_fixing_kbs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::vulnerability_note::windows_detail::KnowledgeBase>,
        {
            use std::iter::Iterator;
            self.fixing_kbs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for WindowsDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityNote.WindowsDetail"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WindowsDetail {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cpe_uri,
                __name,
                __description,
                __fixing_kbs,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WindowsDetail")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cpeUri" => Ok(__FieldTag::__cpe_uri),
                                "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                                "name" => Ok(__FieldTag::__name),
                                "description" => Ok(__FieldTag::__description),
                                "fixingKbs" => Ok(__FieldTag::__fixing_kbs),
                                "fixing_kbs" => Ok(__FieldTag::__fixing_kbs),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WindowsDetail;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WindowsDetail")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cpe_uri => {
                                if !fields.insert(__FieldTag::__cpe_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cpe_uri",
                                    ));
                                }
                                result.cpe_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__fixing_kbs => {
                                if !fields.insert(__FieldTag::__fixing_kbs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fixing_kbs",
                                    ));
                                }
                                result.fixing_kbs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::vulnerability_note::windows_detail::KnowledgeBase>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WindowsDetail {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.cpe_uri.is_empty() {
                state.serialize_entry("cpeUri", &self.cpe_uri)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !self.fixing_kbs.is_empty() {
                state.serialize_entry("fixingKbs", &self.fixing_kbs)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [WindowsDetail].
    pub mod windows_detail {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct KnowledgeBase {
            /// The KB name (generally of the form KB[0-9]+ (e.g., KB123456)).
            pub name: std::string::String,

            /// A link to the KB in the [Windows update catalog]
            /// (<https://www.catalog.update.microsoft.com/>).
            pub url: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl KnowledgeBase {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::vulnerability_note::windows_detail::KnowledgeBase::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of [url][crate::model::vulnerability_note::windows_detail::KnowledgeBase::url].
            pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.url = v.into();
                self
            }
        }

        impl wkt::message::Message for KnowledgeBase {
            fn typename() -> &'static str {
                "type.googleapis.com/grafeas.v1.VulnerabilityNote.WindowsDetail.KnowledgeBase"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for KnowledgeBase {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __name,
                    __url,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for KnowledgeBase")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "name" => Ok(__FieldTag::__name),
                                    "url" => Ok(__FieldTag::__url),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = KnowledgeBase;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct KnowledgeBase")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__name => {
                                    if !fields.insert(__FieldTag::__name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for name"),
                                        );
                                    }
                                    result.name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__url => {
                                    if !fields.insert(__FieldTag::__url) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for url"),
                                        );
                                    }
                                    result.url = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for KnowledgeBase {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.name.is_empty() {
                    state.serialize_entry("name", &self.name)?;
                }
                if !self.url.is_empty() {
                    state.serialize_entry("url", &self.url)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }
}

/// An occurrence of a severity vulnerability on a resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VulnerabilityOccurrence {
    /// The type of package; whether native or non native (e.g., ruby gems, node.js
    /// packages, etc.).
    pub r#type: std::string::String,

    /// Output only. The note provider assigned severity of this vulnerability.
    pub severity: crate::model::Severity,

    /// Output only. The CVSS score of this vulnerability. CVSS score is on a
    /// scale of 0 - 10 where 0 indicates low severity and 10 indicates high
    /// severity.
    pub cvss_score: f32,

    /// The cvss v3 score for the vulnerability.
    pub cvssv3: std::option::Option<crate::model::Cvss>,

    /// Required. The set of affected locations and their fixes (if available)
    /// within the associated resource.
    pub package_issue: std::vec::Vec<crate::model::vulnerability_occurrence::PackageIssue>,

    /// Output only. A one sentence description of this vulnerability.
    pub short_description: std::string::String,

    /// Output only. A detailed description of this vulnerability.
    pub long_description: std::string::String,

    /// Output only. URLs related to this vulnerability.
    pub related_urls: std::vec::Vec<crate::model::RelatedUrl>,

    /// The distro assigned severity for this vulnerability when it is available,
    /// otherwise this is the note provider assigned severity.
    ///
    /// When there are multiple PackageIssues for this vulnerability, they can have
    /// different effective severities because some might be provided by the distro
    /// while others are provided by the language ecosystem for a language pack.
    /// For this reason, it is advised to use the effective severity on the
    /// PackageIssue level. In the case where multiple PackageIssues have differing
    /// effective severities, this field should be the highest severity for any of
    /// the PackageIssues.
    pub effective_severity: crate::model::Severity,

    /// Output only. Whether at least one of the affected packages has a fix
    /// available.
    pub fix_available: bool,

    /// Output only. CVSS version used to populate cvss_score and severity.
    pub cvss_version: crate::model::CVSSVersion,

    /// The cvss v2 score for the vulnerability.
    pub cvss_v2: std::option::Option<crate::model::Cvss>,

    pub vex_assessment: std::option::Option<crate::model::vulnerability_occurrence::VexAssessment>,

    /// Occurrence-specific extra details about the vulnerability.
    pub extra_details: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerabilityOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::VulnerabilityOccurrence::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::VulnerabilityOccurrence::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [cvss_score][crate::model::VulnerabilityOccurrence::cvss_score].
    pub fn set_cvss_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.cvss_score = v.into();
        self
    }

    /// Sets the value of [cvssv3][crate::model::VulnerabilityOccurrence::cvssv3].
    pub fn set_cvssv3<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cvss>,
    {
        self.cvssv3 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cvssv3][crate::model::VulnerabilityOccurrence::cvssv3].
    pub fn set_or_clear_cvssv3<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cvss>,
    {
        self.cvssv3 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [package_issue][crate::model::VulnerabilityOccurrence::package_issue].
    pub fn set_package_issue<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerability_occurrence::PackageIssue>,
    {
        use std::iter::Iterator;
        self.package_issue = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [short_description][crate::model::VulnerabilityOccurrence::short_description].
    pub fn set_short_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.short_description = v.into();
        self
    }

    /// Sets the value of [long_description][crate::model::VulnerabilityOccurrence::long_description].
    pub fn set_long_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.long_description = v.into();
        self
    }

    /// Sets the value of [related_urls][crate::model::VulnerabilityOccurrence::related_urls].
    pub fn set_related_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedUrl>,
    {
        use std::iter::Iterator;
        self.related_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [effective_severity][crate::model::VulnerabilityOccurrence::effective_severity].
    pub fn set_effective_severity<T: std::convert::Into<crate::model::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.effective_severity = v.into();
        self
    }

    /// Sets the value of [fix_available][crate::model::VulnerabilityOccurrence::fix_available].
    pub fn set_fix_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.fix_available = v.into();
        self
    }

    /// Sets the value of [cvss_version][crate::model::VulnerabilityOccurrence::cvss_version].
    pub fn set_cvss_version<T: std::convert::Into<crate::model::CVSSVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.cvss_version = v.into();
        self
    }

    /// Sets the value of [cvss_v2][crate::model::VulnerabilityOccurrence::cvss_v2].
    pub fn set_cvss_v2<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cvss>,
    {
        self.cvss_v2 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cvss_v2][crate::model::VulnerabilityOccurrence::cvss_v2].
    pub fn set_or_clear_cvss_v2<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cvss>,
    {
        self.cvss_v2 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vex_assessment][crate::model::VulnerabilityOccurrence::vex_assessment].
    pub fn set_vex_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_occurrence::VexAssessment>,
    {
        self.vex_assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vex_assessment][crate::model::VulnerabilityOccurrence::vex_assessment].
    pub fn set_or_clear_vex_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_occurrence::VexAssessment>,
    {
        self.vex_assessment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [extra_details][crate::model::VulnerabilityOccurrence::extra_details].
    pub fn set_extra_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.extra_details = v.into();
        self
    }
}

impl wkt::message::Message for VulnerabilityOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.VulnerabilityOccurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VulnerabilityOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __severity,
            __cvss_score,
            __cvssv3,
            __package_issue,
            __short_description,
            __long_description,
            __related_urls,
            __effective_severity,
            __fix_available,
            __cvss_version,
            __cvss_v2,
            __vex_assessment,
            __extra_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VulnerabilityOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "severity" => Ok(__FieldTag::__severity),
                            "cvssScore" => Ok(__FieldTag::__cvss_score),
                            "cvss_score" => Ok(__FieldTag::__cvss_score),
                            "cvssv3" => Ok(__FieldTag::__cvssv3),
                            "packageIssue" => Ok(__FieldTag::__package_issue),
                            "package_issue" => Ok(__FieldTag::__package_issue),
                            "shortDescription" => Ok(__FieldTag::__short_description),
                            "short_description" => Ok(__FieldTag::__short_description),
                            "longDescription" => Ok(__FieldTag::__long_description),
                            "long_description" => Ok(__FieldTag::__long_description),
                            "relatedUrls" => Ok(__FieldTag::__related_urls),
                            "related_urls" => Ok(__FieldTag::__related_urls),
                            "effectiveSeverity" => Ok(__FieldTag::__effective_severity),
                            "effective_severity" => Ok(__FieldTag::__effective_severity),
                            "fixAvailable" => Ok(__FieldTag::__fix_available),
                            "fix_available" => Ok(__FieldTag::__fix_available),
                            "cvssVersion" => Ok(__FieldTag::__cvss_version),
                            "cvss_version" => Ok(__FieldTag::__cvss_version),
                            "cvssV2" => Ok(__FieldTag::__cvss_v2),
                            "cvss_v2" => Ok(__FieldTag::__cvss_v2),
                            "vexAssessment" => Ok(__FieldTag::__vex_assessment),
                            "vex_assessment" => Ok(__FieldTag::__vex_assessment),
                            "extraDetails" => Ok(__FieldTag::__extra_details),
                            "extra_details" => Ok(__FieldTag::__extra_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VulnerabilityOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VulnerabilityOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<crate::model::Severity>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cvss_score => {
                            if !fields.insert(__FieldTag::__cvss_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cvss_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cvssv3 => {
                            if !fields.insert(__FieldTag::__cvssv3) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvssv3",
                                ));
                            }
                            result.cvssv3 =
                                map.next_value::<std::option::Option<crate::model::Cvss>>()?;
                        }
                        __FieldTag::__package_issue => {
                            if !fields.insert(__FieldTag::__package_issue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_issue",
                                ));
                            }
                            result.package_issue = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::vulnerability_occurrence::PackageIssue,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__short_description => {
                            if !fields.insert(__FieldTag::__short_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for short_description",
                                ));
                            }
                            result.short_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__long_description => {
                            if !fields.insert(__FieldTag::__long_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for long_description",
                                ));
                            }
                            result.long_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__related_urls => {
                            if !fields.insert(__FieldTag::__related_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_urls",
                                ));
                            }
                            result.related_urls = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RelatedUrl>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__effective_severity => {
                            if !fields.insert(__FieldTag::__effective_severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effective_severity",
                                ));
                            }
                            result.effective_severity = map
                                .next_value::<std::option::Option<crate::model::Severity>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fix_available => {
                            if !fields.insert(__FieldTag::__fix_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fix_available",
                                ));
                            }
                            result.fix_available = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cvss_version => {
                            if !fields.insert(__FieldTag::__cvss_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_version",
                                ));
                            }
                            result.cvss_version = map
                                .next_value::<std::option::Option<crate::model::CVSSVersion>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cvss_v2 => {
                            if !fields.insert(__FieldTag::__cvss_v2) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_v2",
                                ));
                            }
                            result.cvss_v2 =
                                map.next_value::<std::option::Option<crate::model::Cvss>>()?;
                        }
                        __FieldTag::__vex_assessment => {
                            if !fields.insert(__FieldTag::__vex_assessment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vex_assessment",
                                ));
                            }
                            result.vex_assessment = map.next_value::<std::option::Option<
                                crate::model::vulnerability_occurrence::VexAssessment,
                            >>()?;
                        }
                        __FieldTag::__extra_details => {
                            if !fields.insert(__FieldTag::__extra_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extra_details",
                                ));
                            }
                            result.extra_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VulnerabilityOccurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !wkt::internal::is_default(&self.cvss_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cvssScore", &__With(&self.cvss_score))?;
        }
        if self.cvssv3.is_some() {
            state.serialize_entry("cvssv3", &self.cvssv3)?;
        }
        if !self.package_issue.is_empty() {
            state.serialize_entry("packageIssue", &self.package_issue)?;
        }
        if !self.short_description.is_empty() {
            state.serialize_entry("shortDescription", &self.short_description)?;
        }
        if !self.long_description.is_empty() {
            state.serialize_entry("longDescription", &self.long_description)?;
        }
        if !self.related_urls.is_empty() {
            state.serialize_entry("relatedUrls", &self.related_urls)?;
        }
        if !wkt::internal::is_default(&self.effective_severity) {
            state.serialize_entry("effectiveSeverity", &self.effective_severity)?;
        }
        if !wkt::internal::is_default(&self.fix_available) {
            state.serialize_entry("fixAvailable", &self.fix_available)?;
        }
        if !wkt::internal::is_default(&self.cvss_version) {
            state.serialize_entry("cvssVersion", &self.cvss_version)?;
        }
        if self.cvss_v2.is_some() {
            state.serialize_entry("cvssV2", &self.cvss_v2)?;
        }
        if self.vex_assessment.is_some() {
            state.serialize_entry("vexAssessment", &self.vex_assessment)?;
        }
        if !self.extra_details.is_empty() {
            state.serialize_entry("extraDetails", &self.extra_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VulnerabilityOccurrence].
pub mod vulnerability_occurrence {
    #[allow(unused_imports)]
    use super::*;

    /// A detail for a distro and package this vulnerability occurrence was found
    /// in and its associated fix (if one is available).
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PackageIssue {
        /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
        /// vulnerability was found in.
        pub affected_cpe_uri: std::string::String,

        /// Required. The package this vulnerability was found in.
        pub affected_package: std::string::String,

        /// Required. The version of the package that is installed on the resource
        /// affected by this vulnerability.
        pub affected_version: std::option::Option<crate::model::Version>,

        /// The [CPE URI](https://cpe.mitre.org/specification/) this vulnerability
        /// was fixed in. It is possible for this to be different from the
        /// affected_cpe_uri.
        pub fixed_cpe_uri: std::string::String,

        /// The package this vulnerability was fixed in. It is possible for this to
        /// be different from the affected_package.
        pub fixed_package: std::string::String,

        /// Required. The version of the package this vulnerability was fixed in.
        /// Setting this to VersionKind.MAXIMUM means no fix is yet available.
        pub fixed_version: std::option::Option<crate::model::Version>,

        /// Output only. Whether a fix is available for this package.
        pub fix_available: bool,

        /// The type of package (e.g. OS, MAVEN, GO).
        pub package_type: std::string::String,

        /// The distro or language system assigned severity for this vulnerability
        /// when that is available and note provider assigned severity when it is not
        /// available.
        pub effective_severity: crate::model::Severity,

        /// The location at which this package was found.
        pub file_location: std::vec::Vec<crate::model::FileLocation>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PackageIssue {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [affected_cpe_uri][crate::model::vulnerability_occurrence::PackageIssue::affected_cpe_uri].
        pub fn set_affected_cpe_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.affected_cpe_uri = v.into();
            self
        }

        /// Sets the value of [affected_package][crate::model::vulnerability_occurrence::PackageIssue::affected_package].
        pub fn set_affected_package<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.affected_package = v.into();
            self
        }

        /// Sets the value of [affected_version][crate::model::vulnerability_occurrence::PackageIssue::affected_version].
        pub fn set_affected_version<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.affected_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [affected_version][crate::model::vulnerability_occurrence::PackageIssue::affected_version].
        pub fn set_or_clear_affected_version<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.affected_version = v.map(|x| x.into());
            self
        }

        /// Sets the value of [fixed_cpe_uri][crate::model::vulnerability_occurrence::PackageIssue::fixed_cpe_uri].
        pub fn set_fixed_cpe_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.fixed_cpe_uri = v.into();
            self
        }

        /// Sets the value of [fixed_package][crate::model::vulnerability_occurrence::PackageIssue::fixed_package].
        pub fn set_fixed_package<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.fixed_package = v.into();
            self
        }

        /// Sets the value of [fixed_version][crate::model::vulnerability_occurrence::PackageIssue::fixed_version].
        pub fn set_fixed_version<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.fixed_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [fixed_version][crate::model::vulnerability_occurrence::PackageIssue::fixed_version].
        pub fn set_or_clear_fixed_version<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.fixed_version = v.map(|x| x.into());
            self
        }

        /// Sets the value of [fix_available][crate::model::vulnerability_occurrence::PackageIssue::fix_available].
        pub fn set_fix_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.fix_available = v.into();
            self
        }

        /// Sets the value of [package_type][crate::model::vulnerability_occurrence::PackageIssue::package_type].
        pub fn set_package_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.package_type = v.into();
            self
        }

        /// Sets the value of [effective_severity][crate::model::vulnerability_occurrence::PackageIssue::effective_severity].
        pub fn set_effective_severity<T: std::convert::Into<crate::model::Severity>>(
            mut self,
            v: T,
        ) -> Self {
            self.effective_severity = v.into();
            self
        }

        /// Sets the value of [file_location][crate::model::vulnerability_occurrence::PackageIssue::file_location].
        pub fn set_file_location<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FileLocation>,
        {
            use std::iter::Iterator;
            self.file_location = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PackageIssue {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityOccurrence.PackageIssue"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PackageIssue {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __affected_cpe_uri,
                __affected_package,
                __affected_version,
                __fixed_cpe_uri,
                __fixed_package,
                __fixed_version,
                __fix_available,
                __package_type,
                __effective_severity,
                __file_location,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PackageIssue")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "affectedCpeUri" => Ok(__FieldTag::__affected_cpe_uri),
                                "affected_cpe_uri" => Ok(__FieldTag::__affected_cpe_uri),
                                "affectedPackage" => Ok(__FieldTag::__affected_package),
                                "affected_package" => Ok(__FieldTag::__affected_package),
                                "affectedVersion" => Ok(__FieldTag::__affected_version),
                                "affected_version" => Ok(__FieldTag::__affected_version),
                                "fixedCpeUri" => Ok(__FieldTag::__fixed_cpe_uri),
                                "fixed_cpe_uri" => Ok(__FieldTag::__fixed_cpe_uri),
                                "fixedPackage" => Ok(__FieldTag::__fixed_package),
                                "fixed_package" => Ok(__FieldTag::__fixed_package),
                                "fixedVersion" => Ok(__FieldTag::__fixed_version),
                                "fixed_version" => Ok(__FieldTag::__fixed_version),
                                "fixAvailable" => Ok(__FieldTag::__fix_available),
                                "fix_available" => Ok(__FieldTag::__fix_available),
                                "packageType" => Ok(__FieldTag::__package_type),
                                "package_type" => Ok(__FieldTag::__package_type),
                                "effectiveSeverity" => Ok(__FieldTag::__effective_severity),
                                "effective_severity" => Ok(__FieldTag::__effective_severity),
                                "fileLocation" => Ok(__FieldTag::__file_location),
                                "file_location" => Ok(__FieldTag::__file_location),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PackageIssue;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PackageIssue")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__affected_cpe_uri => {
                                if !fields.insert(__FieldTag::__affected_cpe_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for affected_cpe_uri",
                                    ));
                                }
                                result.affected_cpe_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__affected_package => {
                                if !fields.insert(__FieldTag::__affected_package) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for affected_package",
                                    ));
                                }
                                result.affected_package = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__affected_version => {
                                if !fields.insert(__FieldTag::__affected_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for affected_version",
                                    ));
                                }
                                result.affected_version =
                                    map.next_value::<std::option::Option<crate::model::Version>>()?;
                            }
                            __FieldTag::__fixed_cpe_uri => {
                                if !fields.insert(__FieldTag::__fixed_cpe_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fixed_cpe_uri",
                                    ));
                                }
                                result.fixed_cpe_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__fixed_package => {
                                if !fields.insert(__FieldTag::__fixed_package) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fixed_package",
                                    ));
                                }
                                result.fixed_package = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__fixed_version => {
                                if !fields.insert(__FieldTag::__fixed_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fixed_version",
                                    ));
                                }
                                result.fixed_version =
                                    map.next_value::<std::option::Option<crate::model::Version>>()?;
                            }
                            __FieldTag::__fix_available => {
                                if !fields.insert(__FieldTag::__fix_available) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fix_available",
                                    ));
                                }
                                result.fix_available = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__package_type => {
                                if !fields.insert(__FieldTag::__package_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for package_type",
                                    ));
                                }
                                result.package_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__effective_severity => {
                                if !fields.insert(__FieldTag::__effective_severity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for effective_severity",
                                    ));
                                }
                                result.effective_severity = map
                                    .next_value::<std::option::Option<crate::model::Severity>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__file_location => {
                                if !fields.insert(__FieldTag::__file_location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for file_location",
                                    ));
                                }
                                result.file_location =
                                    map.next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::FileLocation>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PackageIssue {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.affected_cpe_uri.is_empty() {
                state.serialize_entry("affectedCpeUri", &self.affected_cpe_uri)?;
            }
            if !self.affected_package.is_empty() {
                state.serialize_entry("affectedPackage", &self.affected_package)?;
            }
            if self.affected_version.is_some() {
                state.serialize_entry("affectedVersion", &self.affected_version)?;
            }
            if !self.fixed_cpe_uri.is_empty() {
                state.serialize_entry("fixedCpeUri", &self.fixed_cpe_uri)?;
            }
            if !self.fixed_package.is_empty() {
                state.serialize_entry("fixedPackage", &self.fixed_package)?;
            }
            if self.fixed_version.is_some() {
                state.serialize_entry("fixedVersion", &self.fixed_version)?;
            }
            if !wkt::internal::is_default(&self.fix_available) {
                state.serialize_entry("fixAvailable", &self.fix_available)?;
            }
            if !self.package_type.is_empty() {
                state.serialize_entry("packageType", &self.package_type)?;
            }
            if !wkt::internal::is_default(&self.effective_severity) {
                state.serialize_entry("effectiveSeverity", &self.effective_severity)?;
            }
            if !self.file_location.is_empty() {
                state.serialize_entry("fileLocation", &self.file_location)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// VexAssessment provides all publisher provided Vex information that is
    /// related to this vulnerability.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VexAssessment {
        /// Holds the MITRE standard Common Vulnerabilities and Exposures (CVE)
        /// tracking number for the vulnerability.
        /// Deprecated: Use vulnerability_id instead to denote CVEs.
        #[deprecated]
        pub cve: std::string::String,

        /// The vulnerability identifier for this Assessment. Will hold one of
        /// common identifiers e.g. CVE, GHSA etc.
        pub vulnerability_id: std::string::String,

        /// Holds a list of references associated with this vulnerability item and
        /// assessment.
        pub related_uris: std::vec::Vec<crate::model::RelatedUrl>,

        /// The VulnerabilityAssessment note from which this VexAssessment was
        /// generated.
        /// This will be of the form: `projects/[PROJECT_ID]/notes/[NOTE_ID]`.
        /// (-- api-linter: core::0122::name-suffix=disabled
        /// aip.dev/not-precedent: The suffix is kept for consistency. --)
        pub note_name: std::string::String,

        /// Provides the state of this Vulnerability assessment.
        pub state: crate::model::vulnerability_assessment_note::assessment::State,

        /// Contains information about the impact of this vulnerability,
        /// this will change with time.
        pub impacts: std::vec::Vec<std::string::String>,

        /// Specifies details on how to handle (and presumably, fix) a vulnerability.
        pub remediations:
            std::vec::Vec<crate::model::vulnerability_assessment_note::assessment::Remediation>,

        /// Justification provides the justification when the state of the
        /// assessment if NOT_AFFECTED.
        pub justification: std::option::Option<
            crate::model::vulnerability_assessment_note::assessment::Justification,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VexAssessment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cve][crate::model::vulnerability_occurrence::VexAssessment::cve].
        #[deprecated]
        pub fn set_cve<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cve = v.into();
            self
        }

        /// Sets the value of [vulnerability_id][crate::model::vulnerability_occurrence::VexAssessment::vulnerability_id].
        pub fn set_vulnerability_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.vulnerability_id = v.into();
            self
        }

        /// Sets the value of [related_uris][crate::model::vulnerability_occurrence::VexAssessment::related_uris].
        pub fn set_related_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::RelatedUrl>,
        {
            use std::iter::Iterator;
            self.related_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [note_name][crate::model::vulnerability_occurrence::VexAssessment::note_name].
        pub fn set_note_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.note_name = v.into();
            self
        }

        /// Sets the value of [state][crate::model::vulnerability_occurrence::VexAssessment::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [impacts][crate::model::vulnerability_occurrence::VexAssessment::impacts].
        pub fn set_impacts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.impacts = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [remediations][crate::model::vulnerability_occurrence::VexAssessment::remediations].
        pub fn set_remediations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::vulnerability_assessment_note::assessment::Remediation,
                >,
        {
            use std::iter::Iterator;
            self.remediations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [justification][crate::model::vulnerability_occurrence::VexAssessment::justification].
        pub fn set_justification<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::vulnerability_assessment_note::assessment::Justification,
                >,
        {
            self.justification = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [justification][crate::model::vulnerability_occurrence::VexAssessment::justification].
        pub fn set_or_clear_justification<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::vulnerability_assessment_note::assessment::Justification,
                >,
        {
            self.justification = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for VexAssessment {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityOccurrence.VexAssessment"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VexAssessment {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cve,
                __vulnerability_id,
                __related_uris,
                __note_name,
                __state,
                __impacts,
                __remediations,
                __justification,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VexAssessment")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cve" => Ok(__FieldTag::__cve),
                                "vulnerabilityId" => Ok(__FieldTag::__vulnerability_id),
                                "vulnerability_id" => Ok(__FieldTag::__vulnerability_id),
                                "relatedUris" => Ok(__FieldTag::__related_uris),
                                "related_uris" => Ok(__FieldTag::__related_uris),
                                "noteName" => Ok(__FieldTag::__note_name),
                                "note_name" => Ok(__FieldTag::__note_name),
                                "state" => Ok(__FieldTag::__state),
                                "impacts" => Ok(__FieldTag::__impacts),
                                "remediations" => Ok(__FieldTag::__remediations),
                                "justification" => Ok(__FieldTag::__justification),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VexAssessment;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VexAssessment")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cve => {
                                if !fields.insert(__FieldTag::__cve) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cve",
                                    ));
                                }
                                result.cve = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__vulnerability_id => {
                                if !fields.insert(__FieldTag::__vulnerability_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vulnerability_id",
                                    ));
                                }
                                result.vulnerability_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__related_uris => {
                                if !fields.insert(__FieldTag::__related_uris) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for related_uris",
                                    ));
                                }
                                result.related_uris =
                                    map.next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::RelatedUrl>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__note_name => {
                                if !fields.insert(__FieldTag::__note_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for note_name",
                                    ));
                                }
                                result.note_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::vulnerability_assessment_note::assessment::State>>()?.unwrap_or_default();
                            }
                            __FieldTag::__impacts => {
                                if !fields.insert(__FieldTag::__impacts) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for impacts",
                                    ));
                                }
                                result.impacts = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__remediations => {
                                if !fields.insert(__FieldTag::__remediations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for remediations",
                                    ));
                                }
                                result.remediations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::vulnerability_assessment_note::assessment::Remediation>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__justification => {
                                if !fields.insert(__FieldTag::__justification) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for justification",
                                    ));
                                }
                                result.justification = map.next_value::<std::option::Option<crate::model::vulnerability_assessment_note::assessment::Justification>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for VexAssessment {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.cve.is_empty() {
                state.serialize_entry("cve", &self.cve)?;
            }
            if !self.vulnerability_id.is_empty() {
                state.serialize_entry("vulnerabilityId", &self.vulnerability_id)?;
            }
            if !self.related_uris.is_empty() {
                state.serialize_entry("relatedUris", &self.related_uris)?;
            }
            if !self.note_name.is_empty() {
                state.serialize_entry("noteName", &self.note_name)?;
            }
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.impacts.is_empty() {
                state.serialize_entry("impacts", &self.impacts)?;
            }
            if !self.remediations.is_empty() {
                state.serialize_entry("remediations", &self.remediations)?;
            }
            if self.justification.is_some() {
                state.serialize_entry("justification", &self.justification)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Kind represents the kinds of notes supported.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NoteKind {
    /// Default value. This value is unused.
    Unspecified,
    /// The note and occurrence represent a package vulnerability.
    Vulnerability,
    /// The note and occurrence assert build provenance.
    Build,
    /// This represents an image basis relationship.
    Image,
    /// This represents a package installed via a package manager.
    Package,
    /// The note and occurrence track deployment events.
    Deployment,
    /// The note and occurrence track the initial discovery status of a resource.
    Discovery,
    /// This represents a logical "role" that can attest to artifacts.
    Attestation,
    /// This represents an available package upgrade.
    Upgrade,
    /// This represents a Compliance Note
    Compliance,
    /// This represents a DSSE attestation Note
    DsseAttestation,
    /// This represents a Vulnerability Assessment.
    VulnerabilityAssessment,
    /// This represents an SBOM Reference.
    SbomReference,
    /// This represents a secret.
    Secret,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NoteKind::value] or
    /// [NoteKind::name].
    UnknownValue(note_kind::UnknownValue),
}

#[doc(hidden)]
pub mod note_kind {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl NoteKind {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Vulnerability => std::option::Option::Some(1),
            Self::Build => std::option::Option::Some(2),
            Self::Image => std::option::Option::Some(3),
            Self::Package => std::option::Option::Some(4),
            Self::Deployment => std::option::Option::Some(5),
            Self::Discovery => std::option::Option::Some(6),
            Self::Attestation => std::option::Option::Some(7),
            Self::Upgrade => std::option::Option::Some(8),
            Self::Compliance => std::option::Option::Some(9),
            Self::DsseAttestation => std::option::Option::Some(10),
            Self::VulnerabilityAssessment => std::option::Option::Some(11),
            Self::SbomReference => std::option::Option::Some(12),
            Self::Secret => std::option::Option::Some(13),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("NOTE_KIND_UNSPECIFIED"),
            Self::Vulnerability => std::option::Option::Some("VULNERABILITY"),
            Self::Build => std::option::Option::Some("BUILD"),
            Self::Image => std::option::Option::Some("IMAGE"),
            Self::Package => std::option::Option::Some("PACKAGE"),
            Self::Deployment => std::option::Option::Some("DEPLOYMENT"),
            Self::Discovery => std::option::Option::Some("DISCOVERY"),
            Self::Attestation => std::option::Option::Some("ATTESTATION"),
            Self::Upgrade => std::option::Option::Some("UPGRADE"),
            Self::Compliance => std::option::Option::Some("COMPLIANCE"),
            Self::DsseAttestation => std::option::Option::Some("DSSE_ATTESTATION"),
            Self::VulnerabilityAssessment => std::option::Option::Some("VULNERABILITY_ASSESSMENT"),
            Self::SbomReference => std::option::Option::Some("SBOM_REFERENCE"),
            Self::Secret => std::option::Option::Some("SECRET"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for NoteKind {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for NoteKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for NoteKind {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Vulnerability,
            2 => Self::Build,
            3 => Self::Image,
            4 => Self::Package,
            5 => Self::Deployment,
            6 => Self::Discovery,
            7 => Self::Attestation,
            8 => Self::Upgrade,
            9 => Self::Compliance,
            10 => Self::DsseAttestation,
            11 => Self::VulnerabilityAssessment,
            12 => Self::SbomReference,
            13 => Self::Secret,
            _ => Self::UnknownValue(note_kind::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for NoteKind {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NOTE_KIND_UNSPECIFIED" => Self::Unspecified,
            "VULNERABILITY" => Self::Vulnerability,
            "BUILD" => Self::Build,
            "IMAGE" => Self::Image,
            "PACKAGE" => Self::Package,
            "DEPLOYMENT" => Self::Deployment,
            "DISCOVERY" => Self::Discovery,
            "ATTESTATION" => Self::Attestation,
            "UPGRADE" => Self::Upgrade,
            "COMPLIANCE" => Self::Compliance,
            "DSSE_ATTESTATION" => Self::DsseAttestation,
            "VULNERABILITY_ASSESSMENT" => Self::VulnerabilityAssessment,
            "SBOM_REFERENCE" => Self::SbomReference,
            "SECRET" => Self::Secret,
            _ => Self::UnknownValue(note_kind::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for NoteKind {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Vulnerability => serializer.serialize_i32(1),
            Self::Build => serializer.serialize_i32(2),
            Self::Image => serializer.serialize_i32(3),
            Self::Package => serializer.serialize_i32(4),
            Self::Deployment => serializer.serialize_i32(5),
            Self::Discovery => serializer.serialize_i32(6),
            Self::Attestation => serializer.serialize_i32(7),
            Self::Upgrade => serializer.serialize_i32(8),
            Self::Compliance => serializer.serialize_i32(9),
            Self::DsseAttestation => serializer.serialize_i32(10),
            Self::VulnerabilityAssessment => serializer.serialize_i32(11),
            Self::SbomReference => serializer.serialize_i32(12),
            Self::Secret => serializer.serialize_i32(13),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for NoteKind {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NoteKind>::new(
            ".grafeas.v1.NoteKind",
        ))
    }
}

/// CVSS Version.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CVSSVersion {
    Unspecified,
    CvssVersion2,
    CvssVersion3,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CVSSVersion::value] or
    /// [CVSSVersion::name].
    UnknownValue(cvss_version::UnknownValue),
}

#[doc(hidden)]
pub mod cvss_version {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CVSSVersion {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::CvssVersion2 => std::option::Option::Some(1),
            Self::CvssVersion3 => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CVSS_VERSION_UNSPECIFIED"),
            Self::CvssVersion2 => std::option::Option::Some("CVSS_VERSION_2"),
            Self::CvssVersion3 => std::option::Option::Some("CVSS_VERSION_3"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CVSSVersion {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CVSSVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CVSSVersion {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::CvssVersion2,
            2 => Self::CvssVersion3,
            _ => Self::UnknownValue(cvss_version::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CVSSVersion {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CVSS_VERSION_UNSPECIFIED" => Self::Unspecified,
            "CVSS_VERSION_2" => Self::CvssVersion2,
            "CVSS_VERSION_3" => Self::CvssVersion3,
            _ => Self::UnknownValue(cvss_version::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CVSSVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::CvssVersion2 => serializer.serialize_i32(1),
            Self::CvssVersion3 => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CVSSVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CVSSVersion>::new(
            ".grafeas.v1.CVSSVersion",
        ))
    }
}

/// Instruction set architectures supported by various package managers.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Architecture {
    /// Unknown architecture.
    Unspecified,
    /// X86 architecture.
    X86,
    /// X64 architecture.
    X64,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Architecture::value] or
    /// [Architecture::name].
    UnknownValue(architecture::UnknownValue),
}

#[doc(hidden)]
pub mod architecture {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Architecture {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::X86 => std::option::Option::Some(1),
            Self::X64 => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ARCHITECTURE_UNSPECIFIED"),
            Self::X86 => std::option::Option::Some("X86"),
            Self::X64 => std::option::Option::Some("X64"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Architecture {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Architecture {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Architecture {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::X86,
            2 => Self::X64,
            _ => Self::UnknownValue(architecture::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Architecture {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
            "X86" => Self::X86,
            "X64" => Self::X64,
            _ => Self::UnknownValue(architecture::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Architecture {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::X86 => serializer.serialize_i32(1),
            Self::X64 => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Architecture {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Architecture>::new(
            ".grafeas.v1.Architecture",
        ))
    }
}

/// Kind of secret.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SecretKind {
    /// Unspecified
    Unspecified,
    /// The secret kind is unknown.
    Unknown,
    /// A GCP service account key per:
    /// <https://cloud.google.com/iam/docs/creating-managing-service-account-keys>
    GcpServiceAccountKey,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SecretKind::value] or
    /// [SecretKind::name].
    UnknownValue(secret_kind::UnknownValue),
}

#[doc(hidden)]
pub mod secret_kind {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SecretKind {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Unknown => std::option::Option::Some(1),
            Self::GcpServiceAccountKey => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SECRET_KIND_UNSPECIFIED"),
            Self::Unknown => std::option::Option::Some("SECRET_KIND_UNKNOWN"),
            Self::GcpServiceAccountKey => {
                std::option::Option::Some("SECRET_KIND_GCP_SERVICE_ACCOUNT_KEY")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SecretKind {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SecretKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SecretKind {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Unknown,
            2 => Self::GcpServiceAccountKey,
            _ => Self::UnknownValue(secret_kind::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SecretKind {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SECRET_KIND_UNSPECIFIED" => Self::Unspecified,
            "SECRET_KIND_UNKNOWN" => Self::Unknown,
            "SECRET_KIND_GCP_SERVICE_ACCOUNT_KEY" => Self::GcpServiceAccountKey,
            _ => Self::UnknownValue(secret_kind::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SecretKind {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Unknown => serializer.serialize_i32(1),
            Self::GcpServiceAccountKey => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SecretKind {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SecretKind>::new(
            ".grafeas.v1.SecretKind",
        ))
    }
}

/// Note provider assigned severity/impact ranking.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Severity {
    /// Unknown.
    Unspecified,
    /// Minimal severity.
    Minimal,
    /// Low severity.
    Low,
    /// Medium severity.
    Medium,
    /// High severity.
    High,
    /// Critical severity.
    Critical,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Severity::value] or
    /// [Severity::name].
    UnknownValue(severity::UnknownValue),
}

#[doc(hidden)]
pub mod severity {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Severity {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Minimal => std::option::Option::Some(1),
            Self::Low => std::option::Option::Some(2),
            Self::Medium => std::option::Option::Some(3),
            Self::High => std::option::Option::Some(4),
            Self::Critical => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
            Self::Minimal => std::option::Option::Some("MINIMAL"),
            Self::Low => std::option::Option::Some("LOW"),
            Self::Medium => std::option::Option::Some("MEDIUM"),
            Self::High => std::option::Option::Some("HIGH"),
            Self::Critical => std::option::Option::Some("CRITICAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Severity {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Severity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Severity {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Minimal,
            2 => Self::Low,
            3 => Self::Medium,
            4 => Self::High,
            5 => Self::Critical,
            _ => Self::UnknownValue(severity::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Severity {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SEVERITY_UNSPECIFIED" => Self::Unspecified,
            "MINIMAL" => Self::Minimal,
            "LOW" => Self::Low,
            "MEDIUM" => Self::Medium,
            "HIGH" => Self::High,
            "CRITICAL" => Self::Critical,
            _ => Self::UnknownValue(severity::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Severity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Minimal => serializer.serialize_i32(1),
            Self::Low => serializer.serialize_i32(2),
            Self::Medium => serializer.serialize_i32(3),
            Self::High => serializer.serialize_i32(4),
            Self::Critical => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Severity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
            ".grafeas.v1.Severity",
        ))
    }
}
