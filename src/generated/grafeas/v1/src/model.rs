// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Note kind that represents a logical attestation "role" or "authority". For
/// example, an organization might have one `Authority` for "QA" and one for
/// "build". This note is intended to act strictly as a grouping mechanism for
/// the attached occurrences (Attestations). This grouping mechanism also
/// provides a security boundary, since IAM ACLs gate the ability for a principle
/// to attach an occurrence to a given note. It also provides a single point of
/// lookup to find all attached attestation occurrences, even if they don't all
/// live in the same project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttestationNote {
    /// Hint hints at the purpose of the attestation authority.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hint: std::option::Option<crate::model::attestation_note::Hint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttestationNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hint][crate::model::AttestationNote::hint].
    pub fn set_hint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attestation_note::Hint>,
    {
        self.hint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hint][crate::model::AttestationNote::hint].
    pub fn set_or_clear_hint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attestation_note::Hint>,
    {
        self.hint = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AttestationNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.AttestationNote"
    }
}

/// Defines additional types related to [AttestationNote].
pub mod attestation_note {
    #[allow(unused_imports)]
    use super::*;

    /// This submessage provides human-readable hints about the purpose of the
    /// authority. Because the name of a note acts as its resource reference, it is
    /// important to disambiguate the canonical name of the Note (which might be a
    /// UUID for security purposes) from "readable" names more suitable for debug
    /// output. Note that these hints should not be used to look up authorities in
    /// security sensitive contexts, such as when looking up attestations to
    /// verify.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Hint {
        /// Required. The human readable name of this attestation authority, for
        /// example "qa".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub human_readable_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Hint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [human_readable_name][crate::model::attestation_note::Hint::human_readable_name].
        pub fn set_human_readable_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.human_readable_name = v.into();
            self
        }
    }

    impl wkt::message::Message for Hint {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.AttestationNote.Hint"
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Jwt {
    /// The compact encoding of a JWS, which is always three base64 encoded strings
    /// joined by periods. For details, see:
    /// <https://tools.ietf.org/html/rfc7515.html#section-3.1>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub compact_jwt: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Jwt {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [compact_jwt][crate::model::Jwt::compact_jwt].
    pub fn set_compact_jwt<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compact_jwt = v.into();
        self
    }
}

impl wkt::message::Message for Jwt {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Jwt"
    }
}

/// Occurrence that represents a single "attestation". The authenticity of an
/// attestation can be verified using the attached signature. If the verifier
/// trusts the public key of the signer, then verifying the signature is
/// sufficient to establish trust. In this circumstance, the authority to which
/// this attestation is attached is primarily useful for lookup (how to find
/// this attestation if you already know the authority and artifact to be
/// verified) and intent (for which authority this attestation was intended to
/// sign.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttestationOccurrence {
    /// Required. The serialized payload that is verified by one or more
    /// `signatures`.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub serialized_payload: ::bytes::Bytes,

    /// One or more signatures over `serialized_payload`.  Verifier implementations
    /// should consider this attestation message verified if at least one
    /// `signature` verifies `serialized_payload`.  See `Signature` in common.proto
    /// for more details on signature structure and verification.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub signatures: std::vec::Vec<crate::model::Signature>,

    /// One or more JWTs encoding a self-contained attestation.
    /// Each JWT encodes the payload that it verifies within the JWT itself.
    /// Verifier implementation SHOULD ignore the `serialized_payload` field
    /// when verifying these JWTs.
    /// If only JWTs are present on this AttestationOccurrence, then the
    /// `serialized_payload` SHOULD be left empty.
    /// Each JWT SHOULD encode a claim specific to the `resource_uri` of this
    /// Occurrence, but this is not validated by Grafeas metadata API
    /// implementations.  The JWT itself is opaque to Grafeas.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jwts: std::vec::Vec<crate::model::Jwt>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttestationOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [serialized_payload][crate::model::AttestationOccurrence::serialized_payload].
    pub fn set_serialized_payload<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.serialized_payload = v.into();
        self
    }

    /// Sets the value of [signatures][crate::model::AttestationOccurrence::signatures].
    pub fn set_signatures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Signature>,
    {
        use std::iter::Iterator;
        self.signatures = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jwts][crate::model::AttestationOccurrence::jwts].
    pub fn set_jwts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Jwt>,
    {
        use std::iter::Iterator;
        self.jwts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AttestationOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.AttestationOccurrence"
    }
}

/// Note holding the version of the provider's builder and the signature of the
/// provenance message in the build details occurrence.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildNote {
    /// Required. Immutable. Version of the builder which produced this build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub builder_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builder_version][crate::model::BuildNote::builder_version].
    pub fn set_builder_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.builder_version = v.into();
        self
    }
}

impl wkt::message::Message for BuildNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BuildNote"
    }
}

/// Details of a build occurrence.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildOccurrence {
    /// The actual provenance for the build.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub provenance: std::option::Option<crate::model::BuildProvenance>,

    /// Serialized JSON representation of the provenance, used in generating the
    /// build signature in the corresponding build note. After verifying the
    /// signature, `provenance_bytes` can be unmarshalled and compared to the
    /// provenance to confirm that it is unchanged. A base64-encoded string
    /// representation of the provenance bytes is used for the signature in order
    /// to interoperate with openssl which expects this format for signature
    /// verification.
    ///
    /// The serialized form is captured both to avoid ambiguity in how the
    /// provenance is marshalled to json as well to prevent incompatibilities with
    /// future changes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub provenance_bytes: std::string::String,

    /// Deprecated. See InTotoStatement for the replacement.
    /// In-toto Provenance representation as defined in spec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub intoto_provenance: std::option::Option<crate::model::InTotoProvenance>,

    /// In-toto Statement representation as defined in spec.
    /// The intoto_statement can contain any type of provenance. The serialized
    /// payload of the statement can be stored and signed in the Occurrence's
    /// envelope.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub intoto_statement: std::option::Option<crate::model::InTotoStatement>,

    /// In-Toto Slsa Provenance V1 represents a slsa provenance meeting the slsa
    /// spec, wrapped in an in-toto statement. This allows for direct
    /// jsonification of a to-spec in-toto slsa statement with a to-spec
    /// slsa provenance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub in_toto_slsa_provenance_v1: std::option::Option<crate::model::InTotoSlsaProvenanceV1>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provenance][crate::model::BuildOccurrence::provenance].
    pub fn set_provenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuildProvenance>,
    {
        self.provenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provenance][crate::model::BuildOccurrence::provenance].
    pub fn set_or_clear_provenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuildProvenance>,
    {
        self.provenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provenance_bytes][crate::model::BuildOccurrence::provenance_bytes].
    pub fn set_provenance_bytes<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.provenance_bytes = v.into();
        self
    }

    /// Sets the value of [intoto_provenance][crate::model::BuildOccurrence::intoto_provenance].
    pub fn set_intoto_provenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InTotoProvenance>,
    {
        self.intoto_provenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intoto_provenance][crate::model::BuildOccurrence::intoto_provenance].
    pub fn set_or_clear_intoto_provenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InTotoProvenance>,
    {
        self.intoto_provenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [intoto_statement][crate::model::BuildOccurrence::intoto_statement].
    pub fn set_intoto_statement<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InTotoStatement>,
    {
        self.intoto_statement = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intoto_statement][crate::model::BuildOccurrence::intoto_statement].
    pub fn set_or_clear_intoto_statement<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InTotoStatement>,
    {
        self.intoto_statement = v.map(|x| x.into());
        self
    }

    /// Sets the value of [in_toto_slsa_provenance_v1][crate::model::BuildOccurrence::in_toto_slsa_provenance_v1].
    pub fn set_in_toto_slsa_provenance_v1<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InTotoSlsaProvenanceV1>,
    {
        self.in_toto_slsa_provenance_v1 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [in_toto_slsa_provenance_v1][crate::model::BuildOccurrence::in_toto_slsa_provenance_v1].
    pub fn set_or_clear_in_toto_slsa_provenance_v1<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InTotoSlsaProvenanceV1>,
    {
        self.in_toto_slsa_provenance_v1 = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BuildOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BuildOccurrence"
    }
}

/// Metadata for any related URL information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RelatedUrl {
    /// Specific URL associated with the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,

    /// Label to describe usage of the URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub label: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedUrl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::RelatedUrl::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [label][crate::model::RelatedUrl::label].
    pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label = v.into();
        self
    }
}

impl wkt::message::Message for RelatedUrl {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.RelatedUrl"
    }
}

/// Verifiers (e.g. Kritis implementations) MUST verify signatures
/// with respect to the trust anchors defined in policy (e.g. a Kritis policy).
/// Typically this means that the verifier has been configured with a map from
/// `public_key_id` to public key material (and any required parameters, e.g.
/// signing algorithm).
///
/// In particular, verification implementations MUST NOT treat the signature
/// `public_key_id` as anything more than a key lookup hint. The `public_key_id`
/// DOES NOT validate or authenticate a public key; it only provides a mechanism
/// for quickly selecting a public key ALREADY CONFIGURED on the verifier through
/// a trusted channel. Verification implementations MUST reject signatures in any
/// of the following circumstances:
///
/// * The `public_key_id` is not recognized by the verifier.
/// * The public key that `public_key_id` refers to does not verify the
///   signature with respect to the payload.
///
/// The `signature` contents SHOULD NOT be "attached" (where the payload is
/// included with the serialized `signature` bytes). Verifiers MUST ignore any
/// "attached" payload and only verify signatures with respect to explicitly
/// provided payload (e.g. a `payload` field on the proto message that holds
/// this Signature, or the canonical serialization of the proto message that
/// holds this signature).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Signature {
    /// The content of the signature, an opaque bytestring.
    /// The payload that this signature verifies MUST be unambiguously provided
    /// with the Signature during verification. A wrapper message might provide
    /// the payload explicitly. Alternatively, a message might have a canonical
    /// serialization that can always be unambiguously computed to derive the
    /// payload.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub signature: ::bytes::Bytes,

    /// The identifier for the public key that verifies this signature.
    ///
    /// * The `public_key_id` is required.
    /// * The `public_key_id` SHOULD be an RFC3986 conformant URI.
    /// * When possible, the `public_key_id` SHOULD be an immutable reference,
    ///   such as a cryptographic digest.
    ///
    /// Examples of valid `public_key_id`s:
    ///
    /// OpenPGP V4 public key fingerprint:
    ///
    /// * "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA"
    ///   See <https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr> for more
    ///   details on this scheme.
    ///
    /// RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
    /// serialization):
    ///
    /// * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU"
    /// * "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_key_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Signature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [signature][crate::model::Signature::signature].
    pub fn set_signature<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.signature = v.into();
        self
    }

    /// Sets the value of [public_key_id][crate::model::Signature::public_key_id].
    pub fn set_public_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key_id = v.into();
        self
    }
}

impl wkt::message::Message for Signature {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Signature"
    }
}

/// MUST match
/// <https://github.com/secure-systems-lab/dsse/blob/master/envelope.proto>. An
/// authenticated message of arbitrary type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Envelope {
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub payload: ::bytes::Bytes,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub payload_type: std::string::String,

    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub signatures: std::vec::Vec<crate::model::EnvelopeSignature>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Envelope {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [payload][crate::model::Envelope::payload].
    pub fn set_payload<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.payload = v.into();
        self
    }

    /// Sets the value of [payload_type][crate::model::Envelope::payload_type].
    pub fn set_payload_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload_type = v.into();
        self
    }

    /// Sets the value of [signatures][crate::model::Envelope::signatures].
    pub fn set_signatures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvelopeSignature>,
    {
        use std::iter::Iterator;
        self.signatures = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Envelope {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Envelope"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnvelopeSignature {
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub sig: ::bytes::Bytes,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub keyid: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnvelopeSignature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sig][crate::model::EnvelopeSignature::sig].
    pub fn set_sig<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.sig = v.into();
        self
    }

    /// Sets the value of [keyid][crate::model::EnvelopeSignature::keyid].
    pub fn set_keyid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.keyid = v.into();
        self
    }
}

impl wkt::message::Message for EnvelopeSignature {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.EnvelopeSignature"
    }
}

/// Indicates the location at which a package was found.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileLocation {
    /// For jars that are contained inside .war files, this filepath
    /// can indicate the path to war file combined with the path to jar file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_path: std::string::String,

    /// Each package found in a file should have its own layer metadata (that is,
    /// information from the origin layer of the package).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub layer_details: std::option::Option<crate::model::LayerDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_path][crate::model::FileLocation::file_path].
    pub fn set_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_path = v.into();
        self
    }

    /// Sets the value of [layer_details][crate::model::FileLocation::layer_details].
    pub fn set_layer_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LayerDetails>,
    {
        self.layer_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [layer_details][crate::model::FileLocation::layer_details].
    pub fn set_or_clear_layer_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LayerDetails>,
    {
        self.layer_details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FileLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.FileLocation"
    }
}

/// BaseImage describes a base image of a container image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BaseImage {
    /// The name of the base image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The repository name in which the base image is from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repository: std::string::String,

    /// The number of layers that the base image is composed of.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub layer_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BaseImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BaseImage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [repository][crate::model::BaseImage::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [layer_count][crate::model::BaseImage::layer_count].
    pub fn set_layer_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.layer_count = v.into();
        self
    }
}

impl wkt::message::Message for BaseImage {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BaseImage"
    }
}

/// Details about the layer a package was found in.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LayerDetails {
    /// The index of the layer in the container image.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub index: i32,

    /// The diff ID (typically a sha256 hash) of the layer in the container image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub diff_id: std::string::String,

    /// The layer chain ID (sha256 hash) of the layer in the container image.
    /// <https://github.com/opencontainers/image-spec/blob/main/config.md#layer-chainid>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub chain_id: std::string::String,

    /// The layer build command that was used to build the layer. This may not be
    /// found in all layers depending on how the container image is built.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub command: std::string::String,

    /// The base images the layer is found within.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub base_images: std::vec::Vec<crate::model::BaseImage>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LayerDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index][crate::model::LayerDetails::index].
    pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [diff_id][crate::model::LayerDetails::diff_id].
    pub fn set_diff_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.diff_id = v.into();
        self
    }

    /// Sets the value of [chain_id][crate::model::LayerDetails::chain_id].
    pub fn set_chain_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.chain_id = v.into();
        self
    }

    /// Sets the value of [command][crate::model::LayerDetails::command].
    pub fn set_command<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.command = v.into();
        self
    }

    /// Sets the value of [base_images][crate::model::LayerDetails::base_images].
    pub fn set_base_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BaseImage>,
    {
        use std::iter::Iterator;
        self.base_images = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LayerDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.LayerDetails"
    }
}

/// License information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct License {
    /// Often a single license can be used to represent the licensing terms.
    /// Sometimes it is necessary to include a choice of one or more licenses
    /// or some combination of license identifiers.
    /// Examples: "LGPL-2.1-only OR MIT", "LGPL-2.1-only AND MIT",
    /// "GPL-2.0-or-later WITH Bison-exception-2.2".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub expression: std::string::String,

    /// Comments
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub comments: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl License {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expression][crate::model::License::expression].
    pub fn set_expression<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.expression = v.into();
        self
    }

    /// Sets the value of [comments][crate::model::License::comments].
    pub fn set_comments<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comments = v.into();
        self
    }
}

impl wkt::message::Message for License {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.License"
    }
}

/// Digest information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Digest {
    /// `SHA1`, `SHA512` etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub algo: std::string::String,

    /// Value of the digest.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub digest_bytes: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Digest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [algo][crate::model::Digest::algo].
    pub fn set_algo<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.algo = v.into();
        self
    }

    /// Sets the value of [digest_bytes][crate::model::Digest::digest_bytes].
    pub fn set_digest_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.digest_bytes = v.into();
        self
    }
}

impl wkt::message::Message for Digest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Digest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComplianceNote {
    /// The title that identifies this compliance check.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// A description about this compliance check.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The OS and config versions the benchmark applies to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub version: std::vec::Vec<crate::model::ComplianceVersion>,

    /// A rationale for the existence of this compliance check.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rationale: std::string::String,

    /// A description of remediation steps if the compliance check fails.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub remediation: std::string::String,

    /// Serialized scan instructions with a predefined format.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub scan_instructions: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub compliance_type: std::option::Option<crate::model::compliance_note::ComplianceType>,

    /// Potential impact of the suggested remediation
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub potential_impact: std::option::Option<crate::model::compliance_note::PotentialImpact>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [title][crate::model::ComplianceNote::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ComplianceNote::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [version][crate::model::ComplianceNote::version].
    pub fn set_version<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ComplianceVersion>,
    {
        use std::iter::Iterator;
        self.version = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rationale][crate::model::ComplianceNote::rationale].
    pub fn set_rationale<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rationale = v.into();
        self
    }

    /// Sets the value of [remediation][crate::model::ComplianceNote::remediation].
    pub fn set_remediation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remediation = v.into();
        self
    }

    /// Sets the value of [scan_instructions][crate::model::ComplianceNote::scan_instructions].
    pub fn set_scan_instructions<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.scan_instructions = v.into();
        self
    }

    /// Sets the value of [compliance_type][crate::model::ComplianceNote::compliance_type].
    ///
    /// Note that all the setters affecting `compliance_type` are mutually
    /// exclusive.
    pub fn set_compliance_type<
        T: std::convert::Into<std::option::Option<crate::model::compliance_note::ComplianceType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compliance_type = v.into();
        self
    }

    /// The value of [compliance_type][crate::model::ComplianceNote::compliance_type]
    /// if it holds a `CisBenchmark`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cis_benchmark(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::compliance_note::CisBenchmark>> {
        #[allow(unreachable_patterns)]
        self.compliance_type.as_ref().and_then(|v| match v {
            crate::model::compliance_note::ComplianceType::CisBenchmark(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compliance_type][crate::model::ComplianceNote::compliance_type]
    /// to hold a `CisBenchmark`.
    ///
    /// Note that all the setters affecting `compliance_type` are
    /// mutually exclusive.
    pub fn set_cis_benchmark<
        T: std::convert::Into<std::boxed::Box<crate::model::compliance_note::CisBenchmark>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compliance_type = std::option::Option::Some(
            crate::model::compliance_note::ComplianceType::CisBenchmark(v.into()),
        );
        self
    }

    /// Sets the value of [potential_impact][crate::model::ComplianceNote::potential_impact].
    ///
    /// Note that all the setters affecting `potential_impact` are mutually
    /// exclusive.
    pub fn set_potential_impact<
        T: std::convert::Into<std::option::Option<crate::model::compliance_note::PotentialImpact>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.potential_impact = v.into();
        self
    }

    /// The value of [potential_impact][crate::model::ComplianceNote::potential_impact]
    /// if it holds a `Impact`, `None` if the field is not set or
    /// holds a different branch.
    pub fn impact(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.potential_impact.as_ref().and_then(|v| match v {
            crate::model::compliance_note::PotentialImpact::Impact(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [potential_impact][crate::model::ComplianceNote::potential_impact]
    /// to hold a `Impact`.
    ///
    /// Note that all the setters affecting `potential_impact` are
    /// mutually exclusive.
    pub fn set_impact<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.potential_impact = std::option::Option::Some(
            crate::model::compliance_note::PotentialImpact::Impact(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ComplianceNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ComplianceNote"
    }
}

/// Defines additional types related to [ComplianceNote].
pub mod compliance_note {
    #[allow(unused_imports)]
    use super::*;

    /// A compliance check that is a CIS benchmark.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CisBenchmark {
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub profile_level: i32,

        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub severity: crate::model::Severity,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CisBenchmark {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [profile_level][crate::model::compliance_note::CisBenchmark::profile_level].
        pub fn set_profile_level<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.profile_level = v.into();
            self
        }

        /// Sets the value of [severity][crate::model::compliance_note::CisBenchmark::severity].
        pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
            self.severity = v.into();
            self
        }
    }

    impl wkt::message::Message for CisBenchmark {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.ComplianceNote.CisBenchmark"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ComplianceType {
        CisBenchmark(std::boxed::Box<crate::model::compliance_note::CisBenchmark>),
    }

    /// Potential impact of the suggested remediation
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PotentialImpact {
        Impact(std::string::String),
    }
}

/// Describes the CIS benchmark version that is applicable to a given OS and
/// os version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComplianceVersion {
    /// The CPE URI (<https://cpe.mitre.org/specification/>) this benchmark is
    /// applicable to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cpe_uri: std::string::String,

    /// The name of the document that defines this benchmark, e.g. "CIS
    /// Container-Optimized OS".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub benchmark_document: std::string::String,

    /// The version of the benchmark. This is set to the version of the OS-specific
    /// CIS document the benchmark is defined in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpe_uri][crate::model::ComplianceVersion::cpe_uri].
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [benchmark_document][crate::model::ComplianceVersion::benchmark_document].
    pub fn set_benchmark_document<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.benchmark_document = v.into();
        self
    }

    /// Sets the value of [version][crate::model::ComplianceVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for ComplianceVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ComplianceVersion"
    }
}

/// An indication that the compliance checks in the associated ComplianceNote
/// were not satisfied for particular resources or a specified reason.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComplianceOccurrence {
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub non_compliant_files: std::vec::Vec<crate::model::NonCompliantFile>,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub non_compliance_reason: std::string::String,

    /// The OS and config version the benchmark was run on.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::ComplianceVersion>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [non_compliant_files][crate::model::ComplianceOccurrence::non_compliant_files].
    pub fn set_non_compliant_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NonCompliantFile>,
    {
        use std::iter::Iterator;
        self.non_compliant_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [non_compliance_reason][crate::model::ComplianceOccurrence::non_compliance_reason].
    pub fn set_non_compliance_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.non_compliance_reason = v.into();
        self
    }

    /// Sets the value of [version][crate::model::ComplianceOccurrence::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceVersion>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::ComplianceOccurrence::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceVersion>,
    {
        self.version = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComplianceOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ComplianceOccurrence"
    }
}

/// Details about files that caused a compliance check to fail.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NonCompliantFile {
    /// Empty if `display_command` is set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Command to display the non-compliant files.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_command: std::string::String,

    /// Explains why a file is non compliant for a CIS check.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reason: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NonCompliantFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::NonCompliantFile::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [display_command][crate::model::NonCompliantFile::display_command].
    pub fn set_display_command<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_command = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::NonCompliantFile::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }
}

impl wkt::message::Message for NonCompliantFile {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.NonCompliantFile"
    }
}

/// Common Vulnerability Scoring System version 3.
/// For details, see <https://www.first.org/cvss/specification-document>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CVSSv3 {
    /// The base score is a function of the base metric scores.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub base_score: f32,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub exploitability_score: f32,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub impact_score: f32,

    /// Base Metrics
    /// Represents the intrinsic characteristics of a vulnerability that are
    /// constant over time and across user environments.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub attack_vector: crate::model::cvs_sv_3::AttackVector,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub attack_complexity: crate::model::cvs_sv_3::AttackComplexity,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub privileges_required: crate::model::cvs_sv_3::PrivilegesRequired,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub user_interaction: crate::model::cvs_sv_3::UserInteraction,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub scope: crate::model::cvs_sv_3::Scope,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub confidentiality_impact: crate::model::cvs_sv_3::Impact,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub integrity_impact: crate::model::cvs_sv_3::Impact,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub availability_impact: crate::model::cvs_sv_3::Impact,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CVSSv3 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_score][crate::model::CVSSv3::base_score].
    pub fn set_base_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.base_score = v.into();
        self
    }

    /// Sets the value of [exploitability_score][crate::model::CVSSv3::exploitability_score].
    pub fn set_exploitability_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.exploitability_score = v.into();
        self
    }

    /// Sets the value of [impact_score][crate::model::CVSSv3::impact_score].
    pub fn set_impact_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.impact_score = v.into();
        self
    }

    /// Sets the value of [attack_vector][crate::model::CVSSv3::attack_vector].
    pub fn set_attack_vector<T: std::convert::Into<crate::model::cvs_sv_3::AttackVector>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_vector = v.into();
        self
    }

    /// Sets the value of [attack_complexity][crate::model::CVSSv3::attack_complexity].
    pub fn set_attack_complexity<
        T: std::convert::Into<crate::model::cvs_sv_3::AttackComplexity>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.attack_complexity = v.into();
        self
    }

    /// Sets the value of [privileges_required][crate::model::CVSSv3::privileges_required].
    pub fn set_privileges_required<
        T: std::convert::Into<crate::model::cvs_sv_3::PrivilegesRequired>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privileges_required = v.into();
        self
    }

    /// Sets the value of [user_interaction][crate::model::CVSSv3::user_interaction].
    pub fn set_user_interaction<T: std::convert::Into<crate::model::cvs_sv_3::UserInteraction>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_interaction = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::CVSSv3::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::cvs_sv_3::Scope>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [confidentiality_impact][crate::model::CVSSv3::confidentiality_impact].
    pub fn set_confidentiality_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.confidentiality_impact = v.into();
        self
    }

    /// Sets the value of [integrity_impact][crate::model::CVSSv3::integrity_impact].
    pub fn set_integrity_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.integrity_impact = v.into();
        self
    }

    /// Sets the value of [availability_impact][crate::model::CVSSv3::availability_impact].
    pub fn set_availability_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.availability_impact = v.into();
        self
    }
}

impl wkt::message::Message for CVSSv3 {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CVSSv3"
    }
}

/// Defines additional types related to [CVSSv3].
pub mod cvs_sv_3 {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackVector {
        Unspecified,
        Network,
        Adjacent,
        Local,
        Physical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackVector::value] or
        /// [AttackVector::name].
        UnknownValue(attack_vector::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_vector {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackVector {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Network => std::option::Option::Some(1),
                Self::Adjacent => std::option::Option::Some(2),
                Self::Local => std::option::Option::Some(3),
                Self::Physical => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_VECTOR_UNSPECIFIED"),
                Self::Network => std::option::Option::Some("ATTACK_VECTOR_NETWORK"),
                Self::Adjacent => std::option::Option::Some("ATTACK_VECTOR_ADJACENT"),
                Self::Local => std::option::Option::Some("ATTACK_VECTOR_LOCAL"),
                Self::Physical => std::option::Option::Some("ATTACK_VECTOR_PHYSICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackVector {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackVector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackVector {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Network,
                2 => Self::Adjacent,
                3 => Self::Local,
                4 => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackVector {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_VECTOR_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_VECTOR_NETWORK" => Self::Network,
                "ATTACK_VECTOR_ADJACENT" => Self::Adjacent,
                "ATTACK_VECTOR_LOCAL" => Self::Local,
                "ATTACK_VECTOR_PHYSICAL" => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackVector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Network => serializer.serialize_i32(1),
                Self::Adjacent => serializer.serialize_i32(2),
                Self::Local => serializer.serialize_i32(3),
                Self::Physical => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackVector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackVector>::new(
                ".grafeas.v1.CVSSv3.AttackVector",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackComplexity {
        Unspecified,
        Low,
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackComplexity::value] or
        /// [AttackComplexity::name].
        UnknownValue(attack_complexity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_complexity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackComplexity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::High => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_COMPLEXITY_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("ATTACK_COMPLEXITY_LOW"),
                Self::High => std::option::Option::Some("ATTACK_COMPLEXITY_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackComplexity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackComplexity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackComplexity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::High,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackComplexity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_COMPLEXITY_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_COMPLEXITY_LOW" => Self::Low,
                "ATTACK_COMPLEXITY_HIGH" => Self::High,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackComplexity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::High => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackComplexity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackComplexity>::new(
                ".grafeas.v1.CVSSv3.AttackComplexity",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivilegesRequired {
        Unspecified,
        None,
        Low,
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivilegesRequired::value] or
        /// [PrivilegesRequired::name].
        UnknownValue(privileges_required::UnknownValue),
    }

    #[doc(hidden)]
    pub mod privileges_required {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PrivilegesRequired {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIVILEGES_REQUIRED_UNSPECIFIED"),
                Self::None => std::option::Option::Some("PRIVILEGES_REQUIRED_NONE"),
                Self::Low => std::option::Option::Some("PRIVILEGES_REQUIRED_LOW"),
                Self::High => std::option::Option::Some("PRIVILEGES_REQUIRED_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PrivilegesRequired {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PrivilegesRequired {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PrivilegesRequired {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Low,
                3 => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PrivilegesRequired {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIVILEGES_REQUIRED_UNSPECIFIED" => Self::Unspecified,
                "PRIVILEGES_REQUIRED_NONE" => Self::None,
                "PRIVILEGES_REQUIRED_LOW" => Self::Low,
                "PRIVILEGES_REQUIRED_HIGH" => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PrivilegesRequired {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PrivilegesRequired {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PrivilegesRequired>::new(
                ".grafeas.v1.CVSSv3.PrivilegesRequired",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserInteraction {
        Unspecified,
        None,
        Required,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserInteraction::value] or
        /// [UserInteraction::name].
        UnknownValue(user_interaction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_interaction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserInteraction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Required => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("USER_INTERACTION_UNSPECIFIED"),
                Self::None => std::option::Option::Some("USER_INTERACTION_NONE"),
                Self::Required => std::option::Option::Some("USER_INTERACTION_REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserInteraction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserInteraction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserInteraction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for UserInteraction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_INTERACTION_UNSPECIFIED" => Self::Unspecified,
                "USER_INTERACTION_NONE" => Self::None,
                "USER_INTERACTION_REQUIRED" => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for UserInteraction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Required => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserInteraction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserInteraction>::new(
                ".grafeas.v1.CVSSv3.UserInteraction",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        Unspecified,
        Unchanged,
        Changed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unchanged => std::option::Option::Some(1),
                Self::Changed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Unchanged => std::option::Option::Some("SCOPE_UNCHANGED"),
                Self::Changed => std::option::Option::Some("SCOPE_CHANGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unchanged,
                2 => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "SCOPE_UNCHANGED" => Self::Unchanged,
                "SCOPE_CHANGED" => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unchanged => serializer.serialize_i32(1),
                Self::Changed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".grafeas.v1.CVSSv3.Scope",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Impact {
        Unspecified,
        High,
        Low,
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Impact::value] or
        /// [Impact::name].
        UnknownValue(impact::UnknownValue),
    }

    #[doc(hidden)]
    pub mod impact {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Impact {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPACT_UNSPECIFIED"),
                Self::High => std::option::Option::Some("IMPACT_HIGH"),
                Self::Low => std::option::Option::Some("IMPACT_LOW"),
                Self::None => std::option::Option::Some("IMPACT_NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Impact {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Impact {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Impact {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Low,
                3 => Self::None,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Impact {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPACT_UNSPECIFIED" => Self::Unspecified,
                "IMPACT_HIGH" => Self::High,
                "IMPACT_LOW" => Self::Low,
                "IMPACT_NONE" => Self::None,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Impact {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Impact {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Impact>::new(
                ".grafeas.v1.CVSSv3.Impact",
            ))
        }
    }
}

/// Common Vulnerability Scoring System.
/// For details, see <https://www.first.org/cvss/specification-document>
/// This is a message we will try to use for storing various versions of CVSS
/// rather than making a separate proto for storing a specific version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Cvss {
    /// The base score is a function of the base metric scores.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub base_score: f32,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub exploitability_score: f32,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub impact_score: f32,

    /// Base Metrics
    /// Represents the intrinsic characteristics of a vulnerability that are
    /// constant over time and across user environments.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub attack_vector: crate::model::cvss::AttackVector,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub attack_complexity: crate::model::cvss::AttackComplexity,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub authentication: crate::model::cvss::Authentication,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub privileges_required: crate::model::cvss::PrivilegesRequired,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub user_interaction: crate::model::cvss::UserInteraction,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub scope: crate::model::cvss::Scope,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub confidentiality_impact: crate::model::cvss::Impact,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub integrity_impact: crate::model::cvss::Impact,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub availability_impact: crate::model::cvss::Impact,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cvss {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_score][crate::model::Cvss::base_score].
    pub fn set_base_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.base_score = v.into();
        self
    }

    /// Sets the value of [exploitability_score][crate::model::Cvss::exploitability_score].
    pub fn set_exploitability_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.exploitability_score = v.into();
        self
    }

    /// Sets the value of [impact_score][crate::model::Cvss::impact_score].
    pub fn set_impact_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.impact_score = v.into();
        self
    }

    /// Sets the value of [attack_vector][crate::model::Cvss::attack_vector].
    pub fn set_attack_vector<T: std::convert::Into<crate::model::cvss::AttackVector>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_vector = v.into();
        self
    }

    /// Sets the value of [attack_complexity][crate::model::Cvss::attack_complexity].
    pub fn set_attack_complexity<T: std::convert::Into<crate::model::cvss::AttackComplexity>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_complexity = v.into();
        self
    }

    /// Sets the value of [authentication][crate::model::Cvss::authentication].
    pub fn set_authentication<T: std::convert::Into<crate::model::cvss::Authentication>>(
        mut self,
        v: T,
    ) -> Self {
        self.authentication = v.into();
        self
    }

    /// Sets the value of [privileges_required][crate::model::Cvss::privileges_required].
    pub fn set_privileges_required<
        T: std::convert::Into<crate::model::cvss::PrivilegesRequired>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privileges_required = v.into();
        self
    }

    /// Sets the value of [user_interaction][crate::model::Cvss::user_interaction].
    pub fn set_user_interaction<T: std::convert::Into<crate::model::cvss::UserInteraction>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_interaction = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::Cvss::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::cvss::Scope>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [confidentiality_impact][crate::model::Cvss::confidentiality_impact].
    pub fn set_confidentiality_impact<T: std::convert::Into<crate::model::cvss::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.confidentiality_impact = v.into();
        self
    }

    /// Sets the value of [integrity_impact][crate::model::Cvss::integrity_impact].
    pub fn set_integrity_impact<T: std::convert::Into<crate::model::cvss::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.integrity_impact = v.into();
        self
    }

    /// Sets the value of [availability_impact][crate::model::Cvss::availability_impact].
    pub fn set_availability_impact<T: std::convert::Into<crate::model::cvss::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.availability_impact = v.into();
        self
    }
}

impl wkt::message::Message for Cvss {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CVSS"
    }
}

/// Defines additional types related to [CVSS].
pub mod cvss {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackVector {
        Unspecified,
        Network,
        Adjacent,
        Local,
        Physical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackVector::value] or
        /// [AttackVector::name].
        UnknownValue(attack_vector::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_vector {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackVector {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Network => std::option::Option::Some(1),
                Self::Adjacent => std::option::Option::Some(2),
                Self::Local => std::option::Option::Some(3),
                Self::Physical => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_VECTOR_UNSPECIFIED"),
                Self::Network => std::option::Option::Some("ATTACK_VECTOR_NETWORK"),
                Self::Adjacent => std::option::Option::Some("ATTACK_VECTOR_ADJACENT"),
                Self::Local => std::option::Option::Some("ATTACK_VECTOR_LOCAL"),
                Self::Physical => std::option::Option::Some("ATTACK_VECTOR_PHYSICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackVector {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackVector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackVector {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Network,
                2 => Self::Adjacent,
                3 => Self::Local,
                4 => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackVector {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_VECTOR_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_VECTOR_NETWORK" => Self::Network,
                "ATTACK_VECTOR_ADJACENT" => Self::Adjacent,
                "ATTACK_VECTOR_LOCAL" => Self::Local,
                "ATTACK_VECTOR_PHYSICAL" => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackVector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Network => serializer.serialize_i32(1),
                Self::Adjacent => serializer.serialize_i32(2),
                Self::Local => serializer.serialize_i32(3),
                Self::Physical => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackVector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackVector>::new(
                ".grafeas.v1.CVSS.AttackVector",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackComplexity {
        Unspecified,
        Low,
        High,
        Medium,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackComplexity::value] or
        /// [AttackComplexity::name].
        UnknownValue(attack_complexity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_complexity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackComplexity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::High => std::option::Option::Some(2),
                Self::Medium => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_COMPLEXITY_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("ATTACK_COMPLEXITY_LOW"),
                Self::High => std::option::Option::Some("ATTACK_COMPLEXITY_HIGH"),
                Self::Medium => std::option::Option::Some("ATTACK_COMPLEXITY_MEDIUM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackComplexity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackComplexity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackComplexity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::High,
                3 => Self::Medium,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackComplexity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_COMPLEXITY_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_COMPLEXITY_LOW" => Self::Low,
                "ATTACK_COMPLEXITY_HIGH" => Self::High,
                "ATTACK_COMPLEXITY_MEDIUM" => Self::Medium,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackComplexity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::High => serializer.serialize_i32(2),
                Self::Medium => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackComplexity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackComplexity>::new(
                ".grafeas.v1.CVSS.AttackComplexity",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Authentication {
        Unspecified,
        Multiple,
        Single,
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Authentication::value] or
        /// [Authentication::name].
        UnknownValue(authentication::UnknownValue),
    }

    #[doc(hidden)]
    pub mod authentication {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Authentication {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Multiple => std::option::Option::Some(1),
                Self::Single => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUTHENTICATION_UNSPECIFIED"),
                Self::Multiple => std::option::Option::Some("AUTHENTICATION_MULTIPLE"),
                Self::Single => std::option::Option::Some("AUTHENTICATION_SINGLE"),
                Self::None => std::option::Option::Some("AUTHENTICATION_NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Authentication {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Authentication {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Authentication {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Multiple,
                2 => Self::Single,
                3 => Self::None,
                _ => Self::UnknownValue(authentication::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Authentication {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTHENTICATION_UNSPECIFIED" => Self::Unspecified,
                "AUTHENTICATION_MULTIPLE" => Self::Multiple,
                "AUTHENTICATION_SINGLE" => Self::Single,
                "AUTHENTICATION_NONE" => Self::None,
                _ => Self::UnknownValue(authentication::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Authentication {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Multiple => serializer.serialize_i32(1),
                Self::Single => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Authentication {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Authentication>::new(
                ".grafeas.v1.CVSS.Authentication",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivilegesRequired {
        Unspecified,
        None,
        Low,
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivilegesRequired::value] or
        /// [PrivilegesRequired::name].
        UnknownValue(privileges_required::UnknownValue),
    }

    #[doc(hidden)]
    pub mod privileges_required {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PrivilegesRequired {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIVILEGES_REQUIRED_UNSPECIFIED"),
                Self::None => std::option::Option::Some("PRIVILEGES_REQUIRED_NONE"),
                Self::Low => std::option::Option::Some("PRIVILEGES_REQUIRED_LOW"),
                Self::High => std::option::Option::Some("PRIVILEGES_REQUIRED_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PrivilegesRequired {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PrivilegesRequired {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PrivilegesRequired {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Low,
                3 => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PrivilegesRequired {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIVILEGES_REQUIRED_UNSPECIFIED" => Self::Unspecified,
                "PRIVILEGES_REQUIRED_NONE" => Self::None,
                "PRIVILEGES_REQUIRED_LOW" => Self::Low,
                "PRIVILEGES_REQUIRED_HIGH" => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PrivilegesRequired {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PrivilegesRequired {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PrivilegesRequired>::new(
                ".grafeas.v1.CVSS.PrivilegesRequired",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserInteraction {
        Unspecified,
        None,
        Required,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserInteraction::value] or
        /// [UserInteraction::name].
        UnknownValue(user_interaction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_interaction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserInteraction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Required => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("USER_INTERACTION_UNSPECIFIED"),
                Self::None => std::option::Option::Some("USER_INTERACTION_NONE"),
                Self::Required => std::option::Option::Some("USER_INTERACTION_REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserInteraction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserInteraction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserInteraction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for UserInteraction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_INTERACTION_UNSPECIFIED" => Self::Unspecified,
                "USER_INTERACTION_NONE" => Self::None,
                "USER_INTERACTION_REQUIRED" => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for UserInteraction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Required => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserInteraction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserInteraction>::new(
                ".grafeas.v1.CVSS.UserInteraction",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        Unspecified,
        Unchanged,
        Changed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unchanged => std::option::Option::Some(1),
                Self::Changed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Unchanged => std::option::Option::Some("SCOPE_UNCHANGED"),
                Self::Changed => std::option::Option::Some("SCOPE_CHANGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unchanged,
                2 => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "SCOPE_UNCHANGED" => Self::Unchanged,
                "SCOPE_CHANGED" => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unchanged => serializer.serialize_i32(1),
                Self::Changed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".grafeas.v1.CVSS.Scope",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Impact {
        Unspecified,
        High,
        Low,
        None,
        Partial,
        Complete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Impact::value] or
        /// [Impact::name].
        UnknownValue(impact::UnknownValue),
    }

    #[doc(hidden)]
    pub mod impact {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Impact {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::Partial => std::option::Option::Some(4),
                Self::Complete => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPACT_UNSPECIFIED"),
                Self::High => std::option::Option::Some("IMPACT_HIGH"),
                Self::Low => std::option::Option::Some("IMPACT_LOW"),
                Self::None => std::option::Option::Some("IMPACT_NONE"),
                Self::Partial => std::option::Option::Some("IMPACT_PARTIAL"),
                Self::Complete => std::option::Option::Some("IMPACT_COMPLETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Impact {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Impact {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Impact {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Low,
                3 => Self::None,
                4 => Self::Partial,
                5 => Self::Complete,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Impact {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPACT_UNSPECIFIED" => Self::Unspecified,
                "IMPACT_HIGH" => Self::High,
                "IMPACT_LOW" => Self::Low,
                "IMPACT_NONE" => Self::None,
                "IMPACT_PARTIAL" => Self::Partial,
                "IMPACT_COMPLETE" => Self::Complete,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Impact {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::Partial => serializer.serialize_i32(4),
                Self::Complete => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Impact {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Impact>::new(
                ".grafeas.v1.CVSS.Impact",
            ))
        }
    }
}

/// An artifact that can be deployed in some runtime.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeploymentNote {
    /// Required. Resource URI for the artifact being deployed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_uri: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeploymentNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_uri][crate::model::DeploymentNote::resource_uri].
    pub fn set_resource_uri<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_uri = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DeploymentNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DeploymentNote"
    }
}

/// The period during which some deployable was active in a runtime.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeploymentOccurrence {
    /// Identity of the user that triggered this deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_email: std::string::String,

    /// Required. Beginning of the lifetime of this deployment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deploy_time: std::option::Option<wkt::Timestamp>,

    /// End of the lifetime of this deployment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub undeploy_time: std::option::Option<wkt::Timestamp>,

    /// Configuration used to create this deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub config: std::string::String,

    /// Address of the runtime element hosting this deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub address: std::string::String,

    /// Output only. Resource URI for the artifact being deployed taken from
    /// the deployable field with the same name.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_uri: std::vec::Vec<std::string::String>,

    /// Platform hosting this deployment.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub platform: crate::model::deployment_occurrence::Platform,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeploymentOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_email][crate::model::DeploymentOccurrence::user_email].
    pub fn set_user_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_email = v.into();
        self
    }

    /// Sets the value of [deploy_time][crate::model::DeploymentOccurrence::deploy_time].
    pub fn set_deploy_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deploy_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deploy_time][crate::model::DeploymentOccurrence::deploy_time].
    pub fn set_or_clear_deploy_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deploy_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [undeploy_time][crate::model::DeploymentOccurrence::undeploy_time].
    pub fn set_undeploy_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.undeploy_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [undeploy_time][crate::model::DeploymentOccurrence::undeploy_time].
    pub fn set_or_clear_undeploy_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.undeploy_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config][crate::model::DeploymentOccurrence::config].
    pub fn set_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [address][crate::model::DeploymentOccurrence::address].
    pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.address = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::DeploymentOccurrence::resource_uri].
    pub fn set_resource_uri<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_uri = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [platform][crate::model::DeploymentOccurrence::platform].
    pub fn set_platform<T: std::convert::Into<crate::model::deployment_occurrence::Platform>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform = v.into();
        self
    }
}

impl wkt::message::Message for DeploymentOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DeploymentOccurrence"
    }
}

/// Defines additional types related to [DeploymentOccurrence].
pub mod deployment_occurrence {
    #[allow(unused_imports)]
    use super::*;

    /// Types of platforms.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Platform {
        /// Unknown.
        Unspecified,
        /// Google Container Engine.
        Gke,
        /// Google App Engine: Flexible Environment.
        Flex,
        /// Custom user-defined platform.
        Custom,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Platform::value] or
        /// [Platform::name].
        UnknownValue(platform::UnknownValue),
    }

    #[doc(hidden)]
    pub mod platform {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Platform {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gke => std::option::Option::Some(1),
                Self::Flex => std::option::Option::Some(2),
                Self::Custom => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PLATFORM_UNSPECIFIED"),
                Self::Gke => std::option::Option::Some("GKE"),
                Self::Flex => std::option::Option::Some("FLEX"),
                Self::Custom => std::option::Option::Some("CUSTOM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Platform {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Platform {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Platform {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Gke,
                2 => Self::Flex,
                3 => Self::Custom,
                _ => Self::UnknownValue(platform::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Platform {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PLATFORM_UNSPECIFIED" => Self::Unspecified,
                "GKE" => Self::Gke,
                "FLEX" => Self::Flex,
                "CUSTOM" => Self::Custom,
                _ => Self::UnknownValue(platform::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Platform {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gke => serializer.serialize_i32(1),
                Self::Flex => serializer.serialize_i32(2),
                Self::Custom => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Platform {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Platform>::new(
                ".grafeas.v1.DeploymentOccurrence.Platform",
            ))
        }
    }
}

/// A note that indicates a type of analysis a provider would perform. This note
/// exists in a provider's project. A `Discovery` occurrence is created in a
/// consumer's project at the start of analysis.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryNote {
    /// Required. Immutable. The kind of analysis that is handled by this
    /// discovery.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub analysis_kind: crate::model::NoteKind,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analysis_kind][crate::model::DiscoveryNote::analysis_kind].
    pub fn set_analysis_kind<T: std::convert::Into<crate::model::NoteKind>>(
        mut self,
        v: T,
    ) -> Self {
        self.analysis_kind = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DiscoveryNote"
    }
}

/// Provides information about the analysis status of a discovered resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryOccurrence {
    /// Whether the resource is continuously analyzed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub continuous_analysis: crate::model::discovery_occurrence::ContinuousAnalysis,

    /// The status of discovery for the resource.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub analysis_status: crate::model::discovery_occurrence::AnalysisStatus,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub analysis_completed:
        std::option::Option<crate::model::discovery_occurrence::AnalysisCompleted>,

    /// Indicates any errors encountered during analysis of a resource. There
    /// could be 0 or more of these errors.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub analysis_error: std::vec::Vec<rpc::model::Status>,

    /// When an error is encountered this will contain a LocalizedMessage under
    /// details to show to the user. The LocalizedMessage is output only and
    /// populated by the API.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub analysis_status_error: std::option::Option<rpc::model::Status>,

    /// The CPE of the resource being scanned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cpe: std::string::String,

    /// The last time this resource was scanned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_scan_time: std::option::Option<wkt::Timestamp>,

    /// The time occurrences related to this discovery occurrence were archived.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub archive_time: std::option::Option<wkt::Timestamp>,

    /// The status of an SBOM generation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sbom_status: std::option::Option<crate::model::discovery_occurrence::SBOMStatus>,

    /// The status of an vulnerability attestation generation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vulnerability_attestation:
        std::option::Option<crate::model::discovery_occurrence::VulnerabilityAttestation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [continuous_analysis][crate::model::DiscoveryOccurrence::continuous_analysis].
    pub fn set_continuous_analysis<
        T: std::convert::Into<crate::model::discovery_occurrence::ContinuousAnalysis>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.continuous_analysis = v.into();
        self
    }

    /// Sets the value of [analysis_status][crate::model::DiscoveryOccurrence::analysis_status].
    pub fn set_analysis_status<
        T: std::convert::Into<crate::model::discovery_occurrence::AnalysisStatus>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.analysis_status = v.into();
        self
    }

    /// Sets the value of [analysis_completed][crate::model::DiscoveryOccurrence::analysis_completed].
    pub fn set_analysis_completed<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::discovery_occurrence::AnalysisCompleted>,
    {
        self.analysis_completed = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analysis_completed][crate::model::DiscoveryOccurrence::analysis_completed].
    pub fn set_or_clear_analysis_completed<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::discovery_occurrence::AnalysisCompleted>,
    {
        self.analysis_completed = v.map(|x| x.into());
        self
    }

    /// Sets the value of [analysis_error][crate::model::DiscoveryOccurrence::analysis_error].
    pub fn set_analysis_error<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.analysis_error = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [analysis_status_error][crate::model::DiscoveryOccurrence::analysis_status_error].
    pub fn set_analysis_status_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.analysis_status_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analysis_status_error][crate::model::DiscoveryOccurrence::analysis_status_error].
    pub fn set_or_clear_analysis_status_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.analysis_status_error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cpe][crate::model::DiscoveryOccurrence::cpe].
    pub fn set_cpe<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe = v.into();
        self
    }

    /// Sets the value of [last_scan_time][crate::model::DiscoveryOccurrence::last_scan_time].
    pub fn set_last_scan_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_scan_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_scan_time][crate::model::DiscoveryOccurrence::last_scan_time].
    pub fn set_or_clear_last_scan_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_scan_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [archive_time][crate::model::DiscoveryOccurrence::archive_time].
    pub fn set_archive_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.archive_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [archive_time][crate::model::DiscoveryOccurrence::archive_time].
    pub fn set_or_clear_archive_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.archive_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sbom_status][crate::model::DiscoveryOccurrence::sbom_status].
    pub fn set_sbom_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::discovery_occurrence::SBOMStatus>,
    {
        self.sbom_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sbom_status][crate::model::DiscoveryOccurrence::sbom_status].
    pub fn set_or_clear_sbom_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::discovery_occurrence::SBOMStatus>,
    {
        self.sbom_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vulnerability_attestation][crate::model::DiscoveryOccurrence::vulnerability_attestation].
    pub fn set_vulnerability_attestation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::discovery_occurrence::VulnerabilityAttestation>,
    {
        self.vulnerability_attestation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vulnerability_attestation][crate::model::DiscoveryOccurrence::vulnerability_attestation].
    pub fn set_or_clear_vulnerability_attestation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::discovery_occurrence::VulnerabilityAttestation>,
    {
        self.vulnerability_attestation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DiscoveryOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DiscoveryOccurrence"
    }
}

/// Defines additional types related to [DiscoveryOccurrence].
pub mod discovery_occurrence {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates which analysis completed successfully. Multiple types of
    /// analysis can be performed on a single resource.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AnalysisCompleted {
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub analysis_type: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnalysisCompleted {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [analysis_type][crate::model::discovery_occurrence::AnalysisCompleted::analysis_type].
        pub fn set_analysis_type<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.analysis_type = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for AnalysisCompleted {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.DiscoveryOccurrence.AnalysisCompleted"
        }
    }

    /// The status of an SBOM generation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SBOMStatus {
        /// The progress of the SBOM generation.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub sbom_state: crate::model::discovery_occurrence::sbom_status::SBOMState,

        /// If there was an error generating an SBOM, this will indicate what that
        /// error was.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SBOMStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sbom_state][crate::model::discovery_occurrence::SBOMStatus::sbom_state].
        pub fn set_sbom_state<
            T: std::convert::Into<crate::model::discovery_occurrence::sbom_status::SBOMState>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.sbom_state = v.into();
            self
        }

        /// Sets the value of [error][crate::model::discovery_occurrence::SBOMStatus::error].
        pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.error = v.into();
            self
        }
    }

    impl wkt::message::Message for SBOMStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.DiscoveryOccurrence.SBOMStatus"
        }
    }

    /// Defines additional types related to [SBOMStatus].
    pub mod sbom_status {
        #[allow(unused_imports)]
        use super::*;

        /// An enum indicating the progress of the SBOM generation.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SBOMState {
            /// Default unknown state.
            Unspecified,
            /// SBOM scanning is pending.
            Pending,
            /// SBOM scanning has completed.
            Complete,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SBOMState::value] or
            /// [SBOMState::name].
            UnknownValue(sbom_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod sbom_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SBOMState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Pending => std::option::Option::Some(1),
                    Self::Complete => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SBOM_STATE_UNSPECIFIED"),
                    Self::Pending => std::option::Option::Some("PENDING"),
                    Self::Complete => std::option::Option::Some("COMPLETE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SBOMState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SBOMState {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SBOMState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Pending,
                    2 => Self::Complete,
                    _ => Self::UnknownValue(sbom_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SBOMState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SBOM_STATE_UNSPECIFIED" => Self::Unspecified,
                    "PENDING" => Self::Pending,
                    "COMPLETE" => Self::Complete,
                    _ => Self::UnknownValue(sbom_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SBOMState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Pending => serializer.serialize_i32(1),
                    Self::Complete => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SBOMState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SBOMState>::new(
                    ".grafeas.v1.DiscoveryOccurrence.SBOMStatus.SBOMState",
                ))
            }
        }
    }

    /// The status of an vulnerability attestation generation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VulnerabilityAttestation {

        /// The last time we attempted to generate an attestation.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub last_attempt_time: std::option::Option<wkt::Timestamp>,

        /// The success/failure state of the latest attestation attempt.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub state: crate::model::discovery_occurrence::vulnerability_attestation::VulnerabilityAttestationState,

        /// If failure, the error reason for why the attestation generation failed.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VulnerabilityAttestation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [last_attempt_time][crate::model::discovery_occurrence::VulnerabilityAttestation::last_attempt_time].
        pub fn set_last_attempt_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_attempt_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [last_attempt_time][crate::model::discovery_occurrence::VulnerabilityAttestation::last_attempt_time].
        pub fn set_or_clear_last_attempt_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_attempt_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [state][crate::model::discovery_occurrence::VulnerabilityAttestation::state].
        pub fn set_state<T: std::convert::Into<crate::model::discovery_occurrence::vulnerability_attestation::VulnerabilityAttestationState>>(mut self, v: T) -> Self{
            self.state = v.into();
            self
        }

        /// Sets the value of [error][crate::model::discovery_occurrence::VulnerabilityAttestation::error].
        pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.error = v.into();
            self
        }
    }

    impl wkt::message::Message for VulnerabilityAttestation {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.DiscoveryOccurrence.VulnerabilityAttestation"
        }
    }

    /// Defines additional types related to [VulnerabilityAttestation].
    pub mod vulnerability_attestation {
        #[allow(unused_imports)]
        use super::*;

        /// An enum indicating the state of the attestation generation.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum VulnerabilityAttestationState {
            /// Default unknown state.
            Unspecified,
            /// Attestation was successfully generated and stored.
            Success,
            /// Attestation was unsuccessfully generated and stored.
            Failure,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [VulnerabilityAttestationState::value] or
            /// [VulnerabilityAttestationState::name].
            UnknownValue(vulnerability_attestation_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod vulnerability_attestation_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl VulnerabilityAttestationState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Success => std::option::Option::Some(1),
                    Self::Failure => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("VULNERABILITY_ATTESTATION_STATE_UNSPECIFIED")
                    }
                    Self::Success => std::option::Option::Some("SUCCESS"),
                    Self::Failure => std::option::Option::Some("FAILURE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for VulnerabilityAttestationState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for VulnerabilityAttestationState {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for VulnerabilityAttestationState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Success,
                    2 => Self::Failure,
                    _ => Self::UnknownValue(vulnerability_attestation_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for VulnerabilityAttestationState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "VULNERABILITY_ATTESTATION_STATE_UNSPECIFIED" => Self::Unspecified,
                    "SUCCESS" => Self::Success,
                    "FAILURE" => Self::Failure,
                    _ => Self::UnknownValue(vulnerability_attestation_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for VulnerabilityAttestationState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Success => serializer.serialize_i32(1),
                    Self::Failure => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for VulnerabilityAttestationState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<VulnerabilityAttestationState>::new(
                    ".grafeas.v1.DiscoveryOccurrence.VulnerabilityAttestation.VulnerabilityAttestationState"))
            }
        }
    }

    /// Whether the resource is continuously analyzed.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ContinuousAnalysis {
        /// Unknown.
        Unspecified,
        /// The resource is continuously analyzed.
        Active,
        /// The resource is ignored for continuous analysis.
        Inactive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ContinuousAnalysis::value] or
        /// [ContinuousAnalysis::name].
        UnknownValue(continuous_analysis::UnknownValue),
    }

    #[doc(hidden)]
    pub mod continuous_analysis {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ContinuousAnalysis {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Inactive => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONTINUOUS_ANALYSIS_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ContinuousAnalysis {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ContinuousAnalysis {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ContinuousAnalysis {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Inactive,
                _ => Self::UnknownValue(continuous_analysis::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ContinuousAnalysis {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONTINUOUS_ANALYSIS_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "INACTIVE" => Self::Inactive,
                _ => Self::UnknownValue(continuous_analysis::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ContinuousAnalysis {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Inactive => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ContinuousAnalysis {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContinuousAnalysis>::new(
                ".grafeas.v1.DiscoveryOccurrence.ContinuousAnalysis",
            ))
        }
    }

    /// Analysis status for a resource. Currently for initial analysis only (not
    /// updated in continuous analysis).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AnalysisStatus {
        /// Unknown.
        Unspecified,
        /// Resource is known but no action has been taken yet.
        Pending,
        /// Resource is being analyzed.
        Scanning,
        /// Analysis has finished successfully.
        FinishedSuccess,
        /// Analysis has completed.
        Complete,
        /// Analysis has finished unsuccessfully, the analysis itself is in a bad
        /// state.
        FinishedFailed,
        /// The resource is known not to be supported.
        FinishedUnsupported,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AnalysisStatus::value] or
        /// [AnalysisStatus::name].
        UnknownValue(analysis_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod analysis_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AnalysisStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Scanning => std::option::Option::Some(2),
                Self::FinishedSuccess => std::option::Option::Some(3),
                Self::Complete => std::option::Option::Some(3),
                Self::FinishedFailed => std::option::Option::Some(4),
                Self::FinishedUnsupported => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ANALYSIS_STATUS_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Scanning => std::option::Option::Some("SCANNING"),
                Self::FinishedSuccess => std::option::Option::Some("FINISHED_SUCCESS"),
                Self::Complete => std::option::Option::Some("COMPLETE"),
                Self::FinishedFailed => std::option::Option::Some("FINISHED_FAILED"),
                Self::FinishedUnsupported => std::option::Option::Some("FINISHED_UNSUPPORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AnalysisStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AnalysisStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AnalysisStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Scanning,
                3 => Self::Complete,
                4 => Self::FinishedFailed,
                5 => Self::FinishedUnsupported,
                _ => Self::UnknownValue(analysis_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AnalysisStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANALYSIS_STATUS_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "SCANNING" => Self::Scanning,
                "FINISHED_SUCCESS" => Self::FinishedSuccess,
                "COMPLETE" => Self::Complete,
                "FINISHED_FAILED" => Self::FinishedFailed,
                "FINISHED_UNSUPPORTED" => Self::FinishedUnsupported,
                _ => Self::UnknownValue(analysis_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AnalysisStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Scanning => serializer.serialize_i32(2),
                Self::FinishedSuccess => serializer.serialize_i32(3),
                Self::Complete => serializer.serialize_i32(3),
                Self::FinishedFailed => serializer.serialize_i32(4),
                Self::FinishedUnsupported => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AnalysisStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AnalysisStatus>::new(
                ".grafeas.v1.DiscoveryOccurrence.AnalysisStatus",
            ))
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DSSEAttestationNote {
    /// DSSEHint hints at the purpose of the attestation authority.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hint: std::option::Option<crate::model::dsse_attestation_note::DSSEHint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DSSEAttestationNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hint][crate::model::DSSEAttestationNote::hint].
    pub fn set_hint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::dsse_attestation_note::DSSEHint>,
    {
        self.hint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hint][crate::model::DSSEAttestationNote::hint].
    pub fn set_or_clear_hint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::dsse_attestation_note::DSSEHint>,
    {
        self.hint = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DSSEAttestationNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DSSEAttestationNote"
    }
}

/// Defines additional types related to [DSSEAttestationNote].
pub mod dsse_attestation_note {
    #[allow(unused_imports)]
    use super::*;

    /// This submessage provides human-readable hints about the purpose of the
    /// authority. Because the name of a note acts as its resource reference, it is
    /// important to disambiguate the canonical name of the Note (which might be a
    /// UUID for security purposes) from "readable" names more suitable for debug
    /// output. Note that these hints should not be used to look up authorities in
    /// security sensitive contexts, such as when looking up attestations to
    /// verify.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DSSEHint {
        /// Required. The human readable name of this attestation authority, for
        /// example "cloudbuild-prod".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub human_readable_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DSSEHint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [human_readable_name][crate::model::dsse_attestation_note::DSSEHint::human_readable_name].
        pub fn set_human_readable_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.human_readable_name = v.into();
            self
        }
    }

    impl wkt::message::Message for DSSEHint {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.DSSEAttestationNote.DSSEHint"
        }
    }
}

/// Deprecated. Prefer to use a regular Occurrence, and populate the
/// Envelope at the top level of the Occurrence.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DSSEAttestationOccurrence {
    /// If doing something security critical, make sure to verify the signatures in
    /// this metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub envelope: std::option::Option<crate::model::Envelope>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub decoded_payload:
        std::option::Option<crate::model::dsse_attestation_occurrence::DecodedPayload>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DSSEAttestationOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [envelope][crate::model::DSSEAttestationOccurrence::envelope].
    pub fn set_envelope<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Envelope>,
    {
        self.envelope = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [envelope][crate::model::DSSEAttestationOccurrence::envelope].
    pub fn set_or_clear_envelope<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Envelope>,
    {
        self.envelope = v.map(|x| x.into());
        self
    }

    /// Sets the value of [decoded_payload][crate::model::DSSEAttestationOccurrence::decoded_payload].
    ///
    /// Note that all the setters affecting `decoded_payload` are mutually
    /// exclusive.
    pub fn set_decoded_payload<
        T: std::convert::Into<
                std::option::Option<crate::model::dsse_attestation_occurrence::DecodedPayload>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.decoded_payload = v.into();
        self
    }

    /// The value of [decoded_payload][crate::model::DSSEAttestationOccurrence::decoded_payload]
    /// if it holds a `Statement`, `None` if the field is not set or
    /// holds a different branch.
    pub fn statement(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InTotoStatement>> {
        #[allow(unreachable_patterns)]
        self.decoded_payload.as_ref().and_then(|v| match v {
            crate::model::dsse_attestation_occurrence::DecodedPayload::Statement(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [decoded_payload][crate::model::DSSEAttestationOccurrence::decoded_payload]
    /// to hold a `Statement`.
    ///
    /// Note that all the setters affecting `decoded_payload` are
    /// mutually exclusive.
    pub fn set_statement<T: std::convert::Into<std::boxed::Box<crate::model::InTotoStatement>>>(
        mut self,
        v: T,
    ) -> Self {
        self.decoded_payload = std::option::Option::Some(
            crate::model::dsse_attestation_occurrence::DecodedPayload::Statement(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DSSEAttestationOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DSSEAttestationOccurrence"
    }
}

/// Defines additional types related to [DSSEAttestationOccurrence].
pub mod dsse_attestation_occurrence {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DecodedPayload {
        Statement(std::boxed::Box<crate::model::InTotoStatement>),
    }
}

/// An instance of an analysis type that has been found on a resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Occurrence {
    /// Output only. The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Immutable. A URI that represents the resource for which the
    /// occurrence applies. For example,
    /// `<https://gcr.io/project/image@sha256:123abc>` for a Docker image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_uri: std::string::String,

    /// Required. Immutable. The analysis note associated with this occurrence, in
    /// the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
    /// used as a filter in list requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub note_name: std::string::String,

    /// Output only. This explicitly denotes which of the occurrence details are
    /// specified. This field can be used as a filter in list requests.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub kind: crate::model::NoteKind,

    /// A description of actions that can be taken to remedy the note.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub remediation: std::string::String,

    /// Output only. The time this occurrence was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this occurrence was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// <https://github.com/secure-systems-lab/dsse>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub envelope: std::option::Option<crate::model::Envelope>,

    /// Required. Immutable. Describes the details of the note kind found on this
    /// resource.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::occurrence::Details>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Occurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Occurrence::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::Occurrence::resource_uri].
    pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [note_name][crate::model::Occurrence::note_name].
    pub fn set_note_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.note_name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Occurrence::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::NoteKind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [remediation][crate::model::Occurrence::remediation].
    pub fn set_remediation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remediation = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Occurrence::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Occurrence::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Occurrence::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Occurrence::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [envelope][crate::model::Occurrence::envelope].
    pub fn set_envelope<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Envelope>,
    {
        self.envelope = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [envelope][crate::model::Occurrence::envelope].
    pub fn set_or_clear_envelope<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Envelope>,
    {
        self.envelope = v.map(|x| x.into());
        self
    }

    /// Sets the value of [details][crate::model::Occurrence::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::occurrence::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Vulnerability`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vulnerability(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VulnerabilityOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Vulnerability(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Vulnerability`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_vulnerability<
        T: std::convert::Into<std::boxed::Box<crate::model::VulnerabilityOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Vulnerability(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Build`, `None` if the field is not set or
    /// holds a different branch.
    pub fn build(&self) -> std::option::Option<&std::boxed::Box<crate::model::BuildOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Build(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Build`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_build<T: std::convert::Into<std::boxed::Box<crate::model::BuildOccurrence>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Build(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Image`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image(&self) -> std::option::Option<&std::boxed::Box<crate::model::ImageOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Image(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Image`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_image<T: std::convert::Into<std::boxed::Box<crate::model::ImageOccurrence>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Image(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Package`, `None` if the field is not set or
    /// holds a different branch.
    pub fn package(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PackageOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Package(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Package`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_package<T: std::convert::Into<std::boxed::Box<crate::model::PackageOccurrence>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Package(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Deployment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deployment(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeploymentOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Deployment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Deployment`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_deployment<
        T: std::convert::Into<std::boxed::Box<crate::model::DeploymentOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Deployment(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Discovery`, `None` if the field is not set or
    /// holds a different branch.
    pub fn discovery(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Discovery(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Discovery`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_discovery<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Discovery(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Attestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn attestation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AttestationOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Attestation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Attestation`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_attestation<
        T: std::convert::Into<std::boxed::Box<crate::model::AttestationOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Attestation(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Upgrade`, `None` if the field is not set or
    /// holds a different branch.
    pub fn upgrade(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpgradeOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Upgrade(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Upgrade`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_upgrade<T: std::convert::Into<std::boxed::Box<crate::model::UpgradeOccurrence>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Upgrade(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Compliance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compliance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComplianceOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Compliance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Compliance`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_compliance<
        T: std::convert::Into<std::boxed::Box<crate::model::ComplianceOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Compliance(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `DsseAttestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dsse_attestation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DSSEAttestationOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::DsseAttestation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `DsseAttestation`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_dsse_attestation<
        T: std::convert::Into<std::boxed::Box<crate::model::DSSEAttestationOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::DsseAttestation(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `SbomReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sbom_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SBOMReferenceOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::SbomReference(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `SbomReference`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_sbom_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::SBOMReferenceOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::SbomReference(v.into()));
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Secret`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret(&self) -> std::option::Option<&std::boxed::Box<crate::model::SecretOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Secret(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Secret`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_secret<T: std::convert::Into<std::boxed::Box<crate::model::SecretOccurrence>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::occurrence::Details::Secret(v.into()));
        self
    }
}

impl wkt::message::Message for Occurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Occurrence"
    }
}

/// Defines additional types related to [Occurrence].
pub mod occurrence {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Immutable. Describes the details of the note kind found on this
    /// resource.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Details {
        /// Describes a security vulnerability.
        Vulnerability(std::boxed::Box<crate::model::VulnerabilityOccurrence>),
        /// Describes a verifiable build.
        Build(std::boxed::Box<crate::model::BuildOccurrence>),
        /// Describes how this resource derives from the basis in the associated
        /// note.
        Image(std::boxed::Box<crate::model::ImageOccurrence>),
        /// Describes the installation of a package on the linked resource.
        Package(std::boxed::Box<crate::model::PackageOccurrence>),
        /// Describes the deployment of an artifact on a runtime.
        Deployment(std::boxed::Box<crate::model::DeploymentOccurrence>),
        /// Describes when a resource was discovered.
        Discovery(std::boxed::Box<crate::model::DiscoveryOccurrence>),
        /// Describes an attestation of an artifact.
        Attestation(std::boxed::Box<crate::model::AttestationOccurrence>),
        /// Describes an available package upgrade on the linked resource.
        Upgrade(std::boxed::Box<crate::model::UpgradeOccurrence>),
        /// Describes a compliance violation on a linked resource.
        Compliance(std::boxed::Box<crate::model::ComplianceOccurrence>),
        /// Describes an attestation of an artifact using dsse.
        DsseAttestation(std::boxed::Box<crate::model::DSSEAttestationOccurrence>),
        /// Describes a specific SBOM reference occurrences.
        SbomReference(std::boxed::Box<crate::model::SBOMReferenceOccurrence>),
        /// Describes a secret.
        Secret(std::boxed::Box<crate::model::SecretOccurrence>),
    }
}

/// A type of analysis that can be done for a resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Note {
    /// Output only. The name of the note in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A one sentence description of this note.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub short_description: std::string::String,

    /// A detailed description of this note.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub long_description: std::string::String,

    /// Output only. The type of analysis. This field can be used as a filter in
    /// list requests.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub kind: crate::model::NoteKind,

    /// URLs associated with this note.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub related_url: std::vec::Vec<crate::model::RelatedUrl>,

    /// Time of expiration for this note. Empty if note does not expire.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this note was created. This field can be used as a
    /// filter in list requests.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this note was last updated. This field can be used as
    /// a filter in list requests.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Other notes related to this note.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub related_note_names: std::vec::Vec<std::string::String>,

    /// Required. Immutable. The type of analysis this note represents.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::note::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Note {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Note::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [short_description][crate::model::Note::short_description].
    pub fn set_short_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.short_description = v.into();
        self
    }

    /// Sets the value of [long_description][crate::model::Note::long_description].
    pub fn set_long_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.long_description = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Note::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::NoteKind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [related_url][crate::model::Note::related_url].
    pub fn set_related_url<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedUrl>,
    {
        use std::iter::Iterator;
        self.related_url = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [expiration_time][crate::model::Note::expiration_time].
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::Note::expiration_time].
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Note::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Note::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Note::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Note::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [related_note_names][crate::model::Note::related_note_names].
    pub fn set_related_note_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.related_note_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [r#type][crate::model::Note::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::note::Type>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Vulnerability`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vulnerability(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VulnerabilityNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Vulnerability(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Vulnerability`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_vulnerability<
        T: std::convert::Into<std::boxed::Box<crate::model::VulnerabilityNote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Vulnerability(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Build`, `None` if the field is not set or
    /// holds a different branch.
    pub fn build(&self) -> std::option::Option<&std::boxed::Box<crate::model::BuildNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Build(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Build`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_build<T: std::convert::Into<std::boxed::Box<crate::model::BuildNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Build(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Image`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image(&self) -> std::option::Option<&std::boxed::Box<crate::model::ImageNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Image(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Image`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_image<T: std::convert::Into<std::boxed::Box<crate::model::ImageNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Image(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Package`, `None` if the field is not set or
    /// holds a different branch.
    pub fn package(&self) -> std::option::Option<&std::boxed::Box<crate::model::PackageNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Package(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Package`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_package<T: std::convert::Into<std::boxed::Box<crate::model::PackageNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Package(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Deployment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deployment(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeploymentNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Deployment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Deployment`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_deployment<T: std::convert::Into<std::boxed::Box<crate::model::DeploymentNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Deployment(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Discovery`, `None` if the field is not set or
    /// holds a different branch.
    pub fn discovery(&self) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Discovery(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Discovery`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_discovery<T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Discovery(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Attestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn attestation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AttestationNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Attestation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Attestation`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_attestation<
        T: std::convert::Into<std::boxed::Box<crate::model::AttestationNote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Attestation(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Upgrade`, `None` if the field is not set or
    /// holds a different branch.
    pub fn upgrade(&self) -> std::option::Option<&std::boxed::Box<crate::model::UpgradeNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Upgrade(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Upgrade`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_upgrade<T: std::convert::Into<std::boxed::Box<crate::model::UpgradeNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Upgrade(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Compliance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compliance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComplianceNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Compliance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Compliance`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_compliance<T: std::convert::Into<std::boxed::Box<crate::model::ComplianceNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Compliance(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `DsseAttestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dsse_attestation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DSSEAttestationNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::DsseAttestation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `DsseAttestation`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_dsse_attestation<
        T: std::convert::Into<std::boxed::Box<crate::model::DSSEAttestationNote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::note::Type::DsseAttestation(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `VulnerabilityAssessment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vulnerability_assessment(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VulnerabilityAssessmentNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::VulnerabilityAssessment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `VulnerabilityAssessment`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_vulnerability_assessment<
        T: std::convert::Into<std::boxed::Box<crate::model::VulnerabilityAssessmentNote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::note::Type::VulnerabilityAssessment(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `SbomReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sbom_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SBOMReferenceNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::SbomReference(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `SbomReference`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_sbom_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::SBOMReferenceNote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::SbomReference(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Secret`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret(&self) -> std::option::Option<&std::boxed::Box<crate::model::SecretNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Secret(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Secret`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_secret<T: std::convert::Into<std::boxed::Box<crate::model::SecretNote>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::note::Type::Secret(v.into()));
        self
    }
}

impl wkt::message::Message for Note {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Note"
    }
}

/// Defines additional types related to [Note].
pub mod note {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Immutable. The type of analysis this note represents.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// A note describing a package vulnerability.
        Vulnerability(std::boxed::Box<crate::model::VulnerabilityNote>),
        /// A note describing build provenance for a verifiable build.
        Build(std::boxed::Box<crate::model::BuildNote>),
        /// A note describing a base image.
        Image(std::boxed::Box<crate::model::ImageNote>),
        /// A note describing a package hosted by various package managers.
        Package(std::boxed::Box<crate::model::PackageNote>),
        /// A note describing something that can be deployed.
        Deployment(std::boxed::Box<crate::model::DeploymentNote>),
        /// A note describing the initial analysis of a resource.
        Discovery(std::boxed::Box<crate::model::DiscoveryNote>),
        /// A note describing an attestation role.
        Attestation(std::boxed::Box<crate::model::AttestationNote>),
        /// A note describing available package upgrades.
        Upgrade(std::boxed::Box<crate::model::UpgradeNote>),
        /// A note describing a compliance check.
        Compliance(std::boxed::Box<crate::model::ComplianceNote>),
        /// A note describing a dsse attestation note.
        DsseAttestation(std::boxed::Box<crate::model::DSSEAttestationNote>),
        /// A note describing a vulnerability assessment.
        VulnerabilityAssessment(std::boxed::Box<crate::model::VulnerabilityAssessmentNote>),
        /// A note describing an SBOM reference.
        SbomReference(std::boxed::Box<crate::model::SBOMReferenceNote>),
        /// A note describing a secret.
        Secret(std::boxed::Box<crate::model::SecretNote>),
    }
}

/// Request to get an occurrence.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetOccurrenceRequest {
    /// The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOccurrenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOccurrenceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOccurrenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GetOccurrenceRequest"
    }
}

/// Request to list occurrences.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOccurrencesRequest {
    /// The name of the project to list occurrences for in the form of
    /// `projects/[PROJECT_ID]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Number of occurrences to return in the list. Must be positive. Max allowed
    /// page size is 1000. If not specified, page size defaults to 20.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOccurrencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOccurrencesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOccurrencesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOccurrencesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOccurrencesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOccurrencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListOccurrencesRequest"
    }
}

/// Response for listing occurrences.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOccurrencesResponse {
    /// The occurrences requested.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub occurrences: std::vec::Vec<crate::model::Occurrence>,

    /// The next pagination token in the list response. It should be used as
    /// `page_token` for the following request. An empty value means no more
    /// results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOccurrencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [occurrences][crate::model::ListOccurrencesResponse::occurrences].
    pub fn set_occurrences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Occurrence>,
    {
        use std::iter::Iterator;
        self.occurrences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOccurrencesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOccurrencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListOccurrencesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOccurrencesResponse {
    type PageItem = crate::model::Occurrence;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.occurrences
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to delete an occurrence.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteOccurrenceRequest {
    /// The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteOccurrenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteOccurrenceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteOccurrenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DeleteOccurrenceRequest"
    }
}

/// Request to create a new occurrence.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateOccurrenceRequest {
    /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
    /// the occurrence is to be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The occurrence to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub occurrence: std::option::Option<crate::model::Occurrence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateOccurrenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateOccurrenceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [occurrence][crate::model::CreateOccurrenceRequest::occurrence].
    pub fn set_occurrence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Occurrence>,
    {
        self.occurrence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [occurrence][crate::model::CreateOccurrenceRequest::occurrence].
    pub fn set_or_clear_occurrence<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Occurrence>,
    {
        self.occurrence = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateOccurrenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CreateOccurrenceRequest"
    }
}

/// Request to update an occurrence.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateOccurrenceRequest {
    /// The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The updated occurrence.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub occurrence: std::option::Option<crate::model::Occurrence>,

    /// The fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateOccurrenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateOccurrenceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [occurrence][crate::model::UpdateOccurrenceRequest::occurrence].
    pub fn set_occurrence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Occurrence>,
    {
        self.occurrence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [occurrence][crate::model::UpdateOccurrenceRequest::occurrence].
    pub fn set_or_clear_occurrence<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Occurrence>,
    {
        self.occurrence = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateOccurrenceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateOccurrenceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateOccurrenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpdateOccurrenceRequest"
    }
}

/// Request to get a note.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNoteRequest {
    /// The name of the note in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNoteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GetNoteRequest"
    }
}

/// Request to get the note to which the specified occurrence is attached.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetOccurrenceNoteRequest {
    /// The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOccurrenceNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOccurrenceNoteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOccurrenceNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GetOccurrenceNoteRequest"
    }
}

/// Request to list notes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotesRequest {
    /// The name of the project to list notes for in the form of
    /// `projects/[PROJECT_ID]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Number of notes to return in the list. Must be positive. Max allowed page
    /// size is 1000. If not specified, page size defaults to 20.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNotesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNotesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNotesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNotesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListNotesRequest"
    }
}

/// Response for listing notes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotesResponse {
    /// The notes requested.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub notes: std::vec::Vec<crate::model::Note>,

    /// The next pagination token in the list response. It should be used as
    /// `page_token` for the following request. An empty value means no more
    /// results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNotesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notes][crate::model::ListNotesResponse::notes].
    pub fn set_notes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Note>,
    {
        use std::iter::Iterator;
        self.notes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNotesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNotesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListNotesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNotesResponse {
    type PageItem = crate::model::Note;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.notes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to delete a note.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNoteRequest {
    /// The name of the note in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNoteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DeleteNoteRequest"
    }
}

/// Request to create a new note.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNoteRequest {
    /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
    /// the note is to be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The ID to use for this note.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub note_id: std::string::String,

    /// The note to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub note: std::option::Option<crate::model::Note>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNoteRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [note_id][crate::model::CreateNoteRequest::note_id].
    pub fn set_note_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.note_id = v.into();
        self
    }

    /// Sets the value of [note][crate::model::CreateNoteRequest::note].
    pub fn set_note<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Note>,
    {
        self.note = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [note][crate::model::CreateNoteRequest::note].
    pub fn set_or_clear_note<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Note>,
    {
        self.note = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CreateNoteRequest"
    }
}

/// Request to update a note.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateNoteRequest {
    /// The name of the note in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The updated note.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub note: std::option::Option<crate::model::Note>,

    /// The fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateNoteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [note][crate::model::UpdateNoteRequest::note].
    pub fn set_note<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Note>,
    {
        self.note = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [note][crate::model::UpdateNoteRequest::note].
    pub fn set_or_clear_note<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Note>,
    {
        self.note = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNoteRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNoteRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpdateNoteRequest"
    }
}

/// Request to list occurrences for a note.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNoteOccurrencesRequest {
    /// The name of the note to list occurrences for in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Number of occurrences to return in the list.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNoteOccurrencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListNoteOccurrencesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNoteOccurrencesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNoteOccurrencesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNoteOccurrencesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNoteOccurrencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListNoteOccurrencesRequest"
    }
}

/// Response for listing occurrences for a note.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNoteOccurrencesResponse {
    /// The occurrences attached to the specified note.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub occurrences: std::vec::Vec<crate::model::Occurrence>,

    /// Token to provide to skip to a particular spot in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNoteOccurrencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [occurrences][crate::model::ListNoteOccurrencesResponse::occurrences].
    pub fn set_occurrences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Occurrence>,
    {
        use std::iter::Iterator;
        self.occurrences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNoteOccurrencesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNoteOccurrencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListNoteOccurrencesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNoteOccurrencesResponse {
    type PageItem = crate::model::Occurrence;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.occurrences
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to create notes in batch.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateNotesRequest {
    /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
    /// the notes are to be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The notes to create. Max allowed length is 1000.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub notes: std::collections::HashMap<std::string::String, crate::model::Note>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateNotesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateNotesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [notes][crate::model::BatchCreateNotesRequest::notes].
    pub fn set_notes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Note>,
    {
        use std::iter::Iterator;
        self.notes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateNotesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BatchCreateNotesRequest"
    }
}

/// Response for creating notes in batch.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateNotesResponse {
    /// The notes that were created.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub notes: std::vec::Vec<crate::model::Note>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateNotesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notes][crate::model::BatchCreateNotesResponse::notes].
    pub fn set_notes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Note>,
    {
        use std::iter::Iterator;
        self.notes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateNotesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BatchCreateNotesResponse"
    }
}

/// Request to create occurrences in batch.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateOccurrencesRequest {
    /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
    /// the occurrences are to be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The occurrences to create. Max allowed length is 1000.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub occurrences: std::vec::Vec<crate::model::Occurrence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateOccurrencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateOccurrencesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [occurrences][crate::model::BatchCreateOccurrencesRequest::occurrences].
    pub fn set_occurrences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Occurrence>,
    {
        use std::iter::Iterator;
        self.occurrences = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateOccurrencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BatchCreateOccurrencesRequest"
    }
}

/// Response for creating occurrences in batch.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateOccurrencesResponse {
    /// The occurrences that were created.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub occurrences: std::vec::Vec<crate::model::Occurrence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateOccurrencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [occurrences][crate::model::BatchCreateOccurrencesResponse::occurrences].
    pub fn set_occurrences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Occurrence>,
    {
        use std::iter::Iterator;
        self.occurrences = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateOccurrencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BatchCreateOccurrencesResponse"
    }
}

/// Layer holds metadata specific to a layer of a Docker image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Layer {
    /// Required. The recovered Dockerfile directive used to construct this layer.
    /// See <https://docs.docker.com/engine/reference/builder/> for more information.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub directive: std::string::String,

    /// The recovered arguments to the Dockerfile directive.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub arguments: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Layer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [directive][crate::model::Layer::directive].
    pub fn set_directive<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.directive = v.into();
        self
    }

    /// Sets the value of [arguments][crate::model::Layer::arguments].
    pub fn set_arguments<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.arguments = v.into();
        self
    }
}

impl wkt::message::Message for Layer {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Layer"
    }
}

/// A set of properties that uniquely identify a given Docker image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Fingerprint {
    /// Required. The layer ID of the final layer in the Docker image's v1
    /// representation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub v1_name: std::string::String,

    /// Required. The ordered list of v2 blobs that represent a given image.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub v2_blob: std::vec::Vec<std::string::String>,

    /// Output only. The name of the image's v2 blobs computed via:
    /// [bottom] := v2_blob[bottom]
    /// [N] := sha256(v2_blob[N] + " " + v2_name[N+1])
    /// Only the name of the final blob is kept.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub v2_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Fingerprint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [v1_name][crate::model::Fingerprint::v1_name].
    pub fn set_v1_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.v1_name = v.into();
        self
    }

    /// Sets the value of [v2_blob][crate::model::Fingerprint::v2_blob].
    pub fn set_v2_blob<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.v2_blob = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [v2_name][crate::model::Fingerprint::v2_name].
    pub fn set_v2_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.v2_name = v.into();
        self
    }
}

impl wkt::message::Message for Fingerprint {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Fingerprint"
    }
}

/// Basis describes the base image portion (Note) of the DockerImage
/// relationship. Linked occurrences are derived from this or an equivalent image
/// via:
/// FROM <Basis.resource_url>
/// Or an equivalent reference, e.g., a tag of the resource_url.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImageNote {
    /// Required. Immutable. The resource_url for the resource representing the
    /// basis of associated occurrence images.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_url: std::string::String,

    /// Required. Immutable. The fingerprint of the base image.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fingerprint: std::option::Option<crate::model::Fingerprint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_url][crate::model::ImageNote::resource_url].
    pub fn set_resource_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_url = v.into();
        self
    }

    /// Sets the value of [fingerprint][crate::model::ImageNote::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fingerprint>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::ImageNote::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fingerprint>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImageNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ImageNote"
    }
}

/// Details of the derived image portion of the DockerImage relationship. This
/// image would be produced from a Dockerfile with FROM <DockerImage.Basis in
/// attached Note>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImageOccurrence {
    /// Required. The fingerprint of the derived image.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fingerprint: std::option::Option<crate::model::Fingerprint>,

    /// Output only. The number of layers by which this image differs from the
    /// associated image basis.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub distance: i32,

    /// This contains layer-specific metadata, if populated it has length
    /// "distance" and is ordered with [distance] being the layer immediately
    /// following the base image and [1] being the final layer.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub layer_info: std::vec::Vec<crate::model::Layer>,

    /// Output only. This contains the base image URL for the derived image
    /// occurrence.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub base_resource_url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fingerprint][crate::model::ImageOccurrence::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fingerprint>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::ImageOccurrence::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fingerprint>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [distance][crate::model::ImageOccurrence::distance].
    pub fn set_distance<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.distance = v.into();
        self
    }

    /// Sets the value of [layer_info][crate::model::ImageOccurrence::layer_info].
    pub fn set_layer_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Layer>,
    {
        use std::iter::Iterator;
        self.layer_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [base_resource_url][crate::model::ImageOccurrence::base_resource_url].
    pub fn set_base_resource_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.base_resource_url = v.into();
        self
    }
}

impl wkt::message::Message for ImageOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ImageOccurrence"
    }
}

/// Steps taken to build the artifact.
/// For a TaskRun, typically each container corresponds to one step in the
/// recipe.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Recipe {
    /// URI indicating what type of recipe was performed. It determines the meaning
    /// of recipe.entryPoint, recipe.arguments, recipe.environment, and materials.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Index in materials containing the recipe steps that are not implied by
    /// recipe.type. For example, if the recipe type were "make", then this would
    /// point to the source containing the Makefile, not the make program itself.
    /// Set to -1 if the recipe doesn't come from a material, as zero is default
    /// unset value for int64.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub defined_in_material: i64,

    /// String identifying the entry point into the build.
    /// This is often a path to a configuration file and/or a target label within
    /// that file. The syntax and meaning are defined by recipe.type. For example,
    /// if the recipe type were "make", then this would reference the directory in
    /// which to run make as well as which target to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entry_point: std::string::String,

    /// Collection of all external inputs that influenced the build on top of
    /// recipe.definedInMaterial and recipe.entryPoint. For example, if the recipe
    /// type were "make", then this might be the flags passed to make aside from
    /// the target, which is captured in recipe.entryPoint. Since the arguments
    /// field can greatly vary in structure, depending on the builder and recipe
    /// type, this is of form "Any".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub arguments: std::vec::Vec<wkt::Any>,

    /// Any other builder-controlled inputs necessary for correctly evaluating the
    /// recipe. Usually only needed for reproducing the build but not evaluated as
    /// part of policy. Since the environment field can greatly vary in structure,
    /// depending on the builder and recipe type, this is of form "Any".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub environment: std::vec::Vec<wkt::Any>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Recipe {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Recipe::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [defined_in_material][crate::model::Recipe::defined_in_material].
    pub fn set_defined_in_material<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.defined_in_material = v.into();
        self
    }

    /// Sets the value of [entry_point][crate::model::Recipe::entry_point].
    pub fn set_entry_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_point = v.into();
        self
    }

    /// Sets the value of [arguments][crate::model::Recipe::arguments].
    pub fn set_arguments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>,
    {
        use std::iter::Iterator;
        self.arguments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [environment][crate::model::Recipe::environment].
    pub fn set_environment<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>,
    {
        use std::iter::Iterator;
        self.environment = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Recipe {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Recipe"
    }
}

/// Indicates that the builder claims certain fields in this message to be
/// complete.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Completeness {
    /// If true, the builder claims that recipe.arguments is complete, meaning that
    /// all external inputs are properly captured in the recipe.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub arguments: bool,

    /// If true, the builder claims that recipe.environment is claimed to be
    /// complete.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub environment: bool,

    /// If true, the builder claims that materials are complete, usually through
    /// some controls to prevent network access. Sometimes called "hermetic".
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub materials: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Completeness {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [arguments][crate::model::Completeness::arguments].
    pub fn set_arguments<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.arguments = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::Completeness::environment].
    pub fn set_environment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [materials][crate::model::Completeness::materials].
    pub fn set_materials<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.materials = v.into();
        self
    }
}

impl wkt::message::Message for Completeness {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Completeness"
    }
}

/// Other properties of the build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Metadata {
    /// Identifies the particular build invocation, which can be useful for finding
    /// associated logs or other ad-hoc analysis. The value SHOULD be globally
    /// unique, per in-toto Provenance spec.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub build_invocation_id: std::string::String,

    /// The timestamp of when the build started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub build_started_on: std::option::Option<wkt::Timestamp>,

    /// The timestamp of when the build completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub build_finished_on: std::option::Option<wkt::Timestamp>,

    /// Indicates that the builder claims certain fields in this message to be
    /// complete.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completeness: std::option::Option<crate::model::Completeness>,

    /// If true, the builder claims that running the recipe on materials will
    /// produce bit-for-bit identical output.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub reproducible: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Metadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build_invocation_id][crate::model::Metadata::build_invocation_id].
    pub fn set_build_invocation_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.build_invocation_id = v.into();
        self
    }

    /// Sets the value of [build_started_on][crate::model::Metadata::build_started_on].
    pub fn set_build_started_on<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.build_started_on = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_started_on][crate::model::Metadata::build_started_on].
    pub fn set_or_clear_build_started_on<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.build_started_on = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_finished_on][crate::model::Metadata::build_finished_on].
    pub fn set_build_finished_on<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.build_finished_on = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_finished_on][crate::model::Metadata::build_finished_on].
    pub fn set_or_clear_build_finished_on<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.build_finished_on = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completeness][crate::model::Metadata::completeness].
    pub fn set_completeness<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Completeness>,
    {
        self.completeness = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completeness][crate::model::Metadata::completeness].
    pub fn set_or_clear_completeness<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Completeness>,
    {
        self.completeness = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reproducible][crate::model::Metadata::reproducible].
    pub fn set_reproducible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reproducible = v.into();
        self
    }
}

impl wkt::message::Message for Metadata {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Metadata"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuilderConfig {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuilderConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::BuilderConfig::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for BuilderConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BuilderConfig"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InTotoProvenance {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub builder_config: std::option::Option<crate::model::BuilderConfig>,

    /// Identifies the configuration used for the build.
    /// When combined with materials, this SHOULD fully describe the build,
    /// such that re-running this recipe results in bit-for-bit identical output
    /// (if the build is reproducible).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recipe: std::option::Option<crate::model::Recipe>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::Metadata>,

    /// The collection of artifacts that influenced the build including sources,
    /// dependencies, build tools, base images, and so on. This is considered to be
    /// incomplete unless metadata.completeness.materials is true. Unset or null is
    /// equivalent to empty.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub materials: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InTotoProvenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builder_config][crate::model::InTotoProvenance::builder_config].
    pub fn set_builder_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuilderConfig>,
    {
        self.builder_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [builder_config][crate::model::InTotoProvenance::builder_config].
    pub fn set_or_clear_builder_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuilderConfig>,
    {
        self.builder_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recipe][crate::model::InTotoProvenance::recipe].
    pub fn set_recipe<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Recipe>,
    {
        self.recipe = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recipe][crate::model::InTotoProvenance::recipe].
    pub fn set_or_clear_recipe<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Recipe>,
    {
        self.recipe = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::InTotoProvenance::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::InTotoProvenance::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [materials][crate::model::InTotoProvenance::materials].
    pub fn set_materials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.materials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InTotoProvenance {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.InTotoProvenance"
    }
}

/// Spec defined at
/// <https://github.com/in-toto/attestation/tree/main/spec#statement> The
/// serialized InTotoStatement will be stored as Envelope.payload.
/// Envelope.payloadType is always "application/vnd.in-toto+json".
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InTotoStatement {
    /// Always `<https://in-toto.io/Statement/v0.1>`.
    #[serde(rename = "_type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub subject: std::vec::Vec<crate::model::Subject>,

    /// `<https://slsa.dev/provenance/v0.1>` for SlsaProvenance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predicate_type: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub predicate: std::option::Option<crate::model::in_toto_statement::Predicate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InTotoStatement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::InTotoStatement::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::InTotoStatement::subject].
    pub fn set_subject<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Subject>,
    {
        use std::iter::Iterator;
        self.subject = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [predicate_type][crate::model::InTotoStatement::predicate_type].
    pub fn set_predicate_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predicate_type = v.into();
        self
    }

    /// Sets the value of [predicate][crate::model::InTotoStatement::predicate].
    ///
    /// Note that all the setters affecting `predicate` are mutually
    /// exclusive.
    pub fn set_predicate<
        T: std::convert::Into<std::option::Option<crate::model::in_toto_statement::Predicate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predicate = v.into();
        self
    }

    /// The value of [predicate][crate::model::InTotoStatement::predicate]
    /// if it holds a `Provenance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn provenance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InTotoProvenance>> {
        #[allow(unreachable_patterns)]
        self.predicate.as_ref().and_then(|v| match v {
            crate::model::in_toto_statement::Predicate::Provenance(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [predicate][crate::model::InTotoStatement::predicate]
    /// to hold a `Provenance`.
    ///
    /// Note that all the setters affecting `predicate` are
    /// mutually exclusive.
    pub fn set_provenance<
        T: std::convert::Into<std::boxed::Box<crate::model::InTotoProvenance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predicate = std::option::Option::Some(
            crate::model::in_toto_statement::Predicate::Provenance(v.into()),
        );
        self
    }

    /// The value of [predicate][crate::model::InTotoStatement::predicate]
    /// if it holds a `SlsaProvenance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn slsa_provenance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SlsaProvenance>> {
        #[allow(unreachable_patterns)]
        self.predicate.as_ref().and_then(|v| match v {
            crate::model::in_toto_statement::Predicate::SlsaProvenance(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [predicate][crate::model::InTotoStatement::predicate]
    /// to hold a `SlsaProvenance`.
    ///
    /// Note that all the setters affecting `predicate` are
    /// mutually exclusive.
    pub fn set_slsa_provenance<
        T: std::convert::Into<std::boxed::Box<crate::model::SlsaProvenance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predicate = std::option::Option::Some(
            crate::model::in_toto_statement::Predicate::SlsaProvenance(v.into()),
        );
        self
    }

    /// The value of [predicate][crate::model::InTotoStatement::predicate]
    /// if it holds a `SlsaProvenanceZeroTwo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn slsa_provenance_zero_two(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SlsaProvenanceZeroTwo>> {
        #[allow(unreachable_patterns)]
        self.predicate.as_ref().and_then(|v| match v {
            crate::model::in_toto_statement::Predicate::SlsaProvenanceZeroTwo(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [predicate][crate::model::InTotoStatement::predicate]
    /// to hold a `SlsaProvenanceZeroTwo`.
    ///
    /// Note that all the setters affecting `predicate` are
    /// mutually exclusive.
    pub fn set_slsa_provenance_zero_two<
        T: std::convert::Into<std::boxed::Box<crate::model::SlsaProvenanceZeroTwo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predicate = std::option::Option::Some(
            crate::model::in_toto_statement::Predicate::SlsaProvenanceZeroTwo(v.into()),
        );
        self
    }
}

impl wkt::message::Message for InTotoStatement {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.InTotoStatement"
    }
}

/// Defines additional types related to [InTotoStatement].
pub mod in_toto_statement {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Predicate {
        Provenance(std::boxed::Box<crate::model::InTotoProvenance>),
        SlsaProvenance(std::boxed::Box<crate::model::SlsaProvenance>),
        SlsaProvenanceZeroTwo(std::boxed::Box<crate::model::SlsaProvenanceZeroTwo>),
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Subject {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// `"<ALGORITHM>": "<HEX_VALUE>"`
    /// Algorithms can be e.g. sha256, sha512
    /// See
    /// <https://github.com/in-toto/attestation/blob/main/spec/field_types.md#DigestSet>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub digest: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Subject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Subject::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [digest][crate::model::Subject::digest].
    pub fn set_digest<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Subject {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Subject"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InTotoSlsaProvenanceV1 {
    /// InToto spec defined at
    /// <https://github.com/in-toto/attestation/tree/main/spec#statement>
    #[serde(rename = "_type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub subject: std::vec::Vec<crate::model::Subject>,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predicate_type: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub predicate: std::option::Option<crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InTotoSlsaProvenanceV1 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::InTotoSlsaProvenanceV1::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::InTotoSlsaProvenanceV1::subject].
    pub fn set_subject<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Subject>,
    {
        use std::iter::Iterator;
        self.subject = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [predicate_type][crate::model::InTotoSlsaProvenanceV1::predicate_type].
    pub fn set_predicate_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predicate_type = v.into();
        self
    }

    /// Sets the value of [predicate][crate::model::InTotoSlsaProvenanceV1::predicate].
    pub fn set_predicate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1>,
    {
        self.predicate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [predicate][crate::model::InTotoSlsaProvenanceV1::predicate].
    pub fn set_or_clear_predicate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1>,
    {
        self.predicate = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InTotoSlsaProvenanceV1 {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1"
    }
}

/// Defines additional types related to [InTotoSlsaProvenanceV1].
pub mod in_toto_slsa_provenance_v_1 {
    #[allow(unused_imports)]
    use super::*;

    /// Keep in sync with schema at
    /// <https://github.com/slsa-framework/slsa/blob/main/docs/provenance/schema/v1/provenance.proto>
    /// Builder renamed to ProvenanceBuilder because of Java conflicts.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SlsaProvenanceV1 {
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub build_definition:
            std::option::Option<crate::model::in_toto_slsa_provenance_v_1::BuildDefinition>,

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub run_details: std::option::Option<crate::model::in_toto_slsa_provenance_v_1::RunDetails>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaProvenanceV1 {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [build_definition][crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1::build_definition].
        pub fn set_build_definition<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::BuildDefinition>,
        {
            self.build_definition = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_definition][crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1::build_definition].
        pub fn set_or_clear_build_definition<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::BuildDefinition>,
        {
            self.build_definition = v.map(|x| x.into());
            self
        }

        /// Sets the value of [run_details][crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1::run_details].
        pub fn set_run_details<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::RunDetails>,
        {
            self.run_details = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [run_details][crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1::run_details].
        pub fn set_or_clear_run_details<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::RunDetails>,
        {
            self.run_details = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SlsaProvenanceV1 {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.SlsaProvenanceV1"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BuildDefinition {
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub build_type: std::string::String,

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub external_parameters: std::option::Option<wkt::Struct>,

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub internal_parameters: std::option::Option<wkt::Struct>,

        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub resolved_dependencies:
            std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BuildDefinition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [build_type][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::build_type].
        pub fn set_build_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.build_type = v.into();
            self
        }

        /// Sets the value of [external_parameters][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::external_parameters].
        pub fn set_external_parameters<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.external_parameters = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [external_parameters][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::external_parameters].
        pub fn set_or_clear_external_parameters<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.external_parameters = v.map(|x| x.into());
            self
        }

        /// Sets the value of [internal_parameters][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::internal_parameters].
        pub fn set_internal_parameters<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.internal_parameters = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [internal_parameters][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::internal_parameters].
        pub fn set_or_clear_internal_parameters<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.internal_parameters = v.map(|x| x.into());
            self
        }

        /// Sets the value of [resolved_dependencies][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::resolved_dependencies].
        pub fn set_resolved_dependencies<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,
        {
            use std::iter::Iterator;
            self.resolved_dependencies = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for BuildDefinition {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.BuildDefinition"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ResourceDescriptor {
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub digest: std::collections::HashMap<std::string::String, std::string::String>,

        #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub content: ::bytes::Bytes,

        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub download_location: std::string::String,

        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub media_type: std::string::String,

        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub annotations: std::collections::HashMap<std::string::String, wkt::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceDescriptor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [uri][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [digest][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::digest].
        pub fn set_digest<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [content][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::content].
        pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }

        /// Sets the value of [download_location][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::download_location].
        pub fn set_download_location<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.download_location = v.into();
            self
        }

        /// Sets the value of [media_type][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::media_type].
        pub fn set_media_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.media_type = v.into();
            self
        }

        /// Sets the value of [annotations][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::annotations].
        pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for ResourceDescriptor {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.ResourceDescriptor"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RunDetails {
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub builder:
            std::option::Option<crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder>,

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub metadata: std::option::Option<crate::model::in_toto_slsa_provenance_v_1::BuildMetadata>,

        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub byproducts:
            std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RunDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [builder][crate::model::in_toto_slsa_provenance_v_1::RunDetails::builder].
        pub fn set_builder<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder>,
        {
            self.builder = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [builder][crate::model::in_toto_slsa_provenance_v_1::RunDetails::builder].
        pub fn set_or_clear_builder<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder>,
        {
            self.builder = v.map(|x| x.into());
            self
        }

        /// Sets the value of [metadata][crate::model::in_toto_slsa_provenance_v_1::RunDetails::metadata].
        pub fn set_metadata<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::BuildMetadata>,
        {
            self.metadata = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [metadata][crate::model::in_toto_slsa_provenance_v_1::RunDetails::metadata].
        pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::BuildMetadata>,
        {
            self.metadata = v.map(|x| x.into());
            self
        }

        /// Sets the value of [byproducts][crate::model::in_toto_slsa_provenance_v_1::RunDetails::byproducts].
        pub fn set_byproducts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,
        {
            use std::iter::Iterator;
            self.byproducts = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for RunDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.RunDetails"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ProvenanceBuilder {
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub version: std::collections::HashMap<std::string::String, std::string::String>,

        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub builder_dependencies:
            std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ProvenanceBuilder {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [version][crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder::version].
        pub fn set_version<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.version = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [builder_dependencies][crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder::builder_dependencies].
        pub fn set_builder_dependencies<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,
        {
            use std::iter::Iterator;
            self.builder_dependencies = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ProvenanceBuilder {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.ProvenanceBuilder"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BuildMetadata {
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub invocation_id: std::string::String,

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub started_on: std::option::Option<wkt::Timestamp>,

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub finished_on: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BuildMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [invocation_id][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::invocation_id].
        pub fn set_invocation_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.invocation_id = v.into();
            self
        }

        /// Sets the value of [started_on][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::started_on].
        pub fn set_started_on<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.started_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [started_on][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::started_on].
        pub fn set_or_clear_started_on<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.started_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [finished_on][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::finished_on].
        pub fn set_finished_on<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.finished_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [finished_on][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::finished_on].
        pub fn set_or_clear_finished_on<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.finished_on = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for BuildMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.BuildMetadata"
        }
    }
}

/// This represents a particular channel of distribution for a given package.
/// E.g., Debian's jessie-backports dpkg mirror.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Distribution {
    /// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/)
    /// denoting the package manager version distributing a package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cpe_uri: std::string::String,

    /// The CPU architecture for which packages in this distribution channel were
    /// built.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub architecture: crate::model::Architecture,

    /// The latest available version of this package in this distribution channel.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub latest_version: std::option::Option<crate::model::Version>,

    /// A freeform string denoting the maintainer of this package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub maintainer: std::string::String,

    /// The distribution channel-specific homepage for this package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,

    /// The distribution channel-specific description of this package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Distribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpe_uri][crate::model::Distribution::cpe_uri].
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::Distribution::architecture].
    pub fn set_architecture<T: std::convert::Into<crate::model::Architecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }

    /// Sets the value of [latest_version][crate::model::Distribution::latest_version].
    pub fn set_latest_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.latest_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latest_version][crate::model::Distribution::latest_version].
    pub fn set_or_clear_latest_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.latest_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintainer][crate::model::Distribution::maintainer].
    pub fn set_maintainer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.maintainer = v.into();
        self
    }

    /// Sets the value of [url][crate::model::Distribution::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Distribution::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for Distribution {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Distribution"
    }
}

/// An occurrence of a particular package installation found within a system's
/// filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Location {
    /// Deprecated.
    /// The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cpe_uri: std::string::String,

    /// Deprecated.
    /// The version installed at this location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::Version>,

    /// The path from which we gathered that this package/version is installed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Location {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpe_uri][crate::model::Location::cpe_uri].
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Location::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::Location::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [path][crate::model::Location::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for Location {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Location"
    }
}

/// PackageNote represents a particular package version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PackageNote {
    /// The name of the package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Deprecated.
    /// The various channels by which a package is distributed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub distribution: std::vec::Vec<crate::model::Distribution>,

    /// The type of package; whether native or non native (e.g., ruby gems,
    /// node.js packages, etc.).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_type: std::string::String,

    /// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/)
    /// denoting the package manager version distributing a package.
    /// The cpe_uri will be blank for language packages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cpe_uri: std::string::String,

    /// The CPU architecture for which packages in this distribution channel were
    /// built. Architecture will be blank for language packages.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub architecture: crate::model::Architecture,

    /// The version of the package.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::Version>,

    /// A freeform text denoting the maintainer of this package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub maintainer: std::string::String,

    /// The homepage for this package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,

    /// The description of this package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Licenses that have been declared by the authors of the package.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub license: std::option::Option<crate::model::License>,

    /// Hash value, typically a file digest, that allows unique
    /// identification a specific package.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub digest: std::vec::Vec<crate::model::Digest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PackageNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PackageNote::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [distribution][crate::model::PackageNote::distribution].
    pub fn set_distribution<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Distribution>,
    {
        use std::iter::Iterator;
        self.distribution = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [package_type][crate::model::PackageNote::package_type].
    pub fn set_package_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_type = v.into();
        self
    }

    /// Sets the value of [cpe_uri][crate::model::PackageNote::cpe_uri].
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::PackageNote::architecture].
    pub fn set_architecture<T: std::convert::Into<crate::model::Architecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }

    /// Sets the value of [version][crate::model::PackageNote::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::PackageNote::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintainer][crate::model::PackageNote::maintainer].
    pub fn set_maintainer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.maintainer = v.into();
        self
    }

    /// Sets the value of [url][crate::model::PackageNote::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PackageNote::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [license][crate::model::PackageNote::license].
    pub fn set_license<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::License>,
    {
        self.license = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [license][crate::model::PackageNote::license].
    pub fn set_or_clear_license<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::License>,
    {
        self.license = v.map(|x| x.into());
        self
    }

    /// Sets the value of [digest][crate::model::PackageNote::digest].
    pub fn set_digest<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Digest>,
    {
        use std::iter::Iterator;
        self.digest = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PackageNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.PackageNote"
    }
}

/// Details on how a particular software package was installed on a system.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PackageOccurrence {
    /// The name of the installed package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// All of the places within the filesystem versions of this package
    /// have been found.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub location: std::vec::Vec<crate::model::Location>,

    /// The type of package; whether native or non native (e.g., ruby gems,
    /// node.js packages, etc.).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_type: std::string::String,

    /// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/)
    /// denoting the package manager version distributing a package.
    /// The cpe_uri will be blank for language packages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cpe_uri: std::string::String,

    /// The CPU architecture for which packages in this distribution channel were
    /// built. Architecture will be blank for language packages.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub architecture: crate::model::Architecture,

    /// Licenses that have been declared by the authors of the package.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub license: std::option::Option<crate::model::License>,

    /// The version of the package.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::Version>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PackageOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PackageOccurrence::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [location][crate::model::PackageOccurrence::location].
    pub fn set_location<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Location>,
    {
        use std::iter::Iterator;
        self.location = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [package_type][crate::model::PackageOccurrence::package_type].
    pub fn set_package_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_type = v.into();
        self
    }

    /// Sets the value of [cpe_uri][crate::model::PackageOccurrence::cpe_uri].
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::PackageOccurrence::architecture].
    pub fn set_architecture<T: std::convert::Into<crate::model::Architecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }

    /// Sets the value of [license][crate::model::PackageOccurrence::license].
    pub fn set_license<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::License>,
    {
        self.license = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [license][crate::model::PackageOccurrence::license].
    pub fn set_or_clear_license<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::License>,
    {
        self.license = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version][crate::model::PackageOccurrence::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::PackageOccurrence::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PackageOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.PackageOccurrence"
    }
}

/// Version contains structured information about the version of a package.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Version {
    /// Used to correct mistakes in the version numbering scheme.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub epoch: i32,

    /// Required only when version kind is NORMAL. The main part of the version
    /// name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The iteration of the package build from the above version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision: std::string::String,

    /// Whether this version is specifying part of an inclusive range. Grafeas
    /// does not have the capability to specify version ranges; instead we have
    /// fields that specify start version and end versions. At times this is
    /// insufficient - we also need to specify whether the version is included in
    /// the range or is excluded from the range. This boolean is expected to be set
    /// to true when the version is included in a range.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub inclusive: bool,

    /// Required. Distinguishes between sentinel MIN/MAX versions and normal
    /// versions.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub kind: crate::model::version::VersionKind,

    /// Human readable version string. This string is of the form
    /// \<epoch\>:\<name\>-\<revision\> and is only set when kind is NORMAL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub full_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Version {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [epoch][crate::model::Version::epoch].
    pub fn set_epoch<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.epoch = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Version::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::Version::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [inclusive][crate::model::Version::inclusive].
    pub fn set_inclusive<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.inclusive = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Version::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::version::VersionKind>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [full_name][crate::model::Version::full_name].
    pub fn set_full_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_name = v.into();
        self
    }
}

impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Version"
    }
}

/// Defines additional types related to [Version].
pub mod version {
    #[allow(unused_imports)]
    use super::*;

    /// Whether this is an ordinary package version or a sentinel MIN/MAX version.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VersionKind {
        /// Unknown.
        Unspecified,
        /// A standard package version.
        Normal,
        /// A special version representing negative infinity.
        Minimum,
        /// A special version representing positive infinity.
        Maximum,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VersionKind::value] or
        /// [VersionKind::name].
        UnknownValue(version_kind::UnknownValue),
    }

    #[doc(hidden)]
    pub mod version_kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VersionKind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Normal => std::option::Option::Some(1),
                Self::Minimum => std::option::Option::Some(2),
                Self::Maximum => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VERSION_KIND_UNSPECIFIED"),
                Self::Normal => std::option::Option::Some("NORMAL"),
                Self::Minimum => std::option::Option::Some("MINIMUM"),
                Self::Maximum => std::option::Option::Some("MAXIMUM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VersionKind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VersionKind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VersionKind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Normal,
                2 => Self::Minimum,
                3 => Self::Maximum,
                _ => Self::UnknownValue(version_kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VersionKind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VERSION_KIND_UNSPECIFIED" => Self::Unspecified,
                "NORMAL" => Self::Normal,
                "MINIMUM" => Self::Minimum,
                "MAXIMUM" => Self::Maximum,
                _ => Self::UnknownValue(version_kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VersionKind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Normal => serializer.serialize_i32(1),
                Self::Minimum => serializer.serialize_i32(2),
                Self::Maximum => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VersionKind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VersionKind>::new(
                ".grafeas.v1.Version.VersionKind",
            ))
        }
    }
}

/// Provenance of a build. Contains all information needed to verify the full
/// details about the build from source to completion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildProvenance {
    /// Required. Unique identifier of the build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Commands requested by the build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub commands: std::vec::Vec<crate::model::Command>,

    /// Output of the build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub built_artifacts: std::vec::Vec<crate::model::Artifact>,

    /// Time at which the build was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time at which execution of the build was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Time at which execution of the build was finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// E-mail address of the user who initiated this build. Note that this was the
    /// user's e-mail address at the time the build was initiated; this address may
    /// not represent the same end-user for all time.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub creator: std::string::String,

    /// URI where any logs for this provenance were written.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub logs_uri: std::string::String,

    /// Details of the Source input to the build.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_provenance: std::option::Option<crate::model::Source>,

    /// Trigger identifier if the build was triggered automatically; empty if not.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger_id: std::string::String,

    /// Special options applied to this build. This is a catch-all field where
    /// build providers can enter any desired additional details.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub build_options: std::collections::HashMap<std::string::String, std::string::String>,

    /// Version string of the builder at the time this build was executed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub builder_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildProvenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::BuildProvenance::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::BuildProvenance::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [commands][crate::model::BuildProvenance::commands].
    pub fn set_commands<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Command>,
    {
        use std::iter::Iterator;
        self.commands = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [built_artifacts][crate::model::BuildProvenance::built_artifacts].
    pub fn set_built_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Artifact>,
    {
        use std::iter::Iterator;
        self.built_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::BuildProvenance::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BuildProvenance::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::BuildProvenance::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::BuildProvenance::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BuildProvenance::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BuildProvenance::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creator][crate::model::BuildProvenance::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [logs_uri][crate::model::BuildProvenance::logs_uri].
    pub fn set_logs_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.logs_uri = v.into();
        self
    }

    /// Sets the value of [source_provenance][crate::model::BuildProvenance::source_provenance].
    pub fn set_source_provenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source_provenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_provenance][crate::model::BuildProvenance::source_provenance].
    pub fn set_or_clear_source_provenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source_provenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [trigger_id][crate::model::BuildProvenance::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [build_options][crate::model::BuildProvenance::build_options].
    pub fn set_build_options<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.build_options = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [builder_version][crate::model::BuildProvenance::builder_version].
    pub fn set_builder_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.builder_version = v.into();
        self
    }
}

impl wkt::message::Message for BuildProvenance {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BuildProvenance"
    }
}

/// Source describes the location of the source used for the build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Source {
    /// If provided, the input binary artifacts for the build came from this
    /// location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub artifact_storage_source_uri: std::string::String,

    /// Hash(es) of the build source, which can be used to verify that the original
    /// source integrity was maintained in the build.
    ///
    /// The keys to this map are file paths used as build source and the values
    /// contain the hash values for those files.
    ///
    /// If the build source came in a single package such as a gzipped tarfile
    /// (.tar.gz), the FileHash will be for the single path to that file.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub file_hashes: std::collections::HashMap<std::string::String, crate::model::FileHashes>,

    /// If provided, the source code used for the build came from this location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::SourceContext>,

    /// If provided, some of the source code used for the build may be found in
    /// these locations, in the case where the source repository had multiple
    /// remotes or submodules. This list will not include the context specified in
    /// the context field.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub additional_contexts: std::vec::Vec<crate::model::SourceContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Source {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact_storage_source_uri][crate::model::Source::artifact_storage_source_uri].
    pub fn set_artifact_storage_source_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_storage_source_uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::Source::file_hashes].
    pub fn set_file_hashes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FileHashes>,
    {
        use std::iter::Iterator;
        self.file_hashes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [context][crate::model::Source::context].
    pub fn set_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceContext>,
    {
        self.context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [context][crate::model::Source::context].
    pub fn set_or_clear_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceContext>,
    {
        self.context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_contexts][crate::model::Source::additional_contexts].
    pub fn set_additional_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SourceContext>,
    {
        use std::iter::Iterator;
        self.additional_contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Source {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Source"
    }
}

/// Container message for hashes of byte content of files, used in source
/// messages to verify integrity of source input to the build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileHashes {
    /// Required. Collection of file hashes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_hash: std::vec::Vec<crate::model::Hash>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileHashes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_hash][crate::model::FileHashes::file_hash].
    pub fn set_file_hash<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Hash>,
    {
        use std::iter::Iterator;
        self.file_hash = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileHashes {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.FileHashes"
    }
}

/// Container message for hash values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Hash {
    /// Required. The type of hash that was performed, e.g. "SHA-256".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Required. The hash value.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub value: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Hash {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Hash::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Hash::value].
    pub fn set_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Hash {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Hash"
    }
}

/// Command describes a step performed as part of the build pipeline.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Command {
    /// Required. Name of the command, as presented on the command line, or if the
    /// command is packaged as a Docker container, as presented to `docker pull`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Environment variables set before running this command.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub env: std::vec::Vec<std::string::String>,

    /// Command-line arguments used when executing this command.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Working directory (relative to project source root) used when running this
    /// command.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dir: std::string::String,

    /// Optional unique identifier for this command, used in wait_for to reference
    /// this command as a dependency.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The ID(s) of the command(s) that this command depends on.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub wait_for: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Command {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Command::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [env][crate::model::Command::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::Command::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dir][crate::model::Command::dir].
    pub fn set_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dir = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Command::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [wait_for][crate::model::Command::wait_for].
    pub fn set_wait_for<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.wait_for = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Command {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Command"
    }
}

/// Artifact describes a build product.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Artifact {
    /// Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
    /// container.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub checksum: std::string::String,

    /// Artifact ID, if any; for container images, this will be a URL by digest
    /// like `gcr.io/projectID/imagename@sha256:123456`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Related artifact names. This may be the path to a binary or jar file, or in
    /// the case of a container build, the name used to push the container image to
    /// Google Container Registry, as presented to `docker push`. Note that a
    /// single Artifact ID can have multiple names, for example if two tags are
    /// applied to one image.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub names: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Artifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [checksum][crate::model::Artifact::checksum].
    pub fn set_checksum<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.checksum = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Artifact::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [names][crate::model::Artifact::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Artifact {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Artifact"
    }
}

/// A SourceContext is a reference to a tree of files. A SourceContext together
/// with a path point to a unique revision of a single file or directory.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceContext {
    /// Labels with user defined metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A SourceContext can refer any one of the following types of repositories.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::source_context::Context>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [labels][crate::model::SourceContext::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [context][crate::model::SourceContext::context].
    ///
    /// Note that all the setters affecting `context` are mutually
    /// exclusive.
    pub fn set_context<
        T: std::convert::Into<std::option::Option<crate::model::source_context::Context>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// The value of [context][crate::model::SourceContext::context]
    /// if it holds a `CloudRepo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_repo(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudRepoSourceContext>> {
        #[allow(unreachable_patterns)]
        self.context.as_ref().and_then(|v| match v {
            crate::model::source_context::Context::CloudRepo(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [context][crate::model::SourceContext::context]
    /// to hold a `CloudRepo`.
    ///
    /// Note that all the setters affecting `context` are
    /// mutually exclusive.
    pub fn set_cloud_repo<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudRepoSourceContext>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.context =
            std::option::Option::Some(crate::model::source_context::Context::CloudRepo(v.into()));
        self
    }

    /// The value of [context][crate::model::SourceContext::context]
    /// if it holds a `Gerrit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gerrit(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GerritSourceContext>> {
        #[allow(unreachable_patterns)]
        self.context.as_ref().and_then(|v| match v {
            crate::model::source_context::Context::Gerrit(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [context][crate::model::SourceContext::context]
    /// to hold a `Gerrit`.
    ///
    /// Note that all the setters affecting `context` are
    /// mutually exclusive.
    pub fn set_gerrit<T: std::convert::Into<std::boxed::Box<crate::model::GerritSourceContext>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context =
            std::option::Option::Some(crate::model::source_context::Context::Gerrit(v.into()));
        self
    }

    /// The value of [context][crate::model::SourceContext::context]
    /// if it holds a `Git`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git(&self) -> std::option::Option<&std::boxed::Box<crate::model::GitSourceContext>> {
        #[allow(unreachable_patterns)]
        self.context.as_ref().and_then(|v| match v {
            crate::model::source_context::Context::Git(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [context][crate::model::SourceContext::context]
    /// to hold a `Git`.
    ///
    /// Note that all the setters affecting `context` are
    /// mutually exclusive.
    pub fn set_git<T: std::convert::Into<std::boxed::Box<crate::model::GitSourceContext>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context =
            std::option::Option::Some(crate::model::source_context::Context::Git(v.into()));
        self
    }
}

impl wkt::message::Message for SourceContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SourceContext"
    }
}

/// Defines additional types related to [SourceContext].
pub mod source_context {
    #[allow(unused_imports)]
    use super::*;

    /// A SourceContext can refer any one of the following types of repositories.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Context {
        /// A SourceContext referring to a revision in a Google Cloud Source Repo.
        CloudRepo(std::boxed::Box<crate::model::CloudRepoSourceContext>),
        /// A SourceContext referring to a Gerrit project.
        Gerrit(std::boxed::Box<crate::model::GerritSourceContext>),
        /// A SourceContext referring to any third party Git repo (e.g., GitHub).
        Git(std::boxed::Box<crate::model::GitSourceContext>),
    }
}

/// An alias to a repo revision.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AliasContext {
    /// The alias kind.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub kind: crate::model::alias_context::Kind,

    /// The alias name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AliasContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::AliasContext::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::alias_context::Kind>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AliasContext::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AliasContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.AliasContext"
    }
}

/// Defines additional types related to [AliasContext].
pub mod alias_context {
    #[allow(unused_imports)]
    use super::*;

    /// The type of an alias.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// Unknown.
        Unspecified,
        /// Git tag.
        Fixed,
        /// Git branch.
        Movable,
        /// Used to specify non-standard aliases. For example, if a Git repo has a
        /// ref named "refs/foo/bar".
        Other,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Kind::value] or
        /// [Kind::name].
        UnknownValue(kind::UnknownValue),
    }

    #[doc(hidden)]
    pub mod kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Kind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Fixed => std::option::Option::Some(1),
                Self::Movable => std::option::Option::Some(2),
                Self::Other => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KIND_UNSPECIFIED"),
                Self::Fixed => std::option::Option::Some("FIXED"),
                Self::Movable => std::option::Option::Some("MOVABLE"),
                Self::Other => std::option::Option::Some("OTHER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Kind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Kind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Kind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Fixed,
                2 => Self::Movable,
                4 => Self::Other,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Kind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KIND_UNSPECIFIED" => Self::Unspecified,
                "FIXED" => Self::Fixed,
                "MOVABLE" => Self::Movable,
                "OTHER" => Self::Other,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Kind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Fixed => serializer.serialize_i32(1),
                Self::Movable => serializer.serialize_i32(2),
                Self::Other => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Kind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Kind>::new(
                ".grafeas.v1.AliasContext.Kind",
            ))
        }
    }
}

/// A CloudRepoSourceContext denotes a particular revision in a Google Cloud
/// Source Repo.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudRepoSourceContext {
    /// The ID of the repo.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub repo_id: std::option::Option<crate::model::RepoId>,

    /// A revision in a Cloud Repo can be identified by either its revision ID or
    /// its alias.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub revision: std::option::Option<crate::model::cloud_repo_source_context::Revision>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRepoSourceContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repo_id][crate::model::CloudRepoSourceContext::repo_id].
    pub fn set_repo_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RepoId>,
    {
        self.repo_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [repo_id][crate::model::CloudRepoSourceContext::repo_id].
    pub fn set_or_clear_repo_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RepoId>,
    {
        self.repo_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [revision][crate::model::CloudRepoSourceContext::revision].
    ///
    /// Note that all the setters affecting `revision` are mutually
    /// exclusive.
    pub fn set_revision<
        T: std::convert::Into<std::option::Option<crate::model::cloud_repo_source_context::Revision>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.revision = v.into();
        self
    }

    /// The value of [revision][crate::model::CloudRepoSourceContext::revision]
    /// if it holds a `RevisionId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn revision_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::cloud_repo_source_context::Revision::RevisionId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::CloudRepoSourceContext::revision]
    /// to hold a `RevisionId`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = std::option::Option::Some(
            crate::model::cloud_repo_source_context::Revision::RevisionId(v.into()),
        );
        self
    }

    /// The value of [revision][crate::model::CloudRepoSourceContext::revision]
    /// if it holds a `AliasContext`, `None` if the field is not set or
    /// holds a different branch.
    pub fn alias_context(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AliasContext>> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::cloud_repo_source_context::Revision::AliasContext(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::CloudRepoSourceContext::revision]
    /// to hold a `AliasContext`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_alias_context<T: std::convert::Into<std::boxed::Box<crate::model::AliasContext>>>(
        mut self,
        v: T,
    ) -> Self {
        self.revision = std::option::Option::Some(
            crate::model::cloud_repo_source_context::Revision::AliasContext(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloudRepoSourceContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CloudRepoSourceContext"
    }
}

/// Defines additional types related to [CloudRepoSourceContext].
pub mod cloud_repo_source_context {
    #[allow(unused_imports)]
    use super::*;

    /// A revision in a Cloud Repo can be identified by either its revision ID or
    /// its alias.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Revision {
        /// A revision ID.
        RevisionId(std::string::String),
        /// An alias, which may be a branch or tag.
        AliasContext(std::boxed::Box<crate::model::AliasContext>),
    }
}

/// A SourceContext referring to a Gerrit project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GerritSourceContext {
    /// The URI of a running Gerrit instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host_uri: std::string::String,

    /// The full project name within the host. Projects may be nested, so
    /// "project/subproject" is a valid project name. The "repo name" is the
    /// hostURI/project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gerrit_project: std::string::String,

    /// A revision in a Gerrit project can be identified by either its revision ID
    /// or its alias.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub revision: std::option::Option<crate::model::gerrit_source_context::Revision>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GerritSourceContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_uri][crate::model::GerritSourceContext::host_uri].
    pub fn set_host_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_uri = v.into();
        self
    }

    /// Sets the value of [gerrit_project][crate::model::GerritSourceContext::gerrit_project].
    pub fn set_gerrit_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gerrit_project = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::GerritSourceContext::revision].
    ///
    /// Note that all the setters affecting `revision` are mutually
    /// exclusive.
    pub fn set_revision<
        T: std::convert::Into<std::option::Option<crate::model::gerrit_source_context::Revision>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.revision = v.into();
        self
    }

    /// The value of [revision][crate::model::GerritSourceContext::revision]
    /// if it holds a `RevisionId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn revision_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::gerrit_source_context::Revision::RevisionId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::GerritSourceContext::revision]
    /// to hold a `RevisionId`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = std::option::Option::Some(
            crate::model::gerrit_source_context::Revision::RevisionId(v.into()),
        );
        self
    }

    /// The value of [revision][crate::model::GerritSourceContext::revision]
    /// if it holds a `AliasContext`, `None` if the field is not set or
    /// holds a different branch.
    pub fn alias_context(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AliasContext>> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::gerrit_source_context::Revision::AliasContext(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::GerritSourceContext::revision]
    /// to hold a `AliasContext`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_alias_context<T: std::convert::Into<std::boxed::Box<crate::model::AliasContext>>>(
        mut self,
        v: T,
    ) -> Self {
        self.revision = std::option::Option::Some(
            crate::model::gerrit_source_context::Revision::AliasContext(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GerritSourceContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GerritSourceContext"
    }
}

/// Defines additional types related to [GerritSourceContext].
pub mod gerrit_source_context {
    #[allow(unused_imports)]
    use super::*;

    /// A revision in a Gerrit project can be identified by either its revision ID
    /// or its alias.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Revision {
        /// A revision (commit) ID.
        RevisionId(std::string::String),
        /// An alias, which may be a branch or tag.
        AliasContext(std::boxed::Box<crate::model::AliasContext>),
    }
}

/// A GitSourceContext denotes a particular revision in a third party Git
/// repository (e.g., GitHub).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitSourceContext {
    /// Git repository URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,

    /// Git commit hash.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitSourceContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::GitSourceContext::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::GitSourceContext::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }
}

impl wkt::message::Message for GitSourceContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GitSourceContext"
    }
}

/// A unique identifier for a Cloud Repo.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepoId {
    /// A cloud repo can be identified by either its project ID and repository name
    /// combination, or its globally unique identifier.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub id: std::option::Option<crate::model::repo_id::Id>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepoId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::RepoId::id].
    ///
    /// Note that all the setters affecting `id` are mutually
    /// exclusive.
    pub fn set_id<T: std::convert::Into<std::option::Option<crate::model::repo_id::Id>>>(
        mut self,
        v: T,
    ) -> Self {
        self.id = v.into();
        self
    }

    /// The value of [id][crate::model::RepoId::id]
    /// if it holds a `ProjectRepoId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn project_repo_id(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ProjectRepoId>> {
        #[allow(unreachable_patterns)]
        self.id.as_ref().and_then(|v| match v {
            crate::model::repo_id::Id::ProjectRepoId(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [id][crate::model::RepoId::id]
    /// to hold a `ProjectRepoId`.
    ///
    /// Note that all the setters affecting `id` are
    /// mutually exclusive.
    pub fn set_project_repo_id<
        T: std::convert::Into<std::boxed::Box<crate::model::ProjectRepoId>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.id = std::option::Option::Some(crate::model::repo_id::Id::ProjectRepoId(v.into()));
        self
    }

    /// The value of [id][crate::model::RepoId::id]
    /// if it holds a `Uid`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uid(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.id.as_ref().and_then(|v| match v {
            crate::model::repo_id::Id::Uid(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [id][crate::model::RepoId::id]
    /// to hold a `Uid`.
    ///
    /// Note that all the setters affecting `id` are
    /// mutually exclusive.
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = std::option::Option::Some(crate::model::repo_id::Id::Uid(v.into()));
        self
    }
}

impl wkt::message::Message for RepoId {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.RepoId"
    }
}

/// Defines additional types related to [RepoId].
pub mod repo_id {
    #[allow(unused_imports)]
    use super::*;

    /// A cloud repo can be identified by either its project ID and repository name
    /// combination, or its globally unique identifier.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Id {
        /// A combination of a project ID and a repo name.
        ProjectRepoId(std::boxed::Box<crate::model::ProjectRepoId>),
        /// A server-assigned, globally unique identifier.
        Uid(std::string::String),
    }
}

/// Selects a repo using a Google Cloud Platform project ID (e.g.,
/// winged-cargo-31) and a repo name within that project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProjectRepoId {
    /// The ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// The name of the repo. Leave empty for the default repo.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repo_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProjectRepoId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ProjectRepoId::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [repo_name][crate::model::ProjectRepoId::repo_name].
    pub fn set_repo_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repo_name = v.into();
        self
    }
}

impl wkt::message::Message for ProjectRepoId {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ProjectRepoId"
    }
}

/// The note representing an SBOM reference.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SBOMReferenceNote {
    /// The format that SBOM takes. E.g. may be spdx, cyclonedx, etc...
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub format: std::string::String,

    /// The version of the format that the SBOM takes. E.g. if the format
    /// is spdx, the version may be 2.3.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SBOMReferenceNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [format][crate::model::SBOMReferenceNote::format].
    pub fn set_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [version][crate::model::SBOMReferenceNote::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for SBOMReferenceNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SBOMReferenceNote"
    }
}

/// The occurrence representing an SBOM reference as applied to a specific
/// resource. The occurrence follows the DSSE specification. See
/// <https://github.com/secure-systems-lab/dsse/blob/master/envelope.md> for more
/// details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SBOMReferenceOccurrence {
    /// The actual payload that contains the SBOM reference data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub payload: std::option::Option<crate::model::SbomReferenceIntotoPayload>,

    /// The kind of payload that SbomReferenceIntotoPayload takes. Since it's in
    /// the intoto format, this value is expected to be
    /// 'application/vnd.in-toto+json'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub payload_type: std::string::String,

    /// The signatures over the payload.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub signatures: std::vec::Vec<crate::model::EnvelopeSignature>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SBOMReferenceOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [payload][crate::model::SBOMReferenceOccurrence::payload].
    pub fn set_payload<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SbomReferenceIntotoPayload>,
    {
        self.payload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [payload][crate::model::SBOMReferenceOccurrence::payload].
    pub fn set_or_clear_payload<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SbomReferenceIntotoPayload>,
    {
        self.payload = v.map(|x| x.into());
        self
    }

    /// Sets the value of [payload_type][crate::model::SBOMReferenceOccurrence::payload_type].
    pub fn set_payload_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload_type = v.into();
        self
    }

    /// Sets the value of [signatures][crate::model::SBOMReferenceOccurrence::signatures].
    pub fn set_signatures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvelopeSignature>,
    {
        use std::iter::Iterator;
        self.signatures = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SBOMReferenceOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SBOMReferenceOccurrence"
    }
}

/// The actual payload that contains the SBOM Reference data.
/// The payload follows the intoto statement specification. See
/// <https://github.com/in-toto/attestation/blob/main/spec/v1.0/statement.md>
/// for more details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SbomReferenceIntotoPayload {
    /// Identifier for the schema of the Statement.
    #[serde(rename = "_type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// URI identifying the type of the Predicate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predicate_type: std::string::String,

    /// Set of software artifacts that the attestation applies to. Each element
    /// represents a single software artifact.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub subject: std::vec::Vec<crate::model::Subject>,

    /// Additional parameters of the Predicate. Includes the actual data about the
    /// SBOM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub predicate: std::option::Option<crate::model::SbomReferenceIntotoPredicate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SbomReferenceIntotoPayload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::SbomReferenceIntotoPayload::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [predicate_type][crate::model::SbomReferenceIntotoPayload::predicate_type].
    pub fn set_predicate_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predicate_type = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::SbomReferenceIntotoPayload::subject].
    pub fn set_subject<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Subject>,
    {
        use std::iter::Iterator;
        self.subject = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [predicate][crate::model::SbomReferenceIntotoPayload::predicate].
    pub fn set_predicate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SbomReferenceIntotoPredicate>,
    {
        self.predicate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [predicate][crate::model::SbomReferenceIntotoPayload::predicate].
    pub fn set_or_clear_predicate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SbomReferenceIntotoPredicate>,
    {
        self.predicate = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SbomReferenceIntotoPayload {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SbomReferenceIntotoPayload"
    }
}

/// A predicate which describes the SBOM being referenced.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SbomReferenceIntotoPredicate {
    /// The person or system referring this predicate to the consumer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub referrer_id: std::string::String,

    /// The location of the SBOM.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// The mime type of the SBOM.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// A map of algorithm to digest of the contents of the SBOM.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub digest: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SbomReferenceIntotoPredicate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [referrer_id][crate::model::SbomReferenceIntotoPredicate::referrer_id].
    pub fn set_referrer_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.referrer_id = v.into();
        self
    }

    /// Sets the value of [location][crate::model::SbomReferenceIntotoPredicate::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::SbomReferenceIntotoPredicate::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [digest][crate::model::SbomReferenceIntotoPredicate::digest].
    pub fn set_digest<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SbomReferenceIntotoPredicate {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SbomReferenceIntotoPredicate"
    }
}

/// The note representing a secret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretNote {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SecretNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SecretNote"
    }
}

/// The occurrence provides details of a secret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretOccurrence {
    /// Type of secret.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub kind: crate::model::SecretKind,

    /// Locations where the secret is detected.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub locations: std::vec::Vec<crate::model::SecretLocation>,

    /// Status of the secret.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub statuses: std::vec::Vec<crate::model::SecretStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SecretOccurrence::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::SecretKind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [locations][crate::model::SecretOccurrence::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecretLocation>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [statuses][crate::model::SecretOccurrence::statuses].
    pub fn set_statuses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecretStatus>,
    {
        use std::iter::Iterator;
        self.statuses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SecretOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SecretOccurrence"
    }
}

/// The location of the secret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretLocation {
    /// The detailed location of the secret.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::secret_location::Location>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::SecretLocation::location].
    ///
    /// Note that all the setters affecting `location` are mutually
    /// exclusive.
    pub fn set_location<
        T: std::convert::Into<std::option::Option<crate::model::secret_location::Location>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::SecretLocation::location]
    /// if it holds a `FileLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn file_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FileLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::secret_location::Location::FileLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::SecretLocation::location]
    /// to hold a `FileLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_file_location<T: std::convert::Into<std::boxed::Box<crate::model::FileLocation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::secret_location::Location::FileLocation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SecretLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SecretLocation"
    }
}

/// Defines additional types related to [SecretLocation].
pub mod secret_location {
    #[allow(unused_imports)]
    use super::*;

    /// The detailed location of the secret.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Location {
        /// The secret is found from a file.
        FileLocation(std::boxed::Box<crate::model::FileLocation>),
    }
}

/// The status of the secret with a timestamp.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretStatus {
    /// The status of the secret.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub status: crate::model::secret_status::Status,

    /// The time the secret status was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional message about the status code.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::SecretStatus::status].
    pub fn set_status<T: std::convert::Into<crate::model::secret_status::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::SecretStatus::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::SecretStatus::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message][crate::model::SecretStatus::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for SecretStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SecretStatus"
    }
}

/// Defines additional types related to [SecretStatus].
pub mod secret_status {
    #[allow(unused_imports)]
    use super::*;

    /// The status of the secret.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Unspecified
        Unspecified,
        /// The status of the secret is unknown.
        Unknown,
        /// The secret is valid.
        Valid,
        /// The secret is invalid.
        Invalid,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(1),
                Self::Valid => std::option::Option::Some(2),
                Self::Invalid => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Valid => std::option::Option::Some("VALID"),
                Self::Invalid => std::option::Option::Some("INVALID"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unknown,
                2 => Self::Valid,
                3 => Self::Invalid,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN" => Self::Unknown,
                "VALID" => Self::Valid,
                "INVALID" => Self::Invalid,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(1),
                Self::Valid => serializer.serialize_i32(2),
                Self::Invalid => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".grafeas.v1.SecretStatus.Status",
            ))
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SlsaProvenance {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub builder: std::option::Option<crate::model::slsa_provenance::SlsaBuilder>,

    /// Identifies the configuration used for the build.
    /// When combined with materials, this SHOULD fully describe the build,
    /// such that re-running this recipe results in bit-for-bit identical output
    /// (if the build is reproducible).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recipe: std::option::Option<crate::model::slsa_provenance::SlsaRecipe>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::slsa_provenance::SlsaMetadata>,

    /// The collection of artifacts that influenced the build including sources,
    /// dependencies, build tools, base images, and so on. This is considered to be
    /// incomplete unless metadata.completeness.materials is true. Unset or null is
    /// equivalent to empty.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub materials: std::vec::Vec<crate::model::slsa_provenance::Material>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SlsaProvenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builder][crate::model::SlsaProvenance::builder].
    pub fn set_builder<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance::SlsaBuilder>,
    {
        self.builder = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [builder][crate::model::SlsaProvenance::builder].
    pub fn set_or_clear_builder<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance::SlsaBuilder>,
    {
        self.builder = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recipe][crate::model::SlsaProvenance::recipe].
    pub fn set_recipe<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance::SlsaRecipe>,
    {
        self.recipe = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recipe][crate::model::SlsaProvenance::recipe].
    pub fn set_or_clear_recipe<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance::SlsaRecipe>,
    {
        self.recipe = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::SlsaProvenance::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance::SlsaMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::SlsaProvenance::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance::SlsaMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [materials][crate::model::SlsaProvenance::materials].
    pub fn set_materials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::slsa_provenance::Material>,
    {
        use std::iter::Iterator;
        self.materials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SlsaProvenance {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SlsaProvenance"
    }
}

/// Defines additional types related to [SlsaProvenance].
pub mod slsa_provenance {
    #[allow(unused_imports)]
    use super::*;

    /// Steps taken to build the artifact.
    /// For a TaskRun, typically each container corresponds to one step in the
    /// recipe.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SlsaRecipe {
        /// URI indicating what type of recipe was performed. It determines the
        /// meaning of recipe.entryPoint, recipe.arguments, recipe.environment, and
        /// materials.
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub r#type: std::string::String,

        /// Index in materials containing the recipe steps that are not implied by
        /// recipe.type. For example, if the recipe type were "make", then this would
        /// point to the source containing the Makefile, not the make program itself.
        /// Set to -1 if the recipe doesn't come from a material, as zero is default
        /// unset value for int64.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I64")]
        pub defined_in_material: i64,

        /// String identifying the entry point into the build.
        /// This is often a path to a configuration file and/or a target label within
        /// that file. The syntax and meaning are defined by recipe.type. For
        /// example, if the recipe type were "make", then this would reference the
        /// directory in which to run make as well as which target to use.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entry_point: std::string::String,

        /// Collection of all external inputs that influenced the build on top of
        /// recipe.definedInMaterial and recipe.entryPoint. For example, if the
        /// recipe type were "make", then this might be the flags passed to make
        /// aside from the target, which is captured in recipe.entryPoint. Depending
        /// on the recipe Type, the structure may be different.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub arguments: std::option::Option<wkt::Any>,

        /// Any other builder-controlled inputs necessary for correctly evaluating
        /// the recipe. Usually only needed for reproducing the build but not
        /// evaluated as part of policy. Depending on the recipe Type, the structure
        /// may be different.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub environment: std::option::Option<wkt::Any>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaRecipe {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::slsa_provenance::SlsaRecipe::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [defined_in_material][crate::model::slsa_provenance::SlsaRecipe::defined_in_material].
        pub fn set_defined_in_material<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.defined_in_material = v.into();
            self
        }

        /// Sets the value of [entry_point][crate::model::slsa_provenance::SlsaRecipe::entry_point].
        pub fn set_entry_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entry_point = v.into();
            self
        }

        /// Sets the value of [arguments][crate::model::slsa_provenance::SlsaRecipe::arguments].
        pub fn set_arguments<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Any>,
        {
            self.arguments = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [arguments][crate::model::slsa_provenance::SlsaRecipe::arguments].
        pub fn set_or_clear_arguments<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Any>,
        {
            self.arguments = v.map(|x| x.into());
            self
        }

        /// Sets the value of [environment][crate::model::slsa_provenance::SlsaRecipe::environment].
        pub fn set_environment<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Any>,
        {
            self.environment = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [environment][crate::model::slsa_provenance::SlsaRecipe::environment].
        pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Any>,
        {
            self.environment = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SlsaRecipe {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.SlsaRecipe"
        }
    }

    /// Indicates that the builder claims certain fields in this message to be
    /// complete.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SlsaCompleteness {
        /// If true, the builder claims that recipe.arguments is complete, meaning
        /// that all external inputs are properly captured in the recipe.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub arguments: bool,

        /// If true, the builder claims that recipe.environment is claimed to be
        /// complete.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub environment: bool,

        /// If true, the builder claims that materials are complete, usually through
        /// some controls to prevent network access. Sometimes called "hermetic".
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub materials: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaCompleteness {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [arguments][crate::model::slsa_provenance::SlsaCompleteness::arguments].
        pub fn set_arguments<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.arguments = v.into();
            self
        }

        /// Sets the value of [environment][crate::model::slsa_provenance::SlsaCompleteness::environment].
        pub fn set_environment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.environment = v.into();
            self
        }

        /// Sets the value of [materials][crate::model::slsa_provenance::SlsaCompleteness::materials].
        pub fn set_materials<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.materials = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaCompleteness {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.SlsaCompleteness"
        }
    }

    /// Other properties of the build.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SlsaMetadata {
        /// Identifies the particular build invocation, which can be useful for
        /// finding associated logs or other ad-hoc analysis. The value SHOULD be
        /// globally unique, per in-toto Provenance spec.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub build_invocation_id: std::string::String,

        /// The timestamp of when the build started.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub build_started_on: std::option::Option<wkt::Timestamp>,

        /// The timestamp of when the build completed.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub build_finished_on: std::option::Option<wkt::Timestamp>,

        /// Indicates that the builder claims certain fields in this message to be
        /// complete.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub completeness: std::option::Option<crate::model::slsa_provenance::SlsaCompleteness>,

        /// If true, the builder claims that running the recipe on materials will
        /// produce bit-for-bit identical output.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub reproducible: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [build_invocation_id][crate::model::slsa_provenance::SlsaMetadata::build_invocation_id].
        pub fn set_build_invocation_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.build_invocation_id = v.into();
            self
        }

        /// Sets the value of [build_started_on][crate::model::slsa_provenance::SlsaMetadata::build_started_on].
        pub fn set_build_started_on<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_started_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_started_on][crate::model::slsa_provenance::SlsaMetadata::build_started_on].
        pub fn set_or_clear_build_started_on<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_started_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [build_finished_on][crate::model::slsa_provenance::SlsaMetadata::build_finished_on].
        pub fn set_build_finished_on<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_finished_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_finished_on][crate::model::slsa_provenance::SlsaMetadata::build_finished_on].
        pub fn set_or_clear_build_finished_on<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_finished_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [completeness][crate::model::slsa_provenance::SlsaMetadata::completeness].
        pub fn set_completeness<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::slsa_provenance::SlsaCompleteness>,
        {
            self.completeness = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [completeness][crate::model::slsa_provenance::SlsaMetadata::completeness].
        pub fn set_or_clear_completeness<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::slsa_provenance::SlsaCompleteness>,
        {
            self.completeness = v.map(|x| x.into());
            self
        }

        /// Sets the value of [reproducible][crate::model::slsa_provenance::SlsaMetadata::reproducible].
        pub fn set_reproducible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.reproducible = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.SlsaMetadata"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SlsaBuilder {
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaBuilder {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::slsa_provenance::SlsaBuilder::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaBuilder {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.SlsaBuilder"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Material {
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub digest: std::collections::HashMap<std::string::String, std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Material {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::slsa_provenance::Material::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [digest][crate::model::slsa_provenance::Material::digest].
        pub fn set_digest<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for Material {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.Material"
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SlsaProvenanceZeroTwo {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub builder: std::option::Option<crate::model::slsa_provenance_zero_two::SlsaBuilder>,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub build_type: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub invocation: std::option::Option<crate::model::slsa_provenance_zero_two::SlsaInvocation>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub build_config: std::option::Option<wkt::Struct>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::slsa_provenance_zero_two::SlsaMetadata>,

    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub materials: std::vec::Vec<crate::model::slsa_provenance_zero_two::SlsaMaterial>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SlsaProvenanceZeroTwo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builder][crate::model::SlsaProvenanceZeroTwo::builder].
    pub fn set_builder<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaBuilder>,
    {
        self.builder = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [builder][crate::model::SlsaProvenanceZeroTwo::builder].
    pub fn set_or_clear_builder<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaBuilder>,
    {
        self.builder = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_type][crate::model::SlsaProvenanceZeroTwo::build_type].
    pub fn set_build_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build_type = v.into();
        self
    }

    /// Sets the value of [invocation][crate::model::SlsaProvenanceZeroTwo::invocation].
    pub fn set_invocation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaInvocation>,
    {
        self.invocation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [invocation][crate::model::SlsaProvenanceZeroTwo::invocation].
    pub fn set_or_clear_invocation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaInvocation>,
    {
        self.invocation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_config][crate::model::SlsaProvenanceZeroTwo::build_config].
    pub fn set_build_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.build_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_config][crate::model::SlsaProvenanceZeroTwo::build_config].
    pub fn set_or_clear_build_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.build_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::SlsaProvenanceZeroTwo::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::SlsaProvenanceZeroTwo::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [materials][crate::model::SlsaProvenanceZeroTwo::materials].
    pub fn set_materials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaMaterial>,
    {
        use std::iter::Iterator;
        self.materials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SlsaProvenanceZeroTwo {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo"
    }
}

/// Defines additional types related to [SlsaProvenanceZeroTwo].
pub mod slsa_provenance_zero_two {
    #[allow(unused_imports)]
    use super::*;

    /// Identifies the entity that executed the recipe, which is trusted to have
    /// correctly performed the operation and populated this provenance.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SlsaBuilder {
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaBuilder {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::slsa_provenance_zero_two::SlsaBuilder::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaBuilder {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaBuilder"
        }
    }

    /// The collection of artifacts that influenced the build including sources,
    /// dependencies, build tools, base images, and so on.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SlsaMaterial {
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub digest: std::collections::HashMap<std::string::String, std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaMaterial {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::slsa_provenance_zero_two::SlsaMaterial::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [digest][crate::model::slsa_provenance_zero_two::SlsaMaterial::digest].
        pub fn set_digest<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for SlsaMaterial {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaMaterial"
        }
    }

    /// Identifies the event that kicked off the build.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SlsaInvocation {
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub config_source:
            std::option::Option<crate::model::slsa_provenance_zero_two::SlsaConfigSource>,

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub parameters: std::option::Option<wkt::Struct>,

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub environment: std::option::Option<wkt::Struct>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaInvocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [config_source][crate::model::slsa_provenance_zero_two::SlsaInvocation::config_source].
        pub fn set_config_source<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaConfigSource>,
        {
            self.config_source = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [config_source][crate::model::slsa_provenance_zero_two::SlsaInvocation::config_source].
        pub fn set_or_clear_config_source<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaConfigSource>,
        {
            self.config_source = v.map(|x| x.into());
            self
        }

        /// Sets the value of [parameters][crate::model::slsa_provenance_zero_two::SlsaInvocation::parameters].
        pub fn set_parameters<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.parameters = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [parameters][crate::model::slsa_provenance_zero_two::SlsaInvocation::parameters].
        pub fn set_or_clear_parameters<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.parameters = v.map(|x| x.into());
            self
        }

        /// Sets the value of [environment][crate::model::slsa_provenance_zero_two::SlsaInvocation::environment].
        pub fn set_environment<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.environment = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [environment][crate::model::slsa_provenance_zero_two::SlsaInvocation::environment].
        pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.environment = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SlsaInvocation {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaInvocation"
        }
    }

    /// Describes where the config file that kicked off the build came from.
    /// This is effectively a pointer to the source where buildConfig came from.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SlsaConfigSource {
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub digest: std::collections::HashMap<std::string::String, std::string::String>,

        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entry_point: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaConfigSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::slsa_provenance_zero_two::SlsaConfigSource::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [digest][crate::model::slsa_provenance_zero_two::SlsaConfigSource::digest].
        pub fn set_digest<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [entry_point][crate::model::slsa_provenance_zero_two::SlsaConfigSource::entry_point].
        pub fn set_entry_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entry_point = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaConfigSource {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaConfigSource"
        }
    }

    /// Other properties of the build.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SlsaMetadata {
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub build_invocation_id: std::string::String,

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub build_started_on: std::option::Option<wkt::Timestamp>,

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub build_finished_on: std::option::Option<wkt::Timestamp>,

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub completeness:
            std::option::Option<crate::model::slsa_provenance_zero_two::SlsaCompleteness>,

        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub reproducible: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [build_invocation_id][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_invocation_id].
        pub fn set_build_invocation_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.build_invocation_id = v.into();
            self
        }

        /// Sets the value of [build_started_on][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_started_on].
        pub fn set_build_started_on<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_started_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_started_on][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_started_on].
        pub fn set_or_clear_build_started_on<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_started_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [build_finished_on][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_finished_on].
        pub fn set_build_finished_on<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_finished_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_finished_on][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_finished_on].
        pub fn set_or_clear_build_finished_on<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.build_finished_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [completeness][crate::model::slsa_provenance_zero_two::SlsaMetadata::completeness].
        pub fn set_completeness<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaCompleteness>,
        {
            self.completeness = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [completeness][crate::model::slsa_provenance_zero_two::SlsaMetadata::completeness].
        pub fn set_or_clear_completeness<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaCompleteness>,
        {
            self.completeness = v.map(|x| x.into());
            self
        }

        /// Sets the value of [reproducible][crate::model::slsa_provenance_zero_two::SlsaMetadata::reproducible].
        pub fn set_reproducible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.reproducible = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaMetadata"
        }
    }

    /// Indicates that the builder claims certain fields in this message to be
    /// complete.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SlsaCompleteness {
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub parameters: bool,

        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub environment: bool,

        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub materials: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaCompleteness {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parameters][crate::model::slsa_provenance_zero_two::SlsaCompleteness::parameters].
        pub fn set_parameters<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.parameters = v.into();
            self
        }

        /// Sets the value of [environment][crate::model::slsa_provenance_zero_two::SlsaCompleteness::environment].
        pub fn set_environment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.environment = v.into();
            self
        }

        /// Sets the value of [materials][crate::model::slsa_provenance_zero_two::SlsaCompleteness::materials].
        pub fn set_materials<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.materials = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaCompleteness {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaCompleteness"
        }
    }
}

/// An Upgrade Note represents a potential upgrade of a package to a given
/// version. For each package version combination (i.e. bash 4.0, bash 4.1,
/// bash 4.1.2), there will be an Upgrade Note. For Windows, windows_update field
/// represents the information related to the update.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeNote {
    /// Required for non-Windows OS. The package this Upgrade is for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package: std::string::String,

    /// Required for non-Windows OS. The version of the package in machine + human
    /// readable form.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::Version>,

    /// Metadata about the upgrade for each specific operating system.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub distributions: std::vec::Vec<crate::model::UpgradeDistribution>,

    /// Required for Windows OS. Represents the metadata about the Windows update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub windows_update: std::option::Option<crate::model::WindowsUpdate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package][crate::model::UpgradeNote::package].
    pub fn set_package<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package = v.into();
        self
    }

    /// Sets the value of [version][crate::model::UpgradeNote::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::UpgradeNote::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [distributions][crate::model::UpgradeNote::distributions].
    pub fn set_distributions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UpgradeDistribution>,
    {
        use std::iter::Iterator;
        self.distributions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [windows_update][crate::model::UpgradeNote::windows_update].
    pub fn set_windows_update<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WindowsUpdate>,
    {
        self.windows_update = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [windows_update][crate::model::UpgradeNote::windows_update].
    pub fn set_or_clear_windows_update<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WindowsUpdate>,
    {
        self.windows_update = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpgradeNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpgradeNote"
    }
}

/// The Upgrade Distribution represents metadata about the Upgrade for each
/// operating system (CPE). Some distributions have additional metadata around
/// updates, classifying them into various categories and severities.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeDistribution {
    /// Required - The specific operating system this metadata applies to. See
    /// <https://cpe.mitre.org/specification/>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cpe_uri: std::string::String,

    /// The operating system classification of this Upgrade, as specified by the
    /// upstream operating system upgrade feed. For Windows the classification is
    /// one of the category_ids listed at
    /// <https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ff357803>(v=vs.85)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub classification: std::string::String,

    /// The severity as specified by the upstream operating system.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub severity: std::string::String,

    /// The cve tied to this Upgrade.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cve: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeDistribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpe_uri][crate::model::UpgradeDistribution::cpe_uri].
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [classification][crate::model::UpgradeDistribution::classification].
    pub fn set_classification<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.classification = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::UpgradeDistribution::severity].
    pub fn set_severity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [cve][crate::model::UpgradeDistribution::cve].
    pub fn set_cve<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.cve = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UpgradeDistribution {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpgradeDistribution"
    }
}

/// Windows Update represents the metadata about the update for the Windows
/// operating system. The fields in this message come from the Windows Update API
/// documented at
/// <https://docs.microsoft.com/en-us/windows/win32/api/wuapi/nn-wuapi-iupdate>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WindowsUpdate {
    /// Required - The unique identifier for the update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub identity: std::option::Option<crate::model::windows_update::Identity>,

    /// The localized title of the update.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// The localized description of the update.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The list of categories to which the update belongs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub categories: std::vec::Vec<crate::model::windows_update::Category>,

    /// The Microsoft Knowledge Base article IDs that are associated with the
    /// update.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub kb_article_ids: std::vec::Vec<std::string::String>,

    /// The hyperlink to the support information for the update.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub support_url: std::string::String,

    /// The last published timestamp of the update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_published_timestamp: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WindowsUpdate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [identity][crate::model::WindowsUpdate::identity].
    pub fn set_identity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::windows_update::Identity>,
    {
        self.identity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [identity][crate::model::WindowsUpdate::identity].
    pub fn set_or_clear_identity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::windows_update::Identity>,
    {
        self.identity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [title][crate::model::WindowsUpdate::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::WindowsUpdate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [categories][crate::model::WindowsUpdate::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::windows_update::Category>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kb_article_ids][crate::model::WindowsUpdate::kb_article_ids].
    pub fn set_kb_article_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.kb_article_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [support_url][crate::model::WindowsUpdate::support_url].
    pub fn set_support_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.support_url = v.into();
        self
    }

    /// Sets the value of [last_published_timestamp][crate::model::WindowsUpdate::last_published_timestamp].
    pub fn set_last_published_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_published_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_published_timestamp][crate::model::WindowsUpdate::last_published_timestamp].
    pub fn set_or_clear_last_published_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_published_timestamp = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WindowsUpdate {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.WindowsUpdate"
    }
}

/// Defines additional types related to [WindowsUpdate].
pub mod windows_update {
    #[allow(unused_imports)]
    use super::*;

    /// The unique identifier of the update.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Identity {
        /// The revision independent identifier of the update.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub update_id: std::string::String,

        /// The revision number of the update.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub revision: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Identity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [update_id][crate::model::windows_update::Identity::update_id].
        pub fn set_update_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.update_id = v.into();
            self
        }

        /// Sets the value of [revision][crate::model::windows_update::Identity::revision].
        pub fn set_revision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.revision = v.into();
            self
        }
    }

    impl wkt::message::Message for Identity {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.WindowsUpdate.Identity"
        }
    }

    /// The category to which the update belongs.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Category {
        /// The identifier of the category.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub category_id: std::string::String,

        /// The localized name of the category.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Category {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [category_id][crate::model::windows_update::Category::category_id].
        pub fn set_category_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.category_id = v.into();
            self
        }

        /// Sets the value of [name][crate::model::windows_update::Category::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    impl wkt::message::Message for Category {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.WindowsUpdate.Category"
        }
    }
}

/// An Upgrade Occurrence represents that a specific resource_url could install a
/// specific upgrade. This presence is supplied via local sources (i.e. it is
/// present in the mirror and the running system has noticed its availability).
/// For Windows, both distribution and windows_update contain information for the
/// Windows update.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeOccurrence {
    /// Required for non-Windows OS. The package this Upgrade is for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package: std::string::String,

    /// Required for non-Windows OS. The version of the package in a machine +
    /// human readable form.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parsed_version: std::option::Option<crate::model::Version>,

    /// Metadata about the upgrade for available for the specific operating system
    /// for the resource_url. This allows efficient filtering, as well as
    /// making it easier to use the occurrence.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub distribution: std::option::Option<crate::model::UpgradeDistribution>,

    /// Required for Windows OS. Represents the metadata about the Windows update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub windows_update: std::option::Option<crate::model::WindowsUpdate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package][crate::model::UpgradeOccurrence::package].
    pub fn set_package<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package = v.into();
        self
    }

    /// Sets the value of [parsed_version][crate::model::UpgradeOccurrence::parsed_version].
    pub fn set_parsed_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.parsed_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parsed_version][crate::model::UpgradeOccurrence::parsed_version].
    pub fn set_or_clear_parsed_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.parsed_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [distribution][crate::model::UpgradeOccurrence::distribution].
    pub fn set_distribution<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UpgradeDistribution>,
    {
        self.distribution = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [distribution][crate::model::UpgradeOccurrence::distribution].
    pub fn set_or_clear_distribution<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UpgradeDistribution>,
    {
        self.distribution = v.map(|x| x.into());
        self
    }

    /// Sets the value of [windows_update][crate::model::UpgradeOccurrence::windows_update].
    pub fn set_windows_update<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WindowsUpdate>,
    {
        self.windows_update = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [windows_update][crate::model::UpgradeOccurrence::windows_update].
    pub fn set_or_clear_windows_update<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WindowsUpdate>,
    {
        self.windows_update = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpgradeOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpgradeOccurrence"
    }
}

/// A single VulnerabilityAssessmentNote represents
/// one particular product's vulnerability assessment for one CVE.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VulnerabilityAssessmentNote {
    /// The title of the note. E.g. `Vex-Debian-11.4`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// A one sentence description of this Vex.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub short_description: std::string::String,

    /// A detailed description of this Vex.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub long_description: std::string::String,

    /// Identifies the language used by this document,
    /// corresponding to IETF BCP 47 / RFC 5646.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Publisher details of this Note.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub publisher: std::option::Option<crate::model::vulnerability_assessment_note::Publisher>,

    /// The product affected by this vex.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub product: std::option::Option<crate::model::vulnerability_assessment_note::Product>,

    /// Represents a vulnerability assessment for the product.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub assessment: std::option::Option<crate::model::vulnerability_assessment_note::Assessment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerabilityAssessmentNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [title][crate::model::VulnerabilityAssessmentNote::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [short_description][crate::model::VulnerabilityAssessmentNote::short_description].
    pub fn set_short_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.short_description = v.into();
        self
    }

    /// Sets the value of [long_description][crate::model::VulnerabilityAssessmentNote::long_description].
    pub fn set_long_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.long_description = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::VulnerabilityAssessmentNote::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [publisher][crate::model::VulnerabilityAssessmentNote::publisher].
    pub fn set_publisher<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_assessment_note::Publisher>,
    {
        self.publisher = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [publisher][crate::model::VulnerabilityAssessmentNote::publisher].
    pub fn set_or_clear_publisher<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_assessment_note::Publisher>,
    {
        self.publisher = v.map(|x| x.into());
        self
    }

    /// Sets the value of [product][crate::model::VulnerabilityAssessmentNote::product].
    pub fn set_product<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_assessment_note::Product>,
    {
        self.product = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [product][crate::model::VulnerabilityAssessmentNote::product].
    pub fn set_or_clear_product<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_assessment_note::Product>,
    {
        self.product = v.map(|x| x.into());
        self
    }

    /// Sets the value of [assessment][crate::model::VulnerabilityAssessmentNote::assessment].
    pub fn set_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_assessment_note::Assessment>,
    {
        self.assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assessment][crate::model::VulnerabilityAssessmentNote::assessment].
    pub fn set_or_clear_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_assessment_note::Assessment>,
    {
        self.assessment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VulnerabilityAssessmentNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote"
    }
}

/// Defines additional types related to [VulnerabilityAssessmentNote].
pub mod vulnerability_assessment_note {
    #[allow(unused_imports)]
    use super::*;

    /// Publisher contains information about the publisher of
    /// this Note.
    /// (-- api-linter: core::0123::resource-annotation=disabled
    /// aip.dev/not-precedent: Publisher is not a separate resource. --)
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Publisher {
        /// Name of the publisher.
        /// Examples: 'Google', 'Google Cloud Platform'.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Provides information about the authority of the issuing party to
        /// release the document, in particular, the party's constituency and
        /// responsibilities or other obligations.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub issuing_authority: std::string::String,

        /// The context or namespace.
        /// Contains a URL which is under control of the issuing party and can
        /// be used as a globally unique identifier for that issuing party.
        /// Example: <https://csaf.io>
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub publisher_namespace: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Publisher {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::vulnerability_assessment_note::Publisher::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [issuing_authority][crate::model::vulnerability_assessment_note::Publisher::issuing_authority].
        pub fn set_issuing_authority<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.issuing_authority = v.into();
            self
        }

        /// Sets the value of [publisher_namespace][crate::model::vulnerability_assessment_note::Publisher::publisher_namespace].
        pub fn set_publisher_namespace<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.publisher_namespace = v.into();
            self
        }
    }

    impl wkt::message::Message for Publisher {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Publisher"
        }
    }

    /// Product contains information about a product and how to uniquely identify
    /// it.
    /// (-- api-linter: core::0123::resource-annotation=disabled
    /// aip.dev/not-precedent: Product is not a separate resource. --)
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Product {
        /// Name of the product.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Token that identifies a product so that it can be referred to from other
        /// parts in the document. There is no predefined format as long as it
        /// uniquely identifies a group in the context of the current document.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub identifier:
            std::option::Option<crate::model::vulnerability_assessment_note::product::Identifier>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Product {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::vulnerability_assessment_note::Product::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [id][crate::model::vulnerability_assessment_note::Product::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [identifier][crate::model::vulnerability_assessment_note::Product::identifier].
        ///
        /// Note that all the setters affecting `identifier` are mutually
        /// exclusive.
        pub fn set_identifier<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::vulnerability_assessment_note::product::Identifier,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.identifier = v.into();
            self
        }

        /// The value of [identifier][crate::model::vulnerability_assessment_note::Product::identifier]
        /// if it holds a `GenericUri`, `None` if the field is not set or
        /// holds a different branch.
        pub fn generic_uri(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.identifier.as_ref().and_then(|v| match v {
                crate::model::vulnerability_assessment_note::product::Identifier::GenericUri(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [identifier][crate::model::vulnerability_assessment_note::Product::identifier]
        /// to hold a `GenericUri`.
        ///
        /// Note that all the setters affecting `identifier` are
        /// mutually exclusive.
        pub fn set_generic_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.identifier = std::option::Option::Some(
                crate::model::vulnerability_assessment_note::product::Identifier::GenericUri(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for Product {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Product"
        }
    }

    /// Defines additional types related to [Product].
    pub mod product {
        #[allow(unused_imports)]
        use super::*;

        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Identifier {
            /// Contains a URI which is vendor-specific.
            /// Example: The artifact repository URL of an image.
            GenericUri(std::string::String),
        }
    }

    /// Assessment provides all information that is related to a single
    /// vulnerability for this product.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Assessment {
        /// Holds the MITRE standard Common Vulnerabilities and Exposures (CVE)
        /// tracking number for the vulnerability.
        /// Deprecated: Use vulnerability_id instead to denote CVEs.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[deprecated]
        pub cve: std::string::String,

        /// The vulnerability identifier for this Assessment. Will hold one of
        /// common identifiers e.g. CVE, GHSA etc.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub vulnerability_id: std::string::String,

        /// A one sentence description of this Vex.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub short_description: std::string::String,

        /// A detailed description of this Vex.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub long_description: std::string::String,

        /// Holds a list of references associated with this vulnerability item and
        /// assessment. These uris have additional information about the
        /// vulnerability and the assessment itself. E.g. Link to a document which
        /// details how this assessment concluded the state of this vulnerability.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub related_uris: std::vec::Vec<crate::model::RelatedUrl>,

        /// Provides the state of this Vulnerability assessment.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub state: crate::model::vulnerability_assessment_note::assessment::State,

        /// Contains information about the impact of this vulnerability,
        /// this will change with time.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub impacts: std::vec::Vec<std::string::String>,

        /// Justification provides the justification when the state of the
        /// assessment if NOT_AFFECTED.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub justification: std::option::Option<
            crate::model::vulnerability_assessment_note::assessment::Justification,
        >,

        /// Specifies details on how to handle (and presumably, fix) a vulnerability.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub remediations:
            std::vec::Vec<crate::model::vulnerability_assessment_note::assessment::Remediation>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Assessment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cve][crate::model::vulnerability_assessment_note::Assessment::cve].
        #[deprecated]
        pub fn set_cve<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cve = v.into();
            self
        }

        /// Sets the value of [vulnerability_id][crate::model::vulnerability_assessment_note::Assessment::vulnerability_id].
        pub fn set_vulnerability_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.vulnerability_id = v.into();
            self
        }

        /// Sets the value of [short_description][crate::model::vulnerability_assessment_note::Assessment::short_description].
        pub fn set_short_description<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.short_description = v.into();
            self
        }

        /// Sets the value of [long_description][crate::model::vulnerability_assessment_note::Assessment::long_description].
        pub fn set_long_description<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.long_description = v.into();
            self
        }

        /// Sets the value of [related_uris][crate::model::vulnerability_assessment_note::Assessment::related_uris].
        pub fn set_related_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::RelatedUrl>,
        {
            use std::iter::Iterator;
            self.related_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [state][crate::model::vulnerability_assessment_note::Assessment::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [impacts][crate::model::vulnerability_assessment_note::Assessment::impacts].
        pub fn set_impacts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.impacts = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [justification][crate::model::vulnerability_assessment_note::Assessment::justification].
        pub fn set_justification<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::vulnerability_assessment_note::assessment::Justification,
                >,
        {
            self.justification = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [justification][crate::model::vulnerability_assessment_note::Assessment::justification].
        pub fn set_or_clear_justification<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::vulnerability_assessment_note::assessment::Justification,
                >,
        {
            self.justification = v.map(|x| x.into());
            self
        }

        /// Sets the value of [remediations][crate::model::vulnerability_assessment_note::Assessment::remediations].
        pub fn set_remediations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::vulnerability_assessment_note::assessment::Remediation,
                >,
        {
            use std::iter::Iterator;
            self.remediations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Assessment {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Assessment"
        }
    }

    /// Defines additional types related to [Assessment].
    pub mod assessment {
        #[allow(unused_imports)]
        use super::*;

        /// Justification provides the justification when the state of the
        /// assessment if NOT_AFFECTED.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Justification {

            /// The justification type for this vulnerability.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub justification_type: crate::model::vulnerability_assessment_note::assessment::justification::JustificationType,

            /// Additional details on why this justification was chosen.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub details: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Justification {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [justification_type][crate::model::vulnerability_assessment_note::assessment::Justification::justification_type].
            pub fn set_justification_type<T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::justification::JustificationType>>(mut self, v: T) -> Self{
                self.justification_type = v.into();
                self
            }

            /// Sets the value of [details][crate::model::vulnerability_assessment_note::assessment::Justification::details].
            pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.details = v.into();
                self
            }
        }

        impl wkt::message::Message for Justification {
            fn typename() -> &'static str {
                "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Assessment.Justification"
            }
        }

        /// Defines additional types related to [Justification].
        pub mod justification {
            #[allow(unused_imports)]
            use super::*;

            /// Provides the type of justification.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum JustificationType {
                /// JUSTIFICATION_TYPE_UNSPECIFIED.
                Unspecified,
                /// The vulnerable component is not present in the product.
                ComponentNotPresent,
                /// The vulnerable code is not present. Typically this case
                /// occurs when source code is configured or built in a way that excludes
                /// the vulnerable code.
                VulnerableCodeNotPresent,
                /// The vulnerable code can not be executed.
                /// Typically this case occurs when the product includes the vulnerable
                /// code but does not call or use the vulnerable code.
                VulnerableCodeNotInExecutePath,
                /// The vulnerable code cannot be controlled by an attacker to exploit
                /// the vulnerability.
                VulnerableCodeCannotBeControlledByAdversary,
                /// The product includes built-in protections or features that prevent
                /// exploitation of the vulnerability. These built-in protections cannot
                /// be subverted by the attacker and cannot be configured or disabled by
                /// the user. These mitigations completely prevent exploitation based on
                /// known attack vectors.
                InlineMitigationsAlreadyExist,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [JustificationType::value] or
                /// [JustificationType::name].
                UnknownValue(justification_type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod justification_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl JustificationType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::ComponentNotPresent => std::option::Option::Some(1),
                        Self::VulnerableCodeNotPresent => std::option::Option::Some(2),
                        Self::VulnerableCodeNotInExecutePath => std::option::Option::Some(3),
                        Self::VulnerableCodeCannotBeControlledByAdversary => {
                            std::option::Option::Some(4)
                        }
                        Self::InlineMitigationsAlreadyExist => std::option::Option::Some(5),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("JUSTIFICATION_TYPE_UNSPECIFIED")
                        }
                        Self::ComponentNotPresent => {
                            std::option::Option::Some("COMPONENT_NOT_PRESENT")
                        }
                        Self::VulnerableCodeNotPresent => {
                            std::option::Option::Some("VULNERABLE_CODE_NOT_PRESENT")
                        }
                        Self::VulnerableCodeNotInExecutePath => {
                            std::option::Option::Some("VULNERABLE_CODE_NOT_IN_EXECUTE_PATH")
                        }
                        Self::VulnerableCodeCannotBeControlledByAdversary => {
                            std::option::Option::Some(
                                "VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY",
                            )
                        }
                        Self::InlineMitigationsAlreadyExist => {
                            std::option::Option::Some("INLINE_MITIGATIONS_ALREADY_EXIST")
                        }
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for JustificationType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for JustificationType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for JustificationType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::ComponentNotPresent,
                        2 => Self::VulnerableCodeNotPresent,
                        3 => Self::VulnerableCodeNotInExecutePath,
                        4 => Self::VulnerableCodeCannotBeControlledByAdversary,
                        5 => Self::InlineMitigationsAlreadyExist,
                        _ => Self::UnknownValue(justification_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for JustificationType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "JUSTIFICATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "COMPONENT_NOT_PRESENT" => Self::ComponentNotPresent,
                        "VULNERABLE_CODE_NOT_PRESENT" => Self::VulnerableCodeNotPresent,
                        "VULNERABLE_CODE_NOT_IN_EXECUTE_PATH" => {
                            Self::VulnerableCodeNotInExecutePath
                        }
                        "VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY" => {
                            Self::VulnerableCodeCannotBeControlledByAdversary
                        }
                        "INLINE_MITIGATIONS_ALREADY_EXIST" => Self::InlineMitigationsAlreadyExist,
                        _ => Self::UnknownValue(justification_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for JustificationType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::ComponentNotPresent => serializer.serialize_i32(1),
                        Self::VulnerableCodeNotPresent => serializer.serialize_i32(2),
                        Self::VulnerableCodeNotInExecutePath => serializer.serialize_i32(3),
                        Self::VulnerableCodeCannotBeControlledByAdversary => {
                            serializer.serialize_i32(4)
                        }
                        Self::InlineMitigationsAlreadyExist => serializer.serialize_i32(5),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for JustificationType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<JustificationType>::new(
                        ".grafeas.v1.VulnerabilityAssessmentNote.Assessment.Justification.JustificationType"))
                }
            }
        }

        /// Specifies details on how to handle (and presumably, fix) a vulnerability.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Remediation {

            /// The type of remediation that can be applied.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub remediation_type: crate::model::vulnerability_assessment_note::assessment::remediation::RemediationType,

            /// Contains a comprehensive human-readable discussion of the remediation.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub details: std::string::String,

            /// Contains the URL where to obtain the remediation.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub remediation_uri: std::option::Option<crate::model::RelatedUrl>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Remediation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [remediation_type][crate::model::vulnerability_assessment_note::assessment::Remediation::remediation_type].
            pub fn set_remediation_type<T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::remediation::RemediationType>>(mut self, v: T) -> Self{
                self.remediation_type = v.into();
                self
            }

            /// Sets the value of [details][crate::model::vulnerability_assessment_note::assessment::Remediation::details].
            pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.details = v.into();
                self
            }

            /// Sets the value of [remediation_uri][crate::model::vulnerability_assessment_note::assessment::Remediation::remediation_uri].
            pub fn set_remediation_uri<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::RelatedUrl>,
            {
                self.remediation_uri = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [remediation_uri][crate::model::vulnerability_assessment_note::assessment::Remediation::remediation_uri].
            pub fn set_or_clear_remediation_uri<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::RelatedUrl>,
            {
                self.remediation_uri = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Remediation {
            fn typename() -> &'static str {
                "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Assessment.Remediation"
            }
        }

        /// Defines additional types related to [Remediation].
        pub mod remediation {
            #[allow(unused_imports)]
            use super::*;

            /// The type of remediation that can be applied.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum RemediationType {
                /// No remediation type specified.
                Unspecified,
                /// A MITIGATION is available.
                Mitigation,
                /// No fix is planned.
                NoFixPlanned,
                /// Not available.
                NoneAvailable,
                /// A vendor fix is available.
                VendorFix,
                /// A workaround is available.
                Workaround,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [RemediationType::value] or
                /// [RemediationType::name].
                UnknownValue(remediation_type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod remediation_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl RemediationType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Mitigation => std::option::Option::Some(1),
                        Self::NoFixPlanned => std::option::Option::Some(2),
                        Self::NoneAvailable => std::option::Option::Some(3),
                        Self::VendorFix => std::option::Option::Some(4),
                        Self::Workaround => std::option::Option::Some(5),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("REMEDIATION_TYPE_UNSPECIFIED")
                        }
                        Self::Mitigation => std::option::Option::Some("MITIGATION"),
                        Self::NoFixPlanned => std::option::Option::Some("NO_FIX_PLANNED"),
                        Self::NoneAvailable => std::option::Option::Some("NONE_AVAILABLE"),
                        Self::VendorFix => std::option::Option::Some("VENDOR_FIX"),
                        Self::Workaround => std::option::Option::Some("WORKAROUND"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for RemediationType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for RemediationType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for RemediationType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Mitigation,
                        2 => Self::NoFixPlanned,
                        3 => Self::NoneAvailable,
                        4 => Self::VendorFix,
                        5 => Self::Workaround,
                        _ => Self::UnknownValue(remediation_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for RemediationType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "REMEDIATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "MITIGATION" => Self::Mitigation,
                        "NO_FIX_PLANNED" => Self::NoFixPlanned,
                        "NONE_AVAILABLE" => Self::NoneAvailable,
                        "VENDOR_FIX" => Self::VendorFix,
                        "WORKAROUND" => Self::Workaround,
                        _ => Self::UnknownValue(remediation_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for RemediationType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Mitigation => serializer.serialize_i32(1),
                        Self::NoFixPlanned => serializer.serialize_i32(2),
                        Self::NoneAvailable => serializer.serialize_i32(3),
                        Self::VendorFix => serializer.serialize_i32(4),
                        Self::Workaround => serializer.serialize_i32(5),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for RemediationType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<RemediationType>::new(
                        ".grafeas.v1.VulnerabilityAssessmentNote.Assessment.Remediation.RemediationType"))
                }
            }
        }

        /// Provides the state of this Vulnerability assessment.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// No state is specified.
            Unspecified,
            /// This product is known to be affected by this vulnerability.
            Affected,
            /// This product is known to be not affected by this vulnerability.
            NotAffected,
            /// This product contains a fix for this vulnerability.
            Fixed,
            /// It is not known yet whether these versions are or are not affected
            /// by the vulnerability. However, it is still under investigation.
            UnderInvestigation,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Affected => std::option::Option::Some(1),
                    Self::NotAffected => std::option::Option::Some(2),
                    Self::Fixed => std::option::Option::Some(3),
                    Self::UnderInvestigation => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Affected => std::option::Option::Some("AFFECTED"),
                    Self::NotAffected => std::option::Option::Some("NOT_AFFECTED"),
                    Self::Fixed => std::option::Option::Some("FIXED"),
                    Self::UnderInvestigation => std::option::Option::Some("UNDER_INVESTIGATION"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Affected,
                    2 => Self::NotAffected,
                    3 => Self::Fixed,
                    4 => Self::UnderInvestigation,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "AFFECTED" => Self::Affected,
                    "NOT_AFFECTED" => Self::NotAffected,
                    "FIXED" => Self::Fixed,
                    "UNDER_INVESTIGATION" => Self::UnderInvestigation,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Affected => serializer.serialize_i32(1),
                    Self::NotAffected => serializer.serialize_i32(2),
                    Self::Fixed => serializer.serialize_i32(3),
                    Self::UnderInvestigation => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".grafeas.v1.VulnerabilityAssessmentNote.Assessment.State",
                ))
            }
        }
    }
}

/// A security vulnerability that can be found in resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VulnerabilityNote {
    /// The CVSS score of this vulnerability. CVSS score is on a scale of 0 - 10
    /// where 0 indicates low severity and 10 indicates high severity.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub cvss_score: f32,

    /// The note provider assigned severity of this vulnerability.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub severity: crate::model::Severity,

    /// Details of all known distros and packages affected by this vulnerability.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub details: std::vec::Vec<crate::model::vulnerability_note::Detail>,

    /// The full description of the CVSSv3 for this vulnerability.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cvss_v3: std::option::Option<crate::model::CVSSv3>,

    /// Windows details get their own format because the information format and
    /// model don't match a normal detail. Specifically Windows updates are done as
    /// patches, thus Windows vulnerabilities really are a missing package, rather
    /// than a package being at an incorrect version.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub windows_details: std::vec::Vec<crate::model::vulnerability_note::WindowsDetail>,

    /// The time this information was last changed at the source. This is an
    /// upstream timestamp from the underlying information source - e.g. Ubuntu
    /// security tracker.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_update_time: std::option::Option<wkt::Timestamp>,

    /// CVSS version used to populate cvss_score and severity.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub cvss_version: crate::model::CVSSVersion,

    /// The full description of the v2 CVSS for this vulnerability.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cvss_v2: std::option::Option<crate::model::Cvss>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerabilityNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cvss_score][crate::model::VulnerabilityNote::cvss_score].
    pub fn set_cvss_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.cvss_score = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::VulnerabilityNote::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [details][crate::model::VulnerabilityNote::details].
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerability_note::Detail>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cvss_v3][crate::model::VulnerabilityNote::cvss_v3].
    pub fn set_cvss_v3<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CVSSv3>,
    {
        self.cvss_v3 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cvss_v3][crate::model::VulnerabilityNote::cvss_v3].
    pub fn set_or_clear_cvss_v3<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CVSSv3>,
    {
        self.cvss_v3 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [windows_details][crate::model::VulnerabilityNote::windows_details].
    pub fn set_windows_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerability_note::WindowsDetail>,
    {
        use std::iter::Iterator;
        self.windows_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_update_time][crate::model::VulnerabilityNote::source_update_time].
    pub fn set_source_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.source_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_update_time][crate::model::VulnerabilityNote::source_update_time].
    pub fn set_or_clear_source_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.source_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cvss_version][crate::model::VulnerabilityNote::cvss_version].
    pub fn set_cvss_version<T: std::convert::Into<crate::model::CVSSVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.cvss_version = v.into();
        self
    }

    /// Sets the value of [cvss_v2][crate::model::VulnerabilityNote::cvss_v2].
    pub fn set_cvss_v2<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cvss>,
    {
        self.cvss_v2 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cvss_v2][crate::model::VulnerabilityNote::cvss_v2].
    pub fn set_or_clear_cvss_v2<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cvss>,
    {
        self.cvss_v2 = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VulnerabilityNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.VulnerabilityNote"
    }
}

/// Defines additional types related to [VulnerabilityNote].
pub mod vulnerability_note {
    #[allow(unused_imports)]
    use super::*;

    /// A detail for a distro and package affected by this vulnerability and its
    /// associated fix (if one is available).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Detail {
        /// The distro assigned severity of this vulnerability.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub severity_name: std::string::String,

        /// A vendor-specific description of this vulnerability.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub description: std::string::String,

        /// The type of package; whether native or non native (e.g., ruby gems,
        /// node.js packages, etc.).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub package_type: std::string::String,

        /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
        /// vulnerability affects.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub affected_cpe_uri: std::string::String,

        /// Required. The package this vulnerability affects.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub affected_package: std::string::String,

        /// The version number at the start of an interval in which this
        /// vulnerability exists. A vulnerability can affect a package between
        /// version numbers that are disjoint sets of intervals (example:
        /// [1.0.0-1.1.0], [2.4.6-2.4.8] and [4.5.6-4.6.8]) each of which will be
        /// represented in its own Detail. If a specific affected version is provided
        /// by a vulnerability database, affected_version_start and
        /// affected_version_end will be the same in that Detail.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub affected_version_start: std::option::Option<crate::model::Version>,

        /// The version number at the end of an interval in which this vulnerability
        /// exists. A vulnerability can affect a package between version numbers
        /// that are disjoint sets of intervals (example: [1.0.0-1.1.0],
        /// [2.4.6-2.4.8] and [4.5.6-4.6.8]) each of which will be represented in its
        /// own Detail. If a specific affected version is provided by a vulnerability
        /// database, affected_version_start and affected_version_end will be the
        /// same in that Detail.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub affected_version_end: std::option::Option<crate::model::Version>,

        /// The distro recommended [CPE URI](https://cpe.mitre.org/specification/)
        /// to update to that contains a fix for this vulnerability. It is possible
        /// for this to be different from the affected_cpe_uri.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub fixed_cpe_uri: std::string::String,

        /// The distro recommended package to update to that contains a fix for this
        /// vulnerability. It is possible for this to be different from the
        /// affected_package.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub fixed_package: std::string::String,

        /// The distro recommended version to update to that contains a
        /// fix for this vulnerability. Setting this to VersionKind.MAXIMUM means no
        /// such version is yet available.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub fixed_version: std::option::Option<crate::model::Version>,

        /// Whether this detail is obsolete. Occurrences are expected not to point to
        /// obsolete details.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub is_obsolete: bool,

        /// The time this information was last changed at the source. This is an
        /// upstream timestamp from the underlying information source - e.g. Ubuntu
        /// security tracker.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub source_update_time: std::option::Option<wkt::Timestamp>,

        /// The source from which the information in this Detail was obtained.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source: std::string::String,

        /// The name of the vendor of the product.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub vendor: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Detail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [severity_name][crate::model::vulnerability_note::Detail::severity_name].
        pub fn set_severity_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.severity_name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::vulnerability_note::Detail::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [package_type][crate::model::vulnerability_note::Detail::package_type].
        pub fn set_package_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.package_type = v.into();
            self
        }

        /// Sets the value of [affected_cpe_uri][crate::model::vulnerability_note::Detail::affected_cpe_uri].
        pub fn set_affected_cpe_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.affected_cpe_uri = v.into();
            self
        }

        /// Sets the value of [affected_package][crate::model::vulnerability_note::Detail::affected_package].
        pub fn set_affected_package<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.affected_package = v.into();
            self
        }

        /// Sets the value of [affected_version_start][crate::model::vulnerability_note::Detail::affected_version_start].
        pub fn set_affected_version_start<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.affected_version_start = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [affected_version_start][crate::model::vulnerability_note::Detail::affected_version_start].
        pub fn set_or_clear_affected_version_start<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.affected_version_start = v.map(|x| x.into());
            self
        }

        /// Sets the value of [affected_version_end][crate::model::vulnerability_note::Detail::affected_version_end].
        pub fn set_affected_version_end<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.affected_version_end = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [affected_version_end][crate::model::vulnerability_note::Detail::affected_version_end].
        pub fn set_or_clear_affected_version_end<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.affected_version_end = v.map(|x| x.into());
            self
        }

        /// Sets the value of [fixed_cpe_uri][crate::model::vulnerability_note::Detail::fixed_cpe_uri].
        pub fn set_fixed_cpe_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.fixed_cpe_uri = v.into();
            self
        }

        /// Sets the value of [fixed_package][crate::model::vulnerability_note::Detail::fixed_package].
        pub fn set_fixed_package<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.fixed_package = v.into();
            self
        }

        /// Sets the value of [fixed_version][crate::model::vulnerability_note::Detail::fixed_version].
        pub fn set_fixed_version<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.fixed_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [fixed_version][crate::model::vulnerability_note::Detail::fixed_version].
        pub fn set_or_clear_fixed_version<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.fixed_version = v.map(|x| x.into());
            self
        }

        /// Sets the value of [is_obsolete][crate::model::vulnerability_note::Detail::is_obsolete].
        pub fn set_is_obsolete<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.is_obsolete = v.into();
            self
        }

        /// Sets the value of [source_update_time][crate::model::vulnerability_note::Detail::source_update_time].
        pub fn set_source_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.source_update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [source_update_time][crate::model::vulnerability_note::Detail::source_update_time].
        pub fn set_or_clear_source_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.source_update_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [source][crate::model::vulnerability_note::Detail::source].
        pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source = v.into();
            self
        }

        /// Sets the value of [vendor][crate::model::vulnerability_note::Detail::vendor].
        pub fn set_vendor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.vendor = v.into();
            self
        }
    }

    impl wkt::message::Message for Detail {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityNote.Detail"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WindowsDetail {
        /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
        /// vulnerability affects.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cpe_uri: std::string::String,

        /// Required. The name of this vulnerability.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// The description of this vulnerability.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub description: std::string::String,

        /// Required. The names of the KBs which have hotfixes to mitigate this
        /// vulnerability. Note that there may be multiple hotfixes (and thus
        /// multiple KBs) that mitigate a given vulnerability. Currently any listed
        /// KBs presence is considered a fix.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub fixing_kbs:
            std::vec::Vec<crate::model::vulnerability_note::windows_detail::KnowledgeBase>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WindowsDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpe_uri][crate::model::vulnerability_note::WindowsDetail::cpe_uri].
        pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cpe_uri = v.into();
            self
        }

        /// Sets the value of [name][crate::model::vulnerability_note::WindowsDetail::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::vulnerability_note::WindowsDetail::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [fixing_kbs][crate::model::vulnerability_note::WindowsDetail::fixing_kbs].
        pub fn set_fixing_kbs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::vulnerability_note::windows_detail::KnowledgeBase>,
        {
            use std::iter::Iterator;
            self.fixing_kbs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for WindowsDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityNote.WindowsDetail"
        }
    }

    /// Defines additional types related to [WindowsDetail].
    pub mod windows_detail {
        #[allow(unused_imports)]
        use super::*;

        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct KnowledgeBase {
            /// The KB name (generally of the form KB[0-9]+ (e.g., KB123456)).
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub name: std::string::String,

            /// A link to the KB in the [Windows update catalog]
            /// (<https://www.catalog.update.microsoft.com/>).
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub url: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl KnowledgeBase {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::vulnerability_note::windows_detail::KnowledgeBase::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of [url][crate::model::vulnerability_note::windows_detail::KnowledgeBase::url].
            pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.url = v.into();
                self
            }
        }

        impl wkt::message::Message for KnowledgeBase {
            fn typename() -> &'static str {
                "type.googleapis.com/grafeas.v1.VulnerabilityNote.WindowsDetail.KnowledgeBase"
            }
        }
    }
}

/// An occurrence of a severity vulnerability on a resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VulnerabilityOccurrence {
    /// The type of package; whether native or non native (e.g., ruby gems, node.js
    /// packages, etc.).
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Output only. The note provider assigned severity of this vulnerability.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub severity: crate::model::Severity,

    /// Output only. The CVSS score of this vulnerability. CVSS score is on a
    /// scale of 0 - 10 where 0 indicates low severity and 10 indicates high
    /// severity.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub cvss_score: f32,

    /// The cvss v3 score for the vulnerability.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cvssv3: std::option::Option<crate::model::Cvss>,

    /// Required. The set of affected locations and their fixes (if available)
    /// within the associated resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub package_issue: std::vec::Vec<crate::model::vulnerability_occurrence::PackageIssue>,

    /// Output only. A one sentence description of this vulnerability.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub short_description: std::string::String,

    /// Output only. A detailed description of this vulnerability.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub long_description: std::string::String,

    /// Output only. URLs related to this vulnerability.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub related_urls: std::vec::Vec<crate::model::RelatedUrl>,

    /// The distro assigned severity for this vulnerability when it is available,
    /// otherwise this is the note provider assigned severity.
    ///
    /// When there are multiple PackageIssues for this vulnerability, they can have
    /// different effective severities because some might be provided by the distro
    /// while others are provided by the language ecosystem for a language pack.
    /// For this reason, it is advised to use the effective severity on the
    /// PackageIssue level. In the case where multiple PackageIssues have differing
    /// effective severities, this field should be the highest severity for any of
    /// the PackageIssues.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub effective_severity: crate::model::Severity,

    /// Output only. Whether at least one of the affected packages has a fix
    /// available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub fix_available: bool,

    /// Output only. CVSS version used to populate cvss_score and severity.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub cvss_version: crate::model::CVSSVersion,

    /// The cvss v2 score for the vulnerability.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cvss_v2: std::option::Option<crate::model::Cvss>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vex_assessment: std::option::Option<crate::model::vulnerability_occurrence::VexAssessment>,

    /// Occurrence-specific extra details about the vulnerability.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub extra_details: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerabilityOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::VulnerabilityOccurrence::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::VulnerabilityOccurrence::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [cvss_score][crate::model::VulnerabilityOccurrence::cvss_score].
    pub fn set_cvss_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.cvss_score = v.into();
        self
    }

    /// Sets the value of [cvssv3][crate::model::VulnerabilityOccurrence::cvssv3].
    pub fn set_cvssv3<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cvss>,
    {
        self.cvssv3 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cvssv3][crate::model::VulnerabilityOccurrence::cvssv3].
    pub fn set_or_clear_cvssv3<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cvss>,
    {
        self.cvssv3 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [package_issue][crate::model::VulnerabilityOccurrence::package_issue].
    pub fn set_package_issue<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerability_occurrence::PackageIssue>,
    {
        use std::iter::Iterator;
        self.package_issue = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [short_description][crate::model::VulnerabilityOccurrence::short_description].
    pub fn set_short_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.short_description = v.into();
        self
    }

    /// Sets the value of [long_description][crate::model::VulnerabilityOccurrence::long_description].
    pub fn set_long_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.long_description = v.into();
        self
    }

    /// Sets the value of [related_urls][crate::model::VulnerabilityOccurrence::related_urls].
    pub fn set_related_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedUrl>,
    {
        use std::iter::Iterator;
        self.related_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [effective_severity][crate::model::VulnerabilityOccurrence::effective_severity].
    pub fn set_effective_severity<T: std::convert::Into<crate::model::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.effective_severity = v.into();
        self
    }

    /// Sets the value of [fix_available][crate::model::VulnerabilityOccurrence::fix_available].
    pub fn set_fix_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.fix_available = v.into();
        self
    }

    /// Sets the value of [cvss_version][crate::model::VulnerabilityOccurrence::cvss_version].
    pub fn set_cvss_version<T: std::convert::Into<crate::model::CVSSVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.cvss_version = v.into();
        self
    }

    /// Sets the value of [cvss_v2][crate::model::VulnerabilityOccurrence::cvss_v2].
    pub fn set_cvss_v2<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cvss>,
    {
        self.cvss_v2 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cvss_v2][crate::model::VulnerabilityOccurrence::cvss_v2].
    pub fn set_or_clear_cvss_v2<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cvss>,
    {
        self.cvss_v2 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vex_assessment][crate::model::VulnerabilityOccurrence::vex_assessment].
    pub fn set_vex_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_occurrence::VexAssessment>,
    {
        self.vex_assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vex_assessment][crate::model::VulnerabilityOccurrence::vex_assessment].
    pub fn set_or_clear_vex_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vulnerability_occurrence::VexAssessment>,
    {
        self.vex_assessment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [extra_details][crate::model::VulnerabilityOccurrence::extra_details].
    pub fn set_extra_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.extra_details = v.into();
        self
    }
}

impl wkt::message::Message for VulnerabilityOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.VulnerabilityOccurrence"
    }
}

/// Defines additional types related to [VulnerabilityOccurrence].
pub mod vulnerability_occurrence {
    #[allow(unused_imports)]
    use super::*;

    /// A detail for a distro and package this vulnerability occurrence was found
    /// in and its associated fix (if one is available).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PackageIssue {
        /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
        /// vulnerability was found in.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub affected_cpe_uri: std::string::String,

        /// Required. The package this vulnerability was found in.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub affected_package: std::string::String,

        /// Required. The version of the package that is installed on the resource
        /// affected by this vulnerability.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub affected_version: std::option::Option<crate::model::Version>,

        /// The [CPE URI](https://cpe.mitre.org/specification/) this vulnerability
        /// was fixed in. It is possible for this to be different from the
        /// affected_cpe_uri.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub fixed_cpe_uri: std::string::String,

        /// The package this vulnerability was fixed in. It is possible for this to
        /// be different from the affected_package.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub fixed_package: std::string::String,

        /// Required. The version of the package this vulnerability was fixed in.
        /// Setting this to VersionKind.MAXIMUM means no fix is yet available.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub fixed_version: std::option::Option<crate::model::Version>,

        /// Output only. Whether a fix is available for this package.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub fix_available: bool,

        /// The type of package (e.g. OS, MAVEN, GO).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub package_type: std::string::String,

        /// The distro or language system assigned severity for this vulnerability
        /// when that is available and note provider assigned severity when it is not
        /// available.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub effective_severity: crate::model::Severity,

        /// The location at which this package was found.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub file_location: std::vec::Vec<crate::model::FileLocation>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PackageIssue {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [affected_cpe_uri][crate::model::vulnerability_occurrence::PackageIssue::affected_cpe_uri].
        pub fn set_affected_cpe_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.affected_cpe_uri = v.into();
            self
        }

        /// Sets the value of [affected_package][crate::model::vulnerability_occurrence::PackageIssue::affected_package].
        pub fn set_affected_package<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.affected_package = v.into();
            self
        }

        /// Sets the value of [affected_version][crate::model::vulnerability_occurrence::PackageIssue::affected_version].
        pub fn set_affected_version<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.affected_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [affected_version][crate::model::vulnerability_occurrence::PackageIssue::affected_version].
        pub fn set_or_clear_affected_version<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.affected_version = v.map(|x| x.into());
            self
        }

        /// Sets the value of [fixed_cpe_uri][crate::model::vulnerability_occurrence::PackageIssue::fixed_cpe_uri].
        pub fn set_fixed_cpe_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.fixed_cpe_uri = v.into();
            self
        }

        /// Sets the value of [fixed_package][crate::model::vulnerability_occurrence::PackageIssue::fixed_package].
        pub fn set_fixed_package<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.fixed_package = v.into();
            self
        }

        /// Sets the value of [fixed_version][crate::model::vulnerability_occurrence::PackageIssue::fixed_version].
        pub fn set_fixed_version<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.fixed_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [fixed_version][crate::model::vulnerability_occurrence::PackageIssue::fixed_version].
        pub fn set_or_clear_fixed_version<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Version>,
        {
            self.fixed_version = v.map(|x| x.into());
            self
        }

        /// Sets the value of [fix_available][crate::model::vulnerability_occurrence::PackageIssue::fix_available].
        pub fn set_fix_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.fix_available = v.into();
            self
        }

        /// Sets the value of [package_type][crate::model::vulnerability_occurrence::PackageIssue::package_type].
        pub fn set_package_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.package_type = v.into();
            self
        }

        /// Sets the value of [effective_severity][crate::model::vulnerability_occurrence::PackageIssue::effective_severity].
        pub fn set_effective_severity<T: std::convert::Into<crate::model::Severity>>(
            mut self,
            v: T,
        ) -> Self {
            self.effective_severity = v.into();
            self
        }

        /// Sets the value of [file_location][crate::model::vulnerability_occurrence::PackageIssue::file_location].
        pub fn set_file_location<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FileLocation>,
        {
            use std::iter::Iterator;
            self.file_location = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PackageIssue {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityOccurrence.PackageIssue"
        }
    }

    /// VexAssessment provides all publisher provided Vex information that is
    /// related to this vulnerability.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VexAssessment {
        /// Holds the MITRE standard Common Vulnerabilities and Exposures (CVE)
        /// tracking number for the vulnerability.
        /// Deprecated: Use vulnerability_id instead to denote CVEs.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[deprecated]
        pub cve: std::string::String,

        /// The vulnerability identifier for this Assessment. Will hold one of
        /// common identifiers e.g. CVE, GHSA etc.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub vulnerability_id: std::string::String,

        /// Holds a list of references associated with this vulnerability item and
        /// assessment.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub related_uris: std::vec::Vec<crate::model::RelatedUrl>,

        /// The VulnerabilityAssessment note from which this VexAssessment was
        /// generated.
        /// This will be of the form: `projects/[PROJECT_ID]/notes/[NOTE_ID]`.
        /// (-- api-linter: core::0122::name-suffix=disabled
        /// aip.dev/not-precedent: The suffix is kept for consistency. --)
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub note_name: std::string::String,

        /// Provides the state of this Vulnerability assessment.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub state: crate::model::vulnerability_assessment_note::assessment::State,

        /// Contains information about the impact of this vulnerability,
        /// this will change with time.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub impacts: std::vec::Vec<std::string::String>,

        /// Specifies details on how to handle (and presumably, fix) a vulnerability.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub remediations:
            std::vec::Vec<crate::model::vulnerability_assessment_note::assessment::Remediation>,

        /// Justification provides the justification when the state of the
        /// assessment if NOT_AFFECTED.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub justification: std::option::Option<
            crate::model::vulnerability_assessment_note::assessment::Justification,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VexAssessment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cve][crate::model::vulnerability_occurrence::VexAssessment::cve].
        #[deprecated]
        pub fn set_cve<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cve = v.into();
            self
        }

        /// Sets the value of [vulnerability_id][crate::model::vulnerability_occurrence::VexAssessment::vulnerability_id].
        pub fn set_vulnerability_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.vulnerability_id = v.into();
            self
        }

        /// Sets the value of [related_uris][crate::model::vulnerability_occurrence::VexAssessment::related_uris].
        pub fn set_related_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::RelatedUrl>,
        {
            use std::iter::Iterator;
            self.related_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [note_name][crate::model::vulnerability_occurrence::VexAssessment::note_name].
        pub fn set_note_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.note_name = v.into();
            self
        }

        /// Sets the value of [state][crate::model::vulnerability_occurrence::VexAssessment::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [impacts][crate::model::vulnerability_occurrence::VexAssessment::impacts].
        pub fn set_impacts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.impacts = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [remediations][crate::model::vulnerability_occurrence::VexAssessment::remediations].
        pub fn set_remediations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::vulnerability_assessment_note::assessment::Remediation,
                >,
        {
            use std::iter::Iterator;
            self.remediations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [justification][crate::model::vulnerability_occurrence::VexAssessment::justification].
        pub fn set_justification<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::vulnerability_assessment_note::assessment::Justification,
                >,
        {
            self.justification = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [justification][crate::model::vulnerability_occurrence::VexAssessment::justification].
        pub fn set_or_clear_justification<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::vulnerability_assessment_note::assessment::Justification,
                >,
        {
            self.justification = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for VexAssessment {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityOccurrence.VexAssessment"
        }
    }
}

/// Kind represents the kinds of notes supported.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NoteKind {
    /// Default value. This value is unused.
    Unspecified,
    /// The note and occurrence represent a package vulnerability.
    Vulnerability,
    /// The note and occurrence assert build provenance.
    Build,
    /// This represents an image basis relationship.
    Image,
    /// This represents a package installed via a package manager.
    Package,
    /// The note and occurrence track deployment events.
    Deployment,
    /// The note and occurrence track the initial discovery status of a resource.
    Discovery,
    /// This represents a logical "role" that can attest to artifacts.
    Attestation,
    /// This represents an available package upgrade.
    Upgrade,
    /// This represents a Compliance Note
    Compliance,
    /// This represents a DSSE attestation Note
    DsseAttestation,
    /// This represents a Vulnerability Assessment.
    VulnerabilityAssessment,
    /// This represents an SBOM Reference.
    SbomReference,
    /// This represents a secret.
    Secret,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NoteKind::value] or
    /// [NoteKind::name].
    UnknownValue(note_kind::UnknownValue),
}

#[doc(hidden)]
pub mod note_kind {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl NoteKind {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Vulnerability => std::option::Option::Some(1),
            Self::Build => std::option::Option::Some(2),
            Self::Image => std::option::Option::Some(3),
            Self::Package => std::option::Option::Some(4),
            Self::Deployment => std::option::Option::Some(5),
            Self::Discovery => std::option::Option::Some(6),
            Self::Attestation => std::option::Option::Some(7),
            Self::Upgrade => std::option::Option::Some(8),
            Self::Compliance => std::option::Option::Some(9),
            Self::DsseAttestation => std::option::Option::Some(10),
            Self::VulnerabilityAssessment => std::option::Option::Some(11),
            Self::SbomReference => std::option::Option::Some(12),
            Self::Secret => std::option::Option::Some(13),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("NOTE_KIND_UNSPECIFIED"),
            Self::Vulnerability => std::option::Option::Some("VULNERABILITY"),
            Self::Build => std::option::Option::Some("BUILD"),
            Self::Image => std::option::Option::Some("IMAGE"),
            Self::Package => std::option::Option::Some("PACKAGE"),
            Self::Deployment => std::option::Option::Some("DEPLOYMENT"),
            Self::Discovery => std::option::Option::Some("DISCOVERY"),
            Self::Attestation => std::option::Option::Some("ATTESTATION"),
            Self::Upgrade => std::option::Option::Some("UPGRADE"),
            Self::Compliance => std::option::Option::Some("COMPLIANCE"),
            Self::DsseAttestation => std::option::Option::Some("DSSE_ATTESTATION"),
            Self::VulnerabilityAssessment => std::option::Option::Some("VULNERABILITY_ASSESSMENT"),
            Self::SbomReference => std::option::Option::Some("SBOM_REFERENCE"),
            Self::Secret => std::option::Option::Some("SECRET"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for NoteKind {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for NoteKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for NoteKind {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Vulnerability,
            2 => Self::Build,
            3 => Self::Image,
            4 => Self::Package,
            5 => Self::Deployment,
            6 => Self::Discovery,
            7 => Self::Attestation,
            8 => Self::Upgrade,
            9 => Self::Compliance,
            10 => Self::DsseAttestation,
            11 => Self::VulnerabilityAssessment,
            12 => Self::SbomReference,
            13 => Self::Secret,
            _ => Self::UnknownValue(note_kind::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for NoteKind {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NOTE_KIND_UNSPECIFIED" => Self::Unspecified,
            "VULNERABILITY" => Self::Vulnerability,
            "BUILD" => Self::Build,
            "IMAGE" => Self::Image,
            "PACKAGE" => Self::Package,
            "DEPLOYMENT" => Self::Deployment,
            "DISCOVERY" => Self::Discovery,
            "ATTESTATION" => Self::Attestation,
            "UPGRADE" => Self::Upgrade,
            "COMPLIANCE" => Self::Compliance,
            "DSSE_ATTESTATION" => Self::DsseAttestation,
            "VULNERABILITY_ASSESSMENT" => Self::VulnerabilityAssessment,
            "SBOM_REFERENCE" => Self::SbomReference,
            "SECRET" => Self::Secret,
            _ => Self::UnknownValue(note_kind::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for NoteKind {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Vulnerability => serializer.serialize_i32(1),
            Self::Build => serializer.serialize_i32(2),
            Self::Image => serializer.serialize_i32(3),
            Self::Package => serializer.serialize_i32(4),
            Self::Deployment => serializer.serialize_i32(5),
            Self::Discovery => serializer.serialize_i32(6),
            Self::Attestation => serializer.serialize_i32(7),
            Self::Upgrade => serializer.serialize_i32(8),
            Self::Compliance => serializer.serialize_i32(9),
            Self::DsseAttestation => serializer.serialize_i32(10),
            Self::VulnerabilityAssessment => serializer.serialize_i32(11),
            Self::SbomReference => serializer.serialize_i32(12),
            Self::Secret => serializer.serialize_i32(13),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for NoteKind {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NoteKind>::new(
            ".grafeas.v1.NoteKind",
        ))
    }
}

/// CVSS Version.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CVSSVersion {
    Unspecified,
    CvssVersion2,
    CvssVersion3,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CVSSVersion::value] or
    /// [CVSSVersion::name].
    UnknownValue(cvss_version::UnknownValue),
}

#[doc(hidden)]
pub mod cvss_version {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CVSSVersion {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::CvssVersion2 => std::option::Option::Some(1),
            Self::CvssVersion3 => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CVSS_VERSION_UNSPECIFIED"),
            Self::CvssVersion2 => std::option::Option::Some("CVSS_VERSION_2"),
            Self::CvssVersion3 => std::option::Option::Some("CVSS_VERSION_3"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CVSSVersion {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CVSSVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CVSSVersion {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::CvssVersion2,
            2 => Self::CvssVersion3,
            _ => Self::UnknownValue(cvss_version::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CVSSVersion {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CVSS_VERSION_UNSPECIFIED" => Self::Unspecified,
            "CVSS_VERSION_2" => Self::CvssVersion2,
            "CVSS_VERSION_3" => Self::CvssVersion3,
            _ => Self::UnknownValue(cvss_version::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CVSSVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::CvssVersion2 => serializer.serialize_i32(1),
            Self::CvssVersion3 => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CVSSVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CVSSVersion>::new(
            ".grafeas.v1.CVSSVersion",
        ))
    }
}

/// Instruction set architectures supported by various package managers.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Architecture {
    /// Unknown architecture.
    Unspecified,
    /// X86 architecture.
    X86,
    /// X64 architecture.
    X64,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Architecture::value] or
    /// [Architecture::name].
    UnknownValue(architecture::UnknownValue),
}

#[doc(hidden)]
pub mod architecture {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Architecture {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::X86 => std::option::Option::Some(1),
            Self::X64 => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ARCHITECTURE_UNSPECIFIED"),
            Self::X86 => std::option::Option::Some("X86"),
            Self::X64 => std::option::Option::Some("X64"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Architecture {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Architecture {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Architecture {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::X86,
            2 => Self::X64,
            _ => Self::UnknownValue(architecture::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Architecture {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
            "X86" => Self::X86,
            "X64" => Self::X64,
            _ => Self::UnknownValue(architecture::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Architecture {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::X86 => serializer.serialize_i32(1),
            Self::X64 => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Architecture {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Architecture>::new(
            ".grafeas.v1.Architecture",
        ))
    }
}

/// Kind of secret.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SecretKind {
    /// Unspecified
    Unspecified,
    /// The secret kind is unknown.
    Unknown,
    /// A GCP service account key per:
    /// <https://cloud.google.com/iam/docs/creating-managing-service-account-keys>
    GcpServiceAccountKey,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SecretKind::value] or
    /// [SecretKind::name].
    UnknownValue(secret_kind::UnknownValue),
}

#[doc(hidden)]
pub mod secret_kind {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SecretKind {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Unknown => std::option::Option::Some(1),
            Self::GcpServiceAccountKey => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SECRET_KIND_UNSPECIFIED"),
            Self::Unknown => std::option::Option::Some("SECRET_KIND_UNKNOWN"),
            Self::GcpServiceAccountKey => {
                std::option::Option::Some("SECRET_KIND_GCP_SERVICE_ACCOUNT_KEY")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SecretKind {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SecretKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SecretKind {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Unknown,
            2 => Self::GcpServiceAccountKey,
            _ => Self::UnknownValue(secret_kind::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SecretKind {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SECRET_KIND_UNSPECIFIED" => Self::Unspecified,
            "SECRET_KIND_UNKNOWN" => Self::Unknown,
            "SECRET_KIND_GCP_SERVICE_ACCOUNT_KEY" => Self::GcpServiceAccountKey,
            _ => Self::UnknownValue(secret_kind::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SecretKind {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Unknown => serializer.serialize_i32(1),
            Self::GcpServiceAccountKey => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SecretKind {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SecretKind>::new(
            ".grafeas.v1.SecretKind",
        ))
    }
}

/// Note provider assigned severity/impact ranking.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Severity {
    /// Unknown.
    Unspecified,
    /// Minimal severity.
    Minimal,
    /// Low severity.
    Low,
    /// Medium severity.
    Medium,
    /// High severity.
    High,
    /// Critical severity.
    Critical,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Severity::value] or
    /// [Severity::name].
    UnknownValue(severity::UnknownValue),
}

#[doc(hidden)]
pub mod severity {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Severity {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Minimal => std::option::Option::Some(1),
            Self::Low => std::option::Option::Some(2),
            Self::Medium => std::option::Option::Some(3),
            Self::High => std::option::Option::Some(4),
            Self::Critical => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
            Self::Minimal => std::option::Option::Some("MINIMAL"),
            Self::Low => std::option::Option::Some("LOW"),
            Self::Medium => std::option::Option::Some("MEDIUM"),
            Self::High => std::option::Option::Some("HIGH"),
            Self::Critical => std::option::Option::Some("CRITICAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Severity {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Severity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Severity {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Minimal,
            2 => Self::Low,
            3 => Self::Medium,
            4 => Self::High,
            5 => Self::Critical,
            _ => Self::UnknownValue(severity::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Severity {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SEVERITY_UNSPECIFIED" => Self::Unspecified,
            "MINIMAL" => Self::Minimal,
            "LOW" => Self::Low,
            "MEDIUM" => Self::Medium,
            "HIGH" => Self::High,
            "CRITICAL" => Self::Critical,
            _ => Self::UnknownValue(severity::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Severity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Minimal => serializer.serialize_i32(1),
            Self::Low => serializer.serialize_i32(2),
            Self::Medium => serializer.serialize_i32(3),
            Self::High => serializer.serialize_i32(4),
            Self::Critical => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Severity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
            ".grafeas.v1.Severity",
        ))
    }
}
