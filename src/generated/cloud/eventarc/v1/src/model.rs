// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A representation of the Channel resource.
/// A Channel is a resource on which event providers publish their events.
/// The published events are delivered through the transport associated with the
/// channel. Note that a channel is associated with exactly one event provider.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Channel {
    /// Required. The resource name of the channel. Must be unique within the
    /// location on the project and must be in
    /// `projects/{project}/locations/{location}/channels/{channel_id}` format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the channel. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The name of the event provider (e.g. Eventarc SaaS partner) associated
    /// with the channel. This provider will be granted permissions to publish
    /// events to the channel. Format:
    /// `projects/{project}/locations/{location}/providers/{provider_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub provider: std::string::String,

    /// Output only. The state of a Channel.
    pub state: crate::model::channel::State,

    /// Output only. The activation token for the channel. The token must be used
    /// by the provider to register the channel for publishing.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub activation_token: std::string::String,

    /// Resource name of a KMS crypto key (managed by the user) used to
    /// encrypt/decrypt their event data.
    ///
    /// It must match the pattern
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crypto_key_name: std::string::String,

    /// Output only. Whether or not this Channel satisfies the requirements of
    /// physical zone separation
    pub satisfies_pzs: bool,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub transport: std::option::Option<crate::model::channel::Transport>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Channel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Channel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Channel::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Channel::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Channel::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [provider][crate::model::Channel::provider].
    pub fn set_provider<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.provider = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Channel::state].
    pub fn set_state<T: std::convert::Into<crate::model::channel::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [activation_token][crate::model::Channel::activation_token].
    pub fn set_activation_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.activation_token = v.into();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::Channel::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Channel::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of `transport`.
    pub fn set_transport<
        T: std::convert::Into<std::option::Option<crate::model::channel::Transport>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transport = v.into();
        self
    }

    /// The value of [transport][crate::model::Channel::transport]
    /// if it holds a `PubsubTopic`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pubsub_topic(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.transport.as_ref().and_then(|v| match v {
            crate::model::channel::Transport::PubsubTopic(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transport][crate::model::Channel::transport]
    /// to hold a `PubsubTopic`.
    ///
    /// Note that all the setters affecting `transport` are
    /// mutually exclusive.
    pub fn set_pubsub_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.transport =
            std::option::Option::Some(crate::model::channel::Transport::PubsubTopic(v.into()));
        self
    }
}

impl wkt::message::Message for Channel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Channel"
    }
}

/// Defines additional types related to [Channel].
pub mod channel {
    #[allow(unused_imports)]
    use super::*;

    /// State lists all the possible states of a Channel
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Default value. This value is unused.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The PENDING state indicates that a Channel has been created successfully
        /// and there is a new activation token available for the subscriber to use
        /// to convey the Channel to the provider in order to create a Connection.
        pub const PENDING: State = State::new(1);

        /// The ACTIVE state indicates that a Channel has been successfully
        /// connected with the event provider.
        /// An ACTIVE Channel is ready to receive and route events from the
        /// event provider.
        pub const ACTIVE: State = State::new(2);

        /// The INACTIVE state indicates that the Channel cannot receive events
        /// permanently. There are two possible cases this state can happen:
        ///
        /// . The SaaS provider disconnected from this Channel.
        /// . The Channel activation token has expired but the SaaS provider
        ///   wasn't connected.
        ///
        /// To re-establish a Connection with a provider, the subscriber
        /// should create a new Channel and give it to the provider.
        pub const INACTIVE: State = State::new(3);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PENDING"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                3 => std::borrow::Cow::Borrowed("INACTIVE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "PENDING" => std::option::Option::Some(Self::PENDING),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "INACTIVE" => std::option::Option::Some(Self::INACTIVE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Transport {
        /// Output only. The name of the Pub/Sub topic created and managed by
        /// Eventarc system as a transport for the event delivery. Format:
        /// `projects/{project}/topics/{topic_id}`.
        PubsubTopic(std::string::String),
    }
}

/// A representation of the ChannelConnection resource.
/// A ChannelConnection is a resource which event providers create during the
/// activation process to establish a connection between the provider and the
/// subscriber channel.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ChannelConnection {
    /// Required. The name of the connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Server assigned ID of the resource.
    /// The server guarantees uniqueness and immutability until deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Required. The name of the connected subscriber Channel.
    /// This is a weak reference to avoid cross project and cross accounts
    /// references. This must be in
    /// `projects/{project}/location/{location}/channels/{channel_id}` format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub channel: std::string::String,

    /// Output only. The creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Input only. Activation token for the channel. The token will be used
    /// during the creation of ChannelConnection to bind the channel with the
    /// provider project. This field will not be stored in the provider resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub activation_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChannelConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ChannelConnection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::ChannelConnection::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [channel][crate::model::ChannelConnection::channel].
    pub fn set_channel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.channel = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ChannelConnection::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ChannelConnection::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [activation_token][crate::model::ChannelConnection::activation_token].
    pub fn set_activation_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.activation_token = v.into();
        self
    }
}

impl wkt::message::Message for ChannelConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ChannelConnection"
    }
}

/// A representation of the Provider resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Provider {
    /// Output only. In
    /// `projects/{project}/locations/{location}/providers/{provider_id}` format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Human friendly name for the Provider. For example "Cloud
    /// Storage".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Event types for this provider.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub event_types: std::vec::Vec<crate::model::EventType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Provider {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Provider::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Provider::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [event_types][crate::model::Provider::event_types].
    pub fn set_event_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventType>,
    {
        use std::iter::Iterator;
        self.event_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Provider {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Provider"
    }
}

/// A representation of the event type resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EventType {
    /// Output only. The full name of the event type (for example,
    /// "google.cloud.storage.object.v1.finalized"). In the form of
    /// {provider-specific-prefix}.{resource}.{version}.{verb}. Types MUST be
    /// versioned and event schemas are guaranteed to remain backward compatible
    /// within one version. Note that event type versions and API versions do not
    /// need to match.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Output only. Human friendly description of what the event type is about.
    /// For example "Bucket created in Cloud Storage".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Filtering attributes for the event type.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub filtering_attributes: std::vec::Vec<crate::model::FilteringAttribute>,

    /// Output only. URI for the event schema.
    /// For example
    /// `https://github.com/googleapis/google-cloudevents/blob/master/proto/google/events/cloud/storage/v1/events.proto`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub event_schema_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::EventType::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EventType::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [event_schema_uri][crate::model::EventType::event_schema_uri].
    pub fn set_event_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_schema_uri = v.into();
        self
    }

    /// Sets the value of [filtering_attributes][crate::model::EventType::filtering_attributes].
    pub fn set_filtering_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FilteringAttribute>,
    {
        use std::iter::Iterator;
        self.filtering_attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EventType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.EventType"
    }
}

/// A representation of the FilteringAttribute resource.
/// Filtering attributes are per event type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FilteringAttribute {
    /// Output only. Attribute used for filtering the event type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attribute: std::string::String,

    /// Output only. Description of the purpose of the attribute.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. If true, the triggers for this provider should always specify
    /// a filter on these attributes. Trigger creation will fail otherwise.
    pub required: bool,

    /// Output only. If true, the attribute accepts matching expressions in the
    /// Eventarc PathPattern format.
    pub path_pattern_supported: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FilteringAttribute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attribute][crate::model::FilteringAttribute::attribute].
    pub fn set_attribute<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attribute = v.into();
        self
    }

    /// Sets the value of [description][crate::model::FilteringAttribute::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [required][crate::model::FilteringAttribute::required].
    pub fn set_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.required = v.into();
        self
    }

    /// Sets the value of [path_pattern_supported][crate::model::FilteringAttribute::path_pattern_supported].
    pub fn set_path_pattern_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.path_pattern_supported = v.into();
        self
    }
}

impl wkt::message::Message for FilteringAttribute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.FilteringAttribute"
    }
}

/// An enrollment represents a subscription for messages on a particular message
/// bus. It defines a matching criteria for messages on the bus and the
/// subscriber endpoint where matched messages should be delivered.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Enrollment {
    /// Identifier. Resource name of the form
    /// projects/{project}/locations/{location}/enrollments/{enrollment}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the channel. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and might be sent only on update and delete requests to
    /// ensure that the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. The creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Resource labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Resource annotations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Resource display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. A CEL expression identifying which messages this enrollment
    /// applies to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cel_match: std::string::String,

    /// Required. Resource name of the message bus identifying the source of the
    /// messages. It matches the form
    /// projects/{project}/locations/{location}/messageBuses/{messageBus}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message_bus: std::string::String,

    /// Required. Destination is the Pipeline that the Enrollment is delivering to.
    /// It must point to the full resource name of a Pipeline. Format:
    /// "projects/{PROJECT_ID}/locations/{region}/pipelines/{PIPELINE_ID)"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Enrollment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Enrollment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Enrollment::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Enrollment::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Enrollment::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Enrollment::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Enrollment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [cel_match][crate::model::Enrollment::cel_match].
    pub fn set_cel_match<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cel_match = v.into();
        self
    }

    /// Sets the value of [message_bus][crate::model::Enrollment::message_bus].
    pub fn set_message_bus<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message_bus = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::Enrollment::destination].
    pub fn set_destination<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Enrollment::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Enrollment::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Enrollment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Enrollment"
    }
}

/// The request message for the GetTrigger method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTriggerRequest {
    /// Required. The name of the trigger to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetTriggerRequest"
    }
}

/// The request message for the ListTriggers method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTriggersRequest {
    /// Required. The parent collection to list triggers on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of triggers to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// The page token; provide the value from the `next_page_token` field in a
    /// previous `ListTriggers` call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListTriggers` must match
    /// the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting order is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, trigger_id`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Filter field. Used to filter the Triggers to be listed. Possible filters
    /// are described in <https://google.aip.dev/160>. For example, using
    /// "?filter=destination:gke" would list only Triggers with a gke destination.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTriggersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTriggersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTriggersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTriggersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTriggersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTriggersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListTriggersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListTriggersRequest"
    }
}

/// The response message for the `ListTriggers` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTriggersResponse {
    /// The requested triggers, up to the number specified in `page_size`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub triggers: std::vec::Vec<crate::model::Trigger>,

    /// A page token that can be sent to `ListTriggers` to request the next page.
    /// If this is empty, then there are no more pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTriggersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTriggersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [triggers][crate::model::ListTriggersResponse::triggers].
    pub fn set_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trigger>,
    {
        use std::iter::Iterator;
        self.triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListTriggersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTriggersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListTriggersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTriggersResponse {
    type PageItem = crate::model::Trigger;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.triggers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for the CreateTrigger method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTriggerRequest {
    /// Required. The parent collection in which to add this trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The trigger to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trigger: std::option::Option<crate::model::Trigger>,

    /// Required. The user-provided ID to be assigned to the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger_id: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTriggerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::CreateTriggerRequest::trigger].
    pub fn set_trigger<T: std::convert::Into<std::option::Option<crate::model::Trigger>>>(
        mut self,
        v: T,
    ) -> Self {
        self.trigger = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::CreateTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateTriggerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreateTriggerRequest"
    }
}

/// The request message for the UpdateTrigger method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTriggerRequest {
    /// The trigger to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trigger: std::option::Option<crate::model::Trigger>,

    /// The fields to be updated; only fields explicitly provided are updated.
    /// If no field mask is provided, all provided fields in the request are
    /// updated. To update all fields, provide a field mask of "*".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set to true, and the trigger is not found, a new trigger will be
    /// created. In this situation, `update_mask` is ignored.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [trigger][crate::model::UpdateTriggerRequest::trigger].
    pub fn set_trigger<T: std::convert::Into<std::option::Option<crate::model::Trigger>>>(
        mut self,
        v: T,
    ) -> Self {
        self.trigger = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTriggerRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateTriggerRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateTriggerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdateTriggerRequest"
    }
}

/// The request message for the DeleteTrigger method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTriggerRequest {
    /// Required. The name of the trigger to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If provided, the trigger will only be deleted if the etag matches the
    /// current etag on the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// If set to true, and the trigger is not found, the request will succeed
    /// but no action will be taken on the server.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteTriggerRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteTriggerRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteTriggerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeleteTriggerRequest"
    }
}

/// The request message for the GetChannel method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetChannelRequest {
    /// Required. The name of the channel to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetChannelRequest"
    }
}

/// The request message for the ListChannels method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListChannelsRequest {
    /// Required. The parent collection to list channels on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of channels to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// The page token; provide the value from the `next_page_token` field in a
    /// previous `ListChannels` call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListChannels` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting order is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, channel_id`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListChannelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListChannelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListChannelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListChannelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListChannelsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListChannelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListChannelsRequest"
    }
}

/// The response message for the `ListChannels` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListChannelsResponse {
    /// The requested channels, up to the number specified in `page_size`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub channels: std::vec::Vec<crate::model::Channel>,

    /// A page token that can be sent to `ListChannels` to request the next page.
    /// If this is empty, then there are no more pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListChannelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListChannelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [channels][crate::model::ListChannelsResponse::channels].
    pub fn set_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Channel>,
    {
        use std::iter::Iterator;
        self.channels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListChannelsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListChannelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListChannelsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListChannelsResponse {
    type PageItem = crate::model::Channel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.channels
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for the CreateChannel method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateChannelRequest {
    /// Required. The parent collection in which to add this channel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The channel to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub channel: std::option::Option<crate::model::Channel>,

    /// Required. The user-provided ID to be assigned to the channel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub channel_id: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateChannelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [channel][crate::model::CreateChannelRequest::channel].
    pub fn set_channel<T: std::convert::Into<std::option::Option<crate::model::Channel>>>(
        mut self,
        v: T,
    ) -> Self {
        self.channel = v.into();
        self
    }

    /// Sets the value of [channel_id][crate::model::CreateChannelRequest::channel_id].
    pub fn set_channel_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.channel_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateChannelRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreateChannelRequest"
    }
}

/// The request message for the UpdateChannel method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateChannelRequest {
    /// The channel to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub channel: std::option::Option<crate::model::Channel>,

    /// The fields to be updated; only fields explicitly provided are updated.
    /// If no field mask is provided, all provided fields in the request are
    /// updated. To update all fields, provide a field mask of "*".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channel][crate::model::UpdateChannelRequest::channel].
    pub fn set_channel<T: std::convert::Into<std::option::Option<crate::model::Channel>>>(
        mut self,
        v: T,
    ) -> Self {
        self.channel = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateChannelRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateChannelRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdateChannelRequest"
    }
}

/// The request message for the DeleteChannel method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteChannelRequest {
    /// Required. The name of the channel to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteChannelRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeleteChannelRequest"
    }
}

/// The request message for the GetProvider method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetProviderRequest {
    /// Required. The name of the provider to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProviderRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProviderRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProviderRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetProviderRequest"
    }
}

/// The request message for the ListProviders method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProvidersRequest {
    /// Required. The parent of the provider to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of providers to return on each page.
    pub page_size: i32,

    /// The page token; provide the value from the `next_page_token` field in a
    /// previous `ListProviders` call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListProviders` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting oder is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, _id`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// The filter field that the list request will filter on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProvidersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProvidersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProvidersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProvidersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListProvidersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListProvidersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListProvidersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListProvidersRequest"
    }
}

/// The response message for the `ListProviders` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProvidersResponse {
    /// The requested providers, up to the number specified in `page_size`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub providers: std::vec::Vec<crate::model::Provider>,

    /// A page token that can be sent to `ListProviders` to request the next page.
    /// If this is empty, then there are no more pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProvidersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListProvidersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [providers][crate::model::ListProvidersResponse::providers].
    pub fn set_providers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Provider>,
    {
        use std::iter::Iterator;
        self.providers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListProvidersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListProvidersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListProvidersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProvidersResponse {
    type PageItem = crate::model::Provider;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.providers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for the GetChannelConnection method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetChannelConnectionRequest {
    /// Required. The name of the channel connection to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetChannelConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetChannelConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetChannelConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetChannelConnectionRequest"
    }
}

/// The request message for the ListChannelConnections method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListChannelConnectionsRequest {
    /// Required. The parent collection from which to list channel connections.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of channel connections to return on each page.
    ///
    /// Note: The service may send fewer responses.
    pub page_size: i32,

    /// The page token; provide the value from the `next_page_token` field in a
    /// previous `ListChannelConnections` call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListChannelConnetions`
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListChannelConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListChannelConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListChannelConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListChannelConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListChannelConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListChannelConnectionsRequest"
    }
}

/// The response message for the `ListChannelConnections` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListChannelConnectionsResponse {
    /// The requested channel connections, up to the number specified in
    /// `page_size`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub channel_connections: std::vec::Vec<crate::model::ChannelConnection>,

    /// A page token that can be sent to `ListChannelConnections` to request the
    /// next page.
    /// If this is empty, then there are no more pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListChannelConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListChannelConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [channel_connections][crate::model::ListChannelConnectionsResponse::channel_connections].
    pub fn set_channel_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ChannelConnection>,
    {
        use std::iter::Iterator;
        self.channel_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListChannelConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListChannelConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListChannelConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListChannelConnectionsResponse {
    type PageItem = crate::model::ChannelConnection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.channel_connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for the CreateChannelConnection method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateChannelConnectionRequest {
    /// Required. The parent collection in which to add this channel connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Channel connection to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub channel_connection: std::option::Option<crate::model::ChannelConnection>,

    /// Required. The user-provided ID to be assigned to the channel connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub channel_connection_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateChannelConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateChannelConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [channel_connection][crate::model::CreateChannelConnectionRequest::channel_connection].
    pub fn set_channel_connection<
        T: std::convert::Into<std::option::Option<crate::model::ChannelConnection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.channel_connection = v.into();
        self
    }

    /// Sets the value of [channel_connection_id][crate::model::CreateChannelConnectionRequest::channel_connection_id].
    pub fn set_channel_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.channel_connection_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateChannelConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreateChannelConnectionRequest"
    }
}

/// The request message for the DeleteChannelConnection method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteChannelConnectionRequest {
    /// Required. The name of the channel connection to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteChannelConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteChannelConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteChannelConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeleteChannelConnectionRequest"
    }
}

/// The request message for the UpdateGoogleChannelConfig method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateGoogleChannelConfigRequest {
    /// Required. The config to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub google_channel_config: std::option::Option<crate::model::GoogleChannelConfig>,

    /// The fields to be updated; only fields explicitly provided are updated.
    /// If no field mask is provided, all provided fields in the request are
    /// updated. To update all fields, provide a field mask of "*".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGoogleChannelConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [google_channel_config][crate::model::UpdateGoogleChannelConfigRequest::google_channel_config].
    pub fn set_google_channel_config<
        T: std::convert::Into<std::option::Option<crate::model::GoogleChannelConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.google_channel_config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateGoogleChannelConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateGoogleChannelConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdateGoogleChannelConfigRequest"
    }
}

/// The request message for the GetGoogleChannelConfig method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetGoogleChannelConfigRequest {
    /// Required. The name of the config to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGoogleChannelConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGoogleChannelConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGoogleChannelConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetGoogleChannelConfigRequest"
    }
}

/// The request message for the GetMessageBus method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMessageBusRequest {
    /// Required. The name of the message bus to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMessageBusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMessageBusRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMessageBusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetMessageBusRequest"
    }
}

/// The request message for the ListMessageBuses method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMessageBusesRequest {
    /// Required. The parent collection to list triggers on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// Optional. The page token; provide the value from the `next_page_token`
    /// field in a previous call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided must match
    /// the previous call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting order is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, update_time`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. The filter field that the list request will filter on.
    /// Possible filtersare described in <https://google.aip.dev/160>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMessageBusesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMessageBusesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMessageBusesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMessageBusesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListMessageBusesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMessageBusesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListMessageBusesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListMessageBusesRequest"
    }
}

/// The response message for the `ListMessageBuses` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMessageBusesResponse {
    /// The requested message buses, up to the number specified in `page_size`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message_buses: std::vec::Vec<crate::model::MessageBus>,

    /// A page token that can be sent to `ListMessageBuses` to request the next
    /// page. If this is empty, then there are no more pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMessageBusesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListMessageBusesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [message_buses][crate::model::ListMessageBusesResponse::message_buses].
    pub fn set_message_buses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageBus>,
    {
        use std::iter::Iterator;
        self.message_buses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListMessageBusesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMessageBusesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListMessageBusesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMessageBusesResponse {
    type PageItem = crate::model::MessageBus;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.message_buses
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for the `ListMessageBusEnrollments` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMessageBusEnrollmentsRequest {
    /// Required. The parent message bus to list enrollments on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// Optional. The page token; provide the value from the `next_page_token`
    /// field in a previous call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided must match
    /// the previous call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMessageBusEnrollmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMessageBusEnrollmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMessageBusEnrollmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMessageBusEnrollmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMessageBusEnrollmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListMessageBusEnrollmentsRequest"
    }
}

/// The response message for the `ListMessageBusEnrollments` method.`
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMessageBusEnrollmentsResponse {
    /// The requested enrollments, up to the number specified in `page_size`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub enrollments: std::vec::Vec<std::string::String>,

    /// A page token that can be sent to `ListMessageBusEnrollments` to request the
    /// next page. If this is empty, then there are no more pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMessageBusEnrollmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListMessageBusEnrollmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [enrollments][crate::model::ListMessageBusEnrollmentsResponse::enrollments].
    pub fn set_enrollments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.enrollments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListMessageBusEnrollmentsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMessageBusEnrollmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListMessageBusEnrollmentsResponse"
    }
}

/// The request message for the CreateMessageBus method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMessageBusRequest {
    /// Required. The parent collection in which to add this message bus.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The message bus to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub message_bus: std::option::Option<crate::model::MessageBus>,

    /// Required. The user-provided ID to be assigned to the MessageBus. It should
    /// match the format (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message_bus_id: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMessageBusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMessageBusRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [message_bus][crate::model::CreateMessageBusRequest::message_bus].
    pub fn set_message_bus<T: std::convert::Into<std::option::Option<crate::model::MessageBus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.message_bus = v.into();
        self
    }

    /// Sets the value of [message_bus_id][crate::model::CreateMessageBusRequest::message_bus_id].
    pub fn set_message_bus_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message_bus_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateMessageBusRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateMessageBusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreateMessageBusRequest"
    }
}

/// The request message for the UpdateMessageBus method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateMessageBusRequest {
    /// Required. The MessageBus to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub message_bus: std::option::Option<crate::model::MessageBus>,

    /// Optional. The fields to be updated; only fields explicitly provided are
    /// updated. If no field mask is provided, all provided fields in the request
    /// are updated. To update all fields, provide a field mask of "*".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set to true, and the MessageBus is not found, a new MessageBus
    /// will be created. In this situation, `update_mask` is ignored.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateMessageBusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message_bus][crate::model::UpdateMessageBusRequest::message_bus].
    pub fn set_message_bus<T: std::convert::Into<std::option::Option<crate::model::MessageBus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.message_bus = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateMessageBusRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateMessageBusRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateMessageBusRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateMessageBusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdateMessageBusRequest"
    }
}

/// The request message for the DeleteMessageBus method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteMessageBusRequest {
    /// Required. The name of the MessageBus to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If provided, the MessageBus will only be deleted if the etag
    /// matches the current etag on the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. If set to true, and the MessageBus is not found, the request will
    /// succeed but no action will be taken on the server.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMessageBusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMessageBusRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteMessageBusRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteMessageBusRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteMessageBusRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMessageBusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeleteMessageBusRequest"
    }
}

/// The request message for the GetEnrollment method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEnrollmentRequest {
    /// Required. The name of the Enrollment to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEnrollmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEnrollmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEnrollmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetEnrollmentRequest"
    }
}

/// The request message for the ListEnrollments method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEnrollmentsRequest {
    /// Required. The parent collection to list triggers on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// Optional. The page token; provide the value from the `next_page_token`
    /// field in a previous call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided must match
    /// the previous call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting order is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, update_time`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. The filter field that the list request will filter on.
    /// Possible filtersare described in <https://google.aip.dev/160>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEnrollmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEnrollmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEnrollmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEnrollmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEnrollmentsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEnrollmentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListEnrollmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListEnrollmentsRequest"
    }
}

/// The response message for the `ListEnrollments` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEnrollmentsResponse {
    /// The requested Enrollments, up to the number specified in `page_size`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub enrollments: std::vec::Vec<crate::model::Enrollment>,

    /// A page token that can be sent to `ListEnrollments` to request the next
    /// page. If this is empty, then there are no more pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEnrollmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEnrollmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [enrollments][crate::model::ListEnrollmentsResponse::enrollments].
    pub fn set_enrollments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Enrollment>,
    {
        use std::iter::Iterator;
        self.enrollments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListEnrollmentsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEnrollmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListEnrollmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEnrollmentsResponse {
    type PageItem = crate::model::Enrollment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.enrollments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for the CreateEnrollment method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEnrollmentRequest {
    /// Required. The parent collection in which to add this enrollment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The enrollment to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enrollment: std::option::Option<crate::model::Enrollment>,

    /// Required. The user-provided ID to be assigned to the Enrollment. It should
    /// match the format (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub enrollment_id: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEnrollmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEnrollmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [enrollment][crate::model::CreateEnrollmentRequest::enrollment].
    pub fn set_enrollment<T: std::convert::Into<std::option::Option<crate::model::Enrollment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enrollment = v.into();
        self
    }

    /// Sets the value of [enrollment_id][crate::model::CreateEnrollmentRequest::enrollment_id].
    pub fn set_enrollment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.enrollment_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateEnrollmentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateEnrollmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreateEnrollmentRequest"
    }
}

/// The request message for the UpdateEnrollment method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEnrollmentRequest {
    /// Required. The Enrollment to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enrollment: std::option::Option<crate::model::Enrollment>,

    /// Optional. The fields to be updated; only fields explicitly provided are
    /// updated. If no field mask is provided, all provided fields in the request
    /// are updated. To update all fields, provide a field mask of "*".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set to true, and the Enrollment is not found, a new Enrollment
    /// will be created. In this situation, `update_mask` is ignored.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEnrollmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enrollment][crate::model::UpdateEnrollmentRequest::enrollment].
    pub fn set_enrollment<T: std::convert::Into<std::option::Option<crate::model::Enrollment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enrollment = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEnrollmentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateEnrollmentRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateEnrollmentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEnrollmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdateEnrollmentRequest"
    }
}

/// The request message for the DeleteEnrollment method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEnrollmentRequest {
    /// Required. The name of the Enrollment to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If provided, the Enrollment will only be deleted if the etag
    /// matches the current etag on the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. If set to true, and the Enrollment is not found, the request will
    /// succeed but no action will be taken on the server.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEnrollmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEnrollmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteEnrollmentRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteEnrollmentRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteEnrollmentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEnrollmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeleteEnrollmentRequest"
    }
}

/// The request message for the GetPipeline method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPipelineRequest {
    /// Required. The name of the pipeline to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetPipelineRequest"
    }
}

/// The request message for the ListPipelines method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPipelinesRequest {
    /// Required. The parent collection to list pipelines on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// Optional. The page token; provide the value from the `next_page_token`
    /// field in a previous call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided must match
    /// the previous call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting order is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, update_time`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. The filter field that the list request will filter on.
    /// Possible filters are described in <https://google.aip.dev/160>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPipelinesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPipelinesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPipelinesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPipelinesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPipelinesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPipelinesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListPipelinesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListPipelinesRequest"
    }
}

/// The response message for the ListPipelines method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPipelinesResponse {
    /// The requested pipelines, up to the number specified in `page_size`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pipelines: std::vec::Vec<crate::model::Pipeline>,

    /// A page token that can be sent to `ListPipelines` to request the next
    /// page. If this is empty, then there are no more pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPipelinesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListPipelinesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [pipelines][crate::model::ListPipelinesResponse::pipelines].
    pub fn set_pipelines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Pipeline>,
    {
        use std::iter::Iterator;
        self.pipelines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListPipelinesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPipelinesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListPipelinesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPipelinesResponse {
    type PageItem = crate::model::Pipeline;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.pipelines
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for the CreatePipeline method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePipelineRequest {
    /// Required. The parent collection in which to add this pipeline.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The pipeline to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pipeline: std::option::Option<crate::model::Pipeline>,

    /// Required. The user-provided ID to be assigned to the Pipeline.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pipeline_id: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePipelineRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [pipeline][crate::model::CreatePipelineRequest::pipeline].
    pub fn set_pipeline<T: std::convert::Into<std::option::Option<crate::model::Pipeline>>>(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline = v.into();
        self
    }

    /// Sets the value of [pipeline_id][crate::model::CreatePipelineRequest::pipeline_id].
    pub fn set_pipeline_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreatePipelineRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreatePipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreatePipelineRequest"
    }
}

/// The request message for the UpdatePipeline method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePipelineRequest {
    /// Required. The Pipeline to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pipeline: std::option::Option<crate::model::Pipeline>,

    /// Optional. The fields to be updated; only fields explicitly provided are
    /// updated. If no field mask is provided, all provided fields in the request
    /// are updated. To update all fields, provide a field mask of "*".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set to true, and the Pipeline is not found, a new Pipeline
    /// will be created. In this situation, `update_mask` is ignored.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pipeline][crate::model::UpdatePipelineRequest::pipeline].
    pub fn set_pipeline<T: std::convert::Into<std::option::Option<crate::model::Pipeline>>>(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePipelineRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdatePipelineRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdatePipelineRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdatePipelineRequest"
    }
}

/// The request message for the DeletePipeline method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePipelineRequest {
    /// Required. The name of the Pipeline to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If provided, the Pipeline will only be deleted if the etag
    /// matches the current etag on the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. If set to true, and the Pipeline is not found, the request will
    /// succeed but no action will be taken on the server.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeletePipelineRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeletePipelineRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeletePipelineRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeletePipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeletePipelineRequest"
    }
}

/// The request message for the GetGoogleApiSource method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetGoogleApiSourceRequest {
    /// Required. The name of the google api source to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGoogleApiSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGoogleApiSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGoogleApiSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetGoogleApiSourceRequest"
    }
}

/// The request message for the ListGoogleApiSources method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGoogleApiSourcesRequest {
    /// Required. The parent collection to list GoogleApiSources on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// Optional. The page token; provide the value from the `next_page_token`
    /// field in a previous call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided must match
    /// the previous call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting order is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, update_time`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. The filter field that the list request will filter on.
    /// Possible filtersare described in <https://google.aip.dev/160>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGoogleApiSourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGoogleApiSourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGoogleApiSourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGoogleApiSourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListGoogleApiSourcesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGoogleApiSourcesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListGoogleApiSourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListGoogleApiSourcesRequest"
    }
}

/// The response message for the `ListGoogleApiSources` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGoogleApiSourcesResponse {
    /// The requested GoogleApiSources, up to the number specified in `page_size`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub google_api_sources: std::vec::Vec<crate::model::GoogleApiSource>,

    /// A page token that can be sent to `ListMessageBusEnrollments` to request the
    /// next page. If this is empty, then there are no more pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGoogleApiSourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListGoogleApiSourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [google_api_sources][crate::model::ListGoogleApiSourcesResponse::google_api_sources].
    pub fn set_google_api_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GoogleApiSource>,
    {
        use std::iter::Iterator;
        self.google_api_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListGoogleApiSourcesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGoogleApiSourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListGoogleApiSourcesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGoogleApiSourcesResponse {
    type PageItem = crate::model::GoogleApiSource;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.google_api_sources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for the CreateGoogleApiSource method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateGoogleApiSourceRequest {
    /// Required. The parent collection in which to add this google api source.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The google api source to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub google_api_source: std::option::Option<crate::model::GoogleApiSource>,

    /// Required. The user-provided ID to be assigned to the GoogleApiSource. It
    /// should match the format (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub google_api_source_id: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateGoogleApiSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGoogleApiSourceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [google_api_source][crate::model::CreateGoogleApiSourceRequest::google_api_source].
    pub fn set_google_api_source<
        T: std::convert::Into<std::option::Option<crate::model::GoogleApiSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.google_api_source = v.into();
        self
    }

    /// Sets the value of [google_api_source_id][crate::model::CreateGoogleApiSourceRequest::google_api_source_id].
    pub fn set_google_api_source_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.google_api_source_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateGoogleApiSourceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateGoogleApiSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreateGoogleApiSourceRequest"
    }
}

/// The request message for the UpdateGoogleApiSource method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateGoogleApiSourceRequest {
    /// Required. The GoogleApiSource to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub google_api_source: std::option::Option<crate::model::GoogleApiSource>,

    /// Optional. The fields to be updated; only fields explicitly provided are
    /// updated. If no field mask is provided, all provided fields in the request
    /// are updated. To update all fields, provide a field mask of "*".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set to true, and the GoogleApiSource is not found, a new
    /// GoogleApiSource will be created. In this situation, `update_mask` is
    /// ignored.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGoogleApiSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [google_api_source][crate::model::UpdateGoogleApiSourceRequest::google_api_source].
    pub fn set_google_api_source<
        T: std::convert::Into<std::option::Option<crate::model::GoogleApiSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.google_api_source = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateGoogleApiSourceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateGoogleApiSourceRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateGoogleApiSourceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateGoogleApiSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdateGoogleApiSourceRequest"
    }
}

/// The request message for the DeleteGoogleApiSource method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteGoogleApiSourceRequest {
    /// Required. The name of the GoogleApiSource to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If provided, the MessageBus will only be deleted if the etag
    /// matches the current etag on the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. If set to true, and the MessageBus is not found, the request will
    /// succeed but no action will be taken on the server.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteGoogleApiSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGoogleApiSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteGoogleApiSourceRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteGoogleApiSourceRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteGoogleApiSourceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGoogleApiSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeleteGoogleApiSourceRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.OperationMetadata"
    }
}

/// A GoogleApiSource represents a subscription of 1P events from a MessageBus.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GoogleApiSource {
    /// Identifier. Resource name of the form
    /// projects/{project}/locations/{location}/googleApiSources/{google_api_source}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the channel. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and might be sent only on update and delete requests to
    /// ensure that the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. The creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Resource labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Resource annotations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Resource display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Destination is the message bus that the GoogleApiSource is
    /// delivering to. It must be point to the full resource name of a MessageBus.
    /// Format:
    /// "projects/{PROJECT_ID}/locations/{region}/messagesBuses/{MESSAGE_BUS_ID)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination: std::string::String,

    /// Optional. Resource name of a KMS crypto key (managed by the user) used to
    /// encrypt/decrypt their event data.
    ///
    /// It must match the pattern
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crypto_key_name: std::string::String,

    /// Optional. Config to control Platform logging for the GoogleApiSource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoogleApiSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GoogleApiSource::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::GoogleApiSource::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::GoogleApiSource::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::GoogleApiSource::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::GoogleApiSource::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::GoogleApiSource::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::GoogleApiSource::destination].
    pub fn set_destination<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::GoogleApiSource::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }

    /// Sets the value of [logging_config][crate::model::GoogleApiSource::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::GoogleApiSource::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::GoogleApiSource::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for GoogleApiSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GoogleApiSource"
    }
}

/// A GoogleChannelConfig is a resource that stores the custom settings
/// respected by Eventarc first-party triggers in the matching region.
/// Once configured, first-party event data will be protected
/// using the specified custom managed encryption key instead of Google-managed
/// encryption keys.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GoogleChannelConfig {
    /// Required. The resource name of the config. Must be in the format of,
    /// `projects/{project}/locations/{location}/googleChannelConfig`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The last-modified time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Resource name of a KMS crypto key (managed by the user) used to
    /// encrypt/decrypt their event data.
    ///
    /// It must match the pattern
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crypto_key_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoogleChannelConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GoogleChannelConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::GoogleChannelConfig::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::GoogleChannelConfig::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }
}

impl wkt::message::Message for GoogleChannelConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GoogleChannelConfig"
    }
}

/// The configuration for Platform Telemetry logging for Eventarc Advanced
/// resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoggingConfig {
    /// Optional. The minimum severity of logs that will be sent to
    /// Stackdriver/Platform Telemetry. Logs at severitiy ≥ this value will be
    /// sent, unless it is NONE.
    pub log_severity: crate::model::logging_config::LogSeverity,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_severity][crate::model::LoggingConfig::log_severity].
    pub fn set_log_severity<T: std::convert::Into<crate::model::logging_config::LogSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.log_severity = v.into();
        self
    }
}

impl wkt::message::Message for LoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.LoggingConfig"
    }
}

/// Defines additional types related to [LoggingConfig].
pub mod logging_config {
    #[allow(unused_imports)]
    use super::*;

    /// The different severities for logging supported by Eventarc Advanced
    /// resources.
    /// This enum is an exhaustive list of log severities and is FROZEN. Do not
    /// expect new values to be added.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct LogSeverity(i32);

    impl LogSeverity {
        /// Log severity is not specified. This value is treated the same as NONE,
        /// but is used to distinguish between no update and update to NONE in
        /// update_masks.
        pub const LOG_SEVERITY_UNSPECIFIED: LogSeverity = LogSeverity::new(0);

        /// Default value at resource creation, presence of this value must be
        /// treated as no logging/disable logging.
        pub const NONE: LogSeverity = LogSeverity::new(1);

        /// Debug or trace level logging.
        pub const DEBUG: LogSeverity = LogSeverity::new(2);

        /// Routine information, such as ongoing status or performance.
        pub const INFO: LogSeverity = LogSeverity::new(3);

        /// Normal but significant events, such as start up, shut down, or a
        /// configuration change.
        pub const NOTICE: LogSeverity = LogSeverity::new(4);

        /// Warning events might cause problems.
        pub const WARNING: LogSeverity = LogSeverity::new(5);

        /// Error events are likely to cause problems.
        pub const ERROR: LogSeverity = LogSeverity::new(6);

        /// Critical events cause more severe problems or outages.
        pub const CRITICAL: LogSeverity = LogSeverity::new(7);

        /// A person must take action immediately.
        pub const ALERT: LogSeverity = LogSeverity::new(8);

        /// One or more systems are unusable.
        pub const EMERGENCY: LogSeverity = LogSeverity::new(9);

        /// Creates a new LogSeverity instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("LOG_SEVERITY_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NONE"),
                2 => std::borrow::Cow::Borrowed("DEBUG"),
                3 => std::borrow::Cow::Borrowed("INFO"),
                4 => std::borrow::Cow::Borrowed("NOTICE"),
                5 => std::borrow::Cow::Borrowed("WARNING"),
                6 => std::borrow::Cow::Borrowed("ERROR"),
                7 => std::borrow::Cow::Borrowed("CRITICAL"),
                8 => std::borrow::Cow::Borrowed("ALERT"),
                9 => std::borrow::Cow::Borrowed("EMERGENCY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "LOG_SEVERITY_UNSPECIFIED" => {
                    std::option::Option::Some(Self::LOG_SEVERITY_UNSPECIFIED)
                }
                "NONE" => std::option::Option::Some(Self::NONE),
                "DEBUG" => std::option::Option::Some(Self::DEBUG),
                "INFO" => std::option::Option::Some(Self::INFO),
                "NOTICE" => std::option::Option::Some(Self::NOTICE),
                "WARNING" => std::option::Option::Some(Self::WARNING),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                "CRITICAL" => std::option::Option::Some(Self::CRITICAL),
                "ALERT" => std::option::Option::Some(Self::ALERT),
                "EMERGENCY" => std::option::Option::Some(Self::EMERGENCY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for LogSeverity {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for LogSeverity {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// MessageBus for the messages flowing through the system. The admin has
/// visibility and control over the messages being published and consumed and can
/// restrict publishers and subscribers to only a subset of data available in the
/// system by defining authorization policies.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MessageBus {
    /// Identifier. Resource name of the form
    /// projects/{project}/locations/{location}/messageBuses/{message_bus}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the channel. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and might be sent only on update and delete requests to
    /// ensure that the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. The creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Resource labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Resource annotations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Resource display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. Resource name of a KMS crypto key (managed by the user) used to
    /// encrypt/decrypt their event data.
    ///
    /// It must match the pattern
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crypto_key_name: std::string::String,

    /// Optional. Config to control Platform logging for the Message Bus. This log
    /// configuration is applied to the Message Bus itself, and all the Enrollments
    /// attached to it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MessageBus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MessageBus::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::MessageBus::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::MessageBus::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MessageBus::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::MessageBus::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::MessageBus::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::MessageBus::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }

    /// Sets the value of [logging_config][crate::model::MessageBus::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::MessageBus::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::MessageBus::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for MessageBus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.MessageBus"
    }
}

/// Network Configuration that can be inherited by other protos.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkConfig {
    /// Required. Name of the NetworkAttachment that allows access to the
    /// customer's VPC. Format:
    /// `projects/{PROJECT_ID}/regions/{REGION}/networkAttachments/{NETWORK_ATTACHMENT_NAME}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_attachment: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_attachment][crate::model::NetworkConfig::network_attachment].
    pub fn set_network_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_attachment = v.into();
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.NetworkConfig"
    }
}

/// A representation of the Pipeline resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Pipeline {
    /// Identifier. The resource name of the Pipeline. Must be unique within the
    /// location of the project and must be in
    /// `projects/{project}/locations/{location}/pipelines/{pipeline}` format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The creation time.
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up
    /// to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and
    /// "2014-10-02T15:01:23.045123456Z".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up
    /// to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and
    /// "2014-10-02T15:01:23.045123456Z".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User labels attached to the Pipeline that can be used to group
    /// resources. An object containing a list of "key": value pairs. Example: {
    /// "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Server-assigned unique identifier for the Pipeline. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Optional. User-defined annotations. See
    /// <https://google.aip.dev/128#annotations>.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Display name of resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. List of destinations to which messages will be forwarded.
    /// Currently, exactly one destination is supported per Pipeline.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub destinations: std::vec::Vec<crate::model::pipeline::Destination>,

    /// Optional. List of mediation operations to be performed on the message.
    /// Currently, only one Transformation operation is allowed in each Pipeline.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mediations: std::vec::Vec<crate::model::pipeline::Mediation>,

    /// Optional. Resource name of a KMS crypto key (managed by the user) used to
    /// encrypt/decrypt the event data. If not set, an internal Google-owned key
    /// will be used to encrypt messages. It must match the pattern
    /// "projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crypto_key_name: std::string::String,

    /// Optional. The payload format expected for the messages received by the
    /// Pipeline. If input_payload_format is set then any messages not matching
    /// this format will be treated as persistent errors. If input_payload_format
    /// is not set, then the message data will be treated as an opaque binary and
    /// no output format can be set on the Pipeline through the
    /// Pipeline.Destination.output_payload_format field. Any Mediations on the
    /// Pipeline that involve access to the data field will fail as persistent
    /// errors.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input_payload_format: std::option::Option<crate::model::pipeline::MessagePayloadFormat>,

    /// Optional. Config to control Platform Logging for Pipelines.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Optional. The retry policy to use in the pipeline.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retry_policy: std::option::Option<crate::model::pipeline::RetryPolicy>,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and might be sent only on create requests to ensure that the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Pipeline {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Pipeline::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Pipeline::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Pipeline::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Pipeline::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Pipeline::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::Pipeline::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }

    /// Sets the value of [input_payload_format][crate::model::Pipeline::input_payload_format].
    pub fn set_input_payload_format<
        T: std::convert::Into<std::option::Option<crate::model::pipeline::MessagePayloadFormat>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_payload_format = v.into();
        self
    }

    /// Sets the value of [logging_config][crate::model::Pipeline::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [retry_policy][crate::model::Pipeline::retry_policy].
    pub fn set_retry_policy<
        T: std::convert::Into<std::option::Option<crate::model::pipeline::RetryPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retry_policy = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Pipeline::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [destinations][crate::model::Pipeline::destinations].
    pub fn set_destinations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::pipeline::Destination>,
    {
        use std::iter::Iterator;
        self.destinations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mediations][crate::model::Pipeline::mediations].
    pub fn set_mediations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::pipeline::Mediation>,
    {
        use std::iter::Iterator;
        self.mediations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Pipeline::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Pipeline::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Pipeline {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Pipeline"
    }
}

/// Defines additional types related to [Pipeline].
pub mod pipeline {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the format of message data.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MessagePayloadFormat {
        /// The kind of message format.
        /// One of Protobuf, Avro, and JSON supported.
        /// This allows specification of what specific format
        /// messages are sent and received.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub kind: std::option::Option<crate::model::pipeline::message_payload_format::Kind>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MessagePayloadFormat {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `kind`.
        pub fn set_kind<
            T: std::convert::Into<
                    std::option::Option<crate::model::pipeline::message_payload_format::Kind>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::pipeline::MessagePayloadFormat::kind]
        /// if it holds a `Protobuf`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_protobuf(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::pipeline::message_payload_format::ProtobufFormat>,
        > {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::pipeline::message_payload_format::Kind::Protobuf(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [kind][crate::model::pipeline::MessagePayloadFormat::kind]
        /// if it holds a `Avro`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_avro(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::pipeline::message_payload_format::AvroFormat>,
        > {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::pipeline::message_payload_format::Kind::Avro(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [kind][crate::model::pipeline::MessagePayloadFormat::kind]
        /// if it holds a `Json`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_json(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::pipeline::message_payload_format::JsonFormat>,
        > {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::pipeline::message_payload_format::Kind::Json(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::pipeline::MessagePayloadFormat::kind]
        /// to hold a `Protobuf`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_protobuf<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::pipeline::message_payload_format::ProtobufFormat>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::pipeline::message_payload_format::Kind::Protobuf(v.into()),
            );
            self
        }

        /// Sets the value of [kind][crate::model::pipeline::MessagePayloadFormat::kind]
        /// to hold a `Avro`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_avro<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::pipeline::message_payload_format::AvroFormat>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::pipeline::message_payload_format::Kind::Avro(v.into()),
            );
            self
        }

        /// Sets the value of [kind][crate::model::pipeline::MessagePayloadFormat::kind]
        /// to hold a `Json`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_json<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::pipeline::message_payload_format::JsonFormat>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::pipeline::message_payload_format::Kind::Json(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for MessagePayloadFormat {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.MessagePayloadFormat"
        }
    }

    /// Defines additional types related to [MessagePayloadFormat].
    pub mod message_payload_format {
        #[allow(unused_imports)]
        use super::*;

        /// The format of a JSON message payload.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct JsonFormat {
            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JsonFormat {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for JsonFormat {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.MessagePayloadFormat.JsonFormat"
            }
        }

        /// The format of a Protobuf message payload.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ProtobufFormat {
            /// Optional. The entire schema definition is stored in this field.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub schema_definition: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ProtobufFormat {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [schema_definition][crate::model::pipeline::message_payload_format::ProtobufFormat::schema_definition].
            pub fn set_schema_definition<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.schema_definition = v.into();
                self
            }
        }

        impl wkt::message::Message for ProtobufFormat {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.MessagePayloadFormat.ProtobufFormat"
            }
        }

        /// The format of an AVRO message payload.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AvroFormat {
            /// Optional. The entire schema definition is stored in this field.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub schema_definition: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AvroFormat {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [schema_definition][crate::model::pipeline::message_payload_format::AvroFormat::schema_definition].
            pub fn set_schema_definition<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.schema_definition = v.into();
                self
            }
        }

        impl wkt::message::Message for AvroFormat {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.MessagePayloadFormat.AvroFormat"
            }
        }

        /// The kind of message format.
        /// One of Protobuf, Avro, and JSON supported.
        /// This allows specification of what specific format
        /// messages are sent and received.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Kind {
            /// Optional. Protobuf format.
            Protobuf(
                std::boxed::Box<crate::model::pipeline::message_payload_format::ProtobufFormat>,
            ),
            /// Optional. Avro format.
            Avro(std::boxed::Box<crate::model::pipeline::message_payload_format::AvroFormat>),
            /// Optional. JSON format.
            Json(std::boxed::Box<crate::model::pipeline::message_payload_format::JsonFormat>),
        }
    }

    /// Represents a target of an invocation over HTTP.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Destination {
        /// Optional. Network config is used to configure how Pipeline resolves and
        /// connects to a destination.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub network_config: std::option::Option<crate::model::pipeline::destination::NetworkConfig>,

        /// Optional. An authentication config used to authenticate message requests,
        /// such that destinations can verify the source. For example, this can be
        /// used with private GCP destinations that require GCP credentials to access
        /// like Cloud Run. This field is optional and should be set only by users
        /// interested in authenticated push
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub authentication_config:
            std::option::Option<crate::model::pipeline::destination::AuthenticationConfig>,

        /// Optional. The message format before it is delivered to the destination.
        /// If not set, the message will be delivered in the format it was originally
        /// delivered to the Pipeline. This field can only be set if
        /// Pipeline.input_payload_format is also set.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub output_payload_format:
            std::option::Option<crate::model::pipeline::MessagePayloadFormat>,

        /// The destination identifier to which the request should be routed to.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub destination_descriptor:
            std::option::Option<crate::model::pipeline::destination::DestinationDescriptor>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Destination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_config][crate::model::pipeline::Destination::network_config].
        pub fn set_network_config<
            T: std::convert::Into<
                    std::option::Option<crate::model::pipeline::destination::NetworkConfig>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.network_config = v.into();
            self
        }

        /// Sets the value of [authentication_config][crate::model::pipeline::Destination::authentication_config].
        pub fn set_authentication_config<
            T: std::convert::Into<
                    std::option::Option<crate::model::pipeline::destination::AuthenticationConfig>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication_config = v.into();
            self
        }

        /// Sets the value of [output_payload_format][crate::model::pipeline::Destination::output_payload_format].
        pub fn set_output_payload_format<
            T: std::convert::Into<std::option::Option<crate::model::pipeline::MessagePayloadFormat>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.output_payload_format = v.into();
            self
        }

        /// Sets the value of `destination_descriptor`.
        pub fn set_destination_descriptor<
            T: std::convert::Into<
                    std::option::Option<crate::model::pipeline::destination::DestinationDescriptor>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.destination_descriptor = v.into();
            self
        }

        /// The value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// if it holds a `HttpEndpoint`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_http_endpoint(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::pipeline::destination::HttpEndpoint>>
        {
            #[allow(unreachable_patterns)]
            self.destination_descriptor.as_ref().and_then(|v| match v {
                crate::model::pipeline::destination::DestinationDescriptor::HttpEndpoint(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// if it holds a `Workflow`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_workflow(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.destination_descriptor.as_ref().and_then(|v| match v {
                crate::model::pipeline::destination::DestinationDescriptor::Workflow(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// if it holds a `MessageBus`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_message_bus(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.destination_descriptor.as_ref().and_then(|v| match v {
                crate::model::pipeline::destination::DestinationDescriptor::MessageBus(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// if it holds a `Topic`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_topic(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.destination_descriptor.as_ref().and_then(|v| match v {
                crate::model::pipeline::destination::DestinationDescriptor::Topic(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// to hold a `HttpEndpoint`.
        ///
        /// Note that all the setters affecting `destination_descriptor` are
        /// mutually exclusive.
        pub fn set_http_endpoint<
            T: std::convert::Into<std::boxed::Box<crate::model::pipeline::destination::HttpEndpoint>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.destination_descriptor = std::option::Option::Some(
                crate::model::pipeline::destination::DestinationDescriptor::HttpEndpoint(v.into()),
            );
            self
        }

        /// Sets the value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// to hold a `Workflow`.
        ///
        /// Note that all the setters affecting `destination_descriptor` are
        /// mutually exclusive.
        pub fn set_workflow<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.destination_descriptor = std::option::Option::Some(
                crate::model::pipeline::destination::DestinationDescriptor::Workflow(v.into()),
            );
            self
        }

        /// Sets the value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// to hold a `MessageBus`.
        ///
        /// Note that all the setters affecting `destination_descriptor` are
        /// mutually exclusive.
        pub fn set_message_bus<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.destination_descriptor = std::option::Option::Some(
                crate::model::pipeline::destination::DestinationDescriptor::MessageBus(v.into()),
            );
            self
        }

        /// Sets the value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// to hold a `Topic`.
        ///
        /// Note that all the setters affecting `destination_descriptor` are
        /// mutually exclusive.
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.destination_descriptor = std::option::Option::Some(
                crate::model::pipeline::destination::DestinationDescriptor::Topic(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Destination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Destination"
        }
    }

    /// Defines additional types related to [Destination].
    pub mod destination {
        #[allow(unused_imports)]
        use super::*;

        /// Represents a network config to be used for destination resolution and
        /// connectivity.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct NetworkConfig {
            /// Required. Name of the NetworkAttachment that allows access to the
            /// consumer VPC. Format:
            /// `projects/{PROJECT_ID}/regions/{REGION}/networkAttachments/{NETWORK_ATTACHMENT_NAME}`
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub network_attachment: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl NetworkConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [network_attachment][crate::model::pipeline::destination::NetworkConfig::network_attachment].
            pub fn set_network_attachment<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.network_attachment = v.into();
                self
            }
        }

        impl wkt::message::Message for NetworkConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Destination.NetworkConfig"
            }
        }

        /// Represents a HTTP endpoint destination.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct HttpEndpoint {
            /// Required. The URI of the HTTP enpdoint.
            ///
            /// The value must be a RFC2396 URI string.
            /// Examples: `<https://svc.us-central1.p.local>:8080/route`.
            /// Only the HTTPS protocol is supported.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub uri: std::string::String,

            /// Optional. The CEL expression used to modify how the destination-bound
            /// HTTP request is constructed.
            ///
            /// If a binding expression is not specified here, the message
            /// is treated as a CloudEvent and is mapped to the HTTP request according
            /// to the CloudEvent HTTP Protocol Binding Binary Content Mode. In this
            /// representation, all fields except the `data` and `datacontenttype`
            /// field on the message are mapped to HTTP request headers with a prefix
            /// of `ce-`.
            ///
            /// To construct the HTTP request payload and the value of the content-type
            /// HTTP header, the payload format is defined as follows:
            ///
            /// ) Use the output_payload_format_type on the Pipeline.Destination if it
            ///   is set, else:
            /// ) Use the input_payload_format_type on the Pipeline if it is set,
            ///   else:
            /// ) Treat the payload as opaque binary data.
            ///
            /// The `data` field of the message is converted to the payload format or
            /// left as-is for case 3) and then attached as the payload of the HTTP
            /// request. The `content-type` header on the HTTP request is set to the
            /// payload format type or left empty for case 3). However, if a mediation
            /// has updated the `datacontenttype` field on the message so that it is
            /// not the same as the payload format type but it is still a prefix of the
            /// payload format type, then the `content-type` header on the HTTP request
            /// is set to this `datacontenttype` value. For example, if the
            /// `datacontenttype` is "application/json" and the payload format type is
            /// "application/json; charset=utf-8", then the `content-type` header on
            /// the HTTP request is set to "application/json; charset=utf-8".
            ///
            /// If a non-empty binding expression is specified then this expression is
            /// used to modify the default CloudEvent HTTP Protocol Binding Binary
            /// Content representation.
            /// The result of the CEL expression must be a map of key/value pairs
            /// which is used as follows:
            ///
            /// - If a map named `headers` exists on the result of the expression,
            ///   then its key/value pairs are directly mapped to the HTTP request
            ///   headers. The headers values are constructed from the corresponding
            ///   value type’s canonical representation. If the `headers` field doesn’t
            ///   exist then the resulting HTTP request will be the headers of the
            ///   CloudEvent HTTP Binding Binary Content Mode representation of the final
            ///   message. Note: If the specified binding expression, has updated the
            ///   `datacontenttype` field on the message so that it is not the same as
            ///   the payload format type but it is still a prefix of the payload format
            ///   type, then the `content-type` header in the `headers` map is set to
            ///   this `datacontenttype` value.
            /// - If a field named `body` exists on the result of the expression then
            ///   its value is directly mapped to the body of the request. If the value
            ///   of the `body` field is of type bytes or string then it is used for
            ///   the HTTP request body as-is, with no conversion. If the body field is
            ///   of any other type then it is converted to a JSON string. If the body
            ///   field does not exist then the resulting payload of the HTTP request
            ///   will be data value of the CloudEvent HTTP Binding Binary Content Mode
            ///   representation of the final message as described earlier.
            /// - Any other fields in the resulting expression will be ignored.
            ///
            /// The CEL expression may access the incoming CloudEvent message in its
            /// definition, as follows:
            ///
            /// - The `data` field of the incoming CloudEvent message can be accessed
            ///   using the `message.data` value. Subfields of `message.data` may also be
            ///   accessed if an input_payload_format has been specified on the Pipeline.
            /// - Each attribute of the incoming CloudEvent message can be accessed
            ///   using the `message.\<key\>` value, where \<key\> is replaced with the
            ///   name of the attribute.
            /// - Existing headers can be accessed in the CEL expression using the
            ///   `headers` variable. The `headers` variable defines a map of key/value
            ///   pairs corresponding to the HTTP headers of the CloudEvent HTTP Binding
            ///   Binary Content Mode representation of the final message as described
            ///   earlier. For example, the following CEL expression can be used to
            ///   construct an HTTP request by adding an additional header to the HTTP
            ///   headers of the CloudEvent HTTP Binding Binary Content Mode
            ///   representation of the final message and by overwriting the body of the
            ///   request:
            ///
            /// ```norust
            /// {
            ///   "headers": headers.merge({"new-header-key": "new-header-value"}),
            ///   "body": "new-body"
            /// }
            /// ```
            ///
            /// Additionally, the following CEL extension functions are provided for
            /// use in this CEL expression:
            ///
            /// - toBase64Url:
            ///   map.toBase64Url() -> string
            ///   - Converts a CelValue to a base64url encoded string
            /// - toJsonString: map.toJsonString() -> string
            ///   - Converts a CelValue to a JSON string
            /// - merge:
            ///   map1.merge(map2) -> map3
            ///   - Merges the passed CEL map with the existing CEL map the
            ///     function is applied to.
            ///   - If the same key exists in both maps, if the key's value is type
            ///     map both maps are merged else the value from the passed map is
            ///     used.
            /// - denormalize:
            ///   map.denormalize() -> map
            ///   - Denormalizes a CEL map such that every value of type map or key
            ///     in the map is expanded to return a single level map.
            ///   - The resulting keys are "." separated indices of the map keys.
            ///   - For example:
            ///     {
            ///     "a": 1,
            ///     "b": {
            ///     "c": 2,
            ///     "d": 3
            ///     }
            ///     "e": [4, 5]
            ///     }
            ///     .denormalize()
            ///     -> {
            ///     "a": 1,
            ///     "b.c": 2,
            ///     "b.d": 3,
            ///     "e.0": 4,
            ///     "e.1": 5
            ///     }
            /// - setField:
            ///   map.setField(key, value) -> message
            ///   - Sets the field of the message with the given key to the
            ///     given value.
            ///   - If the field is not present it will be added.
            ///   - If the field is present it will be overwritten.
            ///   - The key can be a dot separated path to set a field in a nested
            ///     message.
            ///   - Key must be of type string.
            ///   - Value may be any valid type.
            /// - removeFields:
            ///   map.removeFields([key1, key2, ...]) -> message
            ///   - Removes the fields of the map with the given keys.
            ///   - The keys can be a dot separated path to remove a field in a
            ///     nested message.
            ///   - If a key is not found it will be ignored.
            ///   - Keys must be of type string.
            /// - toMap:
            ///   [map1, map2, ...].toMap() -> map
            ///   - Converts a CEL list of CEL maps to a single CEL map
            /// - toDestinationPayloadFormat():
            ///   message.data.toDestinationPayloadFormat() -> string or bytes
            ///   - Converts the message data to the destination payload format
            ///     specified in Pipeline.Destination.output_payload_format
            ///   - This function is meant to be applied to the message.data field.
            ///   - If the destination payload format is not set, the function will
            ///     return the message data unchanged.
            /// - toCloudEventJsonWithPayloadFormat:
            ///   message.toCloudEventJsonWithPayloadFormat() -> map
            ///   - Converts a message to the corresponding structure of JSON
            ///     format for CloudEvents
            ///   - This function applies toDestinationPayloadFormat() to the
            ///     message data. It also sets the corresponding datacontenttype of
            ///     the CloudEvent, as indicated by
            ///     Pipeline.Destination.output_payload_format. If no
            ///     output_payload_format is set it will use the existing
            ///     datacontenttype on the CloudEvent if present, else leave
            ///     datacontenttype absent.
            ///   - This function expects that the content of the message will
            ///     adhere to the standard CloudEvent format. If it doesn’t then this
            ///     function will fail.
            ///   - The result is a CEL map that corresponds to the JSON
            ///     representation of the CloudEvent. To convert that data to a JSON
            ///     string it can be chained with the toJsonString function.
            ///
            /// The Pipeline expects that the message it receives adheres to the
            /// standard CloudEvent format. If it doesn’t then the outgoing message
            /// request may fail with a persistent error.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub message_binding_template: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl HttpEndpoint {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [uri][crate::model::pipeline::destination::HttpEndpoint::uri].
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }

            /// Sets the value of [message_binding_template][crate::model::pipeline::destination::HttpEndpoint::message_binding_template].
            pub fn set_message_binding_template<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.message_binding_template = v.into();
                self
            }
        }

        impl wkt::message::Message for HttpEndpoint {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Destination.HttpEndpoint"
            }
        }

        /// Represents a config used to authenticate message requests.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AuthenticationConfig {

            /// The type of authentication method.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub authentication_method_descriptor: std::option::Option<crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AuthenticationConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of `authentication_method_descriptor`.
            pub fn set_authentication_method_descriptor<T: std::convert::Into<std::option::Option<crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor>>>(mut self, v: T) -> Self
            {
                self.authentication_method_descriptor = v.into();
                self
            }

            /// The value of [authentication_method_descriptor][crate::model::pipeline::destination::AuthenticationConfig::authentication_method_descriptor]
            /// if it holds a `GoogleOidc`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_google_oidc(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::pipeline::destination::authentication_config::OidcToken,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.authentication_method_descriptor.as_ref().and_then(|v| match v {
                    crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor::GoogleOidc(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [authentication_method_descriptor][crate::model::pipeline::destination::AuthenticationConfig::authentication_method_descriptor]
            /// if it holds a `OauthToken`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_oauth_token(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::pipeline::destination::authentication_config::OAuthToken,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.authentication_method_descriptor.as_ref().and_then(|v| match v {
                    crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor::OauthToken(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [authentication_method_descriptor][crate::model::pipeline::destination::AuthenticationConfig::authentication_method_descriptor]
            /// to hold a `GoogleOidc`.
            ///
            /// Note that all the setters affecting `authentication_method_descriptor` are
            /// mutually exclusive.
            pub fn set_google_oidc<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::pipeline::destination::authentication_config::OidcToken,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.authentication_method_descriptor = std::option::Option::Some(
                    crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor::GoogleOidc(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [authentication_method_descriptor][crate::model::pipeline::destination::AuthenticationConfig::authentication_method_descriptor]
            /// to hold a `OauthToken`.
            ///
            /// Note that all the setters affecting `authentication_method_descriptor` are
            /// mutually exclusive.
            pub fn set_oauth_token<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::pipeline::destination::authentication_config::OAuthToken,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.authentication_method_descriptor = std::option::Option::Some(
                    crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor::OauthToken(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for AuthenticationConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Destination.AuthenticationConfig"
            }
        }

        /// Defines additional types related to [AuthenticationConfig].
        pub mod authentication_config {
            #[allow(unused_imports)]
            use super::*;

            /// Represents a config used to authenticate with a Google OIDC token using
            /// a GCP service account. Use this authentication method to invoke your
            /// Cloud Run and Cloud Functions destinations or HTTP endpoints that
            /// support Google OIDC.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct OidcToken {
                /// Required. Service account email used to generate the OIDC Token.
                /// The principal who calls this API must have
                /// iam.serviceAccounts.actAs permission in the service account. See
                /// <https://cloud.google.com/iam/docs/understanding-service-accounts?hl=en#sa_common>
                /// for more information. Eventarc service agents must have
                /// roles/roles/iam.serviceAccountTokenCreator role to allow the
                /// Pipeline to create OpenID tokens for authenticated requests.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub service_account: std::string::String,

                /// Optional. Audience to be used to generate the OIDC Token. The
                /// audience claim identifies the recipient that the JWT is intended for.
                /// If unspecified, the destination URI will be used.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub audience: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl OidcToken {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [service_account][crate::model::pipeline::destination::authentication_config::OidcToken::service_account].
                pub fn set_service_account<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.service_account = v.into();
                    self
                }

                /// Sets the value of [audience][crate::model::pipeline::destination::authentication_config::OidcToken::audience].
                pub fn set_audience<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.audience = v.into();
                    self
                }
            }

            impl wkt::message::Message for OidcToken {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Destination.AuthenticationConfig.OidcToken"
                }
            }

            /// Contains information needed for generating an
            /// [OAuth token](https://developers.google.com/identity/protocols/OAuth2).
            /// This type of authorization should generally only be used when calling
            /// Google APIs hosted on *.googleapis.com.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct OAuthToken {
                /// Required. Service account email used to generate the [OAuth
                /// token](https://developers.google.com/identity/protocols/OAuth2).
                /// The principal who calls this API must have
                /// iam.serviceAccounts.actAs permission in the service account. See
                /// <https://cloud.google.com/iam/docs/understanding-service-accounts?hl=en#sa_common>
                /// for more information. Eventarc service agents must have
                /// roles/roles/iam.serviceAccountTokenCreator role to allow Pipeline
                /// to create OAuth2 tokens for authenticated requests.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub service_account: std::string::String,

                /// Optional. OAuth scope to be used for generating OAuth access token.
                /// If not specified, `https://www.googleapis.com/auth/cloud-platform`
                /// will be used.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub scope: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl OAuthToken {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [service_account][crate::model::pipeline::destination::authentication_config::OAuthToken::service_account].
                pub fn set_service_account<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.service_account = v.into();
                    self
                }

                /// Sets the value of [scope][crate::model::pipeline::destination::authentication_config::OAuthToken::scope].
                pub fn set_scope<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.scope = v.into();
                    self
                }
            }

            impl wkt::message::Message for OAuthToken {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Destination.AuthenticationConfig.OAuthToken"
                }
            }

            /// The type of authentication method.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum AuthenticationMethodDescriptor {
                /// Optional. This authenticate method will apply Google OIDC tokens
                /// signed by a GCP service account to the requests.
                GoogleOidc(
                    std::boxed::Box<
                        crate::model::pipeline::destination::authentication_config::OidcToken,
                    >,
                ),
                /// Optional. If specified, an [OAuth
                /// token](https://developers.google.com/identity/protocols/OAuth2) will
                /// be generated and attached as an `Authorization` header in the HTTP
                /// request.
                ///
                /// This type of authorization should generally only be used when calling
                /// Google APIs hosted on *.googleapis.com.
                OauthToken(
                    std::boxed::Box<
                        crate::model::pipeline::destination::authentication_config::OAuthToken,
                    >,
                ),
            }
        }

        /// The destination identifier to which the request should be routed to.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum DestinationDescriptor {
            /// Optional. An HTTP endpoint destination described by an URI.
            /// If a DNS FQDN is provided as the endpoint, Pipeline will create a
            /// peering zone to the consumer VPC and forward DNS requests to the VPC
            /// specified by network config to resolve the service endpoint. See:
            /// <https://cloud.google.com/dns/docs/zones/zones-overview#peering_zones>
            HttpEndpoint(std::boxed::Box<crate::model::pipeline::destination::HttpEndpoint>),
            /// Optional. The resource name of the Workflow whose Executions are
            /// triggered by the events. The Workflow resource should be deployed in
            /// the same project as the Pipeline. Format:
            /// `projects/{project}/locations/{location}/workflows/{workflow}`
            Workflow(std::string::String),
            /// Optional. The resource name of the Message Bus to which events should
            /// be published. The Message Bus resource should exist in the same project
            /// as the Pipeline. Format:
            /// `projects/{project}/locations/{location}/messageBuses/{message_bus}`
            MessageBus(std::string::String),
            /// Optional. The resource name of the Pub/Sub topic to which events should
            /// be published. Format:
            /// `projects/{project}/locations/{location}/topics/{topic}`
            Topic(std::string::String),
        }
    }

    /// Mediation defines different ways to modify the Pipeline.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Mediation {
        /// The config of mediation.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub mediation_descriptor:
            std::option::Option<crate::model::pipeline::mediation::MediationDescriptor>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Mediation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `mediation_descriptor`.
        pub fn set_mediation_descriptor<
            T: std::convert::Into<
                    std::option::Option<crate::model::pipeline::mediation::MediationDescriptor>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mediation_descriptor = v.into();
            self
        }

        /// The value of [mediation_descriptor][crate::model::pipeline::Mediation::mediation_descriptor]
        /// if it holds a `Transformation`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_transformation(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::pipeline::mediation::Transformation>>
        {
            #[allow(unreachable_patterns)]
            self.mediation_descriptor.as_ref().and_then(|v| match v {
                crate::model::pipeline::mediation::MediationDescriptor::Transformation(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [mediation_descriptor][crate::model::pipeline::Mediation::mediation_descriptor]
        /// to hold a `Transformation`.
        ///
        /// Note that all the setters affecting `mediation_descriptor` are
        /// mutually exclusive.
        pub fn set_transformation<
            T: std::convert::Into<std::boxed::Box<crate::model::pipeline::mediation::Transformation>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mediation_descriptor = std::option::Option::Some(
                crate::model::pipeline::mediation::MediationDescriptor::Transformation(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Mediation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Mediation"
        }
    }

    /// Defines additional types related to [Mediation].
    pub mod mediation {
        #[allow(unused_imports)]
        use super::*;

        /// Transformation defines the way to transform an incoming message.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Transformation {
            /// Optional. The CEL expression template to apply to transform messages.
            /// The following CEL extension functions are provided for
            /// use in this CEL expression:
            ///
            /// - merge:
            ///   map1.merge(map2) -> map3
            ///   - Merges the passed CEL map with the existing CEL map the
            ///     function is applied to.
            ///   - If the same key exists in both maps, if the key's value is type
            ///     map both maps are merged else the value from the passed map is
            ///     used.
            /// - denormalize:
            ///   map.denormalize() -> map
            ///   - Denormalizes a CEL map such that every value of type map or key
            ///     in the map is expanded to return a single level map.
            ///   - The resulting keys are "." separated indices of the map keys.
            ///   - For example:
            ///     {
            ///     "a": 1,
            ///     "b": {
            ///     "c": 2,
            ///     "d": 3
            ///     }
            ///     "e": [4, 5]
            ///     }
            ///     .denormalize()
            ///     -> {
            ///     "a": 1,
            ///     "b.c": 2,
            ///     "b.d": 3,
            ///     "e.0": 4,
            ///     "e.1": 5
            ///     }
            /// - setField:
            ///   map.setField(key, value) -> message
            ///   - Sets the field of the message with the given key to the
            ///     given value.
            ///   - If the field is not present it will be added.
            ///   - If the field is present it will be overwritten.
            ///   - The key can be a dot separated path to set a field in a nested
            ///     message.
            ///   - Key must be of type string.
            ///   - Value may be any valid type.
            /// - removeFields:
            ///   map.removeFields([key1, key2, ...]) -> message
            ///   - Removes the fields of the map with the given keys.
            ///   - The keys can be a dot separated path to remove a field in a
            ///     nested message.
            ///   - If a key is not found it will be ignored.
            ///   - Keys must be of type string.
            /// - toMap:
            ///   [map1, map2, ...].toMap() -> map
            ///   - Converts a CEL list of CEL maps to a single CEL map
            /// - toDestinationPayloadFormat():
            ///   message.data.toDestinationPayloadFormat() -> string or bytes
            ///   - Converts the message data to the destination payload format
            ///     specified in Pipeline.Destination.output_payload_format
            ///   - This function is meant to be applied to the message.data field.
            ///   - If the destination payload format is not set, the function will
            ///     return the message data unchanged.
            /// - toCloudEventJsonWithPayloadFormat:
            ///   message.toCloudEventJsonWithPayloadFormat() -> map
            ///   - Converts a message to the corresponding structure of JSON
            ///     format for CloudEvents
            ///   - This function applies toDestinationPayloadFormat() to the
            ///     message data. It also sets the corresponding datacontenttype of
            ///     the CloudEvent, as indicated by
            ///     Pipeline.Destination.output_payload_format. If no
            ///     output_payload_format is set it will use the existing
            ///     datacontenttype on the CloudEvent if present, else leave
            ///     datacontenttype absent.
            ///   - This function expects that the content of the message will
            ///     adhere to the standard CloudEvent format. If it doesn’t then this
            ///     function will fail.
            ///   - The result is a CEL map that corresponds to the JSON
            ///     representation of the CloudEvent. To convert that data to a JSON
            ///     string it can be chained with the toJsonString function.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub transformation_template: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Transformation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [transformation_template][crate::model::pipeline::mediation::Transformation::transformation_template].
            pub fn set_transformation_template<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.transformation_template = v.into();
                self
            }
        }

        impl wkt::message::Message for Transformation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Mediation.Transformation"
            }
        }

        /// The config of mediation.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum MediationDescriptor {
            /// Optional. How the Pipeline is to transform messages
            Transformation(std::boxed::Box<crate::model::pipeline::mediation::Transformation>),
        }
    }

    /// The retry policy configuration for the Pipeline. The pipeline
    /// exponentially backs off in case the destination is non responsive or
    /// returns a retryable error code. The default semantics are as follows:
    /// The backoff starts with a 5 second delay and doubles the
    /// delay after each failed attempt (10 seconds, 20 seconds, 40 seconds, etc.).
    /// The delay is capped at 60 seconds by default.
    /// Please note that if you set the min_retry_delay and max_retry_delay fields
    /// to the same value this will make the duration between retries constant.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RetryPolicy {
        /// Optional. The maximum number of delivery attempts for any message. The
        /// value must be between 1 and 100. The default value for this field is 5.
        pub max_attempts: i32,

        /// Optional. The minimum amount of seconds to wait between retry attempts.
        /// The value must be between 1 and 600. The default value for this field
        /// is 5.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_retry_delay: std::option::Option<wkt::Duration>,

        /// Optional. The maximum amount of seconds to wait between retry attempts.
        /// The value must be between 1 and 600. The default value for this field
        /// is 60.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_retry_delay: std::option::Option<wkt::Duration>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RetryPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_attempts][crate::model::pipeline::RetryPolicy::max_attempts].
        pub fn set_max_attempts<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_attempts = v.into();
            self
        }

        /// Sets the value of [min_retry_delay][crate::model::pipeline::RetryPolicy::min_retry_delay].
        pub fn set_min_retry_delay<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_retry_delay = v.into();
            self
        }

        /// Sets the value of [max_retry_delay][crate::model::pipeline::RetryPolicy::max_retry_delay].
        pub fn set_max_retry_delay<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.max_retry_delay = v.into();
            self
        }
    }

    impl wkt::message::Message for RetryPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.RetryPolicy"
        }
    }
}

/// A representation of the trigger resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Trigger {
    /// Required. The resource name of the trigger. Must be unique within the
    /// location of the project and must be in
    /// `projects/{project}/locations/{location}/triggers/{trigger}` format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Server-assigned unique identifier for the trigger. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. Unordered list. The list of filters that applies to event
    /// attributes. Only events that match all the provided filters are sent to the
    /// destination.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub event_filters: std::vec::Vec<crate::model::EventFilter>,

    /// Optional. The IAM service account email associated with the trigger. The
    /// service account represents the identity of the trigger.
    ///
    /// The `iam.serviceAccounts.actAs` permission must be granted on the service
    /// account to allow a principal to impersonate the service account. For more
    /// information, see the
    /// [Roles and permissions](/eventarc/docs/all-roles-permissions) page specific
    /// to the trigger destination.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Required. Destination specifies where the events should be sent to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::Destination>,

    /// Optional. To deliver messages, Eventarc might use other Google Cloud
    /// products as a transport intermediary. This field contains a reference to
    /// that transport intermediary. This information can be used for debugging
    /// purposes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transport: std::option::Option<crate::model::Transport>,

    /// Optional. User labels attached to the triggers that can be used to group
    /// resources.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The name of the channel associated with the trigger in
    /// `projects/{project}/locations/{location}/channels/{channel}` format.
    /// You must provide a channel to receive events from Eventarc SaaS partners.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub channel: std::string::String,

    /// Output only. The reason(s) why a trigger is in FAILED state.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub conditions: std::collections::HashMap<std::string::String, crate::model::StateCondition>,

    /// Optional. EventDataContentType specifies the type of payload in MIME
    /// format that is expected from the CloudEvent data field. This is set to
    /// `application/json` if the value is not defined.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub event_data_content_type: std::string::String,

    /// Output only. Whether or not this Trigger satisfies the requirements of
    /// physical zone separation
    pub satisfies_pzs: bool,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and might be sent only on create requests to ensure that the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Trigger {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Trigger::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Trigger::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Trigger::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Trigger::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Trigger::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::Trigger::destination].
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [transport][crate::model::Trigger::transport].
    pub fn set_transport<T: std::convert::Into<std::option::Option<crate::model::Transport>>>(
        mut self,
        v: T,
    ) -> Self {
        self.transport = v.into();
        self
    }

    /// Sets the value of [channel][crate::model::Trigger::channel].
    pub fn set_channel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.channel = v.into();
        self
    }

    /// Sets the value of [event_data_content_type][crate::model::Trigger::event_data_content_type].
    pub fn set_event_data_content_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_data_content_type = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Trigger::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Trigger::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [event_filters][crate::model::Trigger::event_filters].
    pub fn set_event_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventFilter>,
    {
        use std::iter::Iterator;
        self.event_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Trigger::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [conditions][crate::model::Trigger::conditions].
    pub fn set_conditions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::StateCondition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Trigger {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Trigger"
    }
}

/// Filters events based on exact matches on the CloudEvents attributes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EventFilter {
    /// Required. The name of a CloudEvents attribute. Currently, only a subset of
    /// attributes are supported for filtering. You can [retrieve a specific
    /// provider's supported event
    /// types](/eventarc/docs/list-providers#describe-provider).
    ///
    /// All triggers MUST provide a filter for the 'type' attribute.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attribute: std::string::String,

    /// Required. The value for the attribute.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    /// Optional. The operator used for matching the events with the value of the
    /// filter. If not specified, only events that have an exact key-value pair
    /// specified in the filter are matched. The allowed values are `path_pattern`
    /// and `match-path-pattern`. `path_pattern` is only allowed for GCFv1
    /// triggers.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operator: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attribute][crate::model::EventFilter::attribute].
    pub fn set_attribute<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attribute = v.into();
        self
    }

    /// Sets the value of [value][crate::model::EventFilter::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [operator][crate::model::EventFilter::operator].
    pub fn set_operator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operator = v.into();
        self
    }
}

impl wkt::message::Message for EventFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.EventFilter"
    }
}

/// A condition that is part of the trigger state computation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StateCondition {
    /// The canonical code of the condition.
    pub code: rpc::model::Code,

    /// Human-readable message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StateCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::StateCondition::code].
    pub fn set_code<T: std::convert::Into<rpc::model::Code>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [message][crate::model::StateCondition::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for StateCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.StateCondition"
    }
}

/// Represents a target of an invocation over HTTP.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Destination {
    /// Optional. Network config is used to configure how Eventarc resolves and
    /// connect to a destination.
    /// This should only be used with HttpEndpoint destination type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_config: std::option::Option<crate::model::NetworkConfig>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub descriptor: std::option::Option<crate::model::destination::Descriptor>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Destination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_config][crate::model::Destination::network_config].
    pub fn set_network_config<
        T: std::convert::Into<std::option::Option<crate::model::NetworkConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_config = v.into();
        self
    }

    /// Sets the value of `descriptor`.
    pub fn set_descriptor<
        T: std::convert::Into<std::option::Option<crate::model::destination::Descriptor>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.descriptor = v.into();
        self
    }

    /// The value of [descriptor][crate::model::Destination::descriptor]
    /// if it holds a `CloudRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_run(&self) -> std::option::Option<&std::boxed::Box<crate::model::CloudRun>> {
        #[allow(unreachable_patterns)]
        self.descriptor.as_ref().and_then(|v| match v {
            crate::model::destination::Descriptor::CloudRun(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [descriptor][crate::model::Destination::descriptor]
    /// if it holds a `CloudFunction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_function(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.descriptor.as_ref().and_then(|v| match v {
            crate::model::destination::Descriptor::CloudFunction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [descriptor][crate::model::Destination::descriptor]
    /// if it holds a `Gke`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gke(&self) -> std::option::Option<&std::boxed::Box<crate::model::Gke>> {
        #[allow(unreachable_patterns)]
        self.descriptor.as_ref().and_then(|v| match v {
            crate::model::destination::Descriptor::Gke(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [descriptor][crate::model::Destination::descriptor]
    /// if it holds a `Workflow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_workflow(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.descriptor.as_ref().and_then(|v| match v {
            crate::model::destination::Descriptor::Workflow(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [descriptor][crate::model::Destination::descriptor]
    /// if it holds a `HttpEndpoint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_http_endpoint(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HttpEndpoint>> {
        #[allow(unreachable_patterns)]
        self.descriptor.as_ref().and_then(|v| match v {
            crate::model::destination::Descriptor::HttpEndpoint(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [descriptor][crate::model::Destination::descriptor]
    /// to hold a `CloudRun`.
    ///
    /// Note that all the setters affecting `descriptor` are
    /// mutually exclusive.
    pub fn set_cloud_run<T: std::convert::Into<std::boxed::Box<crate::model::CloudRun>>>(
        mut self,
        v: T,
    ) -> Self {
        self.descriptor =
            std::option::Option::Some(crate::model::destination::Descriptor::CloudRun(v.into()));
        self
    }

    /// Sets the value of [descriptor][crate::model::Destination::descriptor]
    /// to hold a `CloudFunction`.
    ///
    /// Note that all the setters affecting `descriptor` are
    /// mutually exclusive.
    pub fn set_cloud_function<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.descriptor = std::option::Option::Some(
            crate::model::destination::Descriptor::CloudFunction(v.into()),
        );
        self
    }

    /// Sets the value of [descriptor][crate::model::Destination::descriptor]
    /// to hold a `Gke`.
    ///
    /// Note that all the setters affecting `descriptor` are
    /// mutually exclusive.
    pub fn set_gke<T: std::convert::Into<std::boxed::Box<crate::model::Gke>>>(
        mut self,
        v: T,
    ) -> Self {
        self.descriptor =
            std::option::Option::Some(crate::model::destination::Descriptor::Gke(v.into()));
        self
    }

    /// Sets the value of [descriptor][crate::model::Destination::descriptor]
    /// to hold a `Workflow`.
    ///
    /// Note that all the setters affecting `descriptor` are
    /// mutually exclusive.
    pub fn set_workflow<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.descriptor =
            std::option::Option::Some(crate::model::destination::Descriptor::Workflow(v.into()));
        self
    }

    /// Sets the value of [descriptor][crate::model::Destination::descriptor]
    /// to hold a `HttpEndpoint`.
    ///
    /// Note that all the setters affecting `descriptor` are
    /// mutually exclusive.
    pub fn set_http_endpoint<T: std::convert::Into<std::boxed::Box<crate::model::HttpEndpoint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.descriptor = std::option::Option::Some(
            crate::model::destination::Descriptor::HttpEndpoint(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Destination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Destination"
    }
}

/// Defines additional types related to [Destination].
pub mod destination {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Descriptor {
        /// Cloud Run fully-managed resource that receives the events. The resource
        /// should be in the same project as the trigger.
        CloudRun(std::boxed::Box<crate::model::CloudRun>),
        /// The Cloud Function resource name. Cloud Functions V1 and V2 are
        /// supported.
        /// Format: `projects/{project}/locations/{location}/functions/{function}`
        ///
        /// This is a read-only field. Creating Cloud Functions V1/V2 triggers is
        /// only supported via the Cloud Functions product. An error will be returned
        /// if the user sets this value.
        CloudFunction(std::string::String),
        /// A GKE service capable of receiving events. The service should be running
        /// in the same project as the trigger.
        Gke(std::boxed::Box<crate::model::Gke>),
        /// The resource name of the Workflow whose Executions are triggered by
        /// the events. The Workflow resource should be deployed in the same project
        /// as the trigger.
        /// Format: `projects/{project}/locations/{location}/workflows/{workflow}`
        Workflow(std::string::String),
        /// An HTTP endpoint destination described by an URI.
        HttpEndpoint(std::boxed::Box<crate::model::HttpEndpoint>),
    }
}

/// Represents the transport intermediaries created for the trigger to
/// deliver events.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Transport {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub intermediary: std::option::Option<crate::model::transport::Intermediary>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Transport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `intermediary`.
    pub fn set_intermediary<
        T: std::convert::Into<std::option::Option<crate::model::transport::Intermediary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intermediary = v.into();
        self
    }

    /// The value of [intermediary][crate::model::Transport::intermediary]
    /// if it holds a `Pubsub`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pubsub(&self) -> std::option::Option<&std::boxed::Box<crate::model::Pubsub>> {
        #[allow(unreachable_patterns)]
        self.intermediary.as_ref().and_then(|v| match v {
            crate::model::transport::Intermediary::Pubsub(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [intermediary][crate::model::Transport::intermediary]
    /// to hold a `Pubsub`.
    ///
    /// Note that all the setters affecting `intermediary` are
    /// mutually exclusive.
    pub fn set_pubsub<T: std::convert::Into<std::boxed::Box<crate::model::Pubsub>>>(
        mut self,
        v: T,
    ) -> Self {
        self.intermediary =
            std::option::Option::Some(crate::model::transport::Intermediary::Pubsub(v.into()));
        self
    }
}

impl wkt::message::Message for Transport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Transport"
    }
}

/// Defines additional types related to [Transport].
pub mod transport {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Intermediary {
        /// The Pub/Sub topic and subscription used by Eventarc as a transport
        /// intermediary.
        Pubsub(std::boxed::Box<crate::model::Pubsub>),
    }
}

/// Represents a Cloud Run destination.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudRun {
    /// Required. The name of the Cloud Run service being addressed. See
    /// <https://cloud.google.com/run/docs/reference/rest/v1/namespaces.services>.
    ///
    /// Only services located in the same project as the trigger object
    /// can be addressed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service: std::string::String,

    /// Optional. The relative path on the Cloud Run service the events should be
    /// sent to.
    ///
    /// The value must conform to the definition of a URI path segment (section 3.3
    /// of RFC2396). Examples: "/route", "route", "route/subroute".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Required. The region the Cloud Run service is deployed in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::CloudRun::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [path][crate::model::CloudRun::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [region][crate::model::CloudRun::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for CloudRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CloudRun"
    }
}

/// Represents a GKE destination.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Gke {
    /// Required. The name of the cluster the GKE service is running in. The
    /// cluster must be running in the same project as the trigger being created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster: std::string::String,

    /// Required. The name of the Google Compute Engine in which the cluster
    /// resides, which can either be compute zone (for example, us-central1-a) for
    /// the zonal clusters or region (for example, us-central1) for regional
    /// clusters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Required. The namespace the GKE service is running in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub namespace: std::string::String,

    /// Required. Name of the GKE service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service: std::string::String,

    /// Optional. The relative path on the GKE service the events should be sent
    /// to.
    ///
    /// The value must conform to the definition of a URI path segment (section 3.3
    /// of RFC2396). Examples: "/route", "route", "route/subroute".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Gke {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::Gke::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Gke::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [namespace][crate::model::Gke::namespace].
    pub fn set_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.namespace = v.into();
        self
    }

    /// Sets the value of [service][crate::model::Gke::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Gke::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for Gke {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GKE"
    }
}

/// Represents a Pub/Sub transport.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Pubsub {
    /// Optional. The name of the Pub/Sub topic created and managed by Eventarc as
    /// a transport for the event delivery. Format:
    /// `projects/{PROJECT_ID}/topics/{TOPIC_NAME}`.
    ///
    /// You can set an existing topic for triggers of the type
    /// `google.cloud.pubsub.topic.v1.messagePublished`. The topic you provide
    /// here is not deleted by Eventarc at trigger deletion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub topic: std::string::String,

    /// Output only. The name of the Pub/Sub subscription created and managed by
    /// Eventarc as a transport for the event delivery. Format:
    /// `projects/{PROJECT_ID}/subscriptions/{SUBSCRIPTION_NAME}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subscription: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Pubsub {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::Pubsub::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [subscription][crate::model::Pubsub::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }
}

impl wkt::message::Message for Pubsub {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Pubsub"
    }
}

/// Represents a HTTP endpoint destination.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HttpEndpoint {
    /// Required. The URI of the HTTP enpdoint.
    ///
    /// The value must be a RFC2396 URI string.
    /// Examples: `http://10.10.10.8:80/route`,
    /// `<http://svc.us-central1.p.local>:8080/`.
    /// Only HTTP and HTTPS protocols are supported. The host can be either a
    /// static IP addressable from the VPC specified by the network config, or
    /// an internal DNS hostname of the service resolvable via Cloud DNS.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpEndpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::HttpEndpoint::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for HttpEndpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.HttpEndpoint"
    }
}
