// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A representation of the Channel resource.
/// A Channel is a resource on which event providers publish their events.
/// The published events are delivered through the transport associated with the
/// channel. Note that a channel is associated with exactly one event provider.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Channel {
    /// Required. The resource name of the channel. Must be unique within the
    /// location on the project and must be in
    /// `projects/{project}/locations/{location}/channels/{channel_id}` format.
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the channel. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    pub uid: std::string::String,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The name of the event provider (e.g. Eventarc SaaS partner) associated
    /// with the channel. This provider will be granted permissions to publish
    /// events to the channel. Format:
    /// `projects/{project}/locations/{location}/providers/{provider_id}`.
    pub provider: std::string::String,

    /// Output only. The state of a Channel.
    pub state: crate::model::channel::State,

    /// Output only. The activation token for the channel. The token must be used
    /// by the provider to register the channel for publishing.
    pub activation_token: std::string::String,

    /// Resource name of a KMS crypto key (managed by the user) used to
    /// encrypt/decrypt their event data.
    ///
    /// It must match the pattern
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    pub crypto_key_name: std::string::String,

    /// Output only. Whether or not this Channel satisfies the requirements of
    /// physical zone separation
    pub satisfies_pzs: bool,

    pub transport: std::option::Option<crate::model::channel::Transport>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Channel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Channel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Channel::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Channel::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Channel::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Channel::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Channel::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provider][crate::model::Channel::provider].
    pub fn set_provider<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.provider = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Channel::state].
    pub fn set_state<T: std::convert::Into<crate::model::channel::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [activation_token][crate::model::Channel::activation_token].
    pub fn set_activation_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.activation_token = v.into();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::Channel::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Channel::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [transport][crate::model::Channel::transport].
    ///
    /// Note that all the setters affecting `transport` are mutually
    /// exclusive.
    pub fn set_transport<
        T: std::convert::Into<std::option::Option<crate::model::channel::Transport>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transport = v.into();
        self
    }

    /// The value of [transport][crate::model::Channel::transport]
    /// if it holds a `PubsubTopic`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pubsub_topic(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.transport.as_ref().and_then(|v| match v {
            crate::model::channel::Transport::PubsubTopic(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transport][crate::model::Channel::transport]
    /// to hold a `PubsubTopic`.
    ///
    /// Note that all the setters affecting `transport` are
    /// mutually exclusive.
    pub fn set_pubsub_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.transport =
            std::option::Option::Some(crate::model::channel::Transport::PubsubTopic(v.into()));
        self
    }
}

impl wkt::message::Message for Channel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Channel"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Channel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __provider,
            __pubsub_topic,
            __state,
            __activation_token,
            __crypto_key_name,
            __satisfies_pzs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Channel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "provider" => Ok(__FieldTag::__provider),
                            "pubsubTopic" => Ok(__FieldTag::__pubsub_topic),
                            "pubsub_topic" => Ok(__FieldTag::__pubsub_topic),
                            "state" => Ok(__FieldTag::__state),
                            "activationToken" => Ok(__FieldTag::__activation_token),
                            "activation_token" => Ok(__FieldTag::__activation_token),
                            "cryptoKeyName" => Ok(__FieldTag::__crypto_key_name),
                            "crypto_key_name" => Ok(__FieldTag::__crypto_key_name),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Channel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Channel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__provider => {
                            if !fields.insert(__FieldTag::__provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provider",
                                ));
                            }
                            result.provider = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pubsub_topic => {
                            if !fields.insert(__FieldTag::__pubsub_topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub_topic",
                                ));
                            }
                            if result.transport.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transport`, a oneof with full ID .google.cloud.eventarc.v1.Channel.pubsub_topic, latest field was pubsubTopic",
                                ));
                            }
                            result.transport = std::option::Option::Some(
                                crate::model::channel::Transport::PubsubTopic(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::channel::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__activation_token => {
                            if !fields.insert(__FieldTag::__activation_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for activation_token",
                                ));
                            }
                            result.activation_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crypto_key_name => {
                            if !fields.insert(__FieldTag::__crypto_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_name",
                                ));
                            }
                            result.crypto_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Channel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.provider.is_empty() {
            state.serialize_entry("provider", &self.provider)?;
        }
        if let Some(value) = self.pubsub_topic() {
            state.serialize_entry("pubsubTopic", value)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.activation_token.is_empty() {
            state.serialize_entry("activationToken", &self.activation_token)?;
        }
        if !self.crypto_key_name.is_empty() {
            state.serialize_entry("cryptoKeyName", &self.crypto_key_name)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Channel].
pub mod channel {
    #[allow(unused_imports)]
    use super::*;

    /// State lists all the possible states of a Channel
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// The PENDING state indicates that a Channel has been created successfully
        /// and there is a new activation token available for the subscriber to use
        /// to convey the Channel to the provider in order to create a Connection.
        Pending,
        /// The ACTIVE state indicates that a Channel has been successfully
        /// connected with the event provider.
        /// An ACTIVE Channel is ready to receive and route events from the
        /// event provider.
        Active,
        /// The INACTIVE state indicates that the Channel cannot receive events
        /// permanently. There are two possible cases this state can happen:
        ///
        /// 1. The SaaS provider disconnected from this Channel.
        /// 1. The Channel activation token has expired but the SaaS provider
        ///    wasn't connected.
        ///
        /// To re-establish a Connection with a provider, the subscriber
        /// should create a new Channel and give it to the provider.
        Inactive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Inactive => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Active,
                3 => Self::Inactive,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "ACTIVE" => Self::Active,
                "INACTIVE" => Self::Inactive,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Inactive => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.eventarc.v1.Channel.State",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Transport {
        /// Output only. The name of the Pub/Sub topic created and managed by
        /// Eventarc system as a transport for the event delivery. Format:
        /// `projects/{project}/topics/{topic_id}`.
        PubsubTopic(std::string::String),
    }
}

/// A representation of the ChannelConnection resource.
/// A ChannelConnection is a resource which event providers create during the
/// activation process to establish a connection between the provider and the
/// subscriber channel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ChannelConnection {
    /// Required. The name of the connection.
    pub name: std::string::String,

    /// Output only. Server assigned ID of the resource.
    /// The server guarantees uniqueness and immutability until deleted.
    pub uid: std::string::String,

    /// Required. The name of the connected subscriber Channel.
    /// This is a weak reference to avoid cross project and cross accounts
    /// references. This must be in
    /// `projects/{project}/location/{location}/channels/{channel_id}` format.
    pub channel: std::string::String,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Input only. Activation token for the channel. The token will be used
    /// during the creation of ChannelConnection to bind the channel with the
    /// provider project. This field will not be stored in the provider resource.
    pub activation_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChannelConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ChannelConnection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::ChannelConnection::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [channel][crate::model::ChannelConnection::channel].
    pub fn set_channel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.channel = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ChannelConnection::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ChannelConnection::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ChannelConnection::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ChannelConnection::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [activation_token][crate::model::ChannelConnection::activation_token].
    pub fn set_activation_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.activation_token = v.into();
        self
    }
}

impl wkt::message::Message for ChannelConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ChannelConnection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ChannelConnection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __channel,
            __create_time,
            __update_time,
            __activation_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ChannelConnection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "channel" => Ok(__FieldTag::__channel),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "activationToken" => Ok(__FieldTag::__activation_token),
                            "activation_token" => Ok(__FieldTag::__activation_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ChannelConnection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ChannelConnection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__activation_token => {
                            if !fields.insert(__FieldTag::__activation_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for activation_token",
                                ));
                            }
                            result.activation_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ChannelConnection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.channel.is_empty() {
            state.serialize_entry("channel", &self.channel)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.activation_token.is_empty() {
            state.serialize_entry("activationToken", &self.activation_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A representation of the Provider resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Provider {
    /// Output only. In
    /// `projects/{project}/locations/{location}/providers/{provider_id}` format.
    pub name: std::string::String,

    /// Output only. Human friendly name for the Provider. For example "Cloud
    /// Storage".
    pub display_name: std::string::String,

    /// Output only. Event types for this provider.
    pub event_types: std::vec::Vec<crate::model::EventType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Provider {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Provider::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Provider::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [event_types][crate::model::Provider::event_types].
    pub fn set_event_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventType>,
    {
        use std::iter::Iterator;
        self.event_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Provider {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Provider"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Provider {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __event_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Provider")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "eventTypes" => Ok(__FieldTag::__event_types),
                            "event_types" => Ok(__FieldTag::__event_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Provider;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Provider")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_types => {
                            if !fields.insert(__FieldTag::__event_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_types",
                                ));
                            }
                            result.event_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EventType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Provider {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.event_types.is_empty() {
            state.serialize_entry("eventTypes", &self.event_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A representation of the event type resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EventType {
    /// Output only. The full name of the event type (for example,
    /// "google.cloud.storage.object.v1.finalized"). In the form of
    /// {provider-specific-prefix}.{resource}.{version}.{verb}. Types MUST be
    /// versioned and event schemas are guaranteed to remain backward compatible
    /// within one version. Note that event type versions and API versions do not
    /// need to match.
    pub r#type: std::string::String,

    /// Output only. Human friendly description of what the event type is about.
    /// For example "Bucket created in Cloud Storage".
    pub description: std::string::String,

    /// Output only. Filtering attributes for the event type.
    pub filtering_attributes: std::vec::Vec<crate::model::FilteringAttribute>,

    /// Output only. URI for the event schema.
    /// For example
    /// `https://github.com/googleapis/google-cloudevents/blob/master/proto/google/events/cloud/storage/v1/events.proto`
    pub event_schema_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::EventType::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EventType::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [filtering_attributes][crate::model::EventType::filtering_attributes].
    pub fn set_filtering_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FilteringAttribute>,
    {
        use std::iter::Iterator;
        self.filtering_attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [event_schema_uri][crate::model::EventType::event_schema_uri].
    pub fn set_event_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_schema_uri = v.into();
        self
    }
}

impl wkt::message::Message for EventType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.EventType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EventType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __description,
            __filtering_attributes,
            __event_schema_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EventType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "description" => Ok(__FieldTag::__description),
                            "filteringAttributes" => Ok(__FieldTag::__filtering_attributes),
                            "filtering_attributes" => Ok(__FieldTag::__filtering_attributes),
                            "eventSchemaUri" => Ok(__FieldTag::__event_schema_uri),
                            "event_schema_uri" => Ok(__FieldTag::__event_schema_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EventType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EventType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filtering_attributes => {
                            if !fields.insert(__FieldTag::__filtering_attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filtering_attributes",
                                ));
                            }
                            result.filtering_attributes = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FilteringAttribute>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_schema_uri => {
                            if !fields.insert(__FieldTag::__event_schema_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_schema_uri",
                                ));
                            }
                            result.event_schema_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EventType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.filtering_attributes.is_empty() {
            state.serialize_entry("filteringAttributes", &self.filtering_attributes)?;
        }
        if !self.event_schema_uri.is_empty() {
            state.serialize_entry("eventSchemaUri", &self.event_schema_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A representation of the FilteringAttribute resource.
/// Filtering attributes are per event type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FilteringAttribute {
    /// Output only. Attribute used for filtering the event type.
    pub attribute: std::string::String,

    /// Output only. Description of the purpose of the attribute.
    pub description: std::string::String,

    /// Output only. If true, the triggers for this provider should always specify
    /// a filter on these attributes. Trigger creation will fail otherwise.
    pub required: bool,

    /// Output only. If true, the attribute accepts matching expressions in the
    /// Eventarc PathPattern format.
    pub path_pattern_supported: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FilteringAttribute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attribute][crate::model::FilteringAttribute::attribute].
    pub fn set_attribute<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attribute = v.into();
        self
    }

    /// Sets the value of [description][crate::model::FilteringAttribute::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [required][crate::model::FilteringAttribute::required].
    pub fn set_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.required = v.into();
        self
    }

    /// Sets the value of [path_pattern_supported][crate::model::FilteringAttribute::path_pattern_supported].
    pub fn set_path_pattern_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.path_pattern_supported = v.into();
        self
    }
}

impl wkt::message::Message for FilteringAttribute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.FilteringAttribute"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FilteringAttribute {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attribute,
            __description,
            __required,
            __path_pattern_supported,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FilteringAttribute")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attribute" => Ok(__FieldTag::__attribute),
                            "description" => Ok(__FieldTag::__description),
                            "required" => Ok(__FieldTag::__required),
                            "pathPatternSupported" => Ok(__FieldTag::__path_pattern_supported),
                            "path_pattern_supported" => Ok(__FieldTag::__path_pattern_supported),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FilteringAttribute;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FilteringAttribute")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attribute => {
                            if !fields.insert(__FieldTag::__attribute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute",
                                ));
                            }
                            result.attribute = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__required => {
                            if !fields.insert(__FieldTag::__required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for required",
                                ));
                            }
                            result.required = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path_pattern_supported => {
                            if !fields.insert(__FieldTag::__path_pattern_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path_pattern_supported",
                                ));
                            }
                            result.path_pattern_supported = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FilteringAttribute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attribute.is_empty() {
            state.serialize_entry("attribute", &self.attribute)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.required) {
            state.serialize_entry("required", &self.required)?;
        }
        if !wkt::internal::is_default(&self.path_pattern_supported) {
            state.serialize_entry("pathPatternSupported", &self.path_pattern_supported)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An enrollment represents a subscription for messages on a particular message
/// bus. It defines a matching criteria for messages on the bus and the
/// subscriber endpoint where matched messages should be delivered.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Enrollment {
    /// Identifier. Resource name of the form
    /// projects/{project}/locations/{location}/enrollments/{enrollment}
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the channel. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    pub uid: std::string::String,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and might be sent only on update and delete requests to
    /// ensure that the client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Resource labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Resource annotations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Resource display name.
    pub display_name: std::string::String,

    /// Required. A CEL expression identifying which messages this enrollment
    /// applies to.
    pub cel_match: std::string::String,

    /// Required. Resource name of the message bus identifying the source of the
    /// messages. It matches the form
    /// projects/{project}/locations/{location}/messageBuses/{messageBus}.
    pub message_bus: std::string::String,

    /// Required. Destination is the Pipeline that the Enrollment is delivering to.
    /// It must point to the full resource name of a Pipeline. Format:
    /// "projects/{PROJECT_ID}/locations/{region}/pipelines/{PIPELINE_ID)"
    pub destination: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Enrollment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Enrollment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Enrollment::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Enrollment::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Enrollment::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Enrollment::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Enrollment::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Enrollment::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Enrollment::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Enrollment::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::Enrollment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [cel_match][crate::model::Enrollment::cel_match].
    pub fn set_cel_match<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cel_match = v.into();
        self
    }

    /// Sets the value of [message_bus][crate::model::Enrollment::message_bus].
    pub fn set_message_bus<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message_bus = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::Enrollment::destination].
    pub fn set_destination<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = v.into();
        self
    }
}

impl wkt::message::Message for Enrollment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Enrollment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Enrollment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __etag,
            __create_time,
            __update_time,
            __labels,
            __annotations,
            __display_name,
            __cel_match,
            __message_bus,
            __destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Enrollment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "etag" => Ok(__FieldTag::__etag),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "celMatch" => Ok(__FieldTag::__cel_match),
                            "cel_match" => Ok(__FieldTag::__cel_match),
                            "messageBus" => Ok(__FieldTag::__message_bus),
                            "message_bus" => Ok(__FieldTag::__message_bus),
                            "destination" => Ok(__FieldTag::__destination),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Enrollment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Enrollment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cel_match => {
                            if !fields.insert(__FieldTag::__cel_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cel_match",
                                ));
                            }
                            result.cel_match = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message_bus => {
                            if !fields.insert(__FieldTag::__message_bus) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_bus",
                                ));
                            }
                            result.message_bus = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination",
                                ));
                            }
                            result.destination = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Enrollment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.cel_match.is_empty() {
            state.serialize_entry("celMatch", &self.cel_match)?;
        }
        if !self.message_bus.is_empty() {
            state.serialize_entry("messageBus", &self.message_bus)?;
        }
        if !self.destination.is_empty() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the GetTrigger method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTriggerRequest {
    /// Required. The name of the trigger to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the ListTriggers method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTriggersRequest {
    /// Required. The parent collection to list triggers on.
    pub parent: std::string::String,

    /// The maximum number of triggers to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// The page token; provide the value from the `next_page_token` field in a
    /// previous `ListTriggers` call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListTriggers` must match
    /// the call that provided the page token.
    pub page_token: std::string::String,

    /// The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting order is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, trigger_id`.
    pub order_by: std::string::String,

    /// Filter field. Used to filter the Triggers to be listed. Possible filters
    /// are described in <https://google.aip.dev/160>. For example, using
    /// "?filter=destination:gke" would list only Triggers with a gke destination.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTriggersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTriggersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTriggersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTriggersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTriggersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTriggersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListTriggersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListTriggersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTriggersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTriggersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTriggersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTriggersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTriggersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the `ListTriggers` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTriggersResponse {
    /// The requested triggers, up to the number specified in `page_size`.
    pub triggers: std::vec::Vec<crate::model::Trigger>,

    /// A page token that can be sent to `ListTriggers` to request the next page.
    /// If this is empty, then there are no more pages.
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTriggersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [triggers][crate::model::ListTriggersResponse::triggers].
    pub fn set_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trigger>,
    {
        use std::iter::Iterator;
        self.triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTriggersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListTriggersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTriggersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListTriggersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTriggersResponse {
    type PageItem = crate::model::Trigger;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.triggers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTriggersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __triggers,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTriggersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "triggers" => Ok(__FieldTag::__triggers),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTriggersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTriggersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__triggers => {
                            if !fields.insert(__FieldTag::__triggers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for triggers",
                                ));
                            }
                            result.triggers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Trigger>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTriggersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.triggers.is_empty() {
            state.serialize_entry("triggers", &self.triggers)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the CreateTrigger method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTriggerRequest {
    /// Required. The parent collection in which to add this trigger.
    pub parent: std::string::String,

    /// Required. The trigger to create.
    pub trigger: std::option::Option<crate::model::Trigger>,

    /// Required. The user-provided ID to be assigned to the trigger.
    pub trigger_id: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTriggerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::CreateTriggerRequest::trigger].
    pub fn set_trigger<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Trigger>,
    {
        self.trigger = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trigger][crate::model::CreateTriggerRequest::trigger].
    pub fn set_or_clear_trigger<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Trigger>,
    {
        self.trigger = v.map(|x| x.into());
        self
    }

    /// Sets the value of [trigger_id][crate::model::CreateTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateTriggerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreateTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __trigger,
            __trigger_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "trigger" => Ok(__FieldTag::__trigger),
                            "triggerId" => Ok(__FieldTag::__trigger_id),
                            "trigger_id" => Ok(__FieldTag::__trigger_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger => {
                            if !fields.insert(__FieldTag::__trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger",
                                ));
                            }
                            result.trigger =
                                map.next_value::<std::option::Option<crate::model::Trigger>>()?;
                        }
                        __FieldTag::__trigger_id => {
                            if !fields.insert(__FieldTag::__trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_id",
                                ));
                            }
                            result.trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.trigger.is_some() {
            state.serialize_entry("trigger", &self.trigger)?;
        }
        if !self.trigger_id.is_empty() {
            state.serialize_entry("triggerId", &self.trigger_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the UpdateTrigger method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTriggerRequest {
    /// The trigger to be updated.
    pub trigger: std::option::Option<crate::model::Trigger>,

    /// The fields to be updated; only fields explicitly provided are updated.
    /// If no field mask is provided, all provided fields in the request are
    /// updated. To update all fields, provide a field mask of "*".
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set to true, and the trigger is not found, a new trigger will be
    /// created. In this situation, `update_mask` is ignored.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [trigger][crate::model::UpdateTriggerRequest::trigger].
    pub fn set_trigger<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Trigger>,
    {
        self.trigger = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trigger][crate::model::UpdateTriggerRequest::trigger].
    pub fn set_or_clear_trigger<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Trigger>,
    {
        self.trigger = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTriggerRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTriggerRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateTriggerRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateTriggerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdateTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __trigger,
            __update_mask,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "trigger" => Ok(__FieldTag::__trigger),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__trigger => {
                            if !fields.insert(__FieldTag::__trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger",
                                ));
                            }
                            result.trigger =
                                map.next_value::<std::option::Option<crate::model::Trigger>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.trigger.is_some() {
            state.serialize_entry("trigger", &self.trigger)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the DeleteTrigger method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTriggerRequest {
    /// Required. The name of the trigger to be deleted.
    pub name: std::string::String,

    /// If provided, the trigger will only be deleted if the etag matches the
    /// current etag on the resource.
    pub etag: std::string::String,

    /// If set to true, and the trigger is not found, the request will succeed
    /// but no action will be taken on the server.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteTriggerRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteTriggerRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteTriggerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeleteTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the GetChannel method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetChannelRequest {
    /// Required. The name of the channel to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the ListChannels method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListChannelsRequest {
    /// Required. The parent collection to list channels on.
    pub parent: std::string::String,

    /// The maximum number of channels to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// The page token; provide the value from the `next_page_token` field in a
    /// previous `ListChannels` call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListChannels` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting order is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, channel_id`.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListChannelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListChannelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListChannelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListChannelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListChannelsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListChannelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListChannelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListChannelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListChannelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListChannelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListChannelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListChannelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the `ListChannels` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListChannelsResponse {
    /// The requested channels, up to the number specified in `page_size`.
    pub channels: std::vec::Vec<crate::model::Channel>,

    /// A page token that can be sent to `ListChannels` to request the next page.
    /// If this is empty, then there are no more pages.
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListChannelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channels][crate::model::ListChannelsResponse::channels].
    pub fn set_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Channel>,
    {
        use std::iter::Iterator;
        self.channels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListChannelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListChannelsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListChannelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListChannelsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListChannelsResponse {
    type PageItem = crate::model::Channel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.channels
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListChannelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channels,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListChannelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channels" => Ok(__FieldTag::__channels),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListChannelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListChannelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channels => {
                            if !fields.insert(__FieldTag::__channels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channels",
                                ));
                            }
                            result.channels = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Channel>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListChannelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.channels.is_empty() {
            state.serialize_entry("channels", &self.channels)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the CreateChannel method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateChannelRequest {
    /// Required. The parent collection in which to add this channel.
    pub parent: std::string::String,

    /// Required. The channel to create.
    pub channel: std::option::Option<crate::model::Channel>,

    /// Required. The user-provided ID to be assigned to the channel.
    pub channel_id: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateChannelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [channel][crate::model::CreateChannelRequest::channel].
    pub fn set_channel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Channel>,
    {
        self.channel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [channel][crate::model::CreateChannelRequest::channel].
    pub fn set_or_clear_channel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Channel>,
    {
        self.channel = v.map(|x| x.into());
        self
    }

    /// Sets the value of [channel_id][crate::model::CreateChannelRequest::channel_id].
    pub fn set_channel_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.channel_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateChannelRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreateChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __channel,
            __channel_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "channel" => Ok(__FieldTag::__channel),
                            "channelId" => Ok(__FieldTag::__channel_id),
                            "channel_id" => Ok(__FieldTag::__channel_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel =
                                map.next_value::<std::option::Option<crate::model::Channel>>()?;
                        }
                        __FieldTag::__channel_id => {
                            if !fields.insert(__FieldTag::__channel_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_id",
                                ));
                            }
                            result.channel_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.channel.is_some() {
            state.serialize_entry("channel", &self.channel)?;
        }
        if !self.channel_id.is_empty() {
            state.serialize_entry("channelId", &self.channel_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the UpdateChannel method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateChannelRequest {
    /// The channel to be updated.
    pub channel: std::option::Option<crate::model::Channel>,

    /// The fields to be updated; only fields explicitly provided are updated.
    /// If no field mask is provided, all provided fields in the request are
    /// updated. To update all fields, provide a field mask of "*".
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channel][crate::model::UpdateChannelRequest::channel].
    pub fn set_channel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Channel>,
    {
        self.channel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [channel][crate::model::UpdateChannelRequest::channel].
    pub fn set_or_clear_channel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Channel>,
    {
        self.channel = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateChannelRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateChannelRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateChannelRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdateChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channel,
            __update_mask,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channel" => Ok(__FieldTag::__channel),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel =
                                map.next_value::<std::option::Option<crate::model::Channel>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.channel.is_some() {
            state.serialize_entry("channel", &self.channel)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the DeleteChannel method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteChannelRequest {
    /// Required. The name of the channel to be deleted.
    pub name: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteChannelRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeleteChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the GetProvider method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetProviderRequest {
    /// Required. The name of the provider to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProviderRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProviderRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProviderRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetProviderRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetProviderRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetProviderRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetProviderRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetProviderRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetProviderRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the ListProviders method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProvidersRequest {
    /// Required. The parent of the provider to get.
    pub parent: std::string::String,

    /// The maximum number of providers to return on each page.
    pub page_size: i32,

    /// The page token; provide the value from the `next_page_token` field in a
    /// previous `ListProviders` call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListProviders` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting oder is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, _id`.
    pub order_by: std::string::String,

    /// The filter field that the list request will filter on.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProvidersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProvidersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProvidersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProvidersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListProvidersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListProvidersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListProvidersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListProvidersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProvidersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProvidersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProvidersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProvidersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProvidersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the `ListProviders` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProvidersResponse {
    /// The requested providers, up to the number specified in `page_size`.
    pub providers: std::vec::Vec<crate::model::Provider>,

    /// A page token that can be sent to `ListProviders` to request the next page.
    /// If this is empty, then there are no more pages.
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProvidersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [providers][crate::model::ListProvidersResponse::providers].
    pub fn set_providers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Provider>,
    {
        use std::iter::Iterator;
        self.providers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProvidersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListProvidersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListProvidersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListProvidersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProvidersResponse {
    type PageItem = crate::model::Provider;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.providers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProvidersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __providers,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProvidersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "providers" => Ok(__FieldTag::__providers),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProvidersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProvidersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__providers => {
                            if !fields.insert(__FieldTag::__providers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for providers",
                                ));
                            }
                            result.providers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Provider>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProvidersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.providers.is_empty() {
            state.serialize_entry("providers", &self.providers)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the GetChannelConnection method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetChannelConnectionRequest {
    /// Required. The name of the channel connection to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetChannelConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetChannelConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetChannelConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetChannelConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetChannelConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetChannelConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetChannelConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetChannelConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetChannelConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the ListChannelConnections method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListChannelConnectionsRequest {
    /// Required. The parent collection from which to list channel connections.
    pub parent: std::string::String,

    /// The maximum number of channel connections to return on each page.
    ///
    /// Note: The service may send fewer responses.
    pub page_size: i32,

    /// The page token; provide the value from the `next_page_token` field in a
    /// previous `ListChannelConnections` call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListChannelConnetions`
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListChannelConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListChannelConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListChannelConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListChannelConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListChannelConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListChannelConnectionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListChannelConnectionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListChannelConnectionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListChannelConnectionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListChannelConnectionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListChannelConnectionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the `ListChannelConnections` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListChannelConnectionsResponse {
    /// The requested channel connections, up to the number specified in
    /// `page_size`.
    pub channel_connections: std::vec::Vec<crate::model::ChannelConnection>,

    /// A page token that can be sent to `ListChannelConnections` to request the
    /// next page.
    /// If this is empty, then there are no more pages.
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListChannelConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channel_connections][crate::model::ListChannelConnectionsResponse::channel_connections].
    pub fn set_channel_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ChannelConnection>,
    {
        use std::iter::Iterator;
        self.channel_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListChannelConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListChannelConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListChannelConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListChannelConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListChannelConnectionsResponse {
    type PageItem = crate::model::ChannelConnection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.channel_connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListChannelConnectionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channel_connections,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListChannelConnectionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channelConnections" => Ok(__FieldTag::__channel_connections),
                            "channel_connections" => Ok(__FieldTag::__channel_connections),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListChannelConnectionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListChannelConnectionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channel_connections => {
                            if !fields.insert(__FieldTag::__channel_connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_connections",
                                ));
                            }
                            result.channel_connections =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ChannelConnection>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListChannelConnectionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.channel_connections.is_empty() {
            state.serialize_entry("channelConnections", &self.channel_connections)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the CreateChannelConnection method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateChannelConnectionRequest {
    /// Required. The parent collection in which to add this channel connection.
    pub parent: std::string::String,

    /// Required. Channel connection to create.
    pub channel_connection: std::option::Option<crate::model::ChannelConnection>,

    /// Required. The user-provided ID to be assigned to the channel connection.
    pub channel_connection_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateChannelConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateChannelConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [channel_connection][crate::model::CreateChannelConnectionRequest::channel_connection].
    pub fn set_channel_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ChannelConnection>,
    {
        self.channel_connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [channel_connection][crate::model::CreateChannelConnectionRequest::channel_connection].
    pub fn set_or_clear_channel_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ChannelConnection>,
    {
        self.channel_connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [channel_connection_id][crate::model::CreateChannelConnectionRequest::channel_connection_id].
    pub fn set_channel_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.channel_connection_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateChannelConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreateChannelConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateChannelConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __channel_connection,
            __channel_connection_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateChannelConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "channelConnection" => Ok(__FieldTag::__channel_connection),
                            "channel_connection" => Ok(__FieldTag::__channel_connection),
                            "channelConnectionId" => Ok(__FieldTag::__channel_connection_id),
                            "channel_connection_id" => Ok(__FieldTag::__channel_connection_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateChannelConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateChannelConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__channel_connection => {
                            if !fields.insert(__FieldTag::__channel_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_connection",
                                ));
                            }
                            result.channel_connection = map
                                .next_value::<std::option::Option<crate::model::ChannelConnection>>(
                                )?;
                        }
                        __FieldTag::__channel_connection_id => {
                            if !fields.insert(__FieldTag::__channel_connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_connection_id",
                                ));
                            }
                            result.channel_connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateChannelConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.channel_connection.is_some() {
            state.serialize_entry("channelConnection", &self.channel_connection)?;
        }
        if !self.channel_connection_id.is_empty() {
            state.serialize_entry("channelConnectionId", &self.channel_connection_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the DeleteChannelConnection method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteChannelConnectionRequest {
    /// Required. The name of the channel connection to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteChannelConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteChannelConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteChannelConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeleteChannelConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteChannelConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteChannelConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteChannelConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteChannelConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteChannelConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the UpdateGoogleChannelConfig method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGoogleChannelConfigRequest {
    /// Required. The config to be updated.
    pub google_channel_config: std::option::Option<crate::model::GoogleChannelConfig>,

    /// The fields to be updated; only fields explicitly provided are updated.
    /// If no field mask is provided, all provided fields in the request are
    /// updated. To update all fields, provide a field mask of "*".
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGoogleChannelConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [google_channel_config][crate::model::UpdateGoogleChannelConfigRequest::google_channel_config].
    pub fn set_google_channel_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GoogleChannelConfig>,
    {
        self.google_channel_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [google_channel_config][crate::model::UpdateGoogleChannelConfigRequest::google_channel_config].
    pub fn set_or_clear_google_channel_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GoogleChannelConfig>,
    {
        self.google_channel_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateGoogleChannelConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateGoogleChannelConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateGoogleChannelConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdateGoogleChannelConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGoogleChannelConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __google_channel_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateGoogleChannelConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "googleChannelConfig" => Ok(__FieldTag::__google_channel_config),
                            "google_channel_config" => Ok(__FieldTag::__google_channel_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGoogleChannelConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGoogleChannelConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__google_channel_config => {
                            if !fields.insert(__FieldTag::__google_channel_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_channel_config",
                                ));
                            }
                            result.google_channel_config = map.next_value::<std::option::Option<crate::model::GoogleChannelConfig>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateGoogleChannelConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.google_channel_config.is_some() {
            state.serialize_entry("googleChannelConfig", &self.google_channel_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the GetGoogleChannelConfig method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGoogleChannelConfigRequest {
    /// Required. The name of the config to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGoogleChannelConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGoogleChannelConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGoogleChannelConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetGoogleChannelConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGoogleChannelConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGoogleChannelConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGoogleChannelConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGoogleChannelConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetGoogleChannelConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the GetMessageBus method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMessageBusRequest {
    /// Required. The name of the message bus to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMessageBusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMessageBusRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMessageBusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetMessageBusRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMessageBusRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetMessageBusRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMessageBusRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMessageBusRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMessageBusRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the ListMessageBuses method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMessageBusesRequest {
    /// Required. The parent collection to list triggers on.
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// Optional. The page token; provide the value from the `next_page_token`
    /// field in a previous call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided must match
    /// the previous call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting order is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, update_time`.
    pub order_by: std::string::String,

    /// Optional. The filter field that the list request will filter on.
    /// Possible filtersare described in <https://google.aip.dev/160>.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMessageBusesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMessageBusesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMessageBusesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMessageBusesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListMessageBusesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMessageBusesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListMessageBusesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListMessageBusesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMessageBusesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMessageBusesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMessageBusesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMessageBusesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMessageBusesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the `ListMessageBuses` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMessageBusesResponse {
    /// The requested message buses, up to the number specified in `page_size`.
    pub message_buses: std::vec::Vec<crate::model::MessageBus>,

    /// A page token that can be sent to `ListMessageBuses` to request the next
    /// page. If this is empty, then there are no more pages.
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMessageBusesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message_buses][crate::model::ListMessageBusesResponse::message_buses].
    pub fn set_message_buses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageBus>,
    {
        use std::iter::Iterator;
        self.message_buses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMessageBusesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListMessageBusesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMessageBusesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListMessageBusesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMessageBusesResponse {
    type PageItem = crate::model::MessageBus;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.message_buses
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMessageBusesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message_buses,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMessageBusesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messageBuses" => Ok(__FieldTag::__message_buses),
                            "message_buses" => Ok(__FieldTag::__message_buses),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMessageBusesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMessageBusesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message_buses => {
                            if !fields.insert(__FieldTag::__message_buses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_buses",
                                ));
                            }
                            result.message_buses = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageBus>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMessageBusesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message_buses.is_empty() {
            state.serialize_entry("messageBuses", &self.message_buses)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the `ListMessageBusEnrollments` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMessageBusEnrollmentsRequest {
    /// Required. The parent message bus to list enrollments on.
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// Optional. The page token; provide the value from the `next_page_token`
    /// field in a previous call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided must match
    /// the previous call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMessageBusEnrollmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMessageBusEnrollmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMessageBusEnrollmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMessageBusEnrollmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMessageBusEnrollmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListMessageBusEnrollmentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMessageBusEnrollmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMessageBusEnrollmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMessageBusEnrollmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMessageBusEnrollmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMessageBusEnrollmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the `ListMessageBusEnrollments` method.`
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMessageBusEnrollmentsResponse {
    /// The requested enrollments, up to the number specified in `page_size`.
    pub enrollments: std::vec::Vec<std::string::String>,

    /// A page token that can be sent to `ListMessageBusEnrollments` to request the
    /// next page. If this is empty, then there are no more pages.
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMessageBusEnrollmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enrollments][crate::model::ListMessageBusEnrollmentsResponse::enrollments].
    pub fn set_enrollments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.enrollments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMessageBusEnrollmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListMessageBusEnrollmentsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMessageBusEnrollmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListMessageBusEnrollmentsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMessageBusEnrollmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enrollments,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMessageBusEnrollmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enrollments" => Ok(__FieldTag::__enrollments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMessageBusEnrollmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMessageBusEnrollmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enrollments => {
                            if !fields.insert(__FieldTag::__enrollments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enrollments",
                                ));
                            }
                            result.enrollments = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMessageBusEnrollmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.enrollments.is_empty() {
            state.serialize_entry("enrollments", &self.enrollments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the CreateMessageBus method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateMessageBusRequest {
    /// Required. The parent collection in which to add this message bus.
    pub parent: std::string::String,

    /// Required. The message bus to create.
    pub message_bus: std::option::Option<crate::model::MessageBus>,

    /// Required. The user-provided ID to be assigned to the MessageBus. It should
    /// match the format (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$)
    pub message_bus_id: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMessageBusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMessageBusRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [message_bus][crate::model::CreateMessageBusRequest::message_bus].
    pub fn set_message_bus<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MessageBus>,
    {
        self.message_bus = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message_bus][crate::model::CreateMessageBusRequest::message_bus].
    pub fn set_or_clear_message_bus<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MessageBus>,
    {
        self.message_bus = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message_bus_id][crate::model::CreateMessageBusRequest::message_bus_id].
    pub fn set_message_bus_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message_bus_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateMessageBusRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateMessageBusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreateMessageBusRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateMessageBusRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __message_bus,
            __message_bus_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateMessageBusRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "messageBus" => Ok(__FieldTag::__message_bus),
                            "message_bus" => Ok(__FieldTag::__message_bus),
                            "messageBusId" => Ok(__FieldTag::__message_bus_id),
                            "message_bus_id" => Ok(__FieldTag::__message_bus_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateMessageBusRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateMessageBusRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message_bus => {
                            if !fields.insert(__FieldTag::__message_bus) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_bus",
                                ));
                            }
                            result.message_bus =
                                map.next_value::<std::option::Option<crate::model::MessageBus>>()?;
                        }
                        __FieldTag::__message_bus_id => {
                            if !fields.insert(__FieldTag::__message_bus_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_bus_id",
                                ));
                            }
                            result.message_bus_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateMessageBusRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.message_bus.is_some() {
            state.serialize_entry("messageBus", &self.message_bus)?;
        }
        if !self.message_bus_id.is_empty() {
            state.serialize_entry("messageBusId", &self.message_bus_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the UpdateMessageBus method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateMessageBusRequest {
    /// Required. The MessageBus to be updated.
    pub message_bus: std::option::Option<crate::model::MessageBus>,

    /// Optional. The fields to be updated; only fields explicitly provided are
    /// updated. If no field mask is provided, all provided fields in the request
    /// are updated. To update all fields, provide a field mask of "*".
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set to true, and the MessageBus is not found, a new MessageBus
    /// will be created. In this situation, `update_mask` is ignored.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateMessageBusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message_bus][crate::model::UpdateMessageBusRequest::message_bus].
    pub fn set_message_bus<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MessageBus>,
    {
        self.message_bus = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message_bus][crate::model::UpdateMessageBusRequest::message_bus].
    pub fn set_or_clear_message_bus<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MessageBus>,
    {
        self.message_bus = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateMessageBusRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateMessageBusRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateMessageBusRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateMessageBusRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateMessageBusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdateMessageBusRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateMessageBusRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message_bus,
            __update_mask,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateMessageBusRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messageBus" => Ok(__FieldTag::__message_bus),
                            "message_bus" => Ok(__FieldTag::__message_bus),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateMessageBusRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateMessageBusRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message_bus => {
                            if !fields.insert(__FieldTag::__message_bus) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_bus",
                                ));
                            }
                            result.message_bus =
                                map.next_value::<std::option::Option<crate::model::MessageBus>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateMessageBusRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.message_bus.is_some() {
            state.serialize_entry("messageBus", &self.message_bus)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the DeleteMessageBus method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteMessageBusRequest {
    /// Required. The name of the MessageBus to be deleted.
    pub name: std::string::String,

    /// Optional. If provided, the MessageBus will only be deleted if the etag
    /// matches the current etag on the resource.
    pub etag: std::string::String,

    /// Optional. If set to true, and the MessageBus is not found, the request will
    /// succeed but no action will be taken on the server.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMessageBusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMessageBusRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteMessageBusRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteMessageBusRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteMessageBusRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMessageBusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeleteMessageBusRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteMessageBusRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteMessageBusRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteMessageBusRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteMessageBusRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteMessageBusRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the GetEnrollment method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEnrollmentRequest {
    /// Required. The name of the Enrollment to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEnrollmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEnrollmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEnrollmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetEnrollmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEnrollmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEnrollmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEnrollmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEnrollmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEnrollmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the ListEnrollments method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEnrollmentsRequest {
    /// Required. The parent collection to list triggers on.
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// Optional. The page token; provide the value from the `next_page_token`
    /// field in a previous call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided must match
    /// the previous call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting order is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, update_time`.
    pub order_by: std::string::String,

    /// Optional. The filter field that the list request will filter on.
    /// Possible filtersare described in <https://google.aip.dev/160>.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEnrollmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEnrollmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEnrollmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEnrollmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEnrollmentsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEnrollmentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListEnrollmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListEnrollmentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEnrollmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEnrollmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEnrollmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEnrollmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEnrollmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the `ListEnrollments` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEnrollmentsResponse {
    /// The requested Enrollments, up to the number specified in `page_size`.
    pub enrollments: std::vec::Vec<crate::model::Enrollment>,

    /// A page token that can be sent to `ListEnrollments` to request the next
    /// page. If this is empty, then there are no more pages.
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEnrollmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enrollments][crate::model::ListEnrollmentsResponse::enrollments].
    pub fn set_enrollments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Enrollment>,
    {
        use std::iter::Iterator;
        self.enrollments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEnrollmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListEnrollmentsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEnrollmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListEnrollmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEnrollmentsResponse {
    type PageItem = crate::model::Enrollment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.enrollments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEnrollmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enrollments,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEnrollmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enrollments" => Ok(__FieldTag::__enrollments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEnrollmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEnrollmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enrollments => {
                            if !fields.insert(__FieldTag::__enrollments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enrollments",
                                ));
                            }
                            result.enrollments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Enrollment>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEnrollmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.enrollments.is_empty() {
            state.serialize_entry("enrollments", &self.enrollments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the CreateEnrollment method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEnrollmentRequest {
    /// Required. The parent collection in which to add this enrollment.
    pub parent: std::string::String,

    /// Required. The enrollment to create.
    pub enrollment: std::option::Option<crate::model::Enrollment>,

    /// Required. The user-provided ID to be assigned to the Enrollment. It should
    /// match the format (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$).
    pub enrollment_id: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEnrollmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEnrollmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [enrollment][crate::model::CreateEnrollmentRequest::enrollment].
    pub fn set_enrollment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Enrollment>,
    {
        self.enrollment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enrollment][crate::model::CreateEnrollmentRequest::enrollment].
    pub fn set_or_clear_enrollment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Enrollment>,
    {
        self.enrollment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enrollment_id][crate::model::CreateEnrollmentRequest::enrollment_id].
    pub fn set_enrollment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.enrollment_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateEnrollmentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateEnrollmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreateEnrollmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEnrollmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __enrollment,
            __enrollment_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEnrollmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "enrollment" => Ok(__FieldTag::__enrollment),
                            "enrollmentId" => Ok(__FieldTag::__enrollment_id),
                            "enrollment_id" => Ok(__FieldTag::__enrollment_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEnrollmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEnrollmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enrollment => {
                            if !fields.insert(__FieldTag::__enrollment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enrollment",
                                ));
                            }
                            result.enrollment =
                                map.next_value::<std::option::Option<crate::model::Enrollment>>()?;
                        }
                        __FieldTag::__enrollment_id => {
                            if !fields.insert(__FieldTag::__enrollment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enrollment_id",
                                ));
                            }
                            result.enrollment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateEnrollmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.enrollment.is_some() {
            state.serialize_entry("enrollment", &self.enrollment)?;
        }
        if !self.enrollment_id.is_empty() {
            state.serialize_entry("enrollmentId", &self.enrollment_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the UpdateEnrollment method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEnrollmentRequest {
    /// Required. The Enrollment to be updated.
    pub enrollment: std::option::Option<crate::model::Enrollment>,

    /// Optional. The fields to be updated; only fields explicitly provided are
    /// updated. If no field mask is provided, all provided fields in the request
    /// are updated. To update all fields, provide a field mask of "*".
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set to true, and the Enrollment is not found, a new Enrollment
    /// will be created. In this situation, `update_mask` is ignored.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEnrollmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enrollment][crate::model::UpdateEnrollmentRequest::enrollment].
    pub fn set_enrollment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Enrollment>,
    {
        self.enrollment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enrollment][crate::model::UpdateEnrollmentRequest::enrollment].
    pub fn set_or_clear_enrollment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Enrollment>,
    {
        self.enrollment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEnrollmentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEnrollmentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateEnrollmentRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateEnrollmentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEnrollmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdateEnrollmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEnrollmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enrollment,
            __update_mask,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEnrollmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enrollment" => Ok(__FieldTag::__enrollment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEnrollmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEnrollmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enrollment => {
                            if !fields.insert(__FieldTag::__enrollment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enrollment",
                                ));
                            }
                            result.enrollment =
                                map.next_value::<std::option::Option<crate::model::Enrollment>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateEnrollmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enrollment.is_some() {
            state.serialize_entry("enrollment", &self.enrollment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the DeleteEnrollment method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEnrollmentRequest {
    /// Required. The name of the Enrollment to be deleted.
    pub name: std::string::String,

    /// Optional. If provided, the Enrollment will only be deleted if the etag
    /// matches the current etag on the resource.
    pub etag: std::string::String,

    /// Optional. If set to true, and the Enrollment is not found, the request will
    /// succeed but no action will be taken on the server.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEnrollmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEnrollmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteEnrollmentRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteEnrollmentRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteEnrollmentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEnrollmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeleteEnrollmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEnrollmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEnrollmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEnrollmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEnrollmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteEnrollmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the GetPipeline method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPipelineRequest {
    /// Required. The name of the pipeline to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetPipelineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPipelineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPipelineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPipelineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPipelineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPipelineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the ListPipelines method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPipelinesRequest {
    /// Required. The parent collection to list pipelines on.
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// Optional. The page token; provide the value from the `next_page_token`
    /// field in a previous call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided must match
    /// the previous call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting order is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, update_time`.
    pub order_by: std::string::String,

    /// Optional. The filter field that the list request will filter on.
    /// Possible filters are described in <https://google.aip.dev/160>.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPipelinesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPipelinesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPipelinesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPipelinesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPipelinesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPipelinesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListPipelinesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListPipelinesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPipelinesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPipelinesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPipelinesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPipelinesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPipelinesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the ListPipelines method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPipelinesResponse {
    /// The requested pipelines, up to the number specified in `page_size`.
    pub pipelines: std::vec::Vec<crate::model::Pipeline>,

    /// A page token that can be sent to `ListPipelines` to request the next
    /// page. If this is empty, then there are no more pages.
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPipelinesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pipelines][crate::model::ListPipelinesResponse::pipelines].
    pub fn set_pipelines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Pipeline>,
    {
        use std::iter::Iterator;
        self.pipelines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPipelinesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListPipelinesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPipelinesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListPipelinesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPipelinesResponse {
    type PageItem = crate::model::Pipeline;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.pipelines
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPipelinesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pipelines,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPipelinesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pipelines" => Ok(__FieldTag::__pipelines),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPipelinesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPipelinesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pipelines => {
                            if !fields.insert(__FieldTag::__pipelines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipelines",
                                ));
                            }
                            result.pipelines = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Pipeline>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPipelinesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pipelines.is_empty() {
            state.serialize_entry("pipelines", &self.pipelines)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the CreatePipeline method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePipelineRequest {
    /// Required. The parent collection in which to add this pipeline.
    pub parent: std::string::String,

    /// Required. The pipeline to create.
    pub pipeline: std::option::Option<crate::model::Pipeline>,

    /// Required. The user-provided ID to be assigned to the Pipeline.
    pub pipeline_id: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePipelineRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [pipeline][crate::model::CreatePipelineRequest::pipeline].
    pub fn set_pipeline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Pipeline>,
    {
        self.pipeline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pipeline][crate::model::CreatePipelineRequest::pipeline].
    pub fn set_or_clear_pipeline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Pipeline>,
    {
        self.pipeline = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pipeline_id][crate::model::CreatePipelineRequest::pipeline_id].
    pub fn set_pipeline_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreatePipelineRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreatePipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreatePipelineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatePipelineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __pipeline,
            __pipeline_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePipelineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pipeline" => Ok(__FieldTag::__pipeline),
                            "pipelineId" => Ok(__FieldTag::__pipeline_id),
                            "pipeline_id" => Ok(__FieldTag::__pipeline_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatePipelineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePipelineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pipeline => {
                            if !fields.insert(__FieldTag::__pipeline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipeline",
                                ));
                            }
                            result.pipeline =
                                map.next_value::<std::option::Option<crate::model::Pipeline>>()?;
                        }
                        __FieldTag::__pipeline_id => {
                            if !fields.insert(__FieldTag::__pipeline_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipeline_id",
                                ));
                            }
                            result.pipeline_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatePipelineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.pipeline.is_some() {
            state.serialize_entry("pipeline", &self.pipeline)?;
        }
        if !self.pipeline_id.is_empty() {
            state.serialize_entry("pipelineId", &self.pipeline_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the UpdatePipeline method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdatePipelineRequest {
    /// Required. The Pipeline to be updated.
    pub pipeline: std::option::Option<crate::model::Pipeline>,

    /// Optional. The fields to be updated; only fields explicitly provided are
    /// updated. If no field mask is provided, all provided fields in the request
    /// are updated. To update all fields, provide a field mask of "*".
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set to true, and the Pipeline is not found, a new Pipeline
    /// will be created. In this situation, `update_mask` is ignored.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pipeline][crate::model::UpdatePipelineRequest::pipeline].
    pub fn set_pipeline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Pipeline>,
    {
        self.pipeline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pipeline][crate::model::UpdatePipelineRequest::pipeline].
    pub fn set_or_clear_pipeline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Pipeline>,
    {
        self.pipeline = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePipelineRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePipelineRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdatePipelineRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdatePipelineRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdatePipelineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdatePipelineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pipeline,
            __update_mask,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdatePipelineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pipeline" => Ok(__FieldTag::__pipeline),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdatePipelineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdatePipelineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pipeline => {
                            if !fields.insert(__FieldTag::__pipeline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipeline",
                                ));
                            }
                            result.pipeline =
                                map.next_value::<std::option::Option<crate::model::Pipeline>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdatePipelineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.pipeline.is_some() {
            state.serialize_entry("pipeline", &self.pipeline)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the DeletePipeline method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePipelineRequest {
    /// Required. The name of the Pipeline to be deleted.
    pub name: std::string::String,

    /// Optional. If provided, the Pipeline will only be deleted if the etag
    /// matches the current etag on the resource.
    pub etag: std::string::String,

    /// Optional. If set to true, and the Pipeline is not found, the request will
    /// succeed but no action will be taken on the server.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeletePipelineRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeletePipelineRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeletePipelineRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeletePipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeletePipelineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeletePipelineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePipelineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeletePipelineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePipelineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeletePipelineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the GetGoogleApiSource method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGoogleApiSourceRequest {
    /// Required. The name of the google api source to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGoogleApiSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGoogleApiSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGoogleApiSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GetGoogleApiSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGoogleApiSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGoogleApiSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGoogleApiSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGoogleApiSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetGoogleApiSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the ListGoogleApiSources method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGoogleApiSourcesRequest {
    /// Required. The parent collection to list GoogleApiSources on.
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return on each page.
    ///
    /// Note: The service may send fewer.
    pub page_size: i32,

    /// Optional. The page token; provide the value from the `next_page_token`
    /// field in a previous call to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided must match
    /// the previous call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The sorting order of the resources returned. Value should be a
    /// comma-separated list of fields. The default sorting order is ascending. To
    /// specify descending order for a field, append a `desc` suffix; for example:
    /// `name desc, update_time`.
    pub order_by: std::string::String,

    /// Optional. The filter field that the list request will filter on.
    /// Possible filtersare described in <https://google.aip.dev/160>.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGoogleApiSourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGoogleApiSourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGoogleApiSourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGoogleApiSourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListGoogleApiSourcesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGoogleApiSourcesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListGoogleApiSourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListGoogleApiSourcesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGoogleApiSourcesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGoogleApiSourcesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGoogleApiSourcesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGoogleApiSourcesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGoogleApiSourcesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the `ListGoogleApiSources` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGoogleApiSourcesResponse {
    /// The requested GoogleApiSources, up to the number specified in `page_size`.
    pub google_api_sources: std::vec::Vec<crate::model::GoogleApiSource>,

    /// A page token that can be sent to `ListMessageBusEnrollments` to request the
    /// next page. If this is empty, then there are no more pages.
    pub next_page_token: std::string::String,

    /// Unreachable resources, if any.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGoogleApiSourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [google_api_sources][crate::model::ListGoogleApiSourcesResponse::google_api_sources].
    pub fn set_google_api_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GoogleApiSource>,
    {
        use std::iter::Iterator;
        self.google_api_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGoogleApiSourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListGoogleApiSourcesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGoogleApiSourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.ListGoogleApiSourcesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGoogleApiSourcesResponse {
    type PageItem = crate::model::GoogleApiSource;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.google_api_sources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGoogleApiSourcesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __google_api_sources,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGoogleApiSourcesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "googleApiSources" => Ok(__FieldTag::__google_api_sources),
                            "google_api_sources" => Ok(__FieldTag::__google_api_sources),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGoogleApiSourcesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGoogleApiSourcesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__google_api_sources => {
                            if !fields.insert(__FieldTag::__google_api_sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_api_sources",
                                ));
                            }
                            result.google_api_sources =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::GoogleApiSource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGoogleApiSourcesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.google_api_sources.is_empty() {
            state.serialize_entry("googleApiSources", &self.google_api_sources)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the CreateGoogleApiSource method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateGoogleApiSourceRequest {
    /// Required. The parent collection in which to add this google api source.
    pub parent: std::string::String,

    /// Required. The google api source to create.
    pub google_api_source: std::option::Option<crate::model::GoogleApiSource>,

    /// Required. The user-provided ID to be assigned to the GoogleApiSource. It
    /// should match the format (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$).
    pub google_api_source_id: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateGoogleApiSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGoogleApiSourceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [google_api_source][crate::model::CreateGoogleApiSourceRequest::google_api_source].
    pub fn set_google_api_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GoogleApiSource>,
    {
        self.google_api_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [google_api_source][crate::model::CreateGoogleApiSourceRequest::google_api_source].
    pub fn set_or_clear_google_api_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GoogleApiSource>,
    {
        self.google_api_source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [google_api_source_id][crate::model::CreateGoogleApiSourceRequest::google_api_source_id].
    pub fn set_google_api_source_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.google_api_source_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateGoogleApiSourceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateGoogleApiSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CreateGoogleApiSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateGoogleApiSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __google_api_source,
            __google_api_source_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGoogleApiSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "googleApiSource" => Ok(__FieldTag::__google_api_source),
                            "google_api_source" => Ok(__FieldTag::__google_api_source),
                            "googleApiSourceId" => Ok(__FieldTag::__google_api_source_id),
                            "google_api_source_id" => Ok(__FieldTag::__google_api_source_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateGoogleApiSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGoogleApiSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__google_api_source => {
                            if !fields.insert(__FieldTag::__google_api_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_api_source",
                                ));
                            }
                            result.google_api_source = map
                                .next_value::<std::option::Option<crate::model::GoogleApiSource>>(
                                )?;
                        }
                        __FieldTag::__google_api_source_id => {
                            if !fields.insert(__FieldTag::__google_api_source_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_api_source_id",
                                ));
                            }
                            result.google_api_source_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateGoogleApiSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.google_api_source.is_some() {
            state.serialize_entry("googleApiSource", &self.google_api_source)?;
        }
        if !self.google_api_source_id.is_empty() {
            state.serialize_entry("googleApiSourceId", &self.google_api_source_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the UpdateGoogleApiSource method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGoogleApiSourceRequest {
    /// Required. The GoogleApiSource to be updated.
    pub google_api_source: std::option::Option<crate::model::GoogleApiSource>,

    /// Optional. The fields to be updated; only fields explicitly provided are
    /// updated. If no field mask is provided, all provided fields in the request
    /// are updated. To update all fields, provide a field mask of "*".
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set to true, and the GoogleApiSource is not found, a new
    /// GoogleApiSource will be created. In this situation, `update_mask` is
    /// ignored.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGoogleApiSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [google_api_source][crate::model::UpdateGoogleApiSourceRequest::google_api_source].
    pub fn set_google_api_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GoogleApiSource>,
    {
        self.google_api_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [google_api_source][crate::model::UpdateGoogleApiSourceRequest::google_api_source].
    pub fn set_or_clear_google_api_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GoogleApiSource>,
    {
        self.google_api_source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateGoogleApiSourceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateGoogleApiSourceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateGoogleApiSourceRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateGoogleApiSourceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateGoogleApiSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.UpdateGoogleApiSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGoogleApiSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __google_api_source,
            __update_mask,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateGoogleApiSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "googleApiSource" => Ok(__FieldTag::__google_api_source),
                            "google_api_source" => Ok(__FieldTag::__google_api_source),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGoogleApiSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGoogleApiSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__google_api_source => {
                            if !fields.insert(__FieldTag::__google_api_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_api_source",
                                ));
                            }
                            result.google_api_source = map
                                .next_value::<std::option::Option<crate::model::GoogleApiSource>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateGoogleApiSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.google_api_source.is_some() {
            state.serialize_entry("googleApiSource", &self.google_api_source)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the DeleteGoogleApiSource method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteGoogleApiSourceRequest {
    /// Required. The name of the GoogleApiSource to be deleted.
    pub name: std::string::String,

    /// Optional. If provided, the MessageBus will only be deleted if the etag
    /// matches the current etag on the resource.
    pub etag: std::string::String,

    /// Optional. If set to true, and the MessageBus is not found, the request will
    /// succeed but no action will be taken on the server.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteGoogleApiSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGoogleApiSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteGoogleApiSourceRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteGoogleApiSourceRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteGoogleApiSourceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGoogleApiSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.DeleteGoogleApiSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteGoogleApiSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGoogleApiSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteGoogleApiSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGoogleApiSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteGoogleApiSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A GoogleApiSource represents a subscription of 1P events from a MessageBus.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GoogleApiSource {
    /// Identifier. Resource name of the form
    /// projects/{project}/locations/{location}/googleApiSources/{google_api_source}
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the channel. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    pub uid: std::string::String,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and might be sent only on update and delete requests to
    /// ensure that the client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Resource labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Resource annotations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Resource display name.
    pub display_name: std::string::String,

    /// Required. Destination is the message bus that the GoogleApiSource is
    /// delivering to. It must be point to the full resource name of a MessageBus.
    /// Format:
    /// "projects/{PROJECT_ID}/locations/{region}/messagesBuses/{MESSAGE_BUS_ID)
    pub destination: std::string::String,

    /// Optional. Resource name of a KMS crypto key (managed by the user) used to
    /// encrypt/decrypt their event data.
    ///
    /// It must match the pattern
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    pub crypto_key_name: std::string::String,

    /// Optional. Config to control Platform logging for the GoogleApiSource.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoogleApiSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GoogleApiSource::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::GoogleApiSource::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::GoogleApiSource::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::GoogleApiSource::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::GoogleApiSource::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::GoogleApiSource::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::GoogleApiSource::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::GoogleApiSource::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::GoogleApiSource::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::GoogleApiSource::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::GoogleApiSource::destination].
    pub fn set_destination<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::GoogleApiSource::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }

    /// Sets the value of [logging_config][crate::model::GoogleApiSource::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::GoogleApiSource::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GoogleApiSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GoogleApiSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GoogleApiSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __etag,
            __create_time,
            __update_time,
            __labels,
            __annotations,
            __display_name,
            __destination,
            __crypto_key_name,
            __logging_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleApiSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "etag" => Ok(__FieldTag::__etag),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "destination" => Ok(__FieldTag::__destination),
                            "cryptoKeyName" => Ok(__FieldTag::__crypto_key_name),
                            "crypto_key_name" => Ok(__FieldTag::__crypto_key_name),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GoogleApiSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleApiSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination",
                                ));
                            }
                            result.destination = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crypto_key_name => {
                            if !fields.insert(__FieldTag::__crypto_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_name",
                                ));
                            }
                            result.crypto_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GoogleApiSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.destination.is_empty() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if !self.crypto_key_name.is_empty() {
            state.serialize_entry("cryptoKeyName", &self.crypto_key_name)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A GoogleChannelConfig is a resource that stores the custom settings
/// respected by Eventarc first-party triggers in the matching region.
/// Once configured, first-party event data will be protected
/// using the specified custom managed encryption key instead of Google-managed
/// encryption keys.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GoogleChannelConfig {
    /// Required. The resource name of the config. Must be in the format of,
    /// `projects/{project}/locations/{location}/googleChannelConfig`.
    pub name: std::string::String,

    /// Output only. The last-modified time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Resource name of a KMS crypto key (managed by the user) used to
    /// encrypt/decrypt their event data.
    ///
    /// It must match the pattern
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    pub crypto_key_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoogleChannelConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GoogleChannelConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::GoogleChannelConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::GoogleChannelConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::GoogleChannelConfig::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }
}

impl wkt::message::Message for GoogleChannelConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GoogleChannelConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GoogleChannelConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __update_time,
            __crypto_key_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleChannelConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "cryptoKeyName" => Ok(__FieldTag::__crypto_key_name),
                            "crypto_key_name" => Ok(__FieldTag::__crypto_key_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GoogleChannelConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleChannelConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__crypto_key_name => {
                            if !fields.insert(__FieldTag::__crypto_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_name",
                                ));
                            }
                            result.crypto_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GoogleChannelConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.crypto_key_name.is_empty() {
            state.serialize_entry("cryptoKeyName", &self.crypto_key_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The configuration for Platform Telemetry logging for Eventarc Advanced
/// resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LoggingConfig {
    /// Optional. The minimum severity of logs that will be sent to
    /// Stackdriver/Platform Telemetry. Logs at severitiy ≥ this value will be
    /// sent, unless it is NONE.
    pub log_severity: crate::model::logging_config::LogSeverity,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_severity][crate::model::LoggingConfig::log_severity].
    pub fn set_log_severity<T: std::convert::Into<crate::model::logging_config::LogSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.log_severity = v.into();
        self
    }
}

impl wkt::message::Message for LoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.LoggingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_severity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logSeverity" => Ok(__FieldTag::__log_severity),
                            "log_severity" => Ok(__FieldTag::__log_severity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_severity => {
                            if !fields.insert(__FieldTag::__log_severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_severity",
                                ));
                            }
                            result.log_severity = map.next_value::<std::option::Option<crate::model::logging_config::LogSeverity>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoggingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.log_severity) {
            state.serialize_entry("logSeverity", &self.log_severity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LoggingConfig].
pub mod logging_config {
    #[allow(unused_imports)]
    use super::*;

    /// The different severities for logging supported by Eventarc Advanced
    /// resources.
    /// This enum is an exhaustive list of log severities and is FROZEN. Do not
    /// expect new values to be added.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LogSeverity {
        /// Log severity is not specified. This value is treated the same as NONE,
        /// but is used to distinguish between no update and update to NONE in
        /// update_masks.
        Unspecified,
        /// Default value at resource creation, presence of this value must be
        /// treated as no logging/disable logging.
        None,
        /// Debug or trace level logging.
        Debug,
        /// Routine information, such as ongoing status or performance.
        Info,
        /// Normal but significant events, such as start up, shut down, or a
        /// configuration change.
        Notice,
        /// Warning events might cause problems.
        Warning,
        /// Error events are likely to cause problems.
        Error,
        /// Critical events cause more severe problems or outages.
        Critical,
        /// A person must take action immediately.
        Alert,
        /// One or more systems are unusable.
        Emergency,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LogSeverity::value] or
        /// [LogSeverity::name].
        UnknownValue(log_severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod log_severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LogSeverity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Debug => std::option::Option::Some(2),
                Self::Info => std::option::Option::Some(3),
                Self::Notice => std::option::Option::Some(4),
                Self::Warning => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::Critical => std::option::Option::Some(7),
                Self::Alert => std::option::Option::Some(8),
                Self::Emergency => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOG_SEVERITY_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Debug => std::option::Option::Some("DEBUG"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::Notice => std::option::Option::Some("NOTICE"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Critical => std::option::Option::Some("CRITICAL"),
                Self::Alert => std::option::Option::Some("ALERT"),
                Self::Emergency => std::option::Option::Some("EMERGENCY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LogSeverity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LogSeverity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LogSeverity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Debug,
                3 => Self::Info,
                4 => Self::Notice,
                5 => Self::Warning,
                6 => Self::Error,
                7 => Self::Critical,
                8 => Self::Alert,
                9 => Self::Emergency,
                _ => Self::UnknownValue(log_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LogSeverity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOG_SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "DEBUG" => Self::Debug,
                "INFO" => Self::Info,
                "NOTICE" => Self::Notice,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                "CRITICAL" => Self::Critical,
                "ALERT" => Self::Alert,
                "EMERGENCY" => Self::Emergency,
                _ => Self::UnknownValue(log_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LogSeverity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Debug => serializer.serialize_i32(2),
                Self::Info => serializer.serialize_i32(3),
                Self::Notice => serializer.serialize_i32(4),
                Self::Warning => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::Critical => serializer.serialize_i32(7),
                Self::Alert => serializer.serialize_i32(8),
                Self::Emergency => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LogSeverity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LogSeverity>::new(
                ".google.cloud.eventarc.v1.LoggingConfig.LogSeverity",
            ))
        }
    }
}

/// MessageBus for the messages flowing through the system. The admin has
/// visibility and control over the messages being published and consumed and can
/// restrict publishers and subscribers to only a subset of data available in the
/// system by defining authorization policies.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MessageBus {
    /// Identifier. Resource name of the form
    /// projects/{project}/locations/{location}/messageBuses/{message_bus}
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the channel. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    pub uid: std::string::String,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and might be sent only on update and delete requests to
    /// ensure that the client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Resource labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Resource annotations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Resource display name.
    pub display_name: std::string::String,

    /// Optional. Resource name of a KMS crypto key (managed by the user) used to
    /// encrypt/decrypt their event data.
    ///
    /// It must match the pattern
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    pub crypto_key_name: std::string::String,

    /// Optional. Config to control Platform logging for the Message Bus. This log
    /// configuration is applied to the Message Bus itself, and all the Enrollments
    /// attached to it.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MessageBus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MessageBus::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::MessageBus::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::MessageBus::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MessageBus::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MessageBus::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::MessageBus::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::MessageBus::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::MessageBus::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::MessageBus::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::MessageBus::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::MessageBus::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }

    /// Sets the value of [logging_config][crate::model::MessageBus::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::MessageBus::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MessageBus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.MessageBus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MessageBus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __etag,
            __create_time,
            __update_time,
            __labels,
            __annotations,
            __display_name,
            __crypto_key_name,
            __logging_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageBus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "etag" => Ok(__FieldTag::__etag),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "cryptoKeyName" => Ok(__FieldTag::__crypto_key_name),
                            "crypto_key_name" => Ok(__FieldTag::__crypto_key_name),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MessageBus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageBus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crypto_key_name => {
                            if !fields.insert(__FieldTag::__crypto_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_name",
                                ));
                            }
                            result.crypto_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MessageBus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.crypto_key_name.is_empty() {
            state.serialize_entry("cryptoKeyName", &self.crypto_key_name)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Network Configuration that can be inherited by other protos.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkConfig {
    /// Required. Name of the NetworkAttachment that allows access to the
    /// customer's VPC. Format:
    /// `projects/{PROJECT_ID}/regions/{REGION}/networkAttachments/{NETWORK_ATTACHMENT_NAME}`
    pub network_attachment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_attachment][crate::model::NetworkConfig::network_attachment].
    pub fn set_network_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_attachment = v.into();
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.NetworkConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network_attachment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "networkAttachment" => Ok(__FieldTag::__network_attachment),
                            "network_attachment" => Ok(__FieldTag::__network_attachment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network_attachment => {
                            if !fields.insert(__FieldTag::__network_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_attachment",
                                ));
                            }
                            result.network_attachment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_attachment.is_empty() {
            state.serialize_entry("networkAttachment", &self.network_attachment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A representation of the Pipeline resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Pipeline {
    /// Identifier. The resource name of the Pipeline. Must be unique within the
    /// location of the project and must be in
    /// `projects/{project}/locations/{location}/pipelines/{pipeline}` format.
    pub name: std::string::String,

    /// Output only. The creation time.
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up
    /// to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and
    /// "2014-10-02T15:01:23.045123456Z".
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up
    /// to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and
    /// "2014-10-02T15:01:23.045123456Z".
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User labels attached to the Pipeline that can be used to group
    /// resources. An object containing a list of "key": value pairs. Example: {
    /// "name": "wrench", "mass": "1.3kg", "count": "3" }.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Server-assigned unique identifier for the Pipeline. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    pub uid: std::string::String,

    /// Optional. User-defined annotations. See
    /// <https://google.aip.dev/128#annotations>.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Display name of resource.
    pub display_name: std::string::String,

    /// Required. List of destinations to which messages will be forwarded.
    /// Currently, exactly one destination is supported per Pipeline.
    pub destinations: std::vec::Vec<crate::model::pipeline::Destination>,

    /// Optional. List of mediation operations to be performed on the message.
    /// Currently, only one Transformation operation is allowed in each Pipeline.
    pub mediations: std::vec::Vec<crate::model::pipeline::Mediation>,

    /// Optional. Resource name of a KMS crypto key (managed by the user) used to
    /// encrypt/decrypt the event data. If not set, an internal Google-owned key
    /// will be used to encrypt messages. It must match the pattern
    /// "projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}".
    pub crypto_key_name: std::string::String,

    /// Optional. The payload format expected for the messages received by the
    /// Pipeline. If input_payload_format is set then any messages not matching
    /// this format will be treated as persistent errors. If input_payload_format
    /// is not set, then the message data will be treated as an opaque binary and
    /// no output format can be set on the Pipeline through the
    /// Pipeline.Destination.output_payload_format field. Any Mediations on the
    /// Pipeline that involve access to the data field will fail as persistent
    /// errors.
    pub input_payload_format: std::option::Option<crate::model::pipeline::MessagePayloadFormat>,

    /// Optional. Config to control Platform Logging for Pipelines.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Optional. The retry policy to use in the pipeline.
    pub retry_policy: std::option::Option<crate::model::pipeline::RetryPolicy>,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and might be sent only on create requests to ensure that the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Pipeline {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Pipeline::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Pipeline::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Pipeline::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Pipeline::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Pipeline::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Pipeline::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [uid][crate::model::Pipeline::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Pipeline::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::Pipeline::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [destinations][crate::model::Pipeline::destinations].
    pub fn set_destinations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::pipeline::Destination>,
    {
        use std::iter::Iterator;
        self.destinations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mediations][crate::model::Pipeline::mediations].
    pub fn set_mediations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::pipeline::Mediation>,
    {
        use std::iter::Iterator;
        self.mediations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::Pipeline::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }

    /// Sets the value of [input_payload_format][crate::model::Pipeline::input_payload_format].
    pub fn set_input_payload_format<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::pipeline::MessagePayloadFormat>,
    {
        self.input_payload_format = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_payload_format][crate::model::Pipeline::input_payload_format].
    pub fn set_or_clear_input_payload_format<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::pipeline::MessagePayloadFormat>,
    {
        self.input_payload_format = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_config][crate::model::Pipeline::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::Pipeline::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retry_policy][crate::model::Pipeline::retry_policy].
    pub fn set_retry_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::pipeline::RetryPolicy>,
    {
        self.retry_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retry_policy][crate::model::Pipeline::retry_policy].
    pub fn set_or_clear_retry_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::pipeline::RetryPolicy>,
    {
        self.retry_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Pipeline::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Pipeline {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Pipeline"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Pipeline {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __uid,
            __annotations,
            __display_name,
            __destinations,
            __mediations,
            __crypto_key_name,
            __input_payload_format,
            __logging_config,
            __retry_policy,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Pipeline")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "uid" => Ok(__FieldTag::__uid),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "destinations" => Ok(__FieldTag::__destinations),
                            "mediations" => Ok(__FieldTag::__mediations),
                            "cryptoKeyName" => Ok(__FieldTag::__crypto_key_name),
                            "crypto_key_name" => Ok(__FieldTag::__crypto_key_name),
                            "inputPayloadFormat" => Ok(__FieldTag::__input_payload_format),
                            "input_payload_format" => Ok(__FieldTag::__input_payload_format),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "retryPolicy" => Ok(__FieldTag::__retry_policy),
                            "retry_policy" => Ok(__FieldTag::__retry_policy),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Pipeline;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Pipeline")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destinations => {
                            if !fields.insert(__FieldTag::__destinations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destinations",
                                ));
                            }
                            result.destinations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::pipeline::Destination>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mediations => {
                            if !fields.insert(__FieldTag::__mediations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mediations",
                                ));
                            }
                            result.mediations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::pipeline::Mediation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crypto_key_name => {
                            if !fields.insert(__FieldTag::__crypto_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_name",
                                ));
                            }
                            result.crypto_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_payload_format => {
                            if !fields.insert(__FieldTag::__input_payload_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_payload_format",
                                ));
                            }
                            result.input_payload_format =
                                map.next_value::<std::option::Option<
                                    crate::model::pipeline::MessagePayloadFormat,
                                >>()?;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::__retry_policy => {
                            if !fields.insert(__FieldTag::__retry_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retry_policy",
                                ));
                            }
                            result.retry_policy = map.next_value::<std::option::Option<crate::model::pipeline::RetryPolicy>>()?
                                ;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Pipeline {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.destinations.is_empty() {
            state.serialize_entry("destinations", &self.destinations)?;
        }
        if !self.mediations.is_empty() {
            state.serialize_entry("mediations", &self.mediations)?;
        }
        if !self.crypto_key_name.is_empty() {
            state.serialize_entry("cryptoKeyName", &self.crypto_key_name)?;
        }
        if self.input_payload_format.is_some() {
            state.serialize_entry("inputPayloadFormat", &self.input_payload_format)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if self.retry_policy.is_some() {
            state.serialize_entry("retryPolicy", &self.retry_policy)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Pipeline].
pub mod pipeline {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the format of message data.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MessagePayloadFormat {
        /// The kind of message format.
        /// One of Protobuf, Avro, and JSON supported.
        /// This allows specification of what specific format
        /// messages are sent and received.
        pub kind: std::option::Option<crate::model::pipeline::message_payload_format::Kind>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MessagePayloadFormat {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::pipeline::MessagePayloadFormat::kind].
        ///
        /// Note that all the setters affecting `kind` are mutually
        /// exclusive.
        pub fn set_kind<
            T: std::convert::Into<
                    std::option::Option<crate::model::pipeline::message_payload_format::Kind>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::pipeline::MessagePayloadFormat::kind]
        /// if it holds a `Protobuf`, `None` if the field is not set or
        /// holds a different branch.
        pub fn protobuf(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::pipeline::message_payload_format::ProtobufFormat>,
        > {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::pipeline::message_payload_format::Kind::Protobuf(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::pipeline::MessagePayloadFormat::kind]
        /// to hold a `Protobuf`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_protobuf<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::pipeline::message_payload_format::ProtobufFormat>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::pipeline::message_payload_format::Kind::Protobuf(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::pipeline::MessagePayloadFormat::kind]
        /// if it holds a `Avro`, `None` if the field is not set or
        /// holds a different branch.
        pub fn avro(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::pipeline::message_payload_format::AvroFormat>,
        > {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::pipeline::message_payload_format::Kind::Avro(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::pipeline::MessagePayloadFormat::kind]
        /// to hold a `Avro`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_avro<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::pipeline::message_payload_format::AvroFormat>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::pipeline::message_payload_format::Kind::Avro(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::pipeline::MessagePayloadFormat::kind]
        /// if it holds a `Json`, `None` if the field is not set or
        /// holds a different branch.
        pub fn json(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::pipeline::message_payload_format::JsonFormat>,
        > {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::pipeline::message_payload_format::Kind::Json(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::pipeline::MessagePayloadFormat::kind]
        /// to hold a `Json`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_json<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::pipeline::message_payload_format::JsonFormat>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::pipeline::message_payload_format::Kind::Json(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for MessagePayloadFormat {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.MessagePayloadFormat"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MessagePayloadFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __protobuf,
                __avro,
                __json,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MessagePayloadFormat")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "protobuf" => Ok(__FieldTag::__protobuf),
                                "avro" => Ok(__FieldTag::__avro),
                                "json" => Ok(__FieldTag::__json),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MessagePayloadFormat;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MessagePayloadFormat")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__protobuf => {
                                if !fields.insert(__FieldTag::__protobuf) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for protobuf",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.eventarc.v1.Pipeline.MessagePayloadFormat.protobuf, latest field was protobuf",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::pipeline::message_payload_format::Kind::Protobuf(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::pipeline::message_payload_format::ProtobufFormat>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__avro => {
                                if !fields.insert(__FieldTag::__avro) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for avro",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.eventarc.v1.Pipeline.MessagePayloadFormat.avro, latest field was avro",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::pipeline::message_payload_format::Kind::Avro(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::pipeline::message_payload_format::AvroFormat>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__json => {
                                if !fields.insert(__FieldTag::__json) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for json",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.eventarc.v1.Pipeline.MessagePayloadFormat.json, latest field was json",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::pipeline::message_payload_format::Kind::Json(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::pipeline::message_payload_format::JsonFormat>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MessagePayloadFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.protobuf() {
                state.serialize_entry("protobuf", value)?;
            }
            if let Some(value) = self.avro() {
                state.serialize_entry("avro", value)?;
            }
            if let Some(value) = self.json() {
                state.serialize_entry("json", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [MessagePayloadFormat].
    pub mod message_payload_format {
        #[allow(unused_imports)]
        use super::*;

        /// The format of a JSON message payload.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct JsonFormat {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JsonFormat {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for JsonFormat {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.MessagePayloadFormat.JsonFormat"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for JsonFormat {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for JsonFormat")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = JsonFormat;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct JsonFormat")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for JsonFormat {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The format of a Protobuf message payload.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ProtobufFormat {
            /// Optional. The entire schema definition is stored in this field.
            pub schema_definition: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ProtobufFormat {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [schema_definition][crate::model::pipeline::message_payload_format::ProtobufFormat::schema_definition].
            pub fn set_schema_definition<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.schema_definition = v.into();
                self
            }
        }

        impl wkt::message::Message for ProtobufFormat {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.MessagePayloadFormat.ProtobufFormat"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ProtobufFormat {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __schema_definition,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ProtobufFormat")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "schemaDefinition" => Ok(__FieldTag::__schema_definition),
                                    "schema_definition" => Ok(__FieldTag::__schema_definition),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ProtobufFormat;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ProtobufFormat")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__schema_definition => {
                                    if !fields.insert(__FieldTag::__schema_definition) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for schema_definition",
                                            ),
                                        );
                                    }
                                    result.schema_definition = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ProtobufFormat {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.schema_definition.is_empty() {
                    state.serialize_entry("schemaDefinition", &self.schema_definition)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The format of an AVRO message payload.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AvroFormat {
            /// Optional. The entire schema definition is stored in this field.
            pub schema_definition: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AvroFormat {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [schema_definition][crate::model::pipeline::message_payload_format::AvroFormat::schema_definition].
            pub fn set_schema_definition<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.schema_definition = v.into();
                self
            }
        }

        impl wkt::message::Message for AvroFormat {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.MessagePayloadFormat.AvroFormat"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for AvroFormat {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __schema_definition,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for AvroFormat")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "schemaDefinition" => Ok(__FieldTag::__schema_definition),
                                    "schema_definition" => Ok(__FieldTag::__schema_definition),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = AvroFormat;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct AvroFormat")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__schema_definition => {
                                    if !fields.insert(__FieldTag::__schema_definition) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for schema_definition",
                                            ),
                                        );
                                    }
                                    result.schema_definition = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for AvroFormat {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.schema_definition.is_empty() {
                    state.serialize_entry("schemaDefinition", &self.schema_definition)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The kind of message format.
        /// One of Protobuf, Avro, and JSON supported.
        /// This allows specification of what specific format
        /// messages are sent and received.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Kind {
            /// Optional. Protobuf format.
            Protobuf(
                std::boxed::Box<crate::model::pipeline::message_payload_format::ProtobufFormat>,
            ),
            /// Optional. Avro format.
            Avro(std::boxed::Box<crate::model::pipeline::message_payload_format::AvroFormat>),
            /// Optional. JSON format.
            Json(std::boxed::Box<crate::model::pipeline::message_payload_format::JsonFormat>),
        }
    }

    /// Represents a target of an invocation over HTTP.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Destination {
        /// Optional. Network config is used to configure how Pipeline resolves and
        /// connects to a destination.
        pub network_config: std::option::Option<crate::model::pipeline::destination::NetworkConfig>,

        /// Optional. An authentication config used to authenticate message requests,
        /// such that destinations can verify the source. For example, this can be
        /// used with private GCP destinations that require GCP credentials to access
        /// like Cloud Run. This field is optional and should be set only by users
        /// interested in authenticated push
        pub authentication_config:
            std::option::Option<crate::model::pipeline::destination::AuthenticationConfig>,

        /// Optional. The message format before it is delivered to the destination.
        /// If not set, the message will be delivered in the format it was originally
        /// delivered to the Pipeline. This field can only be set if
        /// Pipeline.input_payload_format is also set.
        pub output_payload_format:
            std::option::Option<crate::model::pipeline::MessagePayloadFormat>,

        /// The destination identifier to which the request should be routed to.
        pub destination_descriptor:
            std::option::Option<crate::model::pipeline::destination::DestinationDescriptor>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Destination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_config][crate::model::pipeline::Destination::network_config].
        pub fn set_network_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::pipeline::destination::NetworkConfig>,
        {
            self.network_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [network_config][crate::model::pipeline::Destination::network_config].
        pub fn set_or_clear_network_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::pipeline::destination::NetworkConfig>,
        {
            self.network_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [authentication_config][crate::model::pipeline::Destination::authentication_config].
        pub fn set_authentication_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::pipeline::destination::AuthenticationConfig>,
        {
            self.authentication_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [authentication_config][crate::model::pipeline::Destination::authentication_config].
        pub fn set_or_clear_authentication_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::pipeline::destination::AuthenticationConfig>,
        {
            self.authentication_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [output_payload_format][crate::model::pipeline::Destination::output_payload_format].
        pub fn set_output_payload_format<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::pipeline::MessagePayloadFormat>,
        {
            self.output_payload_format = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [output_payload_format][crate::model::pipeline::Destination::output_payload_format].
        pub fn set_or_clear_output_payload_format<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::pipeline::MessagePayloadFormat>,
        {
            self.output_payload_format = v.map(|x| x.into());
            self
        }

        /// Sets the value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor].
        ///
        /// Note that all the setters affecting `destination_descriptor` are mutually
        /// exclusive.
        pub fn set_destination_descriptor<
            T: std::convert::Into<
                    std::option::Option<crate::model::pipeline::destination::DestinationDescriptor>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.destination_descriptor = v.into();
            self
        }

        /// The value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// if it holds a `HttpEndpoint`, `None` if the field is not set or
        /// holds a different branch.
        pub fn http_endpoint(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::pipeline::destination::HttpEndpoint>>
        {
            #[allow(unreachable_patterns)]
            self.destination_descriptor.as_ref().and_then(|v| match v {
                crate::model::pipeline::destination::DestinationDescriptor::HttpEndpoint(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// to hold a `HttpEndpoint`.
        ///
        /// Note that all the setters affecting `destination_descriptor` are
        /// mutually exclusive.
        pub fn set_http_endpoint<
            T: std::convert::Into<std::boxed::Box<crate::model::pipeline::destination::HttpEndpoint>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.destination_descriptor = std::option::Option::Some(
                crate::model::pipeline::destination::DestinationDescriptor::HttpEndpoint(v.into()),
            );
            self
        }

        /// The value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// if it holds a `Workflow`, `None` if the field is not set or
        /// holds a different branch.
        pub fn workflow(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.destination_descriptor.as_ref().and_then(|v| match v {
                crate::model::pipeline::destination::DestinationDescriptor::Workflow(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// to hold a `Workflow`.
        ///
        /// Note that all the setters affecting `destination_descriptor` are
        /// mutually exclusive.
        pub fn set_workflow<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.destination_descriptor = std::option::Option::Some(
                crate::model::pipeline::destination::DestinationDescriptor::Workflow(v.into()),
            );
            self
        }

        /// The value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// if it holds a `MessageBus`, `None` if the field is not set or
        /// holds a different branch.
        pub fn message_bus(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.destination_descriptor.as_ref().and_then(|v| match v {
                crate::model::pipeline::destination::DestinationDescriptor::MessageBus(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// to hold a `MessageBus`.
        ///
        /// Note that all the setters affecting `destination_descriptor` are
        /// mutually exclusive.
        pub fn set_message_bus<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.destination_descriptor = std::option::Option::Some(
                crate::model::pipeline::destination::DestinationDescriptor::MessageBus(v.into()),
            );
            self
        }

        /// The value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// if it holds a `Topic`, `None` if the field is not set or
        /// holds a different branch.
        pub fn topic(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.destination_descriptor.as_ref().and_then(|v| match v {
                crate::model::pipeline::destination::DestinationDescriptor::Topic(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [destination_descriptor][crate::model::pipeline::Destination::destination_descriptor]
        /// to hold a `Topic`.
        ///
        /// Note that all the setters affecting `destination_descriptor` are
        /// mutually exclusive.
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.destination_descriptor = std::option::Option::Some(
                crate::model::pipeline::destination::DestinationDescriptor::Topic(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Destination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Destination"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Destination {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __network_config,
                __http_endpoint,
                __workflow,
                __message_bus,
                __topic,
                __authentication_config,
                __output_payload_format,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Destination")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "networkConfig" => Ok(__FieldTag::__network_config),
                                "network_config" => Ok(__FieldTag::__network_config),
                                "httpEndpoint" => Ok(__FieldTag::__http_endpoint),
                                "http_endpoint" => Ok(__FieldTag::__http_endpoint),
                                "workflow" => Ok(__FieldTag::__workflow),
                                "messageBus" => Ok(__FieldTag::__message_bus),
                                "message_bus" => Ok(__FieldTag::__message_bus),
                                "topic" => Ok(__FieldTag::__topic),
                                "authenticationConfig" => Ok(__FieldTag::__authentication_config),
                                "authentication_config" => Ok(__FieldTag::__authentication_config),
                                "outputPayloadFormat" => Ok(__FieldTag::__output_payload_format),
                                "output_payload_format" => Ok(__FieldTag::__output_payload_format),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Destination;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Destination")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__network_config => {
                                if !fields.insert(__FieldTag::__network_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for network_config",
                                    ));
                                }
                                result.network_config = map.next_value::<std::option::Option<
                                    crate::model::pipeline::destination::NetworkConfig,
                                >>()?;
                            }
                            __FieldTag::__http_endpoint => {
                                if !fields.insert(__FieldTag::__http_endpoint) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for http_endpoint",
                                    ));
                                }
                                if result.destination_descriptor.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `destination_descriptor`, a oneof with full ID .google.cloud.eventarc.v1.Pipeline.Destination.http_endpoint, latest field was httpEndpoint",
                                    ));
                                }
                                result.destination_descriptor = std::option::Option::Some(
                                    crate::model::pipeline::destination::DestinationDescriptor::HttpEndpoint(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::pipeline::destination::HttpEndpoint>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__workflow => {
                                if !fields.insert(__FieldTag::__workflow) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for workflow",
                                    ));
                                }
                                if result.destination_descriptor.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `destination_descriptor`, a oneof with full ID .google.cloud.eventarc.v1.Pipeline.Destination.workflow, latest field was workflow",
                                    ));
                                }
                                result.destination_descriptor = std::option::Option::Some(
                                    crate::model::pipeline::destination::DestinationDescriptor::Workflow(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__message_bus => {
                                if !fields.insert(__FieldTag::__message_bus) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for message_bus",
                                    ));
                                }
                                if result.destination_descriptor.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `destination_descriptor`, a oneof with full ID .google.cloud.eventarc.v1.Pipeline.Destination.message_bus, latest field was messageBus",
                                    ));
                                }
                                result.destination_descriptor = std::option::Option::Some(
                                    crate::model::pipeline::destination::DestinationDescriptor::MessageBus(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__topic => {
                                if !fields.insert(__FieldTag::__topic) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for topic",
                                    ));
                                }
                                if result.destination_descriptor.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `destination_descriptor`, a oneof with full ID .google.cloud.eventarc.v1.Pipeline.Destination.topic, latest field was topic",
                                    ));
                                }
                                result.destination_descriptor = std::option::Option::Some(
                                    crate::model::pipeline::destination::DestinationDescriptor::Topic(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__authentication_config => {
                                if !fields.insert(__FieldTag::__authentication_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for authentication_config",
                                    ));
                                }
                                result.authentication_config = map
                                    .next_value::<std::option::Option<
                                        crate::model::pipeline::destination::AuthenticationConfig,
                                    >>()?;
                            }
                            __FieldTag::__output_payload_format => {
                                if !fields.insert(__FieldTag::__output_payload_format) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for output_payload_format",
                                    ));
                                }
                                result.output_payload_format = map
                                    .next_value::<std::option::Option<
                                        crate::model::pipeline::MessagePayloadFormat,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Destination {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.network_config.is_some() {
                state.serialize_entry("networkConfig", &self.network_config)?;
            }
            if let Some(value) = self.http_endpoint() {
                state.serialize_entry("httpEndpoint", value)?;
            }
            if let Some(value) = self.workflow() {
                state.serialize_entry("workflow", value)?;
            }
            if let Some(value) = self.message_bus() {
                state.serialize_entry("messageBus", value)?;
            }
            if let Some(value) = self.topic() {
                state.serialize_entry("topic", value)?;
            }
            if self.authentication_config.is_some() {
                state.serialize_entry("authenticationConfig", &self.authentication_config)?;
            }
            if self.output_payload_format.is_some() {
                state.serialize_entry("outputPayloadFormat", &self.output_payload_format)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Destination].
    pub mod destination {
        #[allow(unused_imports)]
        use super::*;

        /// Represents a network config to be used for destination resolution and
        /// connectivity.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct NetworkConfig {
            /// Required. Name of the NetworkAttachment that allows access to the
            /// consumer VPC. Format:
            /// `projects/{PROJECT_ID}/regions/{REGION}/networkAttachments/{NETWORK_ATTACHMENT_NAME}`
            pub network_attachment: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl NetworkConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [network_attachment][crate::model::pipeline::destination::NetworkConfig::network_attachment].
            pub fn set_network_attachment<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.network_attachment = v.into();
                self
            }
        }

        impl wkt::message::Message for NetworkConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Destination.NetworkConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for NetworkConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __network_attachment,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for NetworkConfig")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "networkAttachment" => Ok(__FieldTag::__network_attachment),
                                    "network_attachment" => Ok(__FieldTag::__network_attachment),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = NetworkConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct NetworkConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__network_attachment => {
                                    if !fields.insert(__FieldTag::__network_attachment) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for network_attachment",
                                            ),
                                        );
                                    }
                                    result.network_attachment = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for NetworkConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.network_attachment.is_empty() {
                    state.serialize_entry("networkAttachment", &self.network_attachment)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Represents a HTTP endpoint destination.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct HttpEndpoint {
            /// Required. The URI of the HTTP enpdoint.
            ///
            /// The value must be a RFC2396 URI string.
            /// Examples: `<https://svc.us-central1.p.local>:8080/route`.
            /// Only the HTTPS protocol is supported.
            pub uri: std::string::String,

            /// Optional. The CEL expression used to modify how the destination-bound
            /// HTTP request is constructed.
            ///
            /// If a binding expression is not specified here, the message
            /// is treated as a CloudEvent and is mapped to the HTTP request according
            /// to the CloudEvent HTTP Protocol Binding Binary Content Mode. In this
            /// representation, all fields except the `data` and `datacontenttype`
            /// field on the message are mapped to HTTP request headers with a prefix
            /// of `ce-`.
            ///
            /// To construct the HTTP request payload and the value of the content-type
            /// HTTP header, the payload format is defined as follows:
            ///
            /// 1. Use the output_payload_format_type on the Pipeline.Destination if it
            ///    is set, else:
            /// 1. Use the input_payload_format_type on the Pipeline if it is set,
            ///    else:
            /// 1. Treat the payload as opaque binary data.
            ///
            /// The `data` field of the message is converted to the payload format or
            /// left as-is for case 3) and then attached as the payload of the HTTP
            /// request. The `content-type` header on the HTTP request is set to the
            /// payload format type or left empty for case 3). However, if a mediation
            /// has updated the `datacontenttype` field on the message so that it is
            /// not the same as the payload format type but it is still a prefix of the
            /// payload format type, then the `content-type` header on the HTTP request
            /// is set to this `datacontenttype` value. For example, if the
            /// `datacontenttype` is "application/json" and the payload format type is
            /// "application/json; charset=utf-8", then the `content-type` header on
            /// the HTTP request is set to "application/json; charset=utf-8".
            ///
            /// If a non-empty binding expression is specified then this expression is
            /// used to modify the default CloudEvent HTTP Protocol Binding Binary
            /// Content representation.
            /// The result of the CEL expression must be a map of key/value pairs
            /// which is used as follows:
            ///
            /// - If a map named `headers` exists on the result of the expression,
            ///   then its key/value pairs are directly mapped to the HTTP request
            ///   headers. The headers values are constructed from the corresponding
            ///   value type’s canonical representation. If the `headers` field doesn’t
            ///   exist then the resulting HTTP request will be the headers of the
            ///   CloudEvent HTTP Binding Binary Content Mode representation of the final
            ///   message. Note: If the specified binding expression, has updated the
            ///   `datacontenttype` field on the message so that it is not the same as
            ///   the payload format type but it is still a prefix of the payload format
            ///   type, then the `content-type` header in the `headers` map is set to
            ///   this `datacontenttype` value.
            /// - If a field named `body` exists on the result of the expression then
            ///   its value is directly mapped to the body of the request. If the value
            ///   of the `body` field is of type bytes or string then it is used for
            ///   the HTTP request body as-is, with no conversion. If the body field is
            ///   of any other type then it is converted to a JSON string. If the body
            ///   field does not exist then the resulting payload of the HTTP request
            ///   will be data value of the CloudEvent HTTP Binding Binary Content Mode
            ///   representation of the final message as described earlier.
            /// - Any other fields in the resulting expression will be ignored.
            ///
            /// The CEL expression may access the incoming CloudEvent message in its
            /// definition, as follows:
            ///
            /// - The `data` field of the incoming CloudEvent message can be accessed
            ///   using the `message.data` value. Subfields of `message.data` may also be
            ///   accessed if an input_payload_format has been specified on the Pipeline.
            /// - Each attribute of the incoming CloudEvent message can be accessed
            ///   using the `message.\<key\>` value, where \<key\> is replaced with the
            ///   name of the attribute.
            /// - Existing headers can be accessed in the CEL expression using the
            ///   `headers` variable. The `headers` variable defines a map of key/value
            ///   pairs corresponding to the HTTP headers of the CloudEvent HTTP Binding
            ///   Binary Content Mode representation of the final message as described
            ///   earlier. For example, the following CEL expression can be used to
            ///   construct an HTTP request by adding an additional header to the HTTP
            ///   headers of the CloudEvent HTTP Binding Binary Content Mode
            ///   representation of the final message and by overwriting the body of the
            ///   request:
            ///
            /// ```norust
            /// {
            ///   "headers": headers.merge({"new-header-key": "new-header-value"}),
            ///   "body": "new-body"
            /// }
            /// ```
            ///
            /// Additionally, the following CEL extension functions are provided for
            /// use in this CEL expression:
            ///
            /// - toBase64Url:
            ///   map.toBase64Url() -> string
            ///   - Converts a CelValue to a base64url encoded string
            /// - toJsonString: map.toJsonString() -> string
            ///   - Converts a CelValue to a JSON string
            /// - merge:
            ///   map1.merge(map2) -> map3
            ///   - Merges the passed CEL map with the existing CEL map the
            ///     function is applied to.
            ///   - If the same key exists in both maps, if the key's value is type
            ///     map both maps are merged else the value from the passed map is
            ///     used.
            /// - denormalize:
            ///   map.denormalize() -> map
            ///   - Denormalizes a CEL map such that every value of type map or key
            ///     in the map is expanded to return a single level map.
            ///   - The resulting keys are "." separated indices of the map keys.
            ///   - For example:
            ///     {
            ///     "a": 1,
            ///     "b": {
            ///     "c": 2,
            ///     "d": 3
            ///     }
            ///     "e": [4, 5]
            ///     }
            ///     .denormalize()
            ///     -> {
            ///     "a": 1,
            ///     "b.c": 2,
            ///     "b.d": 3,
            ///     "e.0": 4,
            ///     "e.1": 5
            ///     }
            /// - setField:
            ///   map.setField(key, value) -> message
            ///   - Sets the field of the message with the given key to the
            ///     given value.
            ///   - If the field is not present it will be added.
            ///   - If the field is present it will be overwritten.
            ///   - The key can be a dot separated path to set a field in a nested
            ///     message.
            ///   - Key must be of type string.
            ///   - Value may be any valid type.
            /// - removeFields:
            ///   map.removeFields([key1, key2, ...]) -> message
            ///   - Removes the fields of the map with the given keys.
            ///   - The keys can be a dot separated path to remove a field in a
            ///     nested message.
            ///   - If a key is not found it will be ignored.
            ///   - Keys must be of type string.
            /// - toMap:
            ///   [map1, map2, ...].toMap() -> map
            ///   - Converts a CEL list of CEL maps to a single CEL map
            /// - toDestinationPayloadFormat():
            ///   message.data.toDestinationPayloadFormat() -> string or bytes
            ///   - Converts the message data to the destination payload format
            ///     specified in Pipeline.Destination.output_payload_format
            ///   - This function is meant to be applied to the message.data field.
            ///   - If the destination payload format is not set, the function will
            ///     return the message data unchanged.
            /// - toCloudEventJsonWithPayloadFormat:
            ///   message.toCloudEventJsonWithPayloadFormat() -> map
            ///   - Converts a message to the corresponding structure of JSON
            ///     format for CloudEvents
            ///   - This function applies toDestinationPayloadFormat() to the
            ///     message data. It also sets the corresponding datacontenttype of
            ///     the CloudEvent, as indicated by
            ///     Pipeline.Destination.output_payload_format. If no
            ///     output_payload_format is set it will use the existing
            ///     datacontenttype on the CloudEvent if present, else leave
            ///     datacontenttype absent.
            ///   - This function expects that the content of the message will
            ///     adhere to the standard CloudEvent format. If it doesn’t then this
            ///     function will fail.
            ///   - The result is a CEL map that corresponds to the JSON
            ///     representation of the CloudEvent. To convert that data to a JSON
            ///     string it can be chained with the toJsonString function.
            ///
            /// The Pipeline expects that the message it receives adheres to the
            /// standard CloudEvent format. If it doesn’t then the outgoing message
            /// request may fail with a persistent error.
            pub message_binding_template: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl HttpEndpoint {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [uri][crate::model::pipeline::destination::HttpEndpoint::uri].
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }

            /// Sets the value of [message_binding_template][crate::model::pipeline::destination::HttpEndpoint::message_binding_template].
            pub fn set_message_binding_template<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.message_binding_template = v.into();
                self
            }
        }

        impl wkt::message::Message for HttpEndpoint {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Destination.HttpEndpoint"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for HttpEndpoint {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __uri,
                    __message_binding_template,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for HttpEndpoint")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "uri" => Ok(__FieldTag::__uri),
                                    "messageBindingTemplate" => {
                                        Ok(__FieldTag::__message_binding_template)
                                    }
                                    "message_binding_template" => {
                                        Ok(__FieldTag::__message_binding_template)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = HttpEndpoint;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct HttpEndpoint")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__uri => {
                                    if !fields.insert(__FieldTag::__uri) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for uri"),
                                        );
                                    }
                                    result.uri = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__message_binding_template => {
                                    if !fields.insert(__FieldTag::__message_binding_template) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for message_binding_template",
                                            ),
                                        );
                                    }
                                    result.message_binding_template = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for HttpEndpoint {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.uri.is_empty() {
                    state.serialize_entry("uri", &self.uri)?;
                }
                if !self.message_binding_template.is_empty() {
                    state.serialize_entry(
                        "messageBindingTemplate",
                        &self.message_binding_template,
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Represents a config used to authenticate message requests.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AuthenticationConfig {

            /// The type of authentication method.
            pub authentication_method_descriptor: std::option::Option<crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AuthenticationConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [authentication_method_descriptor][crate::model::pipeline::destination::AuthenticationConfig::authentication_method_descriptor].
            ///
            /// Note that all the setters affecting `authentication_method_descriptor` are mutually
            /// exclusive.
            pub fn set_authentication_method_descriptor<T: std::convert::Into<std::option::Option<crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor>>>(mut self, v: T) -> Self
            {
                self.authentication_method_descriptor = v.into();
                self
            }

            /// The value of [authentication_method_descriptor][crate::model::pipeline::destination::AuthenticationConfig::authentication_method_descriptor]
            /// if it holds a `GoogleOidc`, `None` if the field is not set or
            /// holds a different branch.
            pub fn google_oidc(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::pipeline::destination::authentication_config::OidcToken,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.authentication_method_descriptor.as_ref().and_then(|v| match v {
                    crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor::GoogleOidc(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [authentication_method_descriptor][crate::model::pipeline::destination::AuthenticationConfig::authentication_method_descriptor]
            /// to hold a `GoogleOidc`.
            ///
            /// Note that all the setters affecting `authentication_method_descriptor` are
            /// mutually exclusive.
            pub fn set_google_oidc<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::pipeline::destination::authentication_config::OidcToken,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.authentication_method_descriptor = std::option::Option::Some(
                    crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor::GoogleOidc(
                        v.into()
                    )
                );
                self
            }

            /// The value of [authentication_method_descriptor][crate::model::pipeline::destination::AuthenticationConfig::authentication_method_descriptor]
            /// if it holds a `OauthToken`, `None` if the field is not set or
            /// holds a different branch.
            pub fn oauth_token(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::pipeline::destination::authentication_config::OAuthToken,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.authentication_method_descriptor.as_ref().and_then(|v| match v {
                    crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor::OauthToken(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [authentication_method_descriptor][crate::model::pipeline::destination::AuthenticationConfig::authentication_method_descriptor]
            /// to hold a `OauthToken`.
            ///
            /// Note that all the setters affecting `authentication_method_descriptor` are
            /// mutually exclusive.
            pub fn set_oauth_token<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::pipeline::destination::authentication_config::OAuthToken,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.authentication_method_descriptor = std::option::Option::Some(
                    crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor::OauthToken(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for AuthenticationConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Destination.AuthenticationConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for AuthenticationConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __google_oidc,
                    __oauth_token,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for AuthenticationConfig")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "googleOidc" => Ok(__FieldTag::__google_oidc),
                                    "google_oidc" => Ok(__FieldTag::__google_oidc),
                                    "oauthToken" => Ok(__FieldTag::__oauth_token),
                                    "oauth_token" => Ok(__FieldTag::__oauth_token),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = AuthenticationConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct AuthenticationConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__google_oidc => {
                                    if !fields.insert(__FieldTag::__google_oidc) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for google_oidc",
                                            ),
                                        );
                                    }
                                    if result.authentication_method_descriptor.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `authentication_method_descriptor`, a oneof with full ID .google.cloud.eventarc.v1.Pipeline.Destination.AuthenticationConfig.google_oidc, latest field was googleOidc",
                                            ),
                                        );
                                    }
                                    result.authentication_method_descriptor = std::option::Option::Some(
                                        crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor::GoogleOidc(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::pipeline::destination::authentication_config::OidcToken>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__oauth_token => {
                                    if !fields.insert(__FieldTag::__oauth_token) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for oauth_token",
                                            ),
                                        );
                                    }
                                    if result.authentication_method_descriptor.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `authentication_method_descriptor`, a oneof with full ID .google.cloud.eventarc.v1.Pipeline.Destination.AuthenticationConfig.oauth_token, latest field was oauthToken",
                                            ),
                                        );
                                    }
                                    result.authentication_method_descriptor = std::option::Option::Some(
                                        crate::model::pipeline::destination::authentication_config::AuthenticationMethodDescriptor::OauthToken(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::pipeline::destination::authentication_config::OAuthToken>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for AuthenticationConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.google_oidc() {
                    state.serialize_entry("googleOidc", value)?;
                }
                if let Some(value) = self.oauth_token() {
                    state.serialize_entry("oauthToken", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [AuthenticationConfig].
        pub mod authentication_config {
            #[allow(unused_imports)]
            use super::*;

            /// Represents a config used to authenticate with a Google OIDC token using
            /// a GCP service account. Use this authentication method to invoke your
            /// Cloud Run and Cloud Functions destinations or HTTP endpoints that
            /// support Google OIDC.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct OidcToken {
                /// Required. Service account email used to generate the OIDC Token.
                /// The principal who calls this API must have
                /// iam.serviceAccounts.actAs permission in the service account. See
                /// <https://cloud.google.com/iam/docs/understanding-service-accounts?hl=en#sa_common>
                /// for more information. Eventarc service agents must have
                /// roles/roles/iam.serviceAccountTokenCreator role to allow the
                /// Pipeline to create OpenID tokens for authenticated requests.
                pub service_account: std::string::String,

                /// Optional. Audience to be used to generate the OIDC Token. The
                /// audience claim identifies the recipient that the JWT is intended for.
                /// If unspecified, the destination URI will be used.
                pub audience: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl OidcToken {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [service_account][crate::model::pipeline::destination::authentication_config::OidcToken::service_account].
                pub fn set_service_account<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.service_account = v.into();
                    self
                }

                /// Sets the value of [audience][crate::model::pipeline::destination::authentication_config::OidcToken::audience].
                pub fn set_audience<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.audience = v.into();
                    self
                }
            }

            impl wkt::message::Message for OidcToken {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Destination.AuthenticationConfig.OidcToken"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for OidcToken {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __service_account,
                        __audience,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for OidcToken")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "serviceAccount" => Ok(__FieldTag::__service_account),
                                        "service_account" => Ok(__FieldTag::__service_account),
                                        "audience" => Ok(__FieldTag::__audience),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = OidcToken;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct OidcToken")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__service_account => {
                                        if !fields.insert(__FieldTag::__service_account) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for service_account",
                                                ),
                                            );
                                        }
                                        result.service_account = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__audience => {
                                        if !fields.insert(__FieldTag::__audience) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for audience",
                                                ),
                                            );
                                        }
                                        result.audience = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for OidcToken {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.service_account.is_empty() {
                        state.serialize_entry("serviceAccount", &self.service_account)?;
                    }
                    if !self.audience.is_empty() {
                        state.serialize_entry("audience", &self.audience)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Contains information needed for generating an
            /// [OAuth token](https://developers.google.com/identity/protocols/OAuth2).
            /// This type of authorization should generally only be used when calling
            /// Google APIs hosted on *.googleapis.com.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct OAuthToken {
                /// Required. Service account email used to generate the [OAuth
                /// token](https://developers.google.com/identity/protocols/OAuth2).
                /// The principal who calls this API must have
                /// iam.serviceAccounts.actAs permission in the service account. See
                /// <https://cloud.google.com/iam/docs/understanding-service-accounts?hl=en#sa_common>
                /// for more information. Eventarc service agents must have
                /// roles/roles/iam.serviceAccountTokenCreator role to allow Pipeline
                /// to create OAuth2 tokens for authenticated requests.
                pub service_account: std::string::String,

                /// Optional. OAuth scope to be used for generating OAuth access token.
                /// If not specified, `https://www.googleapis.com/auth/cloud-platform`
                /// will be used.
                pub scope: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl OAuthToken {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [service_account][crate::model::pipeline::destination::authentication_config::OAuthToken::service_account].
                pub fn set_service_account<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.service_account = v.into();
                    self
                }

                /// Sets the value of [scope][crate::model::pipeline::destination::authentication_config::OAuthToken::scope].
                pub fn set_scope<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.scope = v.into();
                    self
                }
            }

            impl wkt::message::Message for OAuthToken {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Destination.AuthenticationConfig.OAuthToken"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for OAuthToken {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __service_account,
                        __scope,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for OAuthToken")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "serviceAccount" => Ok(__FieldTag::__service_account),
                                        "service_account" => Ok(__FieldTag::__service_account),
                                        "scope" => Ok(__FieldTag::__scope),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = OAuthToken;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct OAuthToken")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__service_account => {
                                        if !fields.insert(__FieldTag::__service_account) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for service_account",
                                                ),
                                            );
                                        }
                                        result.service_account = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__scope => {
                                        if !fields.insert(__FieldTag::__scope) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for scope",
                                                ),
                                            );
                                        }
                                        result.scope = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for OAuthToken {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.service_account.is_empty() {
                        state.serialize_entry("serviceAccount", &self.service_account)?;
                    }
                    if !self.scope.is_empty() {
                        state.serialize_entry("scope", &self.scope)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// The type of authentication method.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum AuthenticationMethodDescriptor {
                /// Optional. This authenticate method will apply Google OIDC tokens
                /// signed by a GCP service account to the requests.
                GoogleOidc(
                    std::boxed::Box<
                        crate::model::pipeline::destination::authentication_config::OidcToken,
                    >,
                ),
                /// Optional. If specified, an [OAuth
                /// token](https://developers.google.com/identity/protocols/OAuth2) will
                /// be generated and attached as an `Authorization` header in the HTTP
                /// request.
                ///
                /// This type of authorization should generally only be used when calling
                /// Google APIs hosted on *.googleapis.com.
                OauthToken(
                    std::boxed::Box<
                        crate::model::pipeline::destination::authentication_config::OAuthToken,
                    >,
                ),
            }
        }

        /// The destination identifier to which the request should be routed to.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum DestinationDescriptor {
            /// Optional. An HTTP endpoint destination described by an URI.
            /// If a DNS FQDN is provided as the endpoint, Pipeline will create a
            /// peering zone to the consumer VPC and forward DNS requests to the VPC
            /// specified by network config to resolve the service endpoint. See:
            /// <https://cloud.google.com/dns/docs/zones/zones-overview#peering_zones>
            HttpEndpoint(std::boxed::Box<crate::model::pipeline::destination::HttpEndpoint>),
            /// Optional. The resource name of the Workflow whose Executions are
            /// triggered by the events. The Workflow resource should be deployed in
            /// the same project as the Pipeline. Format:
            /// `projects/{project}/locations/{location}/workflows/{workflow}`
            Workflow(std::string::String),
            /// Optional. The resource name of the Message Bus to which events should
            /// be published. The Message Bus resource should exist in the same project
            /// as the Pipeline. Format:
            /// `projects/{project}/locations/{location}/messageBuses/{message_bus}`
            MessageBus(std::string::String),
            /// Optional. The resource name of the Pub/Sub topic to which events should
            /// be published. Format:
            /// `projects/{project}/locations/{location}/topics/{topic}`
            Topic(std::string::String),
        }
    }

    /// Mediation defines different ways to modify the Pipeline.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Mediation {
        /// The config of mediation.
        pub mediation_descriptor:
            std::option::Option<crate::model::pipeline::mediation::MediationDescriptor>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Mediation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mediation_descriptor][crate::model::pipeline::Mediation::mediation_descriptor].
        ///
        /// Note that all the setters affecting `mediation_descriptor` are mutually
        /// exclusive.
        pub fn set_mediation_descriptor<
            T: std::convert::Into<
                    std::option::Option<crate::model::pipeline::mediation::MediationDescriptor>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mediation_descriptor = v.into();
            self
        }

        /// The value of [mediation_descriptor][crate::model::pipeline::Mediation::mediation_descriptor]
        /// if it holds a `Transformation`, `None` if the field is not set or
        /// holds a different branch.
        pub fn transformation(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::pipeline::mediation::Transformation>>
        {
            #[allow(unreachable_patterns)]
            self.mediation_descriptor.as_ref().and_then(|v| match v {
                crate::model::pipeline::mediation::MediationDescriptor::Transformation(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [mediation_descriptor][crate::model::pipeline::Mediation::mediation_descriptor]
        /// to hold a `Transformation`.
        ///
        /// Note that all the setters affecting `mediation_descriptor` are
        /// mutually exclusive.
        pub fn set_transformation<
            T: std::convert::Into<std::boxed::Box<crate::model::pipeline::mediation::Transformation>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mediation_descriptor = std::option::Option::Some(
                crate::model::pipeline::mediation::MediationDescriptor::Transformation(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Mediation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Mediation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Mediation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __transformation,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Mediation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "transformation" => Ok(__FieldTag::__transformation),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Mediation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Mediation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__transformation => {
                                if !fields.insert(__FieldTag::__transformation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for transformation",
                                    ));
                                }
                                if result.mediation_descriptor.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `mediation_descriptor`, a oneof with full ID .google.cloud.eventarc.v1.Pipeline.Mediation.transformation, latest field was transformation",
                                    ));
                                }
                                result.mediation_descriptor = std::option::Option::Some(
                                    crate::model::pipeline::mediation::MediationDescriptor::Transformation(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::pipeline::mediation::Transformation>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Mediation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.transformation() {
                state.serialize_entry("transformation", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Mediation].
    pub mod mediation {
        #[allow(unused_imports)]
        use super::*;

        /// Transformation defines the way to transform an incoming message.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Transformation {
            /// Optional. The CEL expression template to apply to transform messages.
            /// The following CEL extension functions are provided for
            /// use in this CEL expression:
            ///
            /// - merge:
            ///   map1.merge(map2) -> map3
            ///   - Merges the passed CEL map with the existing CEL map the
            ///     function is applied to.
            ///   - If the same key exists in both maps, if the key's value is type
            ///     map both maps are merged else the value from the passed map is
            ///     used.
            /// - denormalize:
            ///   map.denormalize() -> map
            ///   - Denormalizes a CEL map such that every value of type map or key
            ///     in the map is expanded to return a single level map.
            ///   - The resulting keys are "." separated indices of the map keys.
            ///   - For example:
            ///     {
            ///     "a": 1,
            ///     "b": {
            ///     "c": 2,
            ///     "d": 3
            ///     }
            ///     "e": [4, 5]
            ///     }
            ///     .denormalize()
            ///     -> {
            ///     "a": 1,
            ///     "b.c": 2,
            ///     "b.d": 3,
            ///     "e.0": 4,
            ///     "e.1": 5
            ///     }
            /// - setField:
            ///   map.setField(key, value) -> message
            ///   - Sets the field of the message with the given key to the
            ///     given value.
            ///   - If the field is not present it will be added.
            ///   - If the field is present it will be overwritten.
            ///   - The key can be a dot separated path to set a field in a nested
            ///     message.
            ///   - Key must be of type string.
            ///   - Value may be any valid type.
            /// - removeFields:
            ///   map.removeFields([key1, key2, ...]) -> message
            ///   - Removes the fields of the map with the given keys.
            ///   - The keys can be a dot separated path to remove a field in a
            ///     nested message.
            ///   - If a key is not found it will be ignored.
            ///   - Keys must be of type string.
            /// - toMap:
            ///   [map1, map2, ...].toMap() -> map
            ///   - Converts a CEL list of CEL maps to a single CEL map
            /// - toDestinationPayloadFormat():
            ///   message.data.toDestinationPayloadFormat() -> string or bytes
            ///   - Converts the message data to the destination payload format
            ///     specified in Pipeline.Destination.output_payload_format
            ///   - This function is meant to be applied to the message.data field.
            ///   - If the destination payload format is not set, the function will
            ///     return the message data unchanged.
            /// - toCloudEventJsonWithPayloadFormat:
            ///   message.toCloudEventJsonWithPayloadFormat() -> map
            ///   - Converts a message to the corresponding structure of JSON
            ///     format for CloudEvents
            ///   - This function applies toDestinationPayloadFormat() to the
            ///     message data. It also sets the corresponding datacontenttype of
            ///     the CloudEvent, as indicated by
            ///     Pipeline.Destination.output_payload_format. If no
            ///     output_payload_format is set it will use the existing
            ///     datacontenttype on the CloudEvent if present, else leave
            ///     datacontenttype absent.
            ///   - This function expects that the content of the message will
            ///     adhere to the standard CloudEvent format. If it doesn’t then this
            ///     function will fail.
            ///   - The result is a CEL map that corresponds to the JSON
            ///     representation of the CloudEvent. To convert that data to a JSON
            ///     string it can be chained with the toJsonString function.
            pub transformation_template: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Transformation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [transformation_template][crate::model::pipeline::mediation::Transformation::transformation_template].
            pub fn set_transformation_template<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.transformation_template = v.into();
                self
            }
        }

        impl wkt::message::Message for Transformation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.Mediation.Transformation"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Transformation {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __transformation_template,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Transformation")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "transformationTemplate" => {
                                        Ok(__FieldTag::__transformation_template)
                                    }
                                    "transformation_template" => {
                                        Ok(__FieldTag::__transformation_template)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Transformation;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Transformation")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__transformation_template => {
                                    if !fields.insert(__FieldTag::__transformation_template) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for transformation_template",
                                            ),
                                        );
                                    }
                                    result.transformation_template = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Transformation {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.transformation_template.is_empty() {
                    state
                        .serialize_entry("transformationTemplate", &self.transformation_template)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The config of mediation.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MediationDescriptor {
            /// Optional. How the Pipeline is to transform messages
            Transformation(std::boxed::Box<crate::model::pipeline::mediation::Transformation>),
        }
    }

    /// The retry policy configuration for the Pipeline. The pipeline
    /// exponentially backs off in case the destination is non responsive or
    /// returns a retryable error code. The default semantics are as follows:
    /// The backoff starts with a 5 second delay and doubles the
    /// delay after each failed attempt (10 seconds, 20 seconds, 40 seconds, etc.).
    /// The delay is capped at 60 seconds by default.
    /// Please note that if you set the min_retry_delay and max_retry_delay fields
    /// to the same value this will make the duration between retries constant.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RetryPolicy {
        /// Optional. The maximum number of delivery attempts for any message. The
        /// value must be between 1 and 100. The default value for this field is 5.
        pub max_attempts: i32,

        /// Optional. The minimum amount of seconds to wait between retry attempts.
        /// The value must be between 1 and 600. The default value for this field
        /// is 5.
        pub min_retry_delay: std::option::Option<wkt::Duration>,

        /// Optional. The maximum amount of seconds to wait between retry attempts.
        /// The value must be between 1 and 600. The default value for this field
        /// is 60.
        pub max_retry_delay: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RetryPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_attempts][crate::model::pipeline::RetryPolicy::max_attempts].
        pub fn set_max_attempts<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_attempts = v.into();
            self
        }

        /// Sets the value of [min_retry_delay][crate::model::pipeline::RetryPolicy::min_retry_delay].
        pub fn set_min_retry_delay<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_retry_delay = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_retry_delay][crate::model::pipeline::RetryPolicy::min_retry_delay].
        pub fn set_or_clear_min_retry_delay<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_retry_delay = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_retry_delay][crate::model::pipeline::RetryPolicy::max_retry_delay].
        pub fn set_max_retry_delay<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.max_retry_delay = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_retry_delay][crate::model::pipeline::RetryPolicy::max_retry_delay].
        pub fn set_or_clear_max_retry_delay<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.max_retry_delay = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for RetryPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.eventarc.v1.Pipeline.RetryPolicy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RetryPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __max_attempts,
                __min_retry_delay,
                __max_retry_delay,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RetryPolicy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "maxAttempts" => Ok(__FieldTag::__max_attempts),
                                "max_attempts" => Ok(__FieldTag::__max_attempts),
                                "minRetryDelay" => Ok(__FieldTag::__min_retry_delay),
                                "min_retry_delay" => Ok(__FieldTag::__min_retry_delay),
                                "maxRetryDelay" => Ok(__FieldTag::__max_retry_delay),
                                "max_retry_delay" => Ok(__FieldTag::__max_retry_delay),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RetryPolicy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RetryPolicy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__max_attempts => {
                                if !fields.insert(__FieldTag::__max_attempts) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_attempts",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_attempts =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__min_retry_delay => {
                                if !fields.insert(__FieldTag::__min_retry_delay) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_retry_delay",
                                    ));
                                }
                                result.min_retry_delay =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__max_retry_delay => {
                                if !fields.insert(__FieldTag::__max_retry_delay) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_retry_delay",
                                    ));
                                }
                                result.max_retry_delay =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RetryPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.max_attempts) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxAttempts", &__With(&self.max_attempts))?;
            }
            if self.min_retry_delay.is_some() {
                state.serialize_entry("minRetryDelay", &self.min_retry_delay)?;
            }
            if self.max_retry_delay.is_some() {
                state.serialize_entry("maxRetryDelay", &self.max_retry_delay)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// A representation of the trigger resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Trigger {
    /// Required. The resource name of the trigger. Must be unique within the
    /// location of the project and must be in
    /// `projects/{project}/locations/{location}/triggers/{trigger}` format.
    pub name: std::string::String,

    /// Output only. Server-assigned unique identifier for the trigger. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    pub uid: std::string::String,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. Unordered list. The list of filters that applies to event
    /// attributes. Only events that match all the provided filters are sent to the
    /// destination.
    pub event_filters: std::vec::Vec<crate::model::EventFilter>,

    /// Optional. The IAM service account email associated with the trigger. The
    /// service account represents the identity of the trigger.
    ///
    /// The `iam.serviceAccounts.actAs` permission must be granted on the service
    /// account to allow a principal to impersonate the service account. For more
    /// information, see the
    /// [Roles and permissions](/eventarc/docs/all-roles-permissions) page specific
    /// to the trigger destination.
    pub service_account: std::string::String,

    /// Required. Destination specifies where the events should be sent to.
    pub destination: std::option::Option<crate::model::Destination>,

    /// Optional. To deliver messages, Eventarc might use other Google Cloud
    /// products as a transport intermediary. This field contains a reference to
    /// that transport intermediary. This information can be used for debugging
    /// purposes.
    pub transport: std::option::Option<crate::model::Transport>,

    /// Optional. User labels attached to the triggers that can be used to group
    /// resources.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The name of the channel associated with the trigger in
    /// `projects/{project}/locations/{location}/channels/{channel}` format.
    /// You must provide a channel to receive events from Eventarc SaaS partners.
    pub channel: std::string::String,

    /// Output only. The reason(s) why a trigger is in FAILED state.
    pub conditions: std::collections::HashMap<std::string::String, crate::model::StateCondition>,

    /// Optional. EventDataContentType specifies the type of payload in MIME
    /// format that is expected from the CloudEvent data field. This is set to
    /// `application/json` if the value is not defined.
    pub event_data_content_type: std::string::String,

    /// Output only. Whether or not this Trigger satisfies the requirements of
    /// physical zone separation
    pub satisfies_pzs: bool,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and might be sent only on create requests to ensure that the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Trigger {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Trigger::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Trigger::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Trigger::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Trigger::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Trigger::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Trigger::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [event_filters][crate::model::Trigger::event_filters].
    pub fn set_event_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventFilter>,
    {
        use std::iter::Iterator;
        self.event_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::Trigger::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::Trigger::destination].
    pub fn set_destination<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Destination>,
    {
        self.destination = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destination][crate::model::Trigger::destination].
    pub fn set_or_clear_destination<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Destination>,
    {
        self.destination = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transport][crate::model::Trigger::transport].
    pub fn set_transport<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Transport>,
    {
        self.transport = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transport][crate::model::Trigger::transport].
    pub fn set_or_clear_transport<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Transport>,
    {
        self.transport = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Trigger::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [channel][crate::model::Trigger::channel].
    pub fn set_channel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.channel = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::Trigger::conditions].
    pub fn set_conditions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::StateCondition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [event_data_content_type][crate::model::Trigger::event_data_content_type].
    pub fn set_event_data_content_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_data_content_type = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Trigger::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Trigger::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Trigger {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Trigger"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Trigger {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __event_filters,
            __service_account,
            __destination,
            __transport,
            __labels,
            __channel,
            __conditions,
            __event_data_content_type,
            __satisfies_pzs,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Trigger")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "eventFilters" => Ok(__FieldTag::__event_filters),
                            "event_filters" => Ok(__FieldTag::__event_filters),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "destination" => Ok(__FieldTag::__destination),
                            "transport" => Ok(__FieldTag::__transport),
                            "labels" => Ok(__FieldTag::__labels),
                            "channel" => Ok(__FieldTag::__channel),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "eventDataContentType" => Ok(__FieldTag::__event_data_content_type),
                            "event_data_content_type" => Ok(__FieldTag::__event_data_content_type),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Trigger;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Trigger")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__event_filters => {
                            if !fields.insert(__FieldTag::__event_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_filters",
                                ));
                            }
                            result.event_filters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EventFilter>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination",
                                ));
                            }
                            result.destination =
                                map.next_value::<std::option::Option<crate::model::Destination>>()?;
                        }
                        __FieldTag::__transport => {
                            if !fields.insert(__FieldTag::__transport) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transport",
                                ));
                            }
                            result.transport =
                                map.next_value::<std::option::Option<crate::model::Transport>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::StateCondition,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_data_content_type => {
                            if !fields.insert(__FieldTag::__event_data_content_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_data_content_type",
                                ));
                            }
                            result.event_data_content_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Trigger {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.event_filters.is_empty() {
            state.serialize_entry("eventFilters", &self.event_filters)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if self.destination.is_some() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if self.transport.is_some() {
            state.serialize_entry("transport", &self.transport)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.channel.is_empty() {
            state.serialize_entry("channel", &self.channel)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if !self.event_data_content_type.is_empty() {
            state.serialize_entry("eventDataContentType", &self.event_data_content_type)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Filters events based on exact matches on the CloudEvents attributes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EventFilter {
    /// Required. The name of a CloudEvents attribute. Currently, only a subset of
    /// attributes are supported for filtering. You can [retrieve a specific
    /// provider's supported event
    /// types](/eventarc/docs/list-providers#describe-provider).
    ///
    /// All triggers MUST provide a filter for the 'type' attribute.
    pub attribute: std::string::String,

    /// Required. The value for the attribute.
    pub value: std::string::String,

    /// Optional. The operator used for matching the events with the value of the
    /// filter. If not specified, only events that have an exact key-value pair
    /// specified in the filter are matched. The allowed values are `path_pattern`
    /// and `match-path-pattern`. `path_pattern` is only allowed for GCFv1
    /// triggers.
    pub operator: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attribute][crate::model::EventFilter::attribute].
    pub fn set_attribute<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attribute = v.into();
        self
    }

    /// Sets the value of [value][crate::model::EventFilter::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [operator][crate::model::EventFilter::operator].
    pub fn set_operator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operator = v.into();
        self
    }
}

impl wkt::message::Message for EventFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.EventFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EventFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attribute,
            __value,
            __operator,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EventFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attribute" => Ok(__FieldTag::__attribute),
                            "value" => Ok(__FieldTag::__value),
                            "operator" => Ok(__FieldTag::__operator),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EventFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EventFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attribute => {
                            if !fields.insert(__FieldTag::__attribute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute",
                                ));
                            }
                            result.attribute = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operator => {
                            if !fields.insert(__FieldTag::__operator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operator",
                                ));
                            }
                            result.operator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EventFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attribute.is_empty() {
            state.serialize_entry("attribute", &self.attribute)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self.operator.is_empty() {
            state.serialize_entry("operator", &self.operator)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A condition that is part of the trigger state computation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StateCondition {
    /// The canonical code of the condition.
    pub code: rpc::model::Code,

    /// Human-readable message.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StateCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::StateCondition::code].
    pub fn set_code<T: std::convert::Into<rpc::model::Code>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [message][crate::model::StateCondition::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for StateCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.StateCondition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StateCondition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StateCondition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StateCondition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StateCondition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<rpc::model::Code>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StateCondition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a target of an invocation over HTTP.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Destination {
    /// Optional. Network config is used to configure how Eventarc resolves and
    /// connect to a destination.
    /// This should only be used with HttpEndpoint destination type.
    pub network_config: std::option::Option<crate::model::NetworkConfig>,

    pub descriptor: std::option::Option<crate::model::destination::Descriptor>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Destination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_config][crate::model::Destination::network_config].
    pub fn set_network_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkConfig>,
    {
        self.network_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_config][crate::model::Destination::network_config].
    pub fn set_or_clear_network_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkConfig>,
    {
        self.network_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [descriptor][crate::model::Destination::descriptor].
    ///
    /// Note that all the setters affecting `descriptor` are mutually
    /// exclusive.
    pub fn set_descriptor<
        T: std::convert::Into<std::option::Option<crate::model::destination::Descriptor>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.descriptor = v.into();
        self
    }

    /// The value of [descriptor][crate::model::Destination::descriptor]
    /// if it holds a `CloudRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_run(&self) -> std::option::Option<&std::boxed::Box<crate::model::CloudRun>> {
        #[allow(unreachable_patterns)]
        self.descriptor.as_ref().and_then(|v| match v {
            crate::model::destination::Descriptor::CloudRun(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [descriptor][crate::model::Destination::descriptor]
    /// to hold a `CloudRun`.
    ///
    /// Note that all the setters affecting `descriptor` are
    /// mutually exclusive.
    pub fn set_cloud_run<T: std::convert::Into<std::boxed::Box<crate::model::CloudRun>>>(
        mut self,
        v: T,
    ) -> Self {
        self.descriptor =
            std::option::Option::Some(crate::model::destination::Descriptor::CloudRun(v.into()));
        self
    }

    /// The value of [descriptor][crate::model::Destination::descriptor]
    /// if it holds a `CloudFunction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_function(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.descriptor.as_ref().and_then(|v| match v {
            crate::model::destination::Descriptor::CloudFunction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [descriptor][crate::model::Destination::descriptor]
    /// to hold a `CloudFunction`.
    ///
    /// Note that all the setters affecting `descriptor` are
    /// mutually exclusive.
    pub fn set_cloud_function<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.descriptor = std::option::Option::Some(
            crate::model::destination::Descriptor::CloudFunction(v.into()),
        );
        self
    }

    /// The value of [descriptor][crate::model::Destination::descriptor]
    /// if it holds a `Gke`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gke(&self) -> std::option::Option<&std::boxed::Box<crate::model::Gke>> {
        #[allow(unreachable_patterns)]
        self.descriptor.as_ref().and_then(|v| match v {
            crate::model::destination::Descriptor::Gke(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [descriptor][crate::model::Destination::descriptor]
    /// to hold a `Gke`.
    ///
    /// Note that all the setters affecting `descriptor` are
    /// mutually exclusive.
    pub fn set_gke<T: std::convert::Into<std::boxed::Box<crate::model::Gke>>>(
        mut self,
        v: T,
    ) -> Self {
        self.descriptor =
            std::option::Option::Some(crate::model::destination::Descriptor::Gke(v.into()));
        self
    }

    /// The value of [descriptor][crate::model::Destination::descriptor]
    /// if it holds a `Workflow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn workflow(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.descriptor.as_ref().and_then(|v| match v {
            crate::model::destination::Descriptor::Workflow(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [descriptor][crate::model::Destination::descriptor]
    /// to hold a `Workflow`.
    ///
    /// Note that all the setters affecting `descriptor` are
    /// mutually exclusive.
    pub fn set_workflow<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.descriptor =
            std::option::Option::Some(crate::model::destination::Descriptor::Workflow(v.into()));
        self
    }

    /// The value of [descriptor][crate::model::Destination::descriptor]
    /// if it holds a `HttpEndpoint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn http_endpoint(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HttpEndpoint>> {
        #[allow(unreachable_patterns)]
        self.descriptor.as_ref().and_then(|v| match v {
            crate::model::destination::Descriptor::HttpEndpoint(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [descriptor][crate::model::Destination::descriptor]
    /// to hold a `HttpEndpoint`.
    ///
    /// Note that all the setters affecting `descriptor` are
    /// mutually exclusive.
    pub fn set_http_endpoint<T: std::convert::Into<std::boxed::Box<crate::model::HttpEndpoint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.descriptor = std::option::Option::Some(
            crate::model::destination::Descriptor::HttpEndpoint(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Destination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Destination"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Destination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_run,
            __cloud_function,
            __gke,
            __workflow,
            __http_endpoint,
            __network_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Destination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudRun" => Ok(__FieldTag::__cloud_run),
                            "cloud_run" => Ok(__FieldTag::__cloud_run),
                            "cloudFunction" => Ok(__FieldTag::__cloud_function),
                            "cloud_function" => Ok(__FieldTag::__cloud_function),
                            "gke" => Ok(__FieldTag::__gke),
                            "workflow" => Ok(__FieldTag::__workflow),
                            "httpEndpoint" => Ok(__FieldTag::__http_endpoint),
                            "http_endpoint" => Ok(__FieldTag::__http_endpoint),
                            "networkConfig" => Ok(__FieldTag::__network_config),
                            "network_config" => Ok(__FieldTag::__network_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Destination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Destination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_run => {
                            if !fields.insert(__FieldTag::__cloud_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_run",
                                ));
                            }
                            if result.descriptor.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `descriptor`, a oneof with full ID .google.cloud.eventarc.v1.Destination.cloud_run, latest field was cloudRun",
                                ));
                            }
                            result.descriptor = std::option::Option::Some(
                                crate::model::destination::Descriptor::CloudRun(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudRun>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_function => {
                            if !fields.insert(__FieldTag::__cloud_function) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_function",
                                ));
                            }
                            if result.descriptor.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `descriptor`, a oneof with full ID .google.cloud.eventarc.v1.Destination.cloud_function, latest field was cloudFunction",
                                ));
                            }
                            result.descriptor = std::option::Option::Some(
                                crate::model::destination::Descriptor::CloudFunction(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gke => {
                            if !fields.insert(__FieldTag::__gke) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke",
                                ));
                            }
                            if result.descriptor.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `descriptor`, a oneof with full ID .google.cloud.eventarc.v1.Destination.gke, latest field was gke",
                                ));
                            }
                            result.descriptor = std::option::Option::Some(
                                crate::model::destination::Descriptor::Gke(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Gke>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__workflow => {
                            if !fields.insert(__FieldTag::__workflow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workflow",
                                ));
                            }
                            if result.descriptor.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `descriptor`, a oneof with full ID .google.cloud.eventarc.v1.Destination.workflow, latest field was workflow",
                                ));
                            }
                            result.descriptor = std::option::Option::Some(
                                crate::model::destination::Descriptor::Workflow(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__http_endpoint => {
                            if !fields.insert(__FieldTag::__http_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_endpoint",
                                ));
                            }
                            if result.descriptor.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `descriptor`, a oneof with full ID .google.cloud.eventarc.v1.Destination.http_endpoint, latest field was httpEndpoint",
                                ));
                            }
                            result.descriptor = std::option::Option::Some(
                                crate::model::destination::Descriptor::HttpEndpoint(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HttpEndpoint>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__network_config => {
                            if !fields.insert(__FieldTag::__network_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_config",
                                ));
                            }
                            result.network_config = map
                                .next_value::<std::option::Option<crate::model::NetworkConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Destination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cloud_run() {
            state.serialize_entry("cloudRun", value)?;
        }
        if let Some(value) = self.cloud_function() {
            state.serialize_entry("cloudFunction", value)?;
        }
        if let Some(value) = self.gke() {
            state.serialize_entry("gke", value)?;
        }
        if let Some(value) = self.workflow() {
            state.serialize_entry("workflow", value)?;
        }
        if let Some(value) = self.http_endpoint() {
            state.serialize_entry("httpEndpoint", value)?;
        }
        if self.network_config.is_some() {
            state.serialize_entry("networkConfig", &self.network_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Destination].
pub mod destination {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Descriptor {
        /// Cloud Run fully-managed resource that receives the events. The resource
        /// should be in the same project as the trigger.
        CloudRun(std::boxed::Box<crate::model::CloudRun>),
        /// The Cloud Function resource name. Cloud Functions V1 and V2 are
        /// supported.
        /// Format: `projects/{project}/locations/{location}/functions/{function}`
        ///
        /// This is a read-only field. Creating Cloud Functions V1/V2 triggers is
        /// only supported via the Cloud Functions product. An error will be returned
        /// if the user sets this value.
        CloudFunction(std::string::String),
        /// A GKE service capable of receiving events. The service should be running
        /// in the same project as the trigger.
        Gke(std::boxed::Box<crate::model::Gke>),
        /// The resource name of the Workflow whose Executions are triggered by
        /// the events. The Workflow resource should be deployed in the same project
        /// as the trigger.
        /// Format: `projects/{project}/locations/{location}/workflows/{workflow}`
        Workflow(std::string::String),
        /// An HTTP endpoint destination described by an URI.
        HttpEndpoint(std::boxed::Box<crate::model::HttpEndpoint>),
    }
}

/// Represents the transport intermediaries created for the trigger to
/// deliver events.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Transport {
    pub intermediary: std::option::Option<crate::model::transport::Intermediary>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Transport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intermediary][crate::model::Transport::intermediary].
    ///
    /// Note that all the setters affecting `intermediary` are mutually
    /// exclusive.
    pub fn set_intermediary<
        T: std::convert::Into<std::option::Option<crate::model::transport::Intermediary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intermediary = v.into();
        self
    }

    /// The value of [intermediary][crate::model::Transport::intermediary]
    /// if it holds a `Pubsub`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pubsub(&self) -> std::option::Option<&std::boxed::Box<crate::model::Pubsub>> {
        #[allow(unreachable_patterns)]
        self.intermediary.as_ref().and_then(|v| match v {
            crate::model::transport::Intermediary::Pubsub(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [intermediary][crate::model::Transport::intermediary]
    /// to hold a `Pubsub`.
    ///
    /// Note that all the setters affecting `intermediary` are
    /// mutually exclusive.
    pub fn set_pubsub<T: std::convert::Into<std::boxed::Box<crate::model::Pubsub>>>(
        mut self,
        v: T,
    ) -> Self {
        self.intermediary =
            std::option::Option::Some(crate::model::transport::Intermediary::Pubsub(v.into()));
        self
    }
}

impl wkt::message::Message for Transport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Transport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Transport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pubsub,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Transport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pubsub" => Ok(__FieldTag::__pubsub),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Transport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Transport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pubsub => {
                            if !fields.insert(__FieldTag::__pubsub) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub",
                                ));
                            }
                            if result.intermediary.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `intermediary`, a oneof with full ID .google.cloud.eventarc.v1.Transport.pubsub, latest field was pubsub",
                                ));
                            }
                            result.intermediary =
                                std::option::Option::Some(
                                    crate::model::transport::Intermediary::Pubsub(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Pubsub>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Transport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.pubsub() {
            state.serialize_entry("pubsub", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Transport].
pub mod transport {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Intermediary {
        /// The Pub/Sub topic and subscription used by Eventarc as a transport
        /// intermediary.
        Pubsub(std::boxed::Box<crate::model::Pubsub>),
    }
}

/// Represents a Cloud Run destination.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudRun {
    /// Required. The name of the Cloud Run service being addressed. See
    /// <https://cloud.google.com/run/docs/reference/rest/v1/namespaces.services>.
    ///
    /// Only services located in the same project as the trigger object
    /// can be addressed.
    pub service: std::string::String,

    /// Optional. The relative path on the Cloud Run service the events should be
    /// sent to.
    ///
    /// The value must conform to the definition of a URI path segment (section 3.3
    /// of RFC2396). Examples: "/route", "route", "route/subroute".
    pub path: std::string::String,

    /// Required. The region the Cloud Run service is deployed in.
    pub region: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::CloudRun::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [path][crate::model::CloudRun::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [region][crate::model::CloudRun::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for CloudRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.CloudRun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            __path,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            "path" => Ok(__FieldTag::__path),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a GKE destination.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Gke {
    /// Required. The name of the cluster the GKE service is running in. The
    /// cluster must be running in the same project as the trigger being created.
    pub cluster: std::string::String,

    /// Required. The name of the Google Compute Engine in which the cluster
    /// resides, which can either be compute zone (for example, us-central1-a) for
    /// the zonal clusters or region (for example, us-central1) for regional
    /// clusters.
    pub location: std::string::String,

    /// Required. The namespace the GKE service is running in.
    pub namespace: std::string::String,

    /// Required. Name of the GKE service.
    pub service: std::string::String,

    /// Optional. The relative path on the GKE service the events should be sent
    /// to.
    ///
    /// The value must conform to the definition of a URI path segment (section 3.3
    /// of RFC2396). Examples: "/route", "route", "route/subroute".
    pub path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Gke {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::Gke::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Gke::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [namespace][crate::model::Gke::namespace].
    pub fn set_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.namespace = v.into();
        self
    }

    /// Sets the value of [service][crate::model::Gke::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Gke::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for Gke {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.GKE"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Gke {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster,
            __location,
            __namespace,
            __service,
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Gke")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cluster" => Ok(__FieldTag::__cluster),
                            "location" => Ok(__FieldTag::__location),
                            "namespace" => Ok(__FieldTag::__namespace),
                            "service" => Ok(__FieldTag::__service),
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Gke;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Gke")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__namespace => {
                            if !fields.insert(__FieldTag::__namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace",
                                ));
                            }
                            result.namespace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Gke {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.namespace.is_empty() {
            state.serialize_entry("namespace", &self.namespace)?;
        }
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a Pub/Sub transport.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Pubsub {
    /// Optional. The name of the Pub/Sub topic created and managed by Eventarc as
    /// a transport for the event delivery. Format:
    /// `projects/{PROJECT_ID}/topics/{TOPIC_NAME}`.
    ///
    /// You can set an existing topic for triggers of the type
    /// `google.cloud.pubsub.topic.v1.messagePublished`. The topic you provide
    /// here is not deleted by Eventarc at trigger deletion.
    pub topic: std::string::String,

    /// Output only. The name of the Pub/Sub subscription created and managed by
    /// Eventarc as a transport for the event delivery. Format:
    /// `projects/{PROJECT_ID}/subscriptions/{SUBSCRIPTION_NAME}`.
    pub subscription: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Pubsub {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::Pubsub::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [subscription][crate::model::Pubsub::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }
}

impl wkt::message::Message for Pubsub {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.Pubsub"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Pubsub {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __topic,
            __subscription,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Pubsub")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "topic" => Ok(__FieldTag::__topic),
                            "subscription" => Ok(__FieldTag::__subscription),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Pubsub;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Pubsub")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic",
                                ));
                            }
                            result.topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subscription => {
                            if !fields.insert(__FieldTag::__subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription",
                                ));
                            }
                            result.subscription = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Pubsub {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.topic.is_empty() {
            state.serialize_entry("topic", &self.topic)?;
        }
        if !self.subscription.is_empty() {
            state.serialize_entry("subscription", &self.subscription)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a HTTP endpoint destination.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HttpEndpoint {
    /// Required. The URI of the HTTP enpdoint.
    ///
    /// The value must be a RFC2396 URI string.
    /// Examples: `http://10.10.10.8:80/route`,
    /// `<http://svc.us-central1.p.local>:8080/`.
    /// Only HTTP and HTTPS protocols are supported. The host can be either a
    /// static IP addressable from the VPC specified by the network config, or
    /// an internal DNS hostname of the service resolvable via Cloud DNS.
    pub uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpEndpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::HttpEndpoint::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for HttpEndpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.eventarc.v1.HttpEndpoint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HttpEndpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpEndpoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HttpEndpoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpEndpoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HttpEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
