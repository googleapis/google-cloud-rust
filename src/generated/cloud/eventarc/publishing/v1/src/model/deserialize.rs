// Copyright 2026 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __source,
            __spec_version,
            __type,
            __attributes,
            __binary_data,
            __text_data,
            __proto_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "source" => Ok(__FieldTag::__source),
                            "specVersion" => Ok(__FieldTag::__spec_version),
                            "spec_version" => Ok(__FieldTag::__spec_version),
                            "type" => Ok(__FieldTag::__type),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "binaryData" => Ok(__FieldTag::__binary_data),
                            "binary_data" => Ok(__FieldTag::__binary_data),
                            "textData" => Ok(__FieldTag::__text_data),
                            "text_data" => Ok(__FieldTag::__text_data),
                            "protoData" => Ok(__FieldTag::__proto_data),
                            "proto_data" => Ok(__FieldTag::__proto_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__spec_version => {
                            if !fields.insert(__FieldTag::__spec_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec_version",
                                ));
                            }
                            result.spec_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::cloud_event::CloudEventAttributeValue,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__binary_data => {
                            if !fields.insert(__FieldTag::__binary_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binary_data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.eventarc.publishing.v1.CloudEvent.binary_data, latest field was binaryData",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::cloud_event::Data::BinaryData(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__text_data => {
                            if !fields.insert(__FieldTag::__text_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_data",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.eventarc.publishing.v1.CloudEvent.text_data, latest field was textData",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::cloud_event::Data::TextData(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__proto_data => {
                            if !fields.insert(__FieldTag::__proto_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proto_data",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.eventarc.publishing.v1.CloudEvent.proto_data, latest field was protoData",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::cloud_event::Data::ProtoData(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Any>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::cloud_event::CloudEventAttributeValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ce_boolean,
            __ce_integer,
            __ce_string,
            __ce_bytes,
            __ce_uri,
            __ce_uri_ref,
            __ce_timestamp,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudEventAttributeValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ceBoolean" => Ok(__FieldTag::__ce_boolean),
                            "ce_boolean" => Ok(__FieldTag::__ce_boolean),
                            "ceInteger" => Ok(__FieldTag::__ce_integer),
                            "ce_integer" => Ok(__FieldTag::__ce_integer),
                            "ceString" => Ok(__FieldTag::__ce_string),
                            "ce_string" => Ok(__FieldTag::__ce_string),
                            "ceBytes" => Ok(__FieldTag::__ce_bytes),
                            "ce_bytes" => Ok(__FieldTag::__ce_bytes),
                            "ceUri" => Ok(__FieldTag::__ce_uri),
                            "ce_uri" => Ok(__FieldTag::__ce_uri),
                            "ceUriRef" => Ok(__FieldTag::__ce_uri_ref),
                            "ce_uri_ref" => Ok(__FieldTag::__ce_uri_ref),
                            "ceTimestamp" => Ok(__FieldTag::__ce_timestamp),
                            "ce_timestamp" => Ok(__FieldTag::__ce_timestamp),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::cloud_event::CloudEventAttributeValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudEventAttributeValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ce_boolean => {
                            if !fields.insert(__FieldTag::__ce_boolean) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ce_boolean",
                                ));
                            }
                            if result.attr.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `attr`, a oneof with full ID .google.cloud.eventarc.publishing.v1.CloudEvent.CloudEventAttributeValue.ce_boolean, latest field was ceBoolean",
                                ));
                            }
                            result.attr = std::option::Option::Some(
                                crate::model::cloud_event::cloud_event_attribute_value::Attr::CeBoolean(
                                    map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__ce_integer => {
                            if !fields.insert(__FieldTag::__ce_integer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ce_integer",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.attr.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `attr`, a oneof with full ID .google.cloud.eventarc.publishing.v1.CloudEvent.CloudEventAttributeValue.ce_integer, latest field was ceInteger",
                                ));
                            }
                            result.attr = std::option::Option::Some(
                                crate::model::cloud_event::cloud_event_attribute_value::Attr::CeInteger(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__ce_string => {
                            if !fields.insert(__FieldTag::__ce_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ce_string",
                                ));
                            }
                            if result.attr.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `attr`, a oneof with full ID .google.cloud.eventarc.publishing.v1.CloudEvent.CloudEventAttributeValue.ce_string, latest field was ceString",
                                ));
                            }
                            result.attr = std::option::Option::Some(
                                crate::model::cloud_event::cloud_event_attribute_value::Attr::CeString(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__ce_bytes => {
                            if !fields.insert(__FieldTag::__ce_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ce_bytes",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.attr.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `attr`, a oneof with full ID .google.cloud.eventarc.publishing.v1.CloudEvent.CloudEventAttributeValue.ce_bytes, latest field was ceBytes",
                                ));
                            }
                            result.attr = std::option::Option::Some(
                                crate::model::cloud_event::cloud_event_attribute_value::Attr::CeBytes(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__ce_uri => {
                            if !fields.insert(__FieldTag::__ce_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ce_uri",
                                ));
                            }
                            if result.attr.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `attr`, a oneof with full ID .google.cloud.eventarc.publishing.v1.CloudEvent.CloudEventAttributeValue.ce_uri, latest field was ceUri",
                                ));
                            }
                            result.attr = std::option::Option::Some(
                                crate::model::cloud_event::cloud_event_attribute_value::Attr::CeUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__ce_uri_ref => {
                            if !fields.insert(__FieldTag::__ce_uri_ref) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ce_uri_ref",
                                ));
                            }
                            if result.attr.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `attr`, a oneof with full ID .google.cloud.eventarc.publishing.v1.CloudEvent.CloudEventAttributeValue.ce_uri_ref, latest field was ceUriRef",
                                ));
                            }
                            result.attr = std::option::Option::Some(
                                crate::model::cloud_event::cloud_event_attribute_value::Attr::CeUriRef(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__ce_timestamp => {
                            if !fields.insert(__FieldTag::__ce_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ce_timestamp",
                                ));
                            }
                            if result.attr.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `attr`, a oneof with full ID .google.cloud.eventarc.publishing.v1.CloudEvent.CloudEventAttributeValue.ce_timestamp, latest field was ceTimestamp",
                                ));
                            }
                            result.attr = std::option::Option::Some(
                                crate::model::cloud_event::cloud_event_attribute_value::Attr::CeTimestamp(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PublishChannelConnectionEventsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channel_connection,
            __events,
            __text_events,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for PublishChannelConnectionEventsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channelConnection" => Ok(__FieldTag::__channel_connection),
                            "channel_connection" => Ok(__FieldTag::__channel_connection),
                            "events" => Ok(__FieldTag::__events),
                            "textEvents" => Ok(__FieldTag::__text_events),
                            "text_events" => Ok(__FieldTag::__text_events),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PublishChannelConnectionEventsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PublishChannelConnectionEventsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channel_connection => {
                            if !fields.insert(__FieldTag::__channel_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_connection",
                                ));
                            }
                            result.channel_connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__events => {
                            if !fields.insert(__FieldTag::__events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for events",
                                ));
                            }
                            result.events = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Any>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text_events => {
                            if !fields.insert(__FieldTag::__text_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_events",
                                ));
                            }
                            result.text_events = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PublishChannelConnectionEventsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for PublishChannelConnectionEventsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PublishChannelConnectionEventsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PublishChannelConnectionEventsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PublishEventsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channel,
            __events,
            __text_events,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PublishEventsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channel" => Ok(__FieldTag::__channel),
                            "events" => Ok(__FieldTag::__events),
                            "textEvents" => Ok(__FieldTag::__text_events),
                            "text_events" => Ok(__FieldTag::__text_events),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PublishEventsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PublishEventsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__events => {
                            if !fields.insert(__FieldTag::__events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for events",
                                ));
                            }
                            result.events = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Any>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text_events => {
                            if !fields.insert(__FieldTag::__text_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_events",
                                ));
                            }
                            result.text_events = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PublishEventsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PublishEventsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PublishEventsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PublishEventsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PublishRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message_bus,
            __proto_message,
            __json_message,
            __avro_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PublishRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messageBus" => Ok(__FieldTag::__message_bus),
                            "message_bus" => Ok(__FieldTag::__message_bus),
                            "protoMessage" => Ok(__FieldTag::__proto_message),
                            "proto_message" => Ok(__FieldTag::__proto_message),
                            "jsonMessage" => Ok(__FieldTag::__json_message),
                            "json_message" => Ok(__FieldTag::__json_message),
                            "avroMessage" => Ok(__FieldTag::__avro_message),
                            "avro_message" => Ok(__FieldTag::__avro_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PublishRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PublishRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message_bus => {
                            if !fields.insert(__FieldTag::__message_bus) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_bus",
                                ));
                            }
                            result.message_bus = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__proto_message => {
                            if !fields.insert(__FieldTag::__proto_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proto_message",
                                ));
                            }
                            if result.format.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `format`, a oneof with full ID .google.cloud.eventarc.publishing.v1.PublishRequest.proto_message, latest field was protoMessage",
                                ));
                            }
                            result.format = std::option::Option::Some(
                                crate::model::publish_request::Format::ProtoMessage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudEvent>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__json_message => {
                            if !fields.insert(__FieldTag::__json_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for json_message",
                                ));
                            }
                            if result.format.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `format`, a oneof with full ID .google.cloud.eventarc.publishing.v1.PublishRequest.json_message, latest field was jsonMessage",
                                ));
                            }
                            result.format = std::option::Option::Some(
                                crate::model::publish_request::Format::JsonMessage(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__avro_message => {
                            if !fields.insert(__FieldTag::__avro_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avro_message",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.format.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `format`, a oneof with full ID .google.cloud.eventarc.publishing.v1.PublishRequest.avro_message, latest field was avroMessage",
                                ));
                            }
                            result.format = std::option::Option::Some(
                                crate::model::publish_request::Format::AvroMessage(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PublishResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PublishResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PublishResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PublishResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
