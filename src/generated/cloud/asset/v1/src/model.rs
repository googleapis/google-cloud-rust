// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate accesscontextmanager_v1;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate orgpolicy_v1;
extern crate osconfig_v1;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The resource owners information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceOwners {
    /// List of resource owners.
    pub resource_owners: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceOwners {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_owners][crate::model::ResourceOwners::resource_owners].
    pub fn set_resource_owners<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_owners = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ResourceOwners {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.ResourceOwners"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceOwners {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_owners,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceOwners")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceOwners" => Ok(__FieldTag::__resource_owners),
                            "resource_owners" => Ok(__FieldTag::__resource_owners),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceOwners;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceOwners")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_owners => {
                            if !fields.insert(__FieldTag::__resource_owners) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_owners",
                                ));
                            }
                            result.resource_owners = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceOwners {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_owners.is_empty() {
            state.serialize_entry("resourceOwners", &self.resource_owners)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResourceOwners {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceOwners");
        debug_struct.field("resource_owners", &self.resource_owners);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the metadata of the longrunning operation for the
/// AnalyzeIamPolicyLongrunning RPC.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeIamPolicyLongrunningMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeIamPolicyLongrunningMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::AnalyzeIamPolicyLongrunningMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AnalyzeIamPolicyLongrunningMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AnalyzeIamPolicyLongrunningMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzeIamPolicyLongrunningMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeIamPolicyLongrunningMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeIamPolicyLongrunningMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeIamPolicyLongrunningMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeIamPolicyLongrunningMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeIamPolicyLongrunningMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeIamPolicyLongrunningMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeIamPolicyLongrunningMetadata");
        debug_struct.field("create_time", &self.create_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Export asset request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportAssetsRequest {
    /// Required. The relative name of the root asset. This can only be an
    /// organization number (such as "organizations/123"), a project ID (such as
    /// "projects/my-project-id"), or a project number (such as "projects/12345"),
    /// or a folder number (such as "folders/123").
    pub parent: std::string::String,

    /// Timestamp to take an asset snapshot. This can only be set to a timestamp
    /// between the current time and the current time minus 35 days (inclusive).
    /// If not specified, the current time will be used. Due to delays in resource
    /// data collection and indexing, there is a volatile window during which
    /// running the same query may get different results.
    pub read_time: std::option::Option<wkt::Timestamp>,

    /// A list of asset types to take a snapshot for. For example:
    /// "compute.googleapis.com/Disk".
    ///
    /// Regular expressions are also supported. For example:
    ///
    /// * "compute.googleapis.com.*" snapshots resources whose asset type starts
    ///   with "compute.googleapis.com".
    /// * ".*Instance" snapshots resources whose asset type ends with "Instance".
    /// * ".*Instance.*" snapshots resources whose asset type contains "Instance".
    ///
    /// See [RE2](https://github.com/google/re2/wiki/Syntax) for all supported
    /// regular expression syntax. If the regular expression does not match any
    /// supported asset type, an INVALID_ARGUMENT error will be returned.
    ///
    /// If specified, only matching assets will be returned, otherwise, it will
    /// snapshot all asset types. See [Introduction to Cloud Asset
    /// Inventory](https://cloud.google.com/asset-inventory/docs/overview)
    /// for all supported asset types.
    pub asset_types: std::vec::Vec<std::string::String>,

    /// Asset content type. If not specified, no content but the asset name will be
    /// returned.
    pub content_type: crate::model::ContentType,

    /// Required. Output configuration indicating where the results will be output
    /// to.
    pub output_config: std::option::Option<crate::model::OutputConfig>,

    /// A list of relationship types to export, for example:
    /// `INSTANCE_TO_INSTANCEGROUP`. This field should only be specified if
    /// content_type=RELATIONSHIP.
    ///
    /// * If specified:
    ///   it snapshots specified relationships. It returns an error if
    ///   any of the [relationship_types] doesn't belong to the supported
    ///   relationship types of the [asset_types] or if any of the [asset_types]
    ///   doesn't belong to the source types of the [relationship_types].
    /// * Otherwise:
    ///   it snapshots the supported relationships for all [asset_types] or returns
    ///   an error if any of the [asset_types] has no relationship support.
    ///   An unspecified asset types field means all supported asset_types.
    ///   See [Introduction to Cloud Asset
    ///   Inventory](https://cloud.google.com/asset-inventory/docs/overview) for all
    ///   supported asset types and relationship types.
    pub relationship_types: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportAssetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ExportAssetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [read_time][crate::model::ExportAssetsRequest::read_time].
    pub fn set_read_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.read_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_time][crate::model::ExportAssetsRequest::read_time].
    pub fn set_or_clear_read_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.read_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [asset_types][crate::model::ExportAssetsRequest::asset_types].
    pub fn set_asset_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.asset_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [content_type][crate::model::ExportAssetsRequest::content_type].
    pub fn set_content_type<T: std::convert::Into<crate::model::ContentType>>(
        mut self,
        v: T,
    ) -> Self {
        self.content_type = v.into();
        self
    }

    /// Sets the value of [output_config][crate::model::ExportAssetsRequest::output_config].
    pub fn set_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_config][crate::model::ExportAssetsRequest::output_config].
    pub fn set_or_clear_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [relationship_types][crate::model::ExportAssetsRequest::relationship_types].
    pub fn set_relationship_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.relationship_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportAssetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.ExportAssetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportAssetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __read_time,
            __asset_types,
            __content_type,
            __output_config,
            __relationship_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportAssetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            "assetTypes" => Ok(__FieldTag::__asset_types),
                            "asset_types" => Ok(__FieldTag::__asset_types),
                            "contentType" => Ok(__FieldTag::__content_type),
                            "content_type" => Ok(__FieldTag::__content_type),
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            "relationshipTypes" => Ok(__FieldTag::__relationship_types),
                            "relationship_types" => Ok(__FieldTag::__relationship_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportAssetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportAssetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            result.read_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__asset_types => {
                            if !fields.insert(__FieldTag::__asset_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_types",
                                ));
                            }
                            result.asset_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__content_type => {
                            if !fields.insert(__FieldTag::__content_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_type",
                                ));
                            }
                            result.content_type = map
                                .next_value::<std::option::Option<crate::model::ContentType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            result.output_config = map
                                .next_value::<std::option::Option<crate::model::OutputConfig>>()?;
                        }
                        __FieldTag::__relationship_types => {
                            if !fields.insert(__FieldTag::__relationship_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relationship_types",
                                ));
                            }
                            result.relationship_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportAssetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.read_time.is_some() {
            state.serialize_entry("readTime", &self.read_time)?;
        }
        if !self.asset_types.is_empty() {
            state.serialize_entry("assetTypes", &self.asset_types)?;
        }
        if !wkt::internal::is_default(&self.content_type) {
            state.serialize_entry("contentType", &self.content_type)?;
        }
        if self.output_config.is_some() {
            state.serialize_entry("outputConfig", &self.output_config)?;
        }
        if !self.relationship_types.is_empty() {
            state.serialize_entry("relationshipTypes", &self.relationship_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportAssetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportAssetsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("read_time", &self.read_time);
        debug_struct.field("asset_types", &self.asset_types);
        debug_struct.field("content_type", &self.content_type);
        debug_struct.field("output_config", &self.output_config);
        debug_struct.field("relationship_types", &self.relationship_types);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The export asset response. This message is returned by the
/// [google.longrunning.Operations.GetOperation][google.longrunning.Operations.GetOperation]
/// method in the returned
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// field.
///
/// [google.longrunning.Operation.response]: longrunning::model::Operation::result
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportAssetsResponse {
    /// Time the snapshot was taken.
    pub read_time: std::option::Option<wkt::Timestamp>,

    /// Output configuration indicating where the results were output to.
    pub output_config: std::option::Option<crate::model::OutputConfig>,

    /// Output result indicating where the assets were exported to. For example, a
    /// set of actual Cloud Storage object URIs where the assets are exported to.
    /// The URIs can be different from what [output_config] has specified, as the
    /// service will split the output object into multiple ones once it exceeds a
    /// single Cloud Storage object limit.
    pub output_result: std::option::Option<crate::model::OutputResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportAssetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [read_time][crate::model::ExportAssetsResponse::read_time].
    pub fn set_read_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.read_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_time][crate::model::ExportAssetsResponse::read_time].
    pub fn set_or_clear_read_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.read_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_config][crate::model::ExportAssetsResponse::output_config].
    pub fn set_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_config][crate::model::ExportAssetsResponse::output_config].
    pub fn set_or_clear_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_result][crate::model::ExportAssetsResponse::output_result].
    pub fn set_output_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputResult>,
    {
        self.output_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_result][crate::model::ExportAssetsResponse::output_result].
    pub fn set_or_clear_output_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputResult>,
    {
        self.output_result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExportAssetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.ExportAssetsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportAssetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __read_time,
            __output_config,
            __output_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportAssetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            "outputResult" => Ok(__FieldTag::__output_result),
                            "output_result" => Ok(__FieldTag::__output_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportAssetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportAssetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            result.read_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            result.output_config = map
                                .next_value::<std::option::Option<crate::model::OutputConfig>>()?;
                        }
                        __FieldTag::__output_result => {
                            if !fields.insert(__FieldTag::__output_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_result",
                                ));
                            }
                            result.output_result = map
                                .next_value::<std::option::Option<crate::model::OutputResult>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportAssetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.read_time.is_some() {
            state.serialize_entry("readTime", &self.read_time)?;
        }
        if self.output_config.is_some() {
            state.serialize_entry("outputConfig", &self.output_config)?;
        }
        if self.output_result.is_some() {
            state.serialize_entry("outputResult", &self.output_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportAssetsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportAssetsResponse");
        debug_struct.field("read_time", &self.read_time);
        debug_struct.field("output_config", &self.output_config);
        debug_struct.field("output_result", &self.output_result);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListAssets request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAssetsRequest {
    /// Required. Name of the organization, folder, or project the assets belong
    /// to. Format: "organizations/[organization-number]" (such as
    /// "organizations/123"), "projects/[project-id]" (such as
    /// "projects/my-project-id"), "projects/[project-number]" (such as
    /// "projects/12345"), or "folders/[folder-number]" (such as "folders/12345").
    pub parent: std::string::String,

    /// Timestamp to take an asset snapshot. This can only be set to a timestamp
    /// between the current time and the current time minus 35 days (inclusive).
    /// If not specified, the current time will be used. Due to delays in resource
    /// data collection and indexing, there is a volatile window during which
    /// running the same query may get different results.
    pub read_time: std::option::Option<wkt::Timestamp>,

    /// A list of asset types to take a snapshot for. For example:
    /// "compute.googleapis.com/Disk".
    ///
    /// Regular expression is also supported. For example:
    ///
    /// * "compute.googleapis.com.*" snapshots resources whose asset type starts
    ///   with "compute.googleapis.com".
    /// * ".*Instance" snapshots resources whose asset type ends with "Instance".
    /// * ".*Instance.*" snapshots resources whose asset type contains "Instance".
    ///
    /// See [RE2](https://github.com/google/re2/wiki/Syntax) for all supported
    /// regular expression syntax. If the regular expression does not match any
    /// supported asset type, an INVALID_ARGUMENT error will be returned.
    ///
    /// If specified, only matching assets will be returned, otherwise, it will
    /// snapshot all asset types. See [Introduction to Cloud Asset
    /// Inventory](https://cloud.google.com/asset-inventory/docs/overview)
    /// for all supported asset types.
    pub asset_types: std::vec::Vec<std::string::String>,

    /// Asset content type. If not specified, no content but the asset name will
    /// be returned.
    pub content_type: crate::model::ContentType,

    /// The maximum number of assets to be returned in a single response. Default
    /// is 100, minimum is 1, and maximum is 1000.
    pub page_size: i32,

    /// The `next_page_token` returned from the previous `ListAssetsResponse`, or
    /// unspecified for the first `ListAssetsRequest`. It is a continuation of a
    /// prior `ListAssets` call, and the API should return the next page of assets.
    pub page_token: std::string::String,

    /// A list of relationship types to output, for example:
    /// `INSTANCE_TO_INSTANCEGROUP`. This field should only be specified if
    /// content_type=RELATIONSHIP.
    ///
    /// * If specified:
    ///   it snapshots specified relationships. It returns an error if
    ///   any of the [relationship_types] doesn't belong to the supported
    ///   relationship types of the [asset_types] or if any of the [asset_types]
    ///   doesn't belong to the source types of the [relationship_types].
    /// * Otherwise:
    ///   it snapshots the supported relationships for all [asset_types] or returns
    ///   an error if any of the [asset_types] has no relationship support.
    ///   An unspecified asset types field means all supported asset_types.
    ///   See [Introduction to Cloud Asset
    ///   Inventory](https://cloud.google.com/asset-inventory/docs/overview)
    ///   for all supported asset types and relationship types.
    pub relationship_types: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAssetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [read_time][crate::model::ListAssetsRequest::read_time].
    pub fn set_read_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.read_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_time][crate::model::ListAssetsRequest::read_time].
    pub fn set_or_clear_read_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.read_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [asset_types][crate::model::ListAssetsRequest::asset_types].
    pub fn set_asset_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.asset_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [content_type][crate::model::ListAssetsRequest::content_type].
    pub fn set_content_type<T: std::convert::Into<crate::model::ContentType>>(
        mut self,
        v: T,
    ) -> Self {
        self.content_type = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAssetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAssetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [relationship_types][crate::model::ListAssetsRequest::relationship_types].
    pub fn set_relationship_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.relationship_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAssetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.ListAssetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAssetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __read_time,
            __asset_types,
            __content_type,
            __page_size,
            __page_token,
            __relationship_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAssetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            "assetTypes" => Ok(__FieldTag::__asset_types),
                            "asset_types" => Ok(__FieldTag::__asset_types),
                            "contentType" => Ok(__FieldTag::__content_type),
                            "content_type" => Ok(__FieldTag::__content_type),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "relationshipTypes" => Ok(__FieldTag::__relationship_types),
                            "relationship_types" => Ok(__FieldTag::__relationship_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAssetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAssetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            result.read_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__asset_types => {
                            if !fields.insert(__FieldTag::__asset_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_types",
                                ));
                            }
                            result.asset_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__content_type => {
                            if !fields.insert(__FieldTag::__content_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_type",
                                ));
                            }
                            result.content_type = map
                                .next_value::<std::option::Option<crate::model::ContentType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relationship_types => {
                            if !fields.insert(__FieldTag::__relationship_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relationship_types",
                                ));
                            }
                            result.relationship_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAssetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.read_time.is_some() {
            state.serialize_entry("readTime", &self.read_time)?;
        }
        if !self.asset_types.is_empty() {
            state.serialize_entry("assetTypes", &self.asset_types)?;
        }
        if !wkt::internal::is_default(&self.content_type) {
            state.serialize_entry("contentType", &self.content_type)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.relationship_types.is_empty() {
            state.serialize_entry("relationshipTypes", &self.relationship_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAssetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAssetsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("read_time", &self.read_time);
        debug_struct.field("asset_types", &self.asset_types);
        debug_struct.field("content_type", &self.content_type);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("relationship_types", &self.relationship_types);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListAssets response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAssetsResponse {
    /// Time the snapshot was taken.
    pub read_time: std::option::Option<wkt::Timestamp>,

    /// Assets.
    pub assets: std::vec::Vec<crate::model::Asset>,

    /// Token to retrieve the next page of results. It expires 72 hours after the
    /// page token for the first page is generated. Set to empty if there are no
    /// remaining results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [read_time][crate::model::ListAssetsResponse::read_time].
    pub fn set_read_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.read_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_time][crate::model::ListAssetsResponse::read_time].
    pub fn set_or_clear_read_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.read_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [assets][crate::model::ListAssetsResponse::assets].
    pub fn set_assets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Asset>,
    {
        use std::iter::Iterator;
        self.assets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAssetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAssetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.ListAssetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAssetsResponse {
    type PageItem = crate::model::Asset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.assets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAssetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __read_time,
            __assets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAssetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            "assets" => Ok(__FieldTag::__assets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAssetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAssetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            result.read_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__assets => {
                            if !fields.insert(__FieldTag::__assets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assets",
                                ));
                            }
                            result.assets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Asset>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAssetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.read_time.is_some() {
            state.serialize_entry("readTime", &self.read_time)?;
        }
        if !self.assets.is_empty() {
            state.serialize_entry("assets", &self.assets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAssetsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAssetsResponse");
        debug_struct.field("read_time", &self.read_time);
        debug_struct.field("assets", &self.assets);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Batch get assets history request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchGetAssetsHistoryRequest {
    /// Required. The relative name of the root asset. It can only be an
    /// organization number (such as "organizations/123"), a project ID (such as
    /// "projects/my-project-id")", or a project number (such as "projects/12345").
    pub parent: std::string::String,

    /// A list of the full names of the assets.
    /// See: <https://cloud.google.com/asset-inventory/docs/resource-name-format>
    /// Example:
    ///
    /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
    ///
    /// The request becomes a no-op if the asset name list is empty, and the max
    /// size of the asset name list is 100 in one request.
    pub asset_names: std::vec::Vec<std::string::String>,

    /// Optional. The content type.
    pub content_type: crate::model::ContentType,

    /// Optional. The time window for the asset history. Both start_time and
    /// end_time are optional and if set, it must be after the current time minus
    /// 35 days. If end_time is not set, it is default to current timestamp.
    /// If start_time is not set, the snapshot of the assets at end_time will be
    /// returned. The returned results contain all temporal assets whose time
    /// window overlap with read_time_window.
    pub read_time_window: std::option::Option<crate::model::TimeWindow>,

    /// Optional. A list of relationship types to output, for example:
    /// `INSTANCE_TO_INSTANCEGROUP`. This field should only be specified if
    /// content_type=RELATIONSHIP.
    ///
    /// * If specified:
    ///   it outputs specified relationships' history on the [asset_names]. It
    ///   returns an error if any of the [relationship_types] doesn't belong to the
    ///   supported relationship types of the [asset_names] or if any of the
    ///   [asset_names]'s types doesn't belong to the source types of the
    ///   [relationship_types].
    /// * Otherwise:
    ///   it outputs the supported relationships' history on the [asset_names] or
    ///   returns an error if any of the [asset_names]'s types has no relationship
    ///   support.
    ///   See [Introduction to Cloud Asset
    ///   Inventory](https://cloud.google.com/asset-inventory/docs/overview) for all
    ///   supported asset types and relationship types.
    pub relationship_types: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchGetAssetsHistoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchGetAssetsHistoryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [asset_names][crate::model::BatchGetAssetsHistoryRequest::asset_names].
    pub fn set_asset_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.asset_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [content_type][crate::model::BatchGetAssetsHistoryRequest::content_type].
    pub fn set_content_type<T: std::convert::Into<crate::model::ContentType>>(
        mut self,
        v: T,
    ) -> Self {
        self.content_type = v.into();
        self
    }

    /// Sets the value of [read_time_window][crate::model::BatchGetAssetsHistoryRequest::read_time_window].
    pub fn set_read_time_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindow>,
    {
        self.read_time_window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_time_window][crate::model::BatchGetAssetsHistoryRequest::read_time_window].
    pub fn set_or_clear_read_time_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindow>,
    {
        self.read_time_window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [relationship_types][crate::model::BatchGetAssetsHistoryRequest::relationship_types].
    pub fn set_relationship_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.relationship_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchGetAssetsHistoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.BatchGetAssetsHistoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchGetAssetsHistoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __asset_names,
            __content_type,
            __read_time_window,
            __relationship_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchGetAssetsHistoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "assetNames" => Ok(__FieldTag::__asset_names),
                            "asset_names" => Ok(__FieldTag::__asset_names),
                            "contentType" => Ok(__FieldTag::__content_type),
                            "content_type" => Ok(__FieldTag::__content_type),
                            "readTimeWindow" => Ok(__FieldTag::__read_time_window),
                            "read_time_window" => Ok(__FieldTag::__read_time_window),
                            "relationshipTypes" => Ok(__FieldTag::__relationship_types),
                            "relationship_types" => Ok(__FieldTag::__relationship_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchGetAssetsHistoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchGetAssetsHistoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset_names => {
                            if !fields.insert(__FieldTag::__asset_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_names",
                                ));
                            }
                            result.asset_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__content_type => {
                            if !fields.insert(__FieldTag::__content_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_type",
                                ));
                            }
                            result.content_type = map
                                .next_value::<std::option::Option<crate::model::ContentType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_time_window => {
                            if !fields.insert(__FieldTag::__read_time_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time_window",
                                ));
                            }
                            result.read_time_window =
                                map.next_value::<std::option::Option<crate::model::TimeWindow>>()?;
                        }
                        __FieldTag::__relationship_types => {
                            if !fields.insert(__FieldTag::__relationship_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relationship_types",
                                ));
                            }
                            result.relationship_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchGetAssetsHistoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.asset_names.is_empty() {
            state.serialize_entry("assetNames", &self.asset_names)?;
        }
        if !wkt::internal::is_default(&self.content_type) {
            state.serialize_entry("contentType", &self.content_type)?;
        }
        if self.read_time_window.is_some() {
            state.serialize_entry("readTimeWindow", &self.read_time_window)?;
        }
        if !self.relationship_types.is_empty() {
            state.serialize_entry("relationshipTypes", &self.relationship_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchGetAssetsHistoryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchGetAssetsHistoryRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("asset_names", &self.asset_names);
        debug_struct.field("content_type", &self.content_type);
        debug_struct.field("read_time_window", &self.read_time_window);
        debug_struct.field("relationship_types", &self.relationship_types);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Batch get assets history response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchGetAssetsHistoryResponse {
    /// A list of assets with valid time windows.
    pub assets: std::vec::Vec<crate::model::TemporalAsset>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchGetAssetsHistoryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [assets][crate::model::BatchGetAssetsHistoryResponse::assets].
    pub fn set_assets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TemporalAsset>,
    {
        use std::iter::Iterator;
        self.assets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchGetAssetsHistoryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.BatchGetAssetsHistoryResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchGetAssetsHistoryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __assets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchGetAssetsHistoryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "assets" => Ok(__FieldTag::__assets),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchGetAssetsHistoryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchGetAssetsHistoryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__assets => {
                            if !fields.insert(__FieldTag::__assets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assets",
                                ));
                            }
                            result.assets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TemporalAsset>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchGetAssetsHistoryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.assets.is_empty() {
            state.serialize_entry("assets", &self.assets)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchGetAssetsHistoryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchGetAssetsHistoryResponse");
        debug_struct.field("assets", &self.assets);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Create asset feed request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateFeedRequest {
    /// Required. The name of the project/folder/organization where this feed
    /// should be created in. It can only be an organization number (such as
    /// "organizations/123"), a folder number (such as "folders/123"), a project ID
    /// (such as "projects/my-project-id"), or a project number (such as
    /// "projects/12345").
    pub parent: std::string::String,

    /// Required. This is the client-assigned asset feed identifier and it needs to
    /// be unique under a specific parent project/folder/organization.
    pub feed_id: std::string::String,

    /// Required. The feed details. The field `name` must be empty and it will be
    /// generated in the format of: projects/project_number/feeds/feed_id
    /// folders/folder_number/feeds/feed_id
    /// organizations/organization_number/feeds/feed_id
    pub feed: std::option::Option<crate::model::Feed>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateFeedRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFeedRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [feed_id][crate::model::CreateFeedRequest::feed_id].
    pub fn set_feed_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feed_id = v.into();
        self
    }

    /// Sets the value of [feed][crate::model::CreateFeedRequest::feed].
    pub fn set_feed<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Feed>,
    {
        self.feed = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [feed][crate::model::CreateFeedRequest::feed].
    pub fn set_or_clear_feed<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Feed>,
    {
        self.feed = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateFeedRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.CreateFeedRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateFeedRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __feed_id,
            __feed,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateFeedRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "feedId" => Ok(__FieldTag::__feed_id),
                            "feed_id" => Ok(__FieldTag::__feed_id),
                            "feed" => Ok(__FieldTag::__feed),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateFeedRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateFeedRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__feed_id => {
                            if !fields.insert(__FieldTag::__feed_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feed_id",
                                ));
                            }
                            result.feed_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__feed => {
                            if !fields.insert(__FieldTag::__feed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feed",
                                ));
                            }
                            result.feed =
                                map.next_value::<std::option::Option<crate::model::Feed>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateFeedRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.feed_id.is_empty() {
            state.serialize_entry("feedId", &self.feed_id)?;
        }
        if self.feed.is_some() {
            state.serialize_entry("feed", &self.feed)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateFeedRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateFeedRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("feed_id", &self.feed_id);
        debug_struct.field("feed", &self.feed);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Get asset feed request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFeedRequest {
    /// Required. The name of the Feed and it must be in the format of:
    /// projects/project_number/feeds/feed_id
    /// folders/folder_number/feeds/feed_id
    /// organizations/organization_number/feeds/feed_id
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFeedRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeedRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFeedRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.GetFeedRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetFeedRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFeedRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetFeedRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFeedRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetFeedRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetFeedRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetFeedRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List asset feeds request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFeedsRequest {
    /// Required. The parent project/folder/organization whose feeds are to be
    /// listed. It can only be using project/folder/organization number (such as
    /// "folders/12345")", or a project ID (such as "projects/my-project-id").
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFeedsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeedsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListFeedsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.ListFeedsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFeedsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFeedsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFeedsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFeedsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFeedsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListFeedsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFeedsRequest");
        debug_struct.field("parent", &self.parent);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFeedsResponse {
    /// A list of feeds.
    pub feeds: std::vec::Vec<crate::model::Feed>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFeedsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feeds][crate::model::ListFeedsResponse::feeds].
    pub fn set_feeds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Feed>,
    {
        use std::iter::Iterator;
        self.feeds = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFeedsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.ListFeedsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFeedsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __feeds,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFeedsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "feeds" => Ok(__FieldTag::__feeds),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFeedsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFeedsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__feeds => {
                            if !fields.insert(__FieldTag::__feeds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feeds",
                                ));
                            }
                            result.feeds = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Feed>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFeedsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.feeds.is_empty() {
            state.serialize_entry("feeds", &self.feeds)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListFeedsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFeedsResponse");
        debug_struct.field("feeds", &self.feeds);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Update asset feed request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateFeedRequest {
    /// Required. The new values of feed details. It must match an existing feed
    /// and the field `name` must be in the format of:
    /// projects/project_number/feeds/feed_id or
    /// folders/folder_number/feeds/feed_id or
    /// organizations/organization_number/feeds/feed_id.
    pub feed: std::option::Option<crate::model::Feed>,

    /// Required. Only updates the `feed` fields indicated by this mask.
    /// The field mask must not be empty, and it must not contain fields that
    /// are immutable or only set by the server.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFeedRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feed][crate::model::UpdateFeedRequest::feed].
    pub fn set_feed<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Feed>,
    {
        self.feed = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [feed][crate::model::UpdateFeedRequest::feed].
    pub fn set_or_clear_feed<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Feed>,
    {
        self.feed = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFeedRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateFeedRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateFeedRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.UpdateFeedRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateFeedRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __feed,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateFeedRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "feed" => Ok(__FieldTag::__feed),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateFeedRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateFeedRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__feed => {
                            if !fields.insert(__FieldTag::__feed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feed",
                                ));
                            }
                            result.feed =
                                map.next_value::<std::option::Option<crate::model::Feed>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateFeedRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.feed.is_some() {
            state.serialize_entry("feed", &self.feed)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateFeedRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateFeedRequest");
        debug_struct.field("feed", &self.feed);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteFeedRequest {
    /// Required. The name of the feed and it must be in the format of:
    /// projects/project_number/feeds/feed_id
    /// folders/folder_number/feeds/feed_id
    /// organizations/organization_number/feeds/feed_id
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteFeedRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFeedRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFeedRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.DeleteFeedRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteFeedRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteFeedRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteFeedRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteFeedRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteFeedRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteFeedRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteFeedRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Output configuration for export assets destination.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OutputConfig {
    /// Asset export destination.
    pub destination: std::option::Option<crate::model::output_config::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::OutputConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::output_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::OutputConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::output_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::OutputConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::output_config::Destination::GcsDestination(v.into()),
        );
        self
    }

    /// The value of [destination][crate::model::OutputConfig::destination]
    /// if it holds a `BigqueryDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::output_config::Destination::BigqueryDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::OutputConfig::destination]
    /// to hold a `BigqueryDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_bigquery_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::output_config::Destination::BigqueryDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.OutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            __bigquery_destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            "bigqueryDestination" => Ok(__FieldTag::__bigquery_destination),
                            "bigquery_destination" => Ok(__FieldTag::__bigquery_destination),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.asset.v1.OutputConfig.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::output_config::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsDestination>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bigquery_destination => {
                            if !fields.insert(__FieldTag::__bigquery_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.asset.v1.OutputConfig.bigquery_destination, latest field was bigqueryDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::output_config::Destination::BigqueryDestination(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryDestination>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if let Some(value) = self.bigquery_destination() {
            state.serialize_entry("bigqueryDestination", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OutputConfig");
        debug_struct.field("destination", &self.destination);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OutputConfig].
pub mod output_config {
    #[allow(unused_imports)]
    use super::*;

    /// Asset export destination.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Destination on Cloud Storage.
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
        /// Destination on BigQuery. The output table stores the fields in asset
        /// Protobuf as columns in BigQuery.
        BigqueryDestination(std::boxed::Box<crate::model::BigQueryDestination>),
    }
}

/// Output result of export assets.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OutputResult {
    /// Asset export result.
    pub result: std::option::Option<crate::model::output_result::Result>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutputResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::OutputResult::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::output_result::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::OutputResult::result]
    /// if it holds a `GcsResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsOutputResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::output_result::Result::GcsResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::OutputResult::result]
    /// to hold a `GcsResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_gcs_result<T: std::convert::Into<std::boxed::Box<crate::model::GcsOutputResult>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::output_result::Result::GcsResult(v.into()));
        self
    }
}

impl wkt::message::Message for OutputResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.OutputResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OutputResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsResult" => Ok(__FieldTag::__gcs_result),
                            "gcs_result" => Ok(__FieldTag::__gcs_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OutputResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_result => {
                            if !fields.insert(__FieldTag::__gcs_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.asset.v1.OutputResult.gcs_result, latest field was gcsResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::output_result::Result::GcsResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsOutputResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OutputResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_result() {
            state.serialize_entry("gcsResult", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OutputResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OutputResult");
        debug_struct.field("result", &self.result);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OutputResult].
pub mod output_result {
    #[allow(unused_imports)]
    use super::*;

    /// Asset export result.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// Export result on Cloud Storage.
        GcsResult(std::boxed::Box<crate::model::GcsOutputResult>),
    }
}

/// A Cloud Storage output result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsOutputResult {
    /// List of URIs of the Cloud Storage objects. Example:
    /// "gs://bucket_name/object_name".
    pub uris: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsOutputResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uris][crate::model::GcsOutputResult::uris].
    pub fn set_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GcsOutputResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.GcsOutputResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsOutputResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uris,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsOutputResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uris" => Ok(__FieldTag::__uris),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsOutputResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsOutputResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uris => {
                            if !fields.insert(__FieldTag::__uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uris",
                                ));
                            }
                            result.uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsOutputResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uris.is_empty() {
            state.serialize_entry("uris", &self.uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsOutputResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsOutputResult");
        debug_struct.field("uris", &self.uris);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A Cloud Storage location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsDestination {
    /// Required.
    pub object_uri: std::option::Option<crate::model::gcs_destination::ObjectUri>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object_uri][crate::model::GcsDestination::object_uri].
    ///
    /// Note that all the setters affecting `object_uri` are mutually
    /// exclusive.
    pub fn set_object_uri<
        T: std::convert::Into<std::option::Option<crate::model::gcs_destination::ObjectUri>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.object_uri = v.into();
        self
    }

    /// The value of [object_uri][crate::model::GcsDestination::object_uri]
    /// if it holds a `Uri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.object_uri.as_ref().and_then(|v| match v {
            crate::model::gcs_destination::ObjectUri::Uri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [object_uri][crate::model::GcsDestination::object_uri]
    /// to hold a `Uri`.
    ///
    /// Note that all the setters affecting `object_uri` are
    /// mutually exclusive.
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object_uri =
            std::option::Option::Some(crate::model::gcs_destination::ObjectUri::Uri(v.into()));
        self
    }

    /// The value of [object_uri][crate::model::GcsDestination::object_uri]
    /// if it holds a `UriPrefix`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uri_prefix(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.object_uri.as_ref().and_then(|v| match v {
            crate::model::gcs_destination::ObjectUri::UriPrefix(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [object_uri][crate::model::GcsDestination::object_uri]
    /// to hold a `UriPrefix`.
    ///
    /// Note that all the setters affecting `object_uri` are
    /// mutually exclusive.
    pub fn set_uri_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object_uri = std::option::Option::Some(
            crate::model::gcs_destination::ObjectUri::UriPrefix(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GcsDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.GcsDestination"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __uri_prefix,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "uriPrefix" => Ok(__FieldTag::__uri_prefix),
                            "uri_prefix" => Ok(__FieldTag::__uri_prefix),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            if result.object_uri.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `object_uri`, a oneof with full ID .google.cloud.asset.v1.GcsDestination.uri, latest field was uri",
                                ));
                            }
                            result.object_uri = std::option::Option::Some(
                                crate::model::gcs_destination::ObjectUri::Uri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__uri_prefix => {
                            if !fields.insert(__FieldTag::__uri_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri_prefix",
                                ));
                            }
                            if result.object_uri.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `object_uri`, a oneof with full ID .google.cloud.asset.v1.GcsDestination.uri_prefix, latest field was uriPrefix",
                                ));
                            }
                            result.object_uri = std::option::Option::Some(
                                crate::model::gcs_destination::ObjectUri::UriPrefix(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.uri() {
            state.serialize_entry("uri", value)?;
        }
        if let Some(value) = self.uri_prefix() {
            state.serialize_entry("uriPrefix", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsDestination");
        debug_struct.field("object_uri", &self.object_uri);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GcsDestination].
pub mod gcs_destination {
    #[allow(unused_imports)]
    use super::*;

    /// Required.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ObjectUri {
        /// The URI of the Cloud Storage object. It's the same URI that is used by
        /// gsutil. Example: "gs://bucket_name/object_name". See [Viewing and
        /// Editing Object
        /// Metadata](https://cloud.google.com/storage/docs/viewing-editing-metadata)
        /// for more information.
        ///
        /// If the specified Cloud Storage object already exists and there is no
        /// [hold](https://cloud.google.com/storage/docs/object-holds), it will be
        /// overwritten with the exported result.
        Uri(std::string::String),
        /// The URI prefix of all generated Cloud Storage objects. Example:
        /// "gs://bucket_name/object_name_prefix". Each object URI is in format:
        /// "gs://bucket_name/object_name_prefix/\<asset type\>/\<shard number\> and only
        /// contains assets for that type. \<shard number\> starts from 0. Example:
        /// "gs://bucket_name/object_name_prefix/compute.googleapis.com/Disk/0" is
        /// the first shard of output objects containing all
        /// compute.googleapis.com/Disk assets. An INVALID_ARGUMENT error will be
        /// returned if file with the same name "gs://bucket_name/object_name_prefix"
        /// already exists.
        UriPrefix(std::string::String),
    }
}

/// A BigQuery destination for exporting assets to.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryDestination {
    /// Required. The BigQuery dataset in format
    /// "projects/projectId/datasets/datasetId", to which the snapshot result
    /// should be exported. If this dataset does not exist, the export call returns
    /// an INVALID_ARGUMENT error. Setting the `contentType` for `exportAssets`
    /// determines the
    /// [schema](/asset-inventory/docs/exporting-to-bigquery#bigquery-schema)
    /// of the BigQuery table. Setting `separateTablesPerAssetType` to `TRUE` also
    /// influences the schema.
    pub dataset: std::string::String,

    /// Required. The BigQuery table to which the snapshot result should be
    /// written. If this table does not exist, a new table with the given name
    /// will be created.
    pub table: std::string::String,

    /// If the destination table already exists and this flag is `TRUE`, the
    /// table will be overwritten by the contents of assets snapshot. If the flag
    /// is `FALSE` or unset and the destination table already exists, the export
    /// call returns an INVALID_ARGUMEMT error.
    pub force: bool,

    /// [partition_spec] determines whether to export to partitioned table(s) and
    /// how to partition the data.
    ///
    /// If [partition_spec] is unset or [partition_spec.partition_key] is unset or
    /// `PARTITION_KEY_UNSPECIFIED`, the snapshot results will be exported to
    /// non-partitioned table(s). [force] will decide whether to overwrite existing
    /// table(s).
    ///
    /// If [partition_spec] is specified. First, the snapshot results will be
    /// written to partitioned table(s) with two additional timestamp columns,
    /// readTime and requestTime, one of which will be the partition key. Secondly,
    /// in the case when any destination table already exists, it will first try to
    /// update existing table's schema as necessary by appending additional
    /// columns. Then, if [force] is `TRUE`, the corresponding partition will be
    /// overwritten by the snapshot results (data in different partitions will
    /// remain intact); if [force] is unset or `FALSE`, it will append the data. An
    /// error will be returned if the schema update or data appension fails.
    pub partition_spec: std::option::Option<crate::model::PartitionSpec>,

    /// If this flag is `TRUE`, the snapshot results will be written to one or
    /// multiple tables, each of which contains results of one asset type. The
    /// [force] and [partition_spec] fields will apply to each of them.
    ///
    /// Field [table] will be concatenated with "_" and the asset type names (see
    /// <https://cloud.google.com/asset-inventory/docs/supported-asset-types> for
    /// supported asset types) to construct per-asset-type table names, in which
    /// all non-alphanumeric characters like "." and "/" will be substituted by
    /// "_". Example: if field [table] is "mytable" and snapshot results
    /// contain "storage.googleapis.com/Bucket" assets, the corresponding table
    /// name will be "mytable_storage_googleapis_com_Bucket". If any of these
    /// tables does not exist, a new table with the concatenated name will be
    /// created.
    ///
    /// When [content_type] in the ExportAssetsRequest is `RESOURCE`, the schema of
    /// each table will include RECORD-type columns mapped to the nested fields in
    /// the Asset.resource.data field of that asset type (up to the 15 nested level
    /// BigQuery supports
    /// (<https://cloud.google.com/bigquery/docs/nested-repeated#limitations>)). The
    /// fields in >15 nested levels will be stored in JSON format string as a child
    /// column of its parent RECORD column.
    ///
    /// If error occurs when exporting to any table, the whole export call will
    /// return an error but the export results that already succeed will persist.
    /// Example: if exporting to table_type_A succeeds when exporting to
    /// table_type_B fails during one export call, the results in table_type_A will
    /// persist and there will not be partial results persisting in a table.
    pub separate_tables_per_asset_type: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::BigQueryDestination::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [table][crate::model::BigQueryDestination::table].
    pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [force][crate::model::BigQueryDestination::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }

    /// Sets the value of [partition_spec][crate::model::BigQueryDestination::partition_spec].
    pub fn set_partition_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PartitionSpec>,
    {
        self.partition_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [partition_spec][crate::model::BigQueryDestination::partition_spec].
    pub fn set_or_clear_partition_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PartitionSpec>,
    {
        self.partition_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [separate_tables_per_asset_type][crate::model::BigQueryDestination::separate_tables_per_asset_type].
    pub fn set_separate_tables_per_asset_type<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.separate_tables_per_asset_type = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.BigQueryDestination"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset,
            __table,
            __force,
            __partition_spec,
            __separate_tables_per_asset_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataset" => Ok(__FieldTag::__dataset),
                            "table" => Ok(__FieldTag::__table),
                            "force" => Ok(__FieldTag::__force),
                            "partitionSpec" => Ok(__FieldTag::__partition_spec),
                            "partition_spec" => Ok(__FieldTag::__partition_spec),
                            "separateTablesPerAssetType" => {
                                Ok(__FieldTag::__separate_tables_per_asset_type)
                            }
                            "separate_tables_per_asset_type" => {
                                Ok(__FieldTag::__separate_tables_per_asset_type)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partition_spec => {
                            if !fields.insert(__FieldTag::__partition_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partition_spec",
                                ));
                            }
                            result.partition_spec = map
                                .next_value::<std::option::Option<crate::model::PartitionSpec>>()?;
                        }
                        __FieldTag::__separate_tables_per_asset_type => {
                            if !fields.insert(__FieldTag::__separate_tables_per_asset_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for separate_tables_per_asset_type",
                                ));
                            }
                            result.separate_tables_per_asset_type = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset.is_empty() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !self.table.is_empty() {
            state.serialize_entry("table", &self.table)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if self.partition_spec.is_some() {
            state.serialize_entry("partitionSpec", &self.partition_spec)?;
        }
        if !wkt::internal::is_default(&self.separate_tables_per_asset_type) {
            state.serialize_entry(
                "separateTablesPerAssetType",
                &self.separate_tables_per_asset_type,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BigQueryDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigQueryDestination");
        debug_struct.field("dataset", &self.dataset);
        debug_struct.field("table", &self.table);
        debug_struct.field("force", &self.force);
        debug_struct.field("partition_spec", &self.partition_spec);
        debug_struct.field(
            "separate_tables_per_asset_type",
            &self.separate_tables_per_asset_type,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specifications of BigQuery partitioned table as export destination.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PartitionSpec {
    /// The partition key for BigQuery partitioned table.
    pub partition_key: crate::model::partition_spec::PartitionKey,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PartitionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [partition_key][crate::model::PartitionSpec::partition_key].
    pub fn set_partition_key<T: std::convert::Into<crate::model::partition_spec::PartitionKey>>(
        mut self,
        v: T,
    ) -> Self {
        self.partition_key = v.into();
        self
    }
}

impl wkt::message::Message for PartitionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.PartitionSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PartitionSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __partition_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PartitionSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "partitionKey" => Ok(__FieldTag::__partition_key),
                            "partition_key" => Ok(__FieldTag::__partition_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PartitionSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PartitionSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__partition_key => {
                            if !fields.insert(__FieldTag::__partition_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partition_key",
                                ));
                            }
                            result.partition_key = map.next_value::<std::option::Option<crate::model::partition_spec::PartitionKey>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PartitionSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.partition_key) {
            state.serialize_entry("partitionKey", &self.partition_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PartitionSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PartitionSpec");
        debug_struct.field("partition_key", &self.partition_key);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PartitionSpec].
pub mod partition_spec {
    #[allow(unused_imports)]
    use super::*;

    /// This enum is used to determine the partition key column when exporting
    /// assets to BigQuery partitioned table(s). Note that, if the partition key is
    /// a timestamp column, the actual partition is based on its date value
    /// (expressed in UTC. see details in
    /// <https://cloud.google.com/bigquery/docs/partitioned-tables#date_timestamp_partitioned_tables>).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PartitionKey {
        /// Unspecified partition key. If used, it means using non-partitioned table.
        Unspecified,
        /// The time when the snapshot is taken. If specified as partition key, the
        /// result table(s) is partitioned by the additional timestamp column,
        /// readTime. If [read_time] in ExportAssetsRequest is specified, the
        /// readTime column's value will be the same as it. Otherwise, its value will
        /// be the current time that is used to take the snapshot.
        ReadTime,
        /// The time when the request is received and started to be processed. If
        /// specified as partition key, the result table(s) is partitioned by the
        /// requestTime column, an additional timestamp column representing when the
        /// request was received.
        RequestTime,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PartitionKey::value] or
        /// [PartitionKey::name].
        UnknownValue(partition_key::UnknownValue),
    }

    #[doc(hidden)]
    pub mod partition_key {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PartitionKey {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ReadTime => std::option::Option::Some(1),
                Self::RequestTime => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PARTITION_KEY_UNSPECIFIED"),
                Self::ReadTime => std::option::Option::Some("READ_TIME"),
                Self::RequestTime => std::option::Option::Some("REQUEST_TIME"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PartitionKey {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PartitionKey {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PartitionKey {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ReadTime,
                2 => Self::RequestTime,
                _ => Self::UnknownValue(partition_key::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PartitionKey {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PARTITION_KEY_UNSPECIFIED" => Self::Unspecified,
                "READ_TIME" => Self::ReadTime,
                "REQUEST_TIME" => Self::RequestTime,
                _ => Self::UnknownValue(partition_key::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PartitionKey {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ReadTime => serializer.serialize_i32(1),
                Self::RequestTime => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PartitionKey {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PartitionKey>::new(
                ".google.cloud.asset.v1.PartitionSpec.PartitionKey",
            ))
        }
    }
}

/// A Pub/Sub destination.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PubsubDestination {
    /// The name of the Pub/Sub topic to publish to.
    /// Example: `projects/PROJECT_ID/topics/TOPIC_ID`.
    pub topic: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PubsubDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::PubsubDestination::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }
}

impl wkt::message::Message for PubsubDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.PubsubDestination"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PubsubDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __topic,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PubsubDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "topic" => Ok(__FieldTag::__topic),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PubsubDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PubsubDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic",
                                ));
                            }
                            result.topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PubsubDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.topic.is_empty() {
            state.serialize_entry("topic", &self.topic)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PubsubDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PubsubDestination");
        debug_struct.field("topic", &self.topic);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Output configuration for asset feed destination.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FeedOutputConfig {
    /// Asset feed destination.
    pub destination: std::option::Option<crate::model::feed_output_config::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FeedOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::FeedOutputConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::feed_output_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::FeedOutputConfig::destination]
    /// if it holds a `PubsubDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pubsub_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PubsubDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::feed_output_config::Destination::PubsubDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::FeedOutputConfig::destination]
    /// to hold a `PubsubDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_pubsub_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::PubsubDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::feed_output_config::Destination::PubsubDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FeedOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.FeedOutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FeedOutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pubsub_destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FeedOutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pubsubDestination" => Ok(__FieldTag::__pubsub_destination),
                            "pubsub_destination" => Ok(__FieldTag::__pubsub_destination),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FeedOutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FeedOutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pubsub_destination => {
                            if !fields.insert(__FieldTag::__pubsub_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.asset.v1.FeedOutputConfig.pubsub_destination, latest field was pubsubDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::feed_output_config::Destination::PubsubDestination(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PubsubDestination>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FeedOutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.pubsub_destination() {
            state.serialize_entry("pubsubDestination", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FeedOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FeedOutputConfig");
        debug_struct.field("destination", &self.destination);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [FeedOutputConfig].
pub mod feed_output_config {
    #[allow(unused_imports)]
    use super::*;

    /// Asset feed destination.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Destination on Pub/Sub.
        PubsubDestination(std::boxed::Box<crate::model::PubsubDestination>),
    }
}

/// An asset feed used to export asset updates to a destinations.
/// An asset feed filter controls what updates are exported.
/// The asset feed must be created within a project, organization, or
/// folder. Supported destinations are:
/// Pub/Sub topics.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Feed {
    /// Required. The format will be
    /// projects/{project_number}/feeds/{client-assigned_feed_identifier} or
    /// folders/{folder_number}/feeds/{client-assigned_feed_identifier} or
    /// organizations/{organization_number}/feeds/{client-assigned_feed_identifier}
    ///
    /// The client-assigned feed identifier must be unique within the parent
    /// project/folder/organization.
    pub name: std::string::String,

    /// A list of the full names of the assets to receive updates. You must specify
    /// either or both of asset_names and asset_types. Only asset updates matching
    /// specified asset_names or asset_types are exported to the feed.
    /// Example:
    /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
    /// For a list of the full names for supported asset types, see [Resource
    /// name format](/asset-inventory/docs/resource-name-format).
    pub asset_names: std::vec::Vec<std::string::String>,

    /// A list of types of the assets to receive updates. You must specify either
    /// or both of asset_names and asset_types. Only asset updates matching
    /// specified asset_names or asset_types are exported to the feed.
    /// Example: `"compute.googleapis.com/Disk"`
    ///
    /// For a list of all supported asset types, see
    /// [Supported asset types](/asset-inventory/docs/supported-asset-types).
    pub asset_types: std::vec::Vec<std::string::String>,

    /// Asset content type. If not specified, no content but the asset name and
    /// type will be returned.
    pub content_type: crate::model::ContentType,

    /// Required. Feed output configuration defining where the asset updates are
    /// published to.
    pub feed_output_config: std::option::Option<crate::model::FeedOutputConfig>,

    /// A condition which determines whether an asset update should be published.
    /// If specified, an asset will be returned only when the expression evaluates
    /// to true.
    /// When set, `expression` field in the `Expr` must be a valid [CEL expression]
    /// (<https://github.com/google/cel-spec>) on a TemporalAsset with name
    /// `temporal_asset`. Example: a Feed with expression ("temporal_asset.deleted
    /// == true") will only publish Asset deletions. Other fields of `Expr` are
    /// optional.
    ///
    /// See our [user
    /// guide](https://cloud.google.com/asset-inventory/docs/monitoring-asset-changes-with-condition)
    /// for detailed instructions.
    pub condition: std::option::Option<gtype::model::Expr>,

    /// A list of relationship types to output, for example:
    /// `INSTANCE_TO_INSTANCEGROUP`. This field should only be specified if
    /// content_type=RELATIONSHIP.
    ///
    /// * If specified:
    ///   it outputs specified relationship updates on the [asset_names] or the
    ///   [asset_types]. It returns an error if any of the [relationship_types]
    ///   doesn't belong to the supported relationship types of the [asset_names] or
    ///   [asset_types], or any of the [asset_names] or the [asset_types] doesn't
    ///   belong to the source types of the [relationship_types].
    /// * Otherwise:
    ///   it outputs the supported relationships of the types of [asset_names] and
    ///   [asset_types] or returns an error if any of the [asset_names] or the
    ///   [asset_types] has no replationship support.
    ///   See [Introduction to Cloud Asset
    ///   Inventory](https://cloud.google.com/asset-inventory/docs/overview)
    ///   for all supported asset types and relationship types.
    pub relationship_types: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Feed {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Feed::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [asset_names][crate::model::Feed::asset_names].
    pub fn set_asset_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.asset_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [asset_types][crate::model::Feed::asset_types].
    pub fn set_asset_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.asset_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [content_type][crate::model::Feed::content_type].
    pub fn set_content_type<T: std::convert::Into<crate::model::ContentType>>(
        mut self,
        v: T,
    ) -> Self {
        self.content_type = v.into();
        self
    }

    /// Sets the value of [feed_output_config][crate::model::Feed::feed_output_config].
    pub fn set_feed_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FeedOutputConfig>,
    {
        self.feed_output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [feed_output_config][crate::model::Feed::feed_output_config].
    pub fn set_or_clear_feed_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FeedOutputConfig>,
    {
        self.feed_output_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [condition][crate::model::Feed::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Expr>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::Feed::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Expr>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [relationship_types][crate::model::Feed::relationship_types].
    pub fn set_relationship_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.relationship_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Feed {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.Feed"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Feed {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __asset_names,
            __asset_types,
            __content_type,
            __feed_output_config,
            __condition,
            __relationship_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Feed")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "assetNames" => Ok(__FieldTag::__asset_names),
                            "asset_names" => Ok(__FieldTag::__asset_names),
                            "assetTypes" => Ok(__FieldTag::__asset_types),
                            "asset_types" => Ok(__FieldTag::__asset_types),
                            "contentType" => Ok(__FieldTag::__content_type),
                            "content_type" => Ok(__FieldTag::__content_type),
                            "feedOutputConfig" => Ok(__FieldTag::__feed_output_config),
                            "feed_output_config" => Ok(__FieldTag::__feed_output_config),
                            "condition" => Ok(__FieldTag::__condition),
                            "relationshipTypes" => Ok(__FieldTag::__relationship_types),
                            "relationship_types" => Ok(__FieldTag::__relationship_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Feed;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Feed")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset_names => {
                            if !fields.insert(__FieldTag::__asset_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_names",
                                ));
                            }
                            result.asset_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__asset_types => {
                            if !fields.insert(__FieldTag::__asset_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_types",
                                ));
                            }
                            result.asset_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__content_type => {
                            if !fields.insert(__FieldTag::__content_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_type",
                                ));
                            }
                            result.content_type = map
                                .next_value::<std::option::Option<crate::model::ContentType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__feed_output_config => {
                            if !fields.insert(__FieldTag::__feed_output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feed_output_config",
                                ));
                            }
                            result.feed_output_config = map
                                .next_value::<std::option::Option<crate::model::FeedOutputConfig>>(
                                )?;
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition =
                                map.next_value::<std::option::Option<gtype::model::Expr>>()?;
                        }
                        __FieldTag::__relationship_types => {
                            if !fields.insert(__FieldTag::__relationship_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relationship_types",
                                ));
                            }
                            result.relationship_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Feed {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.asset_names.is_empty() {
            state.serialize_entry("assetNames", &self.asset_names)?;
        }
        if !self.asset_types.is_empty() {
            state.serialize_entry("assetTypes", &self.asset_types)?;
        }
        if !wkt::internal::is_default(&self.content_type) {
            state.serialize_entry("contentType", &self.content_type)?;
        }
        if self.feed_output_config.is_some() {
            state.serialize_entry("feedOutputConfig", &self.feed_output_config)?;
        }
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self.relationship_types.is_empty() {
            state.serialize_entry("relationshipTypes", &self.relationship_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Feed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Feed");
        debug_struct.field("name", &self.name);
        debug_struct.field("asset_names", &self.asset_names);
        debug_struct.field("asset_types", &self.asset_types);
        debug_struct.field("content_type", &self.content_type);
        debug_struct.field("feed_output_config", &self.feed_output_config);
        debug_struct.field("condition", &self.condition);
        debug_struct.field("relationship_types", &self.relationship_types);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Search all resources request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchAllResourcesRequest {
    /// Required. A scope can be a project, a folder, or an organization. The
    /// search is limited to the resources within the `scope`. The caller must be
    /// granted the
    /// [`cloudasset.assets.searchAllResources`](https://cloud.google.com/asset-inventory/docs/access-control#required_permissions)
    /// permission on the desired scope.
    ///
    /// The allowed values are:
    ///
    /// * projects/{PROJECT_ID} (e.g., "projects/foo-bar")
    /// * projects/{PROJECT_NUMBER} (e.g., "projects/12345678")
    /// * folders/{FOLDER_NUMBER} (e.g., "folders/1234567")
    /// * organizations/{ORGANIZATION_NUMBER} (e.g., "organizations/123456")
    pub scope: std::string::String,

    /// Optional. The query statement. See [how to construct a
    /// query](https://cloud.google.com/asset-inventory/docs/searching-resources#how_to_construct_a_query)
    /// for more information. If not specified or empty, it will search all the
    /// resources within the specified `scope`.
    ///
    /// Examples:
    ///
    /// * `name:Important` to find Google Cloud resources whose name contains
    ///   `Important` as a word.
    /// * `name=Important` to find the Google Cloud resource whose name is exactly
    ///   `Important`.
    /// * `displayName:Impor*` to find Google Cloud resources whose display name
    ///   contains `Impor` as a prefix of any word in the field.
    /// * `location:us-west*` to find Google Cloud resources whose location
    ///   contains both `us` and `west` as prefixes.
    /// * `labels:prod` to find Google Cloud resources whose labels contain `prod`
    ///   as a key or value.
    /// * `labels.env:prod` to find Google Cloud resources that have a label `env`
    ///   and its value is `prod`.
    /// * `labels.env:*` to find Google Cloud resources that have a label `env`.
    /// * `tagKeys:env` to find Google Cloud resources that have directly
    ///   attached tags where the
    ///   [`TagKey.namespacedName`](https://cloud.google.com/resource-manager/reference/rest/v3/tagKeys#resource:-tagkey)
    ///   contains `env`.
    /// * `tagValues:prod*` to find Google Cloud resources that have directly
    ///   attached tags where the
    ///   [`TagValue.namespacedName`](https://cloud.google.com/resource-manager/reference/rest/v3/tagValues#resource:-tagvalue)
    ///   contains a word prefixed by `prod`.
    /// * `tagValueIds=tagValues/123` to find Google Cloud resources that have
    ///   directly attached tags where the
    ///   [`TagValue.name`](https://cloud.google.com/resource-manager/reference/rest/v3/tagValues#resource:-tagvalue)
    ///   is exactly `tagValues/123`.
    /// * `effectiveTagKeys:env` to find Google Cloud resources that have
    ///   directly attached or inherited tags where the
    ///   [`TagKey.namespacedName`](https://cloud.google.com/resource-manager/reference/rest/v3/tagKeys#resource:-tagkey)
    ///   contains `env`.
    /// * `effectiveTagValues:prod*` to find Google Cloud resources that have
    ///   directly attached or inherited tags where the
    ///   [`TagValue.namespacedName`](https://cloud.google.com/resource-manager/reference/rest/v3/tagValues#resource:-tagvalue)
    ///   contains a word prefixed by `prod`.
    /// * `effectiveTagValueIds=tagValues/123` to find Google Cloud resources that
    ///   have directly attached or inherited tags where the
    ///   [`TagValue.name`](https://cloud.google.com/resource-manager/reference/rest/v3/tagValues#resource:-tagvalue)
    ///   is exactly `tagValues/123`.
    /// * `kmsKey:key` to find Google Cloud resources encrypted with a
    ///   customer-managed encryption key whose name contains `key` as a word. This
    ///   field is deprecated. Use the `kmsKeys` field to retrieve Cloud KMS
    ///   key information.
    /// * `kmsKeys:key` to find Google Cloud resources encrypted with
    ///   customer-managed encryption keys whose name contains the word `key`.
    /// * `relationships:instance-group-1` to find Google Cloud resources that have
    ///   relationships with `instance-group-1` in the related resource name.
    /// * `relationships:INSTANCE_TO_INSTANCEGROUP` to find Compute Engine
    ///   instances that have relationships of type `INSTANCE_TO_INSTANCEGROUP`.
    /// * `relationships.INSTANCE_TO_INSTANCEGROUP:instance-group-1` to find
    ///   Compute Engine instances that have relationships with `instance-group-1`
    ///   in the Compute Engine instance group resource name, for relationship type
    ///   `INSTANCE_TO_INSTANCEGROUP`.
    /// * `sccSecurityMarks.key=value` to find Cloud resources that are attached
    ///   with security marks whose key is `key` and value is `value`.
    /// * `sccSecurityMarks.key:*` to find Cloud resources that are attached with
    ///   security marks whose key is `key`.
    /// * `state:ACTIVE` to find Google Cloud resources whose state contains
    ///   `ACTIVE` as a word.
    /// * `NOT state:ACTIVE` to find Google Cloud resources whose state doesn't
    ///   contain `ACTIVE` as a word.
    /// * `createTime<1609459200` to find Google Cloud resources that were created
    ///   before `2021-01-01 00:00:00 UTC`. `1609459200` is the epoch timestamp of
    ///   `2021-01-01 00:00:00 UTC` in seconds.
    /// * `updateTime>1609459200` to find Google Cloud resources that were updated
    ///   after `2021-01-01 00:00:00 UTC`. `1609459200` is the epoch timestamp of
    ///   `2021-01-01 00:00:00 UTC` in seconds.
    /// * `Important` to find Google Cloud resources that contain `Important` as a
    ///   word in any of the searchable fields.
    /// * `Impor*` to find Google Cloud resources that contain `Impor` as a prefix
    ///   of any word in any of the searchable fields.
    /// * `Important location:(us-west1 OR global)` to find Google Cloud
    ///   resources that contain `Important` as a word in any of the searchable
    ///   fields and are also located in the `us-west1` region or the `global`
    ///   location.
    pub query: std::string::String,

    /// Optional. A list of asset types that this request searches for. If empty,
    /// it will search all the asset types [supported by search
    /// APIs](https://cloud.google.com/asset-inventory/docs/supported-asset-types).
    ///
    /// Regular expressions are also supported. For example:
    ///
    /// * "compute.googleapis.com.*" snapshots resources whose asset type starts
    ///   with "compute.googleapis.com".
    /// * ".*Instance" snapshots resources whose asset type ends with "Instance".
    /// * ".*Instance.*" snapshots resources whose asset type contains "Instance".
    ///
    /// See [RE2](https://github.com/google/re2/wiki/Syntax) for all supported
    /// regular expression syntax. If the regular expression does not match any
    /// supported asset type, an INVALID_ARGUMENT error will be returned.
    pub asset_types: std::vec::Vec<std::string::String>,

    /// Optional. The page size for search result pagination. Page size is capped
    /// at 500 even if a larger value is given. If set to zero or a negative value,
    /// server will pick an appropriate default. Returned results may be fewer than
    /// requested. When this happens, there could be more results as long as
    /// `next_page_token` is returned.
    pub page_size: i32,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method. `page_token` must be the value of
    /// `next_page_token` from the previous response. The values of all other
    /// method parameters, must be identical to those in the previous call.
    pub page_token: std::string::String,

    /// Optional. A comma-separated list of fields specifying the sorting order of
    /// the results. The default order is ascending. Add " DESC" after the field
    /// name to indicate descending order. Redundant space characters are ignored.
    /// Example: "location DESC, name".
    /// Only the following fields in the response are sortable:
    ///
    /// * name
    /// * assetType
    /// * project
    /// * displayName
    /// * description
    /// * location
    /// * createTime
    /// * updateTime
    /// * state
    /// * parentFullResourceName
    /// * parentAssetType
    pub order_by: std::string::String,

    /// Optional. A comma-separated list of fields that you want returned in the
    /// results. The following fields are returned by default if not specified:
    ///
    /// * `name`
    /// * `assetType`
    /// * `project`
    /// * `folders`
    /// * `organization`
    /// * `displayName`
    /// * `description`
    /// * `location`
    /// * `labels`
    /// * `tags`
    /// * `effectiveTags`
    /// * `networkTags`
    /// * `kmsKeys`
    /// * `createTime`
    /// * `updateTime`
    /// * `state`
    /// * `additionalAttributes`
    /// * `parentFullResourceName`
    /// * `parentAssetType`
    ///
    /// Some fields of large size, such as `versionedResources`,
    /// `attachedResources`, `effectiveTags` etc., are not returned by default, but
    /// you can specify them in the `read_mask` parameter if you want to include
    /// them. If `"*"` is specified, all [available
    /// fields](https://cloud.google.com/asset-inventory/docs/reference/rest/v1/TopLevel/searchAllResources#resourcesearchresult)
    /// are returned.
    /// Examples: `"name,location"`, `"name,versionedResources"`, `"*"`.
    /// Any invalid field path will trigger INVALID_ARGUMENT error.
    pub read_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchAllResourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scope][crate::model::SearchAllResourcesRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchAllResourcesRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [asset_types][crate::model::SearchAllResourcesRequest::asset_types].
    pub fn set_asset_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.asset_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchAllResourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchAllResourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::SearchAllResourcesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::SearchAllResourcesRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::SearchAllResourcesRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchAllResourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.SearchAllResourcesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchAllResourcesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scope,
            __query,
            __asset_types,
            __page_size,
            __page_token,
            __order_by,
            __read_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchAllResourcesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scope" => Ok(__FieldTag::__scope),
                            "query" => Ok(__FieldTag::__query),
                            "assetTypes" => Ok(__FieldTag::__asset_types),
                            "asset_types" => Ok(__FieldTag::__asset_types),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchAllResourcesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchAllResourcesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset_types => {
                            if !fields.insert(__FieldTag::__asset_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_types",
                                ));
                            }
                            result.asset_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_mask",
                                ));
                            }
                            result.read_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchAllResourcesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.asset_types.is_empty() {
            state.serialize_entry("assetTypes", &self.asset_types)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchAllResourcesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchAllResourcesRequest");
        debug_struct.field("scope", &self.scope);
        debug_struct.field("query", &self.query);
        debug_struct.field("asset_types", &self.asset_types);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("read_mask", &self.read_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Search all resources response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchAllResourcesResponse {
    /// A list of Resources that match the search query. It contains the resource
    /// standard metadata information.
    pub results: std::vec::Vec<crate::model::ResourceSearchResult>,

    /// If there are more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchAllResourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::SearchAllResourcesResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceSearchResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchAllResourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchAllResourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.SearchAllResourcesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchAllResourcesResponse {
    type PageItem = crate::model::ResourceSearchResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchAllResourcesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __results,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchAllResourcesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "results" => Ok(__FieldTag::__results),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchAllResourcesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchAllResourcesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResourceSearchResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchAllResourcesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchAllResourcesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchAllResourcesResponse");
        debug_struct.field("results", &self.results);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Search all IAM policies request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchAllIamPoliciesRequest {
    /// Required. A scope can be a project, a folder, or an organization. The
    /// search is limited to the IAM policies within the `scope`. The caller must
    /// be granted the
    /// [`cloudasset.assets.searchAllIamPolicies`](https://cloud.google.com/asset-inventory/docs/access-control#required_permissions)
    /// permission on the desired scope.
    ///
    /// The allowed values are:
    ///
    /// * projects/{PROJECT_ID} (e.g., "projects/foo-bar")
    /// * projects/{PROJECT_NUMBER} (e.g., "projects/12345678")
    /// * folders/{FOLDER_NUMBER} (e.g., "folders/1234567")
    /// * organizations/{ORGANIZATION_NUMBER} (e.g., "organizations/123456")
    pub scope: std::string::String,

    /// Optional. The query statement. See [how to construct a
    /// query](https://cloud.google.com/asset-inventory/docs/searching-iam-policies#how_to_construct_a_query)
    /// for more information. If not specified or empty, it will search all the
    /// IAM policies within the specified `scope`. Note that the query string is
    /// compared against each IAM policy binding, including its principals,
    /// roles, and IAM conditions. The returned IAM policies will only
    /// contain the bindings that match your query. To learn more about the IAM
    /// policy structure, see the [IAM policy
    /// documentation](https://cloud.google.com/iam/help/allow-policies/structure).
    ///
    /// Examples:
    ///
    /// * `policy:amy@gmail.com` to find IAM policy bindings that specify user
    ///   "amy@gmail.com".
    /// * `policy:roles/compute.admin` to find IAM policy bindings that specify
    ///   the Compute Admin role.
    /// * `policy:comp*` to find IAM policy bindings that contain "comp" as a
    ///   prefix of any word in the binding.
    /// * `policy.role.permissions:storage.buckets.update` to find IAM policy
    ///   bindings that specify a role containing "storage.buckets.update"
    ///   permission. Note that if callers don't have `iam.roles.get` access to a
    ///   role's included permissions, policy bindings that specify this role will
    ///   be dropped from the search results.
    /// * `policy.role.permissions:upd*` to find IAM policy bindings that specify a
    ///   role containing "upd" as a prefix of any word in the role permission.
    ///   Note that if callers don't have `iam.roles.get` access to a role's
    ///   included permissions, policy bindings that specify this role will be
    ///   dropped from the search results.
    /// * `resource:organizations/123456` to find IAM policy bindings
    ///   that are set on "organizations/123456".
    /// * `resource=//cloudresourcemanager.googleapis.com/projects/myproject` to
    ///   find IAM policy bindings that are set on the project named "myproject".
    /// * `Important` to find IAM policy bindings that contain "Important" as a
    ///   word in any of the searchable fields (except for the included
    ///   permissions).
    /// * `resource:(instance1 OR instance2) policy:amy` to find
    ///   IAM policy bindings that are set on resources "instance1" or
    ///   "instance2" and also specify user "amy".
    /// * `roles:roles/compute.admin` to find IAM policy bindings that specify the
    ///   Compute Admin role.
    /// * `memberTypes:user` to find IAM policy bindings that contain the
    ///   principal type "user".
    pub query: std::string::String,

    /// Optional. The page size for search result pagination. Page size is capped
    /// at 500 even if a larger value is given. If set to zero or a negative value,
    /// server will pick an appropriate default. Returned results may be fewer than
    /// requested. When this happens, there could be more results as long as
    /// `next_page_token` is returned.
    pub page_size: i32,

    /// Optional. If present, retrieve the next batch of results from the preceding
    /// call to this method. `page_token` must be the value of `next_page_token`
    /// from the previous response. The values of all other method parameters must
    /// be identical to those in the previous call.
    pub page_token: std::string::String,

    /// Optional. A list of asset types that the IAM policies are attached to. If
    /// empty, it will search the IAM policies that are attached to all the asset
    /// types [supported by search
    /// APIs](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
    ///
    /// Regular expressions are also supported. For example:
    ///
    /// * "compute.googleapis.com.*" snapshots IAM policies attached to asset type
    ///   starts with "compute.googleapis.com".
    /// * ".*Instance" snapshots IAM policies attached to asset type ends with
    ///   "Instance".
    /// * ".*Instance.*" snapshots IAM policies attached to asset type contains
    ///   "Instance".
    ///
    /// See [RE2](https://github.com/google/re2/wiki/Syntax) for all supported
    /// regular expression syntax. If the regular expression does not match any
    /// supported asset type, an INVALID_ARGUMENT error will be returned.
    pub asset_types: std::vec::Vec<std::string::String>,

    /// Optional. A comma-separated list of fields specifying the sorting order of
    /// the results. The default order is ascending. Add " DESC" after the field
    /// name to indicate descending order. Redundant space characters are ignored.
    /// Example: "assetType DESC, resource".
    /// Only singular primitive fields in the response are sortable:
    ///
    /// * resource
    /// * assetType
    /// * project
    ///   All the other fields such as repeated fields (e.g., `folders`) and
    ///   non-primitive fields (e.g., `policy`) are not supported.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchAllIamPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scope][crate::model::SearchAllIamPoliciesRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchAllIamPoliciesRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchAllIamPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchAllIamPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [asset_types][crate::model::SearchAllIamPoliciesRequest::asset_types].
    pub fn set_asset_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.asset_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [order_by][crate::model::SearchAllIamPoliciesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for SearchAllIamPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.SearchAllIamPoliciesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchAllIamPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scope,
            __query,
            __page_size,
            __page_token,
            __asset_types,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchAllIamPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scope" => Ok(__FieldTag::__scope),
                            "query" => Ok(__FieldTag::__query),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "assetTypes" => Ok(__FieldTag::__asset_types),
                            "asset_types" => Ok(__FieldTag::__asset_types),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchAllIamPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchAllIamPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset_types => {
                            if !fields.insert(__FieldTag::__asset_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_types",
                                ));
                            }
                            result.asset_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchAllIamPoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.asset_types.is_empty() {
            state.serialize_entry("assetTypes", &self.asset_types)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchAllIamPoliciesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchAllIamPoliciesRequest");
        debug_struct.field("scope", &self.scope);
        debug_struct.field("query", &self.query);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("asset_types", &self.asset_types);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Search all IAM policies response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchAllIamPoliciesResponse {
    /// A list of IAM policies that match the search query. Related information
    /// such as the associated resource is returned along with the policy.
    pub results: std::vec::Vec<crate::model::IamPolicySearchResult>,

    /// Set if there are more results than those appearing in this response; to get
    /// the next set of results, call this method again, using this value as the
    /// `page_token`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchAllIamPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::SearchAllIamPoliciesResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IamPolicySearchResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchAllIamPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchAllIamPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.SearchAllIamPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchAllIamPoliciesResponse {
    type PageItem = crate::model::IamPolicySearchResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchAllIamPoliciesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __results,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchAllIamPoliciesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "results" => Ok(__FieldTag::__results),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchAllIamPoliciesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchAllIamPoliciesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::IamPolicySearchResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchAllIamPoliciesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchAllIamPoliciesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchAllIamPoliciesResponse");
        debug_struct.field("results", &self.results);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// IAM policy analysis query message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IamPolicyAnalysisQuery {
    /// Required. The relative name of the root asset. Only resources and IAM
    /// policies within the scope will be analyzed.
    ///
    /// This can only be an organization number (such as "organizations/123"), a
    /// folder number (such as "folders/123"), a project ID (such as
    /// "projects/my-project-id"), or a project number (such as "projects/12345").
    ///
    /// To know how to get organization ID, visit [here
    /// ](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).
    ///
    /// To know how to get folder or project ID, visit [here
    /// ](https://cloud.google.com/resource-manager/docs/creating-managing-folders#viewing_or_listing_folders_and_projects).
    pub scope: std::string::String,

    /// Optional. Specifies a resource for analysis.
    pub resource_selector:
        std::option::Option<crate::model::iam_policy_analysis_query::ResourceSelector>,

    /// Optional. Specifies an identity for analysis.
    pub identity_selector:
        std::option::Option<crate::model::iam_policy_analysis_query::IdentitySelector>,

    /// Optional. Specifies roles or permissions for analysis. This is optional.
    pub access_selector:
        std::option::Option<crate::model::iam_policy_analysis_query::AccessSelector>,

    /// Optional. The query options.
    pub options: std::option::Option<crate::model::iam_policy_analysis_query::Options>,

    /// Optional. The hypothetical context for IAM conditions evaluation.
    pub condition_context:
        std::option::Option<crate::model::iam_policy_analysis_query::ConditionContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IamPolicyAnalysisQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scope][crate::model::IamPolicyAnalysisQuery::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [resource_selector][crate::model::IamPolicyAnalysisQuery::resource_selector].
    pub fn set_resource_selector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_analysis_query::ResourceSelector>,
    {
        self.resource_selector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_selector][crate::model::IamPolicyAnalysisQuery::resource_selector].
    pub fn set_or_clear_resource_selector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_analysis_query::ResourceSelector>,
    {
        self.resource_selector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [identity_selector][crate::model::IamPolicyAnalysisQuery::identity_selector].
    pub fn set_identity_selector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_analysis_query::IdentitySelector>,
    {
        self.identity_selector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [identity_selector][crate::model::IamPolicyAnalysisQuery::identity_selector].
    pub fn set_or_clear_identity_selector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_analysis_query::IdentitySelector>,
    {
        self.identity_selector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [access_selector][crate::model::IamPolicyAnalysisQuery::access_selector].
    pub fn set_access_selector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_analysis_query::AccessSelector>,
    {
        self.access_selector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [access_selector][crate::model::IamPolicyAnalysisQuery::access_selector].
    pub fn set_or_clear_access_selector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_analysis_query::AccessSelector>,
    {
        self.access_selector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [options][crate::model::IamPolicyAnalysisQuery::options].
    pub fn set_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_analysis_query::Options>,
    {
        self.options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [options][crate::model::IamPolicyAnalysisQuery::options].
    pub fn set_or_clear_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_analysis_query::Options>,
    {
        self.options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [condition_context][crate::model::IamPolicyAnalysisQuery::condition_context].
    pub fn set_condition_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_analysis_query::ConditionContext>,
    {
        self.condition_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition_context][crate::model::IamPolicyAnalysisQuery::condition_context].
    pub fn set_or_clear_condition_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_analysis_query::ConditionContext>,
    {
        self.condition_context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IamPolicyAnalysisQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisQuery"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IamPolicyAnalysisQuery {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scope,
            __resource_selector,
            __identity_selector,
            __access_selector,
            __options,
            __condition_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IamPolicyAnalysisQuery")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scope" => Ok(__FieldTag::__scope),
                            "resourceSelector" => Ok(__FieldTag::__resource_selector),
                            "resource_selector" => Ok(__FieldTag::__resource_selector),
                            "identitySelector" => Ok(__FieldTag::__identity_selector),
                            "identity_selector" => Ok(__FieldTag::__identity_selector),
                            "accessSelector" => Ok(__FieldTag::__access_selector),
                            "access_selector" => Ok(__FieldTag::__access_selector),
                            "options" => Ok(__FieldTag::__options),
                            "conditionContext" => Ok(__FieldTag::__condition_context),
                            "condition_context" => Ok(__FieldTag::__condition_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IamPolicyAnalysisQuery;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IamPolicyAnalysisQuery")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_selector => {
                            if !fields.insert(__FieldTag::__resource_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_selector",
                                ));
                            }
                            result.resource_selector = map.next_value::<std::option::Option<
                                crate::model::iam_policy_analysis_query::ResourceSelector,
                            >>()?;
                        }
                        __FieldTag::__identity_selector => {
                            if !fields.insert(__FieldTag::__identity_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity_selector",
                                ));
                            }
                            result.identity_selector = map.next_value::<std::option::Option<
                                crate::model::iam_policy_analysis_query::IdentitySelector,
                            >>()?;
                        }
                        __FieldTag::__access_selector => {
                            if !fields.insert(__FieldTag::__access_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_selector",
                                ));
                            }
                            result.access_selector = map.next_value::<std::option::Option<
                                crate::model::iam_policy_analysis_query::AccessSelector,
                            >>()?;
                        }
                        __FieldTag::__options => {
                            if !fields.insert(__FieldTag::__options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for options",
                                ));
                            }
                            result.options = map.next_value::<std::option::Option<
                                crate::model::iam_policy_analysis_query::Options,
                            >>()?;
                        }
                        __FieldTag::__condition_context => {
                            if !fields.insert(__FieldTag::__condition_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition_context",
                                ));
                            }
                            result.condition_context = map.next_value::<std::option::Option<
                                crate::model::iam_policy_analysis_query::ConditionContext,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IamPolicyAnalysisQuery {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if self.resource_selector.is_some() {
            state.serialize_entry("resourceSelector", &self.resource_selector)?;
        }
        if self.identity_selector.is_some() {
            state.serialize_entry("identitySelector", &self.identity_selector)?;
        }
        if self.access_selector.is_some() {
            state.serialize_entry("accessSelector", &self.access_selector)?;
        }
        if self.options.is_some() {
            state.serialize_entry("options", &self.options)?;
        }
        if self.condition_context.is_some() {
            state.serialize_entry("conditionContext", &self.condition_context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IamPolicyAnalysisQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IamPolicyAnalysisQuery");
        debug_struct.field("scope", &self.scope);
        debug_struct.field("resource_selector", &self.resource_selector);
        debug_struct.field("identity_selector", &self.identity_selector);
        debug_struct.field("access_selector", &self.access_selector);
        debug_struct.field("options", &self.options);
        debug_struct.field("condition_context", &self.condition_context);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [IamPolicyAnalysisQuery].
pub mod iam_policy_analysis_query {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the resource to analyze for access policies, which may be set
    /// directly on the resource, or on ancestors such as organizations, folders or
    /// projects.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResourceSelector {
        /// Required. The [full resource name]
        /// (<https://cloud.google.com/asset-inventory/docs/resource-name-format>)
        /// of a resource of [supported resource
        /// types](https://cloud.google.com/asset-inventory/docs/supported-asset-types#analyzable_asset_types).
        pub full_resource_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceSelector {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [full_resource_name][crate::model::iam_policy_analysis_query::ResourceSelector::full_resource_name].
        pub fn set_full_resource_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.full_resource_name = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceSelector {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisQuery.ResourceSelector"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ResourceSelector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __full_resource_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ResourceSelector")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "fullResourceName" => Ok(__FieldTag::__full_resource_name),
                                "full_resource_name" => Ok(__FieldTag::__full_resource_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ResourceSelector;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ResourceSelector")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__full_resource_name => {
                                if !fields.insert(__FieldTag::__full_resource_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for full_resource_name",
                                    ));
                                }
                                result.full_resource_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ResourceSelector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.full_resource_name.is_empty() {
                state.serialize_entry("fullResourceName", &self.full_resource_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ResourceSelector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ResourceSelector");
            debug_struct.field("full_resource_name", &self.full_resource_name);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Specifies an identity for which to determine resource access, based on
    /// roles assigned either directly to them or to the groups they belong to,
    /// directly or indirectly.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IdentitySelector {
        /// Required. The identity appear in the form of principals in
        /// [IAM policy
        /// binding](https://cloud.google.com/iam/reference/rest/v1/Binding).
        ///
        /// The examples of supported forms are:
        /// "user:mike@example.com",
        /// "group:admins@example.com",
        /// "domain:google.com",
        /// "serviceAccount:my-project-id@appspot.gserviceaccount.com".
        ///
        /// Notice that wildcard characters (such as * and ?) are not supported.
        /// You must give a specific identity.
        pub identity: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IdentitySelector {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [identity][crate::model::iam_policy_analysis_query::IdentitySelector::identity].
        pub fn set_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.identity = v.into();
            self
        }
    }

    impl wkt::message::Message for IdentitySelector {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisQuery.IdentitySelector"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IdentitySelector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __identity,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IdentitySelector")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "identity" => Ok(__FieldTag::__identity),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IdentitySelector;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IdentitySelector")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__identity => {
                                if !fields.insert(__FieldTag::__identity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for identity",
                                    ));
                                }
                                result.identity = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IdentitySelector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.identity.is_empty() {
                state.serialize_entry("identity", &self.identity)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for IdentitySelector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("IdentitySelector");
            debug_struct.field("identity", &self.identity);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Specifies roles and/or permissions to analyze, to determine both the
    /// identities possessing them and the resources they control. If multiple
    /// values are specified, results will include roles or permissions matching
    /// any of them. The total number of roles and permissions should be equal or
    /// less than 10.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AccessSelector {
        /// Optional. The roles to appear in result.
        pub roles: std::vec::Vec<std::string::String>,

        /// Optional. The permissions to appear in result.
        pub permissions: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AccessSelector {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [roles][crate::model::iam_policy_analysis_query::AccessSelector::roles].
        pub fn set_roles<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.roles = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [permissions][crate::model::iam_policy_analysis_query::AccessSelector::permissions].
        pub fn set_permissions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.permissions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for AccessSelector {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisQuery.AccessSelector"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AccessSelector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __roles,
                __permissions,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AccessSelector")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "roles" => Ok(__FieldTag::__roles),
                                "permissions" => Ok(__FieldTag::__permissions),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AccessSelector;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AccessSelector")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__roles => {
                                if !fields.insert(__FieldTag::__roles) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for roles",
                                    ));
                                }
                                result.roles = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__permissions => {
                                if !fields.insert(__FieldTag::__permissions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for permissions",
                                    ));
                                }
                                result.permissions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AccessSelector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.roles.is_empty() {
                state.serialize_entry("roles", &self.roles)?;
            }
            if !self.permissions.is_empty() {
                state.serialize_entry("permissions", &self.permissions)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AccessSelector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AccessSelector");
            debug_struct.field("roles", &self.roles);
            debug_struct.field("permissions", &self.permissions);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Contains query options.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Options {
        /// Optional. If true, the identities section of the result will expand any
        /// Google groups appearing in an IAM policy binding.
        ///
        /// If
        /// [IamPolicyAnalysisQuery.identity_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.identity_selector]
        /// is specified, the identity in the result will be determined by the
        /// selector, and this flag is not allowed to set.
        ///
        /// If true, the default max expansion per group is 1000 for
        /// AssetService.AnalyzeIamPolicy][].
        ///
        /// Default is false.
        ///
        /// [google.cloud.asset.v1.IamPolicyAnalysisQuery.identity_selector]: crate::model::IamPolicyAnalysisQuery::identity_selector
        pub expand_groups: bool,

        /// Optional. If true, the access section of result will expand any roles
        /// appearing in IAM policy bindings to include their permissions.
        ///
        /// If
        /// [IamPolicyAnalysisQuery.access_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.access_selector]
        /// is specified, the access section of the result will be determined by the
        /// selector, and this flag is not allowed to set.
        ///
        /// Default is false.
        ///
        /// [google.cloud.asset.v1.IamPolicyAnalysisQuery.access_selector]: crate::model::IamPolicyAnalysisQuery::access_selector
        pub expand_roles: bool,

        /// Optional. If true and
        /// [IamPolicyAnalysisQuery.resource_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.resource_selector]
        /// is not specified, the resource section of the result will expand any
        /// resource attached to an IAM policy to include resources lower in the
        /// resource hierarchy.
        ///
        /// For example, if the request analyzes for which resources user A has
        /// permission P, and the results include an IAM policy with P on a Google
        /// Cloud folder, the results will also include resources in that folder with
        /// permission P.
        ///
        /// If true and
        /// [IamPolicyAnalysisQuery.resource_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.resource_selector]
        /// is specified, the resource section of the result will expand the
        /// specified resource to include resources lower in the resource hierarchy.
        /// Only project or lower resources are supported. Folder and organization
        /// resources cannot be used together with this option.
        ///
        /// For example, if the request analyzes for which users have permission P on
        /// a Google Cloud project with this option enabled, the results will include
        /// all users who have permission P on that project or any lower resource.
        ///
        /// If true, the default max expansion per resource is 1000 for
        /// AssetService.AnalyzeIamPolicy][] and 100000 for
        /// AssetService.AnalyzeIamPolicyLongrunning][].
        ///
        /// Default is false.
        ///
        /// [google.cloud.asset.v1.IamPolicyAnalysisQuery.resource_selector]: crate::model::IamPolicyAnalysisQuery::resource_selector
        pub expand_resources: bool,

        /// Optional. If true, the result will output the relevant parent/child
        /// relationships between resources. Default is false.
        pub output_resource_edges: bool,

        /// Optional. If true, the result will output the relevant membership
        /// relationships between groups and other groups, and between groups and
        /// principals. Default is false.
        pub output_group_edges: bool,

        /// Optional. If true, the response will include access analysis from
        /// identities to resources via service account impersonation. This is a very
        /// expensive operation, because many derived queries will be executed. We
        /// highly recommend you use
        /// [AssetService.AnalyzeIamPolicyLongrunning][google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning]
        /// RPC instead.
        ///
        /// For example, if the request analyzes for which resources user A has
        /// permission P, and there's an IAM policy states user A has
        /// iam.serviceAccounts.getAccessToken permission to a service account SA,
        /// and there's another IAM policy states service account SA has permission P
        /// to a Google Cloud folder F, then user A potentially has access to the
        /// Google Cloud folder F. And those advanced analysis results will be
        /// included in
        /// [AnalyzeIamPolicyResponse.service_account_impersonation_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_account_impersonation_analysis].
        ///
        /// Another example, if the request analyzes for who has
        /// permission P to a Google Cloud folder F, and there's an IAM policy states
        /// user A has iam.serviceAccounts.actAs permission to a service account SA,
        /// and there's another IAM policy states service account SA has permission P
        /// to the Google Cloud folder F, then user A potentially has access to the
        /// Google Cloud folder F. And those advanced analysis results will be
        /// included in
        /// [AnalyzeIamPolicyResponse.service_account_impersonation_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_account_impersonation_analysis].
        ///
        /// Only the following permissions are considered in this analysis:
        ///
        /// * `iam.serviceAccounts.actAs`
        /// * `iam.serviceAccounts.signBlob`
        /// * `iam.serviceAccounts.signJwt`
        /// * `iam.serviceAccounts.getAccessToken`
        /// * `iam.serviceAccounts.getOpenIdToken`
        /// * `iam.serviceAccounts.implicitDelegation`
        ///
        /// Default is false.
        ///
        /// [google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_account_impersonation_analysis]: crate::model::AnalyzeIamPolicyResponse::service_account_impersonation_analysis
        /// [google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning]: crate::client::AssetService::analyze_iam_policy_longrunning
        pub analyze_service_account_impersonation: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Options {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [expand_groups][crate::model::iam_policy_analysis_query::Options::expand_groups].
        pub fn set_expand_groups<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.expand_groups = v.into();
            self
        }

        /// Sets the value of [expand_roles][crate::model::iam_policy_analysis_query::Options::expand_roles].
        pub fn set_expand_roles<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.expand_roles = v.into();
            self
        }

        /// Sets the value of [expand_resources][crate::model::iam_policy_analysis_query::Options::expand_resources].
        pub fn set_expand_resources<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.expand_resources = v.into();
            self
        }

        /// Sets the value of [output_resource_edges][crate::model::iam_policy_analysis_query::Options::output_resource_edges].
        pub fn set_output_resource_edges<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.output_resource_edges = v.into();
            self
        }

        /// Sets the value of [output_group_edges][crate::model::iam_policy_analysis_query::Options::output_group_edges].
        pub fn set_output_group_edges<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.output_group_edges = v.into();
            self
        }

        /// Sets the value of [analyze_service_account_impersonation][crate::model::iam_policy_analysis_query::Options::analyze_service_account_impersonation].
        pub fn set_analyze_service_account_impersonation<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.analyze_service_account_impersonation = v.into();
            self
        }
    }

    impl wkt::message::Message for Options {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisQuery.Options"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Options {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __expand_groups,
                __expand_roles,
                __expand_resources,
                __output_resource_edges,
                __output_group_edges,
                __analyze_service_account_impersonation,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Options")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "expandGroups" => Ok(__FieldTag::__expand_groups),
                                "expand_groups" => Ok(__FieldTag::__expand_groups),
                                "expandRoles" => Ok(__FieldTag::__expand_roles),
                                "expand_roles" => Ok(__FieldTag::__expand_roles),
                                "expandResources" => Ok(__FieldTag::__expand_resources),
                                "expand_resources" => Ok(__FieldTag::__expand_resources),
                                "outputResourceEdges" => Ok(__FieldTag::__output_resource_edges),
                                "output_resource_edges" => Ok(__FieldTag::__output_resource_edges),
                                "outputGroupEdges" => Ok(__FieldTag::__output_group_edges),
                                "output_group_edges" => Ok(__FieldTag::__output_group_edges),
                                "analyzeServiceAccountImpersonation" => {
                                    Ok(__FieldTag::__analyze_service_account_impersonation)
                                }
                                "analyze_service_account_impersonation" => {
                                    Ok(__FieldTag::__analyze_service_account_impersonation)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Options;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Options")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__expand_groups => {
                                if !fields.insert(__FieldTag::__expand_groups) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for expand_groups",
                                    ));
                                }
                                result.expand_groups = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__expand_roles => {
                                if !fields.insert(__FieldTag::__expand_roles) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for expand_roles",
                                    ));
                                }
                                result.expand_roles = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__expand_resources => {
                                if !fields.insert(__FieldTag::__expand_resources) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for expand_resources",
                                    ));
                                }
                                result.expand_resources = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__output_resource_edges => {
                                if !fields.insert(__FieldTag::__output_resource_edges) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for output_resource_edges",
                                    ));
                                }
                                result.output_resource_edges = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__output_group_edges => {
                                if !fields.insert(__FieldTag::__output_group_edges) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for output_group_edges",
                                    ));
                                }
                                result.output_group_edges = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__analyze_service_account_impersonation => {
                                if !fields
                                    .insert(__FieldTag::__analyze_service_account_impersonation)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for analyze_service_account_impersonation",
                                    ));
                                }
                                result.analyze_service_account_impersonation = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Options {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.expand_groups) {
                state.serialize_entry("expandGroups", &self.expand_groups)?;
            }
            if !wkt::internal::is_default(&self.expand_roles) {
                state.serialize_entry("expandRoles", &self.expand_roles)?;
            }
            if !wkt::internal::is_default(&self.expand_resources) {
                state.serialize_entry("expandResources", &self.expand_resources)?;
            }
            if !wkt::internal::is_default(&self.output_resource_edges) {
                state.serialize_entry("outputResourceEdges", &self.output_resource_edges)?;
            }
            if !wkt::internal::is_default(&self.output_group_edges) {
                state.serialize_entry("outputGroupEdges", &self.output_group_edges)?;
            }
            if !wkt::internal::is_default(&self.analyze_service_account_impersonation) {
                state.serialize_entry(
                    "analyzeServiceAccountImpersonation",
                    &self.analyze_service_account_impersonation,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Options {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Options");
            debug_struct.field("expand_groups", &self.expand_groups);
            debug_struct.field("expand_roles", &self.expand_roles);
            debug_struct.field("expand_resources", &self.expand_resources);
            debug_struct.field("output_resource_edges", &self.output_resource_edges);
            debug_struct.field("output_group_edges", &self.output_group_edges);
            debug_struct.field(
                "analyze_service_account_impersonation",
                &self.analyze_service_account_impersonation,
            );

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The IAM conditions context.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConditionContext {
        /// The IAM conditions time context.
        pub time_context: std::option::Option<
            crate::model::iam_policy_analysis_query::condition_context::TimeContext,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConditionContext {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_context][crate::model::iam_policy_analysis_query::ConditionContext::time_context].
        ///
        /// Note that all the setters affecting `time_context` are mutually
        /// exclusive.
        pub fn set_time_context<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::iam_policy_analysis_query::condition_context::TimeContext,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.time_context = v.into();
            self
        }

        /// The value of [time_context][crate::model::iam_policy_analysis_query::ConditionContext::time_context]
        /// if it holds a `AccessTime`, `None` if the field is not set or
        /// holds a different branch.
        pub fn access_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
            #[allow(unreachable_patterns)]
            self.time_context.as_ref().and_then(|v| match v {
                crate::model::iam_policy_analysis_query::condition_context::TimeContext::AccessTime(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [time_context][crate::model::iam_policy_analysis_query::ConditionContext::time_context]
        /// to hold a `AccessTime`.
        ///
        /// Note that all the setters affecting `time_context` are
        /// mutually exclusive.
        pub fn set_access_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.time_context = std::option::Option::Some(
                crate::model::iam_policy_analysis_query::condition_context::TimeContext::AccessTime(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for ConditionContext {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisQuery.ConditionContext"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConditionContext {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __access_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConditionContext")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "accessTime" => Ok(__FieldTag::__access_time),
                                "access_time" => Ok(__FieldTag::__access_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConditionContext;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConditionContext")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__access_time => {
                                if !fields.insert(__FieldTag::__access_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for access_time",
                                    ));
                                }
                                if result.time_context.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `time_context`, a oneof with full ID .google.cloud.asset.v1.IamPolicyAnalysisQuery.ConditionContext.access_time, latest field was accessTime",
                                    ));
                                }
                                result.time_context = std::option::Option::Some(
                                    crate::model::iam_policy_analysis_query::condition_context::TimeContext::AccessTime(
                                        map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConditionContext {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.access_time() {
                state.serialize_entry("accessTime", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ConditionContext {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ConditionContext");
            debug_struct.field("time_context", &self.time_context);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ConditionContext].
    pub mod condition_context {
        #[allow(unused_imports)]
        use super::*;

        /// The IAM conditions time context.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TimeContext {
            /// The hypothetical access timestamp to evaluate IAM conditions. Note that
            /// this value must not be earlier than the current time; otherwise, an
            /// INVALID_ARGUMENT error will be returned.
            AccessTime(std::boxed::Box<wkt::Timestamp>),
        }
    }
}

/// A request message for
/// [AssetService.AnalyzeIamPolicy][google.cloud.asset.v1.AssetService.AnalyzeIamPolicy].
///
/// [google.cloud.asset.v1.AssetService.AnalyzeIamPolicy]: crate::client::AssetService::analyze_iam_policy
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeIamPolicyRequest {
    /// Required. The request query.
    pub analysis_query: std::option::Option<crate::model::IamPolicyAnalysisQuery>,

    /// Optional. The name of a saved query, which must be in the format of:
    ///
    /// * projects/project_number/savedQueries/saved_query_id
    /// * folders/folder_number/savedQueries/saved_query_id
    /// * organizations/organization_number/savedQueries/saved_query_id
    ///
    /// If both `analysis_query` and `saved_analysis_query` are provided, they
    /// will be merged together with the `saved_analysis_query` as base and
    /// the `analysis_query` as overrides. For more details of the merge behavior,
    /// refer to the
    /// [MergeFrom](https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.message#Message.MergeFrom.details)
    /// page.
    ///
    /// Note that you cannot override primitive fields with default value, such as
    /// 0 or empty string, etc., because we use proto3, which doesn't support field
    /// presence yet.
    pub saved_analysis_query: std::string::String,

    /// Optional. Amount of time executable has to complete.  See JSON
    /// representation of
    /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json).
    ///
    /// If this field is set with a value less than the RPC deadline, and the
    /// execution of your query hasn't finished in the specified
    /// execution timeout,  you will get a response with partial result.
    /// Otherwise, your query's execution will continue until the RPC deadline.
    /// If it's not finished until then, you will get a  DEADLINE_EXCEEDED error.
    ///
    /// Default is empty.
    pub execution_timeout: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeIamPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analysis_query][crate::model::AnalyzeIamPolicyRequest::analysis_query].
    pub fn set_analysis_query<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IamPolicyAnalysisQuery>,
    {
        self.analysis_query = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analysis_query][crate::model::AnalyzeIamPolicyRequest::analysis_query].
    pub fn set_or_clear_analysis_query<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IamPolicyAnalysisQuery>,
    {
        self.analysis_query = v.map(|x| x.into());
        self
    }

    /// Sets the value of [saved_analysis_query][crate::model::AnalyzeIamPolicyRequest::saved_analysis_query].
    pub fn set_saved_analysis_query<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.saved_analysis_query = v.into();
        self
    }

    /// Sets the value of [execution_timeout][crate::model::AnalyzeIamPolicyRequest::execution_timeout].
    pub fn set_execution_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.execution_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [execution_timeout][crate::model::AnalyzeIamPolicyRequest::execution_timeout].
    pub fn set_or_clear_execution_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.execution_timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AnalyzeIamPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzeIamPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeIamPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __analysis_query,
            __saved_analysis_query,
            __execution_timeout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeIamPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "analysisQuery" => Ok(__FieldTag::__analysis_query),
                            "analysis_query" => Ok(__FieldTag::__analysis_query),
                            "savedAnalysisQuery" => Ok(__FieldTag::__saved_analysis_query),
                            "saved_analysis_query" => Ok(__FieldTag::__saved_analysis_query),
                            "executionTimeout" => Ok(__FieldTag::__execution_timeout),
                            "execution_timeout" => Ok(__FieldTag::__execution_timeout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeIamPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeIamPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__analysis_query => {
                            if !fields.insert(__FieldTag::__analysis_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_query",
                                ));
                            }
                            result.analysis_query = map.next_value::<std::option::Option<crate::model::IamPolicyAnalysisQuery>>()?
                                ;
                        }
                        __FieldTag::__saved_analysis_query => {
                            if !fields.insert(__FieldTag::__saved_analysis_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for saved_analysis_query",
                                ));
                            }
                            result.saved_analysis_query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_timeout => {
                            if !fields.insert(__FieldTag::__execution_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_timeout",
                                ));
                            }
                            result.execution_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeIamPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.analysis_query.is_some() {
            state.serialize_entry("analysisQuery", &self.analysis_query)?;
        }
        if !self.saved_analysis_query.is_empty() {
            state.serialize_entry("savedAnalysisQuery", &self.saved_analysis_query)?;
        }
        if self.execution_timeout.is_some() {
            state.serialize_entry("executionTimeout", &self.execution_timeout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeIamPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeIamPolicyRequest");
        debug_struct.field("analysis_query", &self.analysis_query);
        debug_struct.field("saved_analysis_query", &self.saved_analysis_query);
        debug_struct.field("execution_timeout", &self.execution_timeout);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response message for
/// [AssetService.AnalyzeIamPolicy][google.cloud.asset.v1.AssetService.AnalyzeIamPolicy].
///
/// [google.cloud.asset.v1.AssetService.AnalyzeIamPolicy]: crate::client::AssetService::analyze_iam_policy
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeIamPolicyResponse {
    /// The main analysis that matches the original request.
    pub main_analysis:
        std::option::Option<crate::model::analyze_iam_policy_response::IamPolicyAnalysis>,

    /// The service account impersonation analysis if
    /// [IamPolicyAnalysisQuery.Options.analyze_service_account_impersonation][google.cloud.asset.v1.IamPolicyAnalysisQuery.Options.analyze_service_account_impersonation]
    /// is enabled.
    ///
    /// [google.cloud.asset.v1.IamPolicyAnalysisQuery.Options.analyze_service_account_impersonation]: crate::model::iam_policy_analysis_query::Options::analyze_service_account_impersonation
    pub service_account_impersonation_analysis:
        std::vec::Vec<crate::model::analyze_iam_policy_response::IamPolicyAnalysis>,

    /// Represents whether all entries in the
    /// [main_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.main_analysis]
    /// and
    /// [service_account_impersonation_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_account_impersonation_analysis]
    /// have been fully explored to answer the query in the request.
    ///
    /// [google.cloud.asset.v1.AnalyzeIamPolicyResponse.main_analysis]: crate::model::AnalyzeIamPolicyResponse::main_analysis
    /// [google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_account_impersonation_analysis]: crate::model::AnalyzeIamPolicyResponse::service_account_impersonation_analysis
    pub fully_explored: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeIamPolicyResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [main_analysis][crate::model::AnalyzeIamPolicyResponse::main_analysis].
    pub fn set_main_analysis<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::analyze_iam_policy_response::IamPolicyAnalysis>,
    {
        self.main_analysis = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [main_analysis][crate::model::AnalyzeIamPolicyResponse::main_analysis].
    pub fn set_or_clear_main_analysis<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::analyze_iam_policy_response::IamPolicyAnalysis>,
    {
        self.main_analysis = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_account_impersonation_analysis][crate::model::AnalyzeIamPolicyResponse::service_account_impersonation_analysis].
    pub fn set_service_account_impersonation_analysis<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::analyze_iam_policy_response::IamPolicyAnalysis>,
    {
        use std::iter::Iterator;
        self.service_account_impersonation_analysis = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [fully_explored][crate::model::AnalyzeIamPolicyResponse::fully_explored].
    pub fn set_fully_explored<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.fully_explored = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeIamPolicyResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzeIamPolicyResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeIamPolicyResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __main_analysis,
            __service_account_impersonation_analysis,
            __fully_explored,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeIamPolicyResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mainAnalysis" => Ok(__FieldTag::__main_analysis),
                            "main_analysis" => Ok(__FieldTag::__main_analysis),
                            "serviceAccountImpersonationAnalysis" => {
                                Ok(__FieldTag::__service_account_impersonation_analysis)
                            }
                            "service_account_impersonation_analysis" => {
                                Ok(__FieldTag::__service_account_impersonation_analysis)
                            }
                            "fullyExplored" => Ok(__FieldTag::__fully_explored),
                            "fully_explored" => Ok(__FieldTag::__fully_explored),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeIamPolicyResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeIamPolicyResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__main_analysis => {
                            if !fields.insert(__FieldTag::__main_analysis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_analysis",
                                ));
                            }
                            result.main_analysis = map.next_value::<std::option::Option<
                                crate::model::analyze_iam_policy_response::IamPolicyAnalysis,
                            >>()?;
                        }
                        __FieldTag::__service_account_impersonation_analysis => {
                            if !fields.insert(__FieldTag::__service_account_impersonation_analysis)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_impersonation_analysis",
                                ));
                            }
                            result.service_account_impersonation_analysis = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyze_iam_policy_response::IamPolicyAnalysis>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__fully_explored => {
                            if !fields.insert(__FieldTag::__fully_explored) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fully_explored",
                                ));
                            }
                            result.fully_explored = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeIamPolicyResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.main_analysis.is_some() {
            state.serialize_entry("mainAnalysis", &self.main_analysis)?;
        }
        if !self.service_account_impersonation_analysis.is_empty() {
            state.serialize_entry(
                "serviceAccountImpersonationAnalysis",
                &self.service_account_impersonation_analysis,
            )?;
        }
        if !wkt::internal::is_default(&self.fully_explored) {
            state.serialize_entry("fullyExplored", &self.fully_explored)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeIamPolicyResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeIamPolicyResponse");
        debug_struct.field("main_analysis", &self.main_analysis);
        debug_struct.field(
            "service_account_impersonation_analysis",
            &self.service_account_impersonation_analysis,
        );
        debug_struct.field("fully_explored", &self.fully_explored);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AnalyzeIamPolicyResponse].
pub mod analyze_iam_policy_response {
    #[allow(unused_imports)]
    use super::*;

    /// An analysis message to group the query and results.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IamPolicyAnalysis {
        /// The analysis query.
        pub analysis_query: std::option::Option<crate::model::IamPolicyAnalysisQuery>,

        /// A list of
        /// [IamPolicyAnalysisResult][google.cloud.asset.v1.IamPolicyAnalysisResult]
        /// that matches the analysis query, or empty if no result is found.
        ///
        /// [google.cloud.asset.v1.IamPolicyAnalysisResult]: crate::model::IamPolicyAnalysisResult
        pub analysis_results: std::vec::Vec<crate::model::IamPolicyAnalysisResult>,

        /// Represents whether all entries in the
        /// [analysis_results][google.cloud.asset.v1.AnalyzeIamPolicyResponse.IamPolicyAnalysis.analysis_results]
        /// have been fully explored to answer the query.
        ///
        /// [google.cloud.asset.v1.AnalyzeIamPolicyResponse.IamPolicyAnalysis.analysis_results]: crate::model::analyze_iam_policy_response::IamPolicyAnalysis::analysis_results
        pub fully_explored: bool,

        /// A list of non-critical errors happened during the query handling.
        pub non_critical_errors: std::vec::Vec<crate::model::IamPolicyAnalysisState>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IamPolicyAnalysis {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [analysis_query][crate::model::analyze_iam_policy_response::IamPolicyAnalysis::analysis_query].
        pub fn set_analysis_query<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::IamPolicyAnalysisQuery>,
        {
            self.analysis_query = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [analysis_query][crate::model::analyze_iam_policy_response::IamPolicyAnalysis::analysis_query].
        pub fn set_or_clear_analysis_query<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::IamPolicyAnalysisQuery>,
        {
            self.analysis_query = v.map(|x| x.into());
            self
        }

        /// Sets the value of [analysis_results][crate::model::analyze_iam_policy_response::IamPolicyAnalysis::analysis_results].
        pub fn set_analysis_results<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::IamPolicyAnalysisResult>,
        {
            use std::iter::Iterator;
            self.analysis_results = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [fully_explored][crate::model::analyze_iam_policy_response::IamPolicyAnalysis::fully_explored].
        pub fn set_fully_explored<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.fully_explored = v.into();
            self
        }

        /// Sets the value of [non_critical_errors][crate::model::analyze_iam_policy_response::IamPolicyAnalysis::non_critical_errors].
        pub fn set_non_critical_errors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::IamPolicyAnalysisState>,
        {
            use std::iter::Iterator;
            self.non_critical_errors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for IamPolicyAnalysis {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.AnalyzeIamPolicyResponse.IamPolicyAnalysis"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IamPolicyAnalysis {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __analysis_query,
                __analysis_results,
                __fully_explored,
                __non_critical_errors,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IamPolicyAnalysis")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "analysisQuery" => Ok(__FieldTag::__analysis_query),
                                "analysis_query" => Ok(__FieldTag::__analysis_query),
                                "analysisResults" => Ok(__FieldTag::__analysis_results),
                                "analysis_results" => Ok(__FieldTag::__analysis_results),
                                "fullyExplored" => Ok(__FieldTag::__fully_explored),
                                "fully_explored" => Ok(__FieldTag::__fully_explored),
                                "nonCriticalErrors" => Ok(__FieldTag::__non_critical_errors),
                                "non_critical_errors" => Ok(__FieldTag::__non_critical_errors),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IamPolicyAnalysis;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IamPolicyAnalysis")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__analysis_query => {
                                if !fields.insert(__FieldTag::__analysis_query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for analysis_query",
                                    ));
                                }
                                result.analysis_query = map.next_value::<std::option::Option<crate::model::IamPolicyAnalysisQuery>>()?
                                    ;
                            }
                            __FieldTag::__analysis_results => {
                                if !fields.insert(__FieldTag::__analysis_results) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for analysis_results",
                                    ));
                                }
                                result.analysis_results = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::IamPolicyAnalysisResult>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__fully_explored => {
                                if !fields.insert(__FieldTag::__fully_explored) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fully_explored",
                                    ));
                                }
                                result.fully_explored = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__non_critical_errors => {
                                if !fields.insert(__FieldTag::__non_critical_errors) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for non_critical_errors",
                                    ));
                                }
                                result.non_critical_errors = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::IamPolicyAnalysisState>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IamPolicyAnalysis {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.analysis_query.is_some() {
                state.serialize_entry("analysisQuery", &self.analysis_query)?;
            }
            if !self.analysis_results.is_empty() {
                state.serialize_entry("analysisResults", &self.analysis_results)?;
            }
            if !wkt::internal::is_default(&self.fully_explored) {
                state.serialize_entry("fullyExplored", &self.fully_explored)?;
            }
            if !self.non_critical_errors.is_empty() {
                state.serialize_entry("nonCriticalErrors", &self.non_critical_errors)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for IamPolicyAnalysis {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("IamPolicyAnalysis");
            debug_struct.field("analysis_query", &self.analysis_query);
            debug_struct.field("analysis_results", &self.analysis_results);
            debug_struct.field("fully_explored", &self.fully_explored);
            debug_struct.field("non_critical_errors", &self.non_critical_errors);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Output configuration for export IAM policy analysis destination.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IamPolicyAnalysisOutputConfig {
    /// IAM policy analysis export destination.
    pub destination:
        std::option::Option<crate::model::iam_policy_analysis_output_config::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IamPolicyAnalysisOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::IamPolicyAnalysisOutputConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::iam_policy_analysis_output_config::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::IamPolicyAnalysisOutputConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::iam_policy_analysis_output_config::GcsDestination>,
    > {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::iam_policy_analysis_output_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::IamPolicyAnalysisOutputConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<
                std::boxed::Box<crate::model::iam_policy_analysis_output_config::GcsDestination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::iam_policy_analysis_output_config::Destination::GcsDestination(v.into()),
        );
        self
    }

    /// The value of [destination][crate::model::IamPolicyAnalysisOutputConfig::destination]
    /// if it holds a `BigqueryDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_destination(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::iam_policy_analysis_output_config::BigQueryDestination>,
    > {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::iam_policy_analysis_output_config::Destination::BigqueryDestination(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::IamPolicyAnalysisOutputConfig::destination]
    /// to hold a `BigqueryDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_bigquery_destination<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::iam_policy_analysis_output_config::BigQueryDestination,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::iam_policy_analysis_output_config::Destination::BigqueryDestination(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for IamPolicyAnalysisOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisOutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IamPolicyAnalysisOutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            __bigquery_destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IamPolicyAnalysisOutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            "bigqueryDestination" => Ok(__FieldTag::__bigquery_destination),
                            "bigquery_destination" => Ok(__FieldTag::__bigquery_destination),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IamPolicyAnalysisOutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IamPolicyAnalysisOutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::iam_policy_analysis_output_config::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::iam_policy_analysis_output_config::GcsDestination>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__bigquery_destination => {
                            if !fields.insert(__FieldTag::__bigquery_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.bigquery_destination, latest field was bigqueryDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::iam_policy_analysis_output_config::Destination::BigqueryDestination(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::iam_policy_analysis_output_config::BigQueryDestination>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IamPolicyAnalysisOutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if let Some(value) = self.bigquery_destination() {
            state.serialize_entry("bigqueryDestination", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IamPolicyAnalysisOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IamPolicyAnalysisOutputConfig");
        debug_struct.field("destination", &self.destination);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [IamPolicyAnalysisOutputConfig].
pub mod iam_policy_analysis_output_config {
    #[allow(unused_imports)]
    use super::*;

    /// A Cloud Storage location.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GcsDestination {
        /// Required. The URI of the Cloud Storage object. It's the same URI that is
        /// used by gsutil. Example: "gs://bucket_name/object_name". See [Viewing and
        /// Editing Object
        /// Metadata](https://cloud.google.com/storage/docs/viewing-editing-metadata)
        /// for more information.
        ///
        /// If the specified Cloud Storage object already exists and there is no
        /// [hold](https://cloud.google.com/storage/docs/object-holds), it will be
        /// overwritten with the analysis result.
        pub uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::iam_policy_analysis_output_config::GcsDestination::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }
    }

    impl wkt::message::Message for GcsDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.GcsDestination"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GcsDestination {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GcsDestination")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uri" => Ok(__FieldTag::__uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GcsDestination;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GcsDestination")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GcsDestination {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GcsDestination {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GcsDestination");
            debug_struct.field("uri", &self.uri);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A BigQuery destination.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BigQueryDestination {
        /// Required. The BigQuery dataset in format
        /// "projects/projectId/datasets/datasetId", to which the analysis results
        /// should be exported. If this dataset does not exist, the export call will
        /// return an INVALID_ARGUMENT error.
        pub dataset: std::string::String,

        /// Required. The prefix of the BigQuery tables to which the analysis results
        /// will be written. Tables will be created based on this table_prefix if not
        /// exist:
        ///
        /// * <table_prefix>_analysis table will contain export operation's metadata.
        /// * <table_prefix>_analysis_result will contain all the
        ///   [IamPolicyAnalysisResult][google.cloud.asset.v1.IamPolicyAnalysisResult].
        ///   When [partition_key] is specified, both tables will be partitioned based
        ///   on the [partition_key].
        ///
        /// [google.cloud.asset.v1.IamPolicyAnalysisResult]: crate::model::IamPolicyAnalysisResult
        pub table_prefix: std::string::String,

        /// The partition key for BigQuery partitioned table.
        pub partition_key:
            crate::model::iam_policy_analysis_output_config::big_query_destination::PartitionKey,

        /// Optional. Specifies the action that occurs if the destination table or
        /// partition already exists. The following values are supported:
        ///
        /// * WRITE_TRUNCATE: If the table or partition already exists, BigQuery
        ///   overwrites the entire table or all the partitions data.
        /// * WRITE_APPEND: If the table or partition already exists, BigQuery
        ///   appends the data to the table or the latest partition.
        /// * WRITE_EMPTY: If the table already exists and contains data, an error is
        ///   returned.
        ///
        /// The default value is WRITE_APPEND. Each action is atomic and only occurs
        /// if BigQuery is able to complete the job successfully. Details are at
        /// <https://cloud.google.com/bigquery/docs/loading-data-local#appending_to_or_overwriting_a_table_using_a_local_file>.
        pub write_disposition: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigQueryDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset][crate::model::iam_policy_analysis_output_config::BigQueryDestination::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [table_prefix][crate::model::iam_policy_analysis_output_config::BigQueryDestination::table_prefix].
        pub fn set_table_prefix<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.table_prefix = v.into();
            self
        }

        /// Sets the value of [partition_key][crate::model::iam_policy_analysis_output_config::BigQueryDestination::partition_key].
        pub fn set_partition_key<T: std::convert::Into<crate::model::iam_policy_analysis_output_config::big_query_destination::PartitionKey>>(mut self, v: T) -> Self{
            self.partition_key = v.into();
            self
        }

        /// Sets the value of [write_disposition][crate::model::iam_policy_analysis_output_config::BigQueryDestination::write_disposition].
        pub fn set_write_disposition<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.write_disposition = v.into();
            self
        }
    }

    impl wkt::message::Message for BigQueryDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.BigQueryDestination"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BigQueryDestination {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dataset,
                __table_prefix,
                __partition_key,
                __write_disposition,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BigQueryDestination")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dataset" => Ok(__FieldTag::__dataset),
                                "tablePrefix" => Ok(__FieldTag::__table_prefix),
                                "table_prefix" => Ok(__FieldTag::__table_prefix),
                                "partitionKey" => Ok(__FieldTag::__partition_key),
                                "partition_key" => Ok(__FieldTag::__partition_key),
                                "writeDisposition" => Ok(__FieldTag::__write_disposition),
                                "write_disposition" => Ok(__FieldTag::__write_disposition),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BigQueryDestination;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BigQueryDestination")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dataset => {
                                if !fields.insert(__FieldTag::__dataset) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataset",
                                    ));
                                }
                                result.dataset = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__table_prefix => {
                                if !fields.insert(__FieldTag::__table_prefix) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table_prefix",
                                    ));
                                }
                                result.table_prefix = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__partition_key => {
                                if !fields.insert(__FieldTag::__partition_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for partition_key",
                                    ));
                                }
                                result.partition_key = map.next_value::<std::option::Option<crate::model::iam_policy_analysis_output_config::big_query_destination::PartitionKey>>()?.unwrap_or_default();
                            }
                            __FieldTag::__write_disposition => {
                                if !fields.insert(__FieldTag::__write_disposition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for write_disposition",
                                    ));
                                }
                                result.write_disposition = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BigQueryDestination {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dataset.is_empty() {
                state.serialize_entry("dataset", &self.dataset)?;
            }
            if !self.table_prefix.is_empty() {
                state.serialize_entry("tablePrefix", &self.table_prefix)?;
            }
            if !wkt::internal::is_default(&self.partition_key) {
                state.serialize_entry("partitionKey", &self.partition_key)?;
            }
            if !self.write_disposition.is_empty() {
                state.serialize_entry("writeDisposition", &self.write_disposition)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BigQueryDestination {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BigQueryDestination");
            debug_struct.field("dataset", &self.dataset);
            debug_struct.field("table_prefix", &self.table_prefix);
            debug_struct.field("partition_key", &self.partition_key);
            debug_struct.field("write_disposition", &self.write_disposition);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [BigQueryDestination].
    pub mod big_query_destination {
        #[allow(unused_imports)]
        use super::*;

        /// This enum determines the partition key column for the bigquery tables.
        /// Partitioning can improve query performance and reduce query cost by
        /// filtering partitions. Refer to
        /// <https://cloud.google.com/bigquery/docs/partitioned-tables> for details.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PartitionKey {
            /// Unspecified partition key. Tables won't be partitioned using this
            /// option.
            Unspecified,
            /// The time when the request is received. If specified as partition key,
            /// the result table(s) is partitioned by the RequestTime column, an
            /// additional timestamp column representing when the request was received.
            RequestTime,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PartitionKey::value] or
            /// [PartitionKey::name].
            UnknownValue(partition_key::UnknownValue),
        }

        #[doc(hidden)]
        pub mod partition_key {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PartitionKey {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::RequestTime => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PARTITION_KEY_UNSPECIFIED"),
                    Self::RequestTime => std::option::Option::Some("REQUEST_TIME"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PartitionKey {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PartitionKey {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PartitionKey {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::RequestTime,
                    _ => Self::UnknownValue(partition_key::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PartitionKey {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PARTITION_KEY_UNSPECIFIED" => Self::Unspecified,
                    "REQUEST_TIME" => Self::RequestTime,
                    _ => Self::UnknownValue(partition_key::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PartitionKey {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::RequestTime => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PartitionKey {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PartitionKey>::new(
                    ".google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey"))
            }
        }
    }

    /// IAM policy analysis export destination.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Destination on Cloud Storage.
        GcsDestination(
            std::boxed::Box<crate::model::iam_policy_analysis_output_config::GcsDestination>,
        ),
        /// Destination on BigQuery.
        BigqueryDestination(
            std::boxed::Box<crate::model::iam_policy_analysis_output_config::BigQueryDestination>,
        ),
    }
}

/// A request message for
/// [AssetService.AnalyzeIamPolicyLongrunning][google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning].
///
/// [google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning]: crate::client::AssetService::analyze_iam_policy_longrunning
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeIamPolicyLongrunningRequest {
    /// Required. The request query.
    pub analysis_query: std::option::Option<crate::model::IamPolicyAnalysisQuery>,

    /// Optional. The name of a saved query, which must be in the format of:
    ///
    /// * projects/project_number/savedQueries/saved_query_id
    /// * folders/folder_number/savedQueries/saved_query_id
    /// * organizations/organization_number/savedQueries/saved_query_id
    ///
    /// If both `analysis_query` and `saved_analysis_query` are provided, they
    /// will be merged together with the `saved_analysis_query` as base and
    /// the `analysis_query` as overrides. For more details of the merge behavior,
    /// refer to the
    /// [MergeFrom](https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.message#Message.MergeFrom.details)
    /// doc.
    ///
    /// Note that you cannot override primitive fields with default value, such as
    /// 0 or empty string, etc., because we use proto3, which doesn't support field
    /// presence yet.
    pub saved_analysis_query: std::string::String,

    /// Required. Output configuration indicating where the results will be output
    /// to.
    pub output_config: std::option::Option<crate::model::IamPolicyAnalysisOutputConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeIamPolicyLongrunningRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analysis_query][crate::model::AnalyzeIamPolicyLongrunningRequest::analysis_query].
    pub fn set_analysis_query<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IamPolicyAnalysisQuery>,
    {
        self.analysis_query = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analysis_query][crate::model::AnalyzeIamPolicyLongrunningRequest::analysis_query].
    pub fn set_or_clear_analysis_query<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IamPolicyAnalysisQuery>,
    {
        self.analysis_query = v.map(|x| x.into());
        self
    }

    /// Sets the value of [saved_analysis_query][crate::model::AnalyzeIamPolicyLongrunningRequest::saved_analysis_query].
    pub fn set_saved_analysis_query<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.saved_analysis_query = v.into();
        self
    }

    /// Sets the value of [output_config][crate::model::AnalyzeIamPolicyLongrunningRequest::output_config].
    pub fn set_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IamPolicyAnalysisOutputConfig>,
    {
        self.output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_config][crate::model::AnalyzeIamPolicyLongrunningRequest::output_config].
    pub fn set_or_clear_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IamPolicyAnalysisOutputConfig>,
    {
        self.output_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AnalyzeIamPolicyLongrunningRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzeIamPolicyLongrunningRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeIamPolicyLongrunningRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __analysis_query,
            __saved_analysis_query,
            __output_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeIamPolicyLongrunningRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "analysisQuery" => Ok(__FieldTag::__analysis_query),
                            "analysis_query" => Ok(__FieldTag::__analysis_query),
                            "savedAnalysisQuery" => Ok(__FieldTag::__saved_analysis_query),
                            "saved_analysis_query" => Ok(__FieldTag::__saved_analysis_query),
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeIamPolicyLongrunningRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeIamPolicyLongrunningRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__analysis_query => {
                            if !fields.insert(__FieldTag::__analysis_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_query",
                                ));
                            }
                            result.analysis_query = map.next_value::<std::option::Option<crate::model::IamPolicyAnalysisQuery>>()?
                                ;
                        }
                        __FieldTag::__saved_analysis_query => {
                            if !fields.insert(__FieldTag::__saved_analysis_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for saved_analysis_query",
                                ));
                            }
                            result.saved_analysis_query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            result.output_config =
                                map.next_value::<std::option::Option<
                                    crate::model::IamPolicyAnalysisOutputConfig,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeIamPolicyLongrunningRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.analysis_query.is_some() {
            state.serialize_entry("analysisQuery", &self.analysis_query)?;
        }
        if !self.saved_analysis_query.is_empty() {
            state.serialize_entry("savedAnalysisQuery", &self.saved_analysis_query)?;
        }
        if self.output_config.is_some() {
            state.serialize_entry("outputConfig", &self.output_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeIamPolicyLongrunningRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeIamPolicyLongrunningRequest");
        debug_struct.field("analysis_query", &self.analysis_query);
        debug_struct.field("saved_analysis_query", &self.saved_analysis_query);
        debug_struct.field("output_config", &self.output_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response message for
/// [AssetService.AnalyzeIamPolicyLongrunning][google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning].
///
/// [google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning]: crate::client::AssetService::analyze_iam_policy_longrunning
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeIamPolicyLongrunningResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeIamPolicyLongrunningResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AnalyzeIamPolicyLongrunningResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzeIamPolicyLongrunningResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeIamPolicyLongrunningResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeIamPolicyLongrunningResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeIamPolicyLongrunningResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeIamPolicyLongrunningResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeIamPolicyLongrunningResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeIamPolicyLongrunningResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeIamPolicyLongrunningResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A saved query which can be shared with others or used later.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SavedQuery {
    /// The resource name of the saved query. The format must be:
    ///
    /// * projects/project_number/savedQueries/saved_query_id
    /// * folders/folder_number/savedQueries/saved_query_id
    /// * organizations/organization_number/savedQueries/saved_query_id
    pub name: std::string::String,

    /// The description of this saved query. This value should be fewer than 255
    /// characters.
    pub description: std::string::String,

    /// Output only. The create time of this saved query.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The account's email address who has created this saved query.
    pub creator: std::string::String,

    /// Output only. The last update time of this saved query.
    pub last_update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The account's email address who has updated this saved query
    /// most recently.
    pub last_updater: std::string::String,

    /// Labels applied on the resource.
    /// This value should not contain more than 10 entries. The key and value of
    /// each entry must be non-empty and fewer than 64 characters.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The query content.
    pub content: std::option::Option<crate::model::saved_query::QueryContent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SavedQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SavedQuery::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SavedQuery::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SavedQuery::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::SavedQuery::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creator][crate::model::SavedQuery::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [last_update_time][crate::model::SavedQuery::last_update_time].
    pub fn set_last_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_update_time][crate::model::SavedQuery::last_update_time].
    pub fn set_or_clear_last_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_updater][crate::model::SavedQuery::last_updater].
    pub fn set_last_updater<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.last_updater = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::SavedQuery::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [content][crate::model::SavedQuery::content].
    pub fn set_content<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::saved_query::QueryContent>,
    {
        self.content = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [content][crate::model::SavedQuery::content].
    pub fn set_or_clear_content<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::saved_query::QueryContent>,
    {
        self.content = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SavedQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.SavedQuery"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SavedQuery {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __create_time,
            __creator,
            __last_update_time,
            __last_updater,
            __labels,
            __content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SavedQuery")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "creator" => Ok(__FieldTag::__creator),
                            "lastUpdateTime" => Ok(__FieldTag::__last_update_time),
                            "last_update_time" => Ok(__FieldTag::__last_update_time),
                            "lastUpdater" => Ok(__FieldTag::__last_updater),
                            "last_updater" => Ok(__FieldTag::__last_updater),
                            "labels" => Ok(__FieldTag::__labels),
                            "content" => Ok(__FieldTag::__content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SavedQuery;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SavedQuery")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__creator => {
                            if !fields.insert(__FieldTag::__creator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creator",
                                ));
                            }
                            result.creator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_update_time => {
                            if !fields.insert(__FieldTag::__last_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_update_time",
                                ));
                            }
                            result.last_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_updater => {
                            if !fields.insert(__FieldTag::__last_updater) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_updater",
                                ));
                            }
                            result.last_updater = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map.next_value::<std::option::Option<crate::model::saved_query::QueryContent>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SavedQuery {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.creator.is_empty() {
            state.serialize_entry("creator", &self.creator)?;
        }
        if self.last_update_time.is_some() {
            state.serialize_entry("lastUpdateTime", &self.last_update_time)?;
        }
        if !self.last_updater.is_empty() {
            state.serialize_entry("lastUpdater", &self.last_updater)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.content.is_some() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SavedQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SavedQuery");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("creator", &self.creator);
        debug_struct.field("last_update_time", &self.last_update_time);
        debug_struct.field("last_updater", &self.last_updater);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("content", &self.content);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SavedQuery].
pub mod saved_query {
    #[allow(unused_imports)]
    use super::*;

    /// The query content.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QueryContent {
        pub query_content:
            std::option::Option<crate::model::saved_query::query_content::QueryContent>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryContent {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query_content][crate::model::saved_query::QueryContent::query_content].
        ///
        /// Note that all the setters affecting `query_content` are mutually
        /// exclusive.
        pub fn set_query_content<
            T: std::convert::Into<
                    std::option::Option<crate::model::saved_query::query_content::QueryContent>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.query_content = v.into();
            self
        }

        /// The value of [query_content][crate::model::saved_query::QueryContent::query_content]
        /// if it holds a `IamPolicyAnalysisQuery`, `None` if the field is not set or
        /// holds a different branch.
        pub fn iam_policy_analysis_query(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::IamPolicyAnalysisQuery>> {
            #[allow(unreachable_patterns)]
            self.query_content.as_ref().and_then(|v| match v {
                crate::model::saved_query::query_content::QueryContent::IamPolicyAnalysisQuery(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [query_content][crate::model::saved_query::QueryContent::query_content]
        /// to hold a `IamPolicyAnalysisQuery`.
        ///
        /// Note that all the setters affecting `query_content` are
        /// mutually exclusive.
        pub fn set_iam_policy_analysis_query<
            T: std::convert::Into<std::boxed::Box<crate::model::IamPolicyAnalysisQuery>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.query_content = std::option::Option::Some(
                crate::model::saved_query::query_content::QueryContent::IamPolicyAnalysisQuery(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for QueryContent {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.SavedQuery.QueryContent"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QueryContent {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __iam_policy_analysis_query,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QueryContent")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "iamPolicyAnalysisQuery" => {
                                    Ok(__FieldTag::__iam_policy_analysis_query)
                                }
                                "iam_policy_analysis_query" => {
                                    Ok(__FieldTag::__iam_policy_analysis_query)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QueryContent;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QueryContent")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__iam_policy_analysis_query => {
                                if !fields.insert(__FieldTag::__iam_policy_analysis_query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for iam_policy_analysis_query",
                                    ));
                                }
                                if result.query_content.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `query_content`, a oneof with full ID .google.cloud.asset.v1.SavedQuery.QueryContent.iam_policy_analysis_query, latest field was iamPolicyAnalysisQuery",
                                    ));
                                }
                                result.query_content = std::option::Option::Some(
                                    crate::model::saved_query::query_content::QueryContent::IamPolicyAnalysisQuery(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::IamPolicyAnalysisQuery>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QueryContent {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.iam_policy_analysis_query() {
                state.serialize_entry("iamPolicyAnalysisQuery", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for QueryContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("QueryContent");
            debug_struct.field("query_content", &self.query_content);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [QueryContent].
    pub mod query_content {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum QueryContent {
            /// An IAM Policy Analysis query, which could be used in
            /// the
            /// [AssetService.AnalyzeIamPolicy][google.cloud.asset.v1.AssetService.AnalyzeIamPolicy]
            /// RPC or the
            /// [AssetService.AnalyzeIamPolicyLongrunning][google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning]
            /// RPC.
            ///
            /// [google.cloud.asset.v1.AssetService.AnalyzeIamPolicy]: crate::client::AssetService::analyze_iam_policy
            /// [google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning]: crate::client::AssetService::analyze_iam_policy_longrunning
            IamPolicyAnalysisQuery(std::boxed::Box<crate::model::IamPolicyAnalysisQuery>),
        }
    }
}

/// Request to create a saved query.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSavedQueryRequest {
    /// Required. The name of the project/folder/organization where this
    /// saved_query should be created in. It can only be an organization number
    /// (such as "organizations/123"), a folder number (such as "folders/123"), a
    /// project ID (such as "projects/my-project-id"), or a project number (such as
    /// "projects/12345").
    pub parent: std::string::String,

    /// Required. The saved_query details. The `name` field must be empty as it
    /// will be generated based on the parent and saved_query_id.
    pub saved_query: std::option::Option<crate::model::SavedQuery>,

    /// Required. The ID to use for the saved query, which must be unique in the
    /// specified parent. It will become the final component of the saved query's
    /// resource name.
    ///
    /// This value should be 4-63 characters, and valid characters
    /// are `[a-z][0-9]-`.
    ///
    /// Notice that this field is required in the saved query creation, and the
    /// `name` field of the `saved_query` will be ignored.
    pub saved_query_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSavedQueryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSavedQueryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [saved_query][crate::model::CreateSavedQueryRequest::saved_query].
    pub fn set_saved_query<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SavedQuery>,
    {
        self.saved_query = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [saved_query][crate::model::CreateSavedQueryRequest::saved_query].
    pub fn set_or_clear_saved_query<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SavedQuery>,
    {
        self.saved_query = v.map(|x| x.into());
        self
    }

    /// Sets the value of [saved_query_id][crate::model::CreateSavedQueryRequest::saved_query_id].
    pub fn set_saved_query_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.saved_query_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSavedQueryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.CreateSavedQueryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSavedQueryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __saved_query,
            __saved_query_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSavedQueryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "savedQuery" => Ok(__FieldTag::__saved_query),
                            "saved_query" => Ok(__FieldTag::__saved_query),
                            "savedQueryId" => Ok(__FieldTag::__saved_query_id),
                            "saved_query_id" => Ok(__FieldTag::__saved_query_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSavedQueryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSavedQueryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__saved_query => {
                            if !fields.insert(__FieldTag::__saved_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for saved_query",
                                ));
                            }
                            result.saved_query =
                                map.next_value::<std::option::Option<crate::model::SavedQuery>>()?;
                        }
                        __FieldTag::__saved_query_id => {
                            if !fields.insert(__FieldTag::__saved_query_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for saved_query_id",
                                ));
                            }
                            result.saved_query_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSavedQueryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.saved_query.is_some() {
            state.serialize_entry("savedQuery", &self.saved_query)?;
        }
        if !self.saved_query_id.is_empty() {
            state.serialize_entry("savedQueryId", &self.saved_query_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateSavedQueryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSavedQueryRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("saved_query", &self.saved_query);
        debug_struct.field("saved_query_id", &self.saved_query_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to get a saved query.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSavedQueryRequest {
    /// Required. The name of the saved query and it must be in the format of:
    ///
    /// * projects/project_number/savedQueries/saved_query_id
    /// * folders/folder_number/savedQueries/saved_query_id
    /// * organizations/organization_number/savedQueries/saved_query_id
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSavedQueryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSavedQueryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSavedQueryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.GetSavedQueryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSavedQueryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSavedQueryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSavedQueryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSavedQueryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSavedQueryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSavedQueryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSavedQueryRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to list saved queries.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSavedQueriesRequest {
    /// Required. The parent project/folder/organization whose savedQueries are to
    /// be listed. It can only be using project/folder/organization number (such as
    /// "folders/12345")", or a project ID (such as "projects/my-project-id").
    pub parent: std::string::String,

    /// Optional. The expression to filter resources.
    /// The expression is a list of zero or more restrictions combined via logical
    /// operators `AND` and `OR`. When `AND` and `OR` are both used in the
    /// expression, parentheses must be appropriately used to group the
    /// combinations. The expression may also contain regular expressions.
    ///
    /// See <https://google.aip.dev/160> for more information on the grammar.
    pub filter: std::string::String,

    /// Optional. The maximum number of saved queries to return per page. The
    /// service may return fewer than this value. If unspecified, at most 50 will
    /// be returned. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListSavedQueries` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListSavedQueries` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSavedQueriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSavedQueriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSavedQueriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSavedQueriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSavedQueriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSavedQueriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.ListSavedQueriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSavedQueriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSavedQueriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSavedQueriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSavedQueriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSavedQueriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSavedQueriesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSavedQueriesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of listing saved queries.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSavedQueriesResponse {
    /// A list of savedQueries.
    pub saved_queries: std::vec::Vec<crate::model::SavedQuery>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSavedQueriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [saved_queries][crate::model::ListSavedQueriesResponse::saved_queries].
    pub fn set_saved_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SavedQuery>,
    {
        use std::iter::Iterator;
        self.saved_queries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSavedQueriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSavedQueriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.ListSavedQueriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSavedQueriesResponse {
    type PageItem = crate::model::SavedQuery;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.saved_queries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSavedQueriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __saved_queries,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSavedQueriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "savedQueries" => Ok(__FieldTag::__saved_queries),
                            "saved_queries" => Ok(__FieldTag::__saved_queries),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSavedQueriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSavedQueriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__saved_queries => {
                            if !fields.insert(__FieldTag::__saved_queries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for saved_queries",
                                ));
                            }
                            result.saved_queries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SavedQuery>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSavedQueriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.saved_queries.is_empty() {
            state.serialize_entry("savedQueries", &self.saved_queries)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSavedQueriesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSavedQueriesResponse");
        debug_struct.field("saved_queries", &self.saved_queries);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to update a saved query.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSavedQueryRequest {
    /// Required. The saved query to update.
    ///
    /// The saved query's `name` field is used to identify the one to update,
    /// which has format as below:
    ///
    /// * projects/project_number/savedQueries/saved_query_id
    /// * folders/folder_number/savedQueries/saved_query_id
    /// * organizations/organization_number/savedQueries/saved_query_id
    pub saved_query: std::option::Option<crate::model::SavedQuery>,

    /// Required. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSavedQueryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [saved_query][crate::model::UpdateSavedQueryRequest::saved_query].
    pub fn set_saved_query<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SavedQuery>,
    {
        self.saved_query = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [saved_query][crate::model::UpdateSavedQueryRequest::saved_query].
    pub fn set_or_clear_saved_query<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SavedQuery>,
    {
        self.saved_query = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSavedQueryRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSavedQueryRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSavedQueryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.UpdateSavedQueryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSavedQueryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __saved_query,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSavedQueryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "savedQuery" => Ok(__FieldTag::__saved_query),
                            "saved_query" => Ok(__FieldTag::__saved_query),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSavedQueryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSavedQueryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__saved_query => {
                            if !fields.insert(__FieldTag::__saved_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for saved_query",
                                ));
                            }
                            result.saved_query =
                                map.next_value::<std::option::Option<crate::model::SavedQuery>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSavedQueryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.saved_query.is_some() {
            state.serialize_entry("savedQuery", &self.saved_query)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSavedQueryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSavedQueryRequest");
        debug_struct.field("saved_query", &self.saved_query);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to delete a saved query.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSavedQueryRequest {
    /// Required. The name of the saved query to delete. It must be in the format
    /// of:
    ///
    /// * projects/project_number/savedQueries/saved_query_id
    /// * folders/folder_number/savedQueries/saved_query_id
    /// * organizations/organization_number/savedQueries/saved_query_id
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSavedQueryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSavedQueryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSavedQueryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.DeleteSavedQueryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSavedQueryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSavedQueryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSavedQueryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSavedQueryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSavedQueryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSavedQueryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSavedQueryRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request message for performing resource move analysis.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeMoveRequest {
    /// Required. Name of the resource to perform the analysis against.
    /// Only Google Cloud projects are supported as of today. Hence, this can only
    /// be a project ID (such as "projects/my-project-id") or a project number
    /// (such as "projects/12345").
    pub resource: std::string::String,

    /// Required. Name of the Google Cloud folder or organization to reparent the
    /// target resource. The analysis will be performed against hypothetically
    /// moving the resource to this specified destination parent. This can only be
    /// a folder number (such as "folders/123") or an organization number (such as
    /// "organizations/123").
    pub destination_parent: std::string::String,

    /// Analysis view indicating what information should be included in the
    /// analysis response. If unspecified, the default view is FULL.
    pub view: crate::model::analyze_move_request::AnalysisView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeMoveRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource][crate::model::AnalyzeMoveRequest::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [destination_parent][crate::model::AnalyzeMoveRequest::destination_parent].
    pub fn set_destination_parent<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::AnalyzeMoveRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::analyze_move_request::AnalysisView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeMoveRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzeMoveRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeMoveRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource,
            __destination_parent,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeMoveRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resource" => Ok(__FieldTag::__resource),
                            "destinationParent" => Ok(__FieldTag::__destination_parent),
                            "destination_parent" => Ok(__FieldTag::__destination_parent),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeMoveRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeMoveRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_parent => {
                            if !fields.insert(__FieldTag::__destination_parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_parent",
                                ));
                            }
                            result.destination_parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<
                                    crate::model::analyze_move_request::AnalysisView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeMoveRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self.destination_parent.is_empty() {
            state.serialize_entry("destinationParent", &self.destination_parent)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeMoveRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeMoveRequest");
        debug_struct.field("resource", &self.resource);
        debug_struct.field("destination_parent", &self.destination_parent);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AnalyzeMoveRequest].
pub mod analyze_move_request {
    #[allow(unused_imports)]
    use super::*;

    /// View enum for supporting partial analysis responses.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AnalysisView {
        /// The default/unset value.
        /// The API will default to the FULL view.
        Unspecified,
        /// Full analysis including all level of impacts of the specified resource
        /// move.
        Full,
        /// Basic analysis only including blockers which will prevent the specified
        /// resource move at runtime.
        Basic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AnalysisView::value] or
        /// [AnalysisView::name].
        UnknownValue(analysis_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod analysis_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AnalysisView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Full => std::option::Option::Some(1),
                Self::Basic => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ANALYSIS_VIEW_UNSPECIFIED"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AnalysisView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AnalysisView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AnalysisView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Full,
                2 => Self::Basic,
                _ => Self::UnknownValue(analysis_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AnalysisView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANALYSIS_VIEW_UNSPECIFIED" => Self::Unspecified,
                "FULL" => Self::Full,
                "BASIC" => Self::Basic,
                _ => Self::UnknownValue(analysis_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AnalysisView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Full => serializer.serialize_i32(1),
                Self::Basic => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AnalysisView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AnalysisView>::new(
                ".google.cloud.asset.v1.AnalyzeMoveRequest.AnalysisView",
            ))
        }
    }
}

/// The response message for resource move analysis.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeMoveResponse {
    /// The list of analyses returned from performing the intended resource move
    /// analysis. The analysis is grouped by different Google Cloud services.
    pub move_analysis: std::vec::Vec<crate::model::MoveAnalysis>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeMoveResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [move_analysis][crate::model::AnalyzeMoveResponse::move_analysis].
    pub fn set_move_analysis<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MoveAnalysis>,
    {
        use std::iter::Iterator;
        self.move_analysis = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AnalyzeMoveResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzeMoveResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeMoveResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __move_analysis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeMoveResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "moveAnalysis" => Ok(__FieldTag::__move_analysis),
                            "move_analysis" => Ok(__FieldTag::__move_analysis),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeMoveResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeMoveResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__move_analysis => {
                            if !fields.insert(__FieldTag::__move_analysis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for move_analysis",
                                ));
                            }
                            result.move_analysis = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MoveAnalysis>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeMoveResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.move_analysis.is_empty() {
            state.serialize_entry("moveAnalysis", &self.move_analysis)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeMoveResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeMoveResponse");
        debug_struct.field("move_analysis", &self.move_analysis);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A message to group the analysis information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveAnalysis {
    /// The user friendly display name of the analysis. E.g. IAM, organization
    /// policy etc.
    pub display_name: std::string::String,

    pub result: std::option::Option<crate::model::move_analysis::Result>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveAnalysis {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::MoveAnalysis::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [result][crate::model::MoveAnalysis::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::move_analysis::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::MoveAnalysis::result]
    /// if it holds a `Analysis`, `None` if the field is not set or
    /// holds a different branch.
    pub fn analysis(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MoveAnalysisResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::move_analysis::Result::Analysis(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::MoveAnalysis::result]
    /// to hold a `Analysis`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_analysis<
        T: std::convert::Into<std::boxed::Box<crate::model::MoveAnalysisResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::move_analysis::Result::Analysis(v.into()));
        self
    }

    /// The value of [result][crate::model::MoveAnalysis::result]
    /// if it holds a `Error`, `None` if the field is not set or
    /// holds a different branch.
    pub fn error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::move_analysis::Result::Error(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::MoveAnalysis::result]
    /// to hold a `Error`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::move_analysis::Result::Error(v.into()));
        self
    }
}

impl wkt::message::Message for MoveAnalysis {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.MoveAnalysis"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MoveAnalysis {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __analysis,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveAnalysis")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "analysis" => Ok(__FieldTag::__analysis),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MoveAnalysis;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveAnalysis")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__analysis => {
                            if !fields.insert(__FieldTag::__analysis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.asset.v1.MoveAnalysis.analysis, latest field was analysis",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::move_analysis::Result::Analysis(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MoveAnalysisResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.asset.v1.MoveAnalysis.error, latest field was error",
                                ));
                            }
                            result.result =
                                std::option::Option::Some(
                                    crate::model::move_analysis::Result::Error(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<rpc::model::Status>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MoveAnalysis {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if let Some(value) = self.analysis() {
            state.serialize_entry("analysis", value)?;
        }
        if let Some(value) = self.error() {
            state.serialize_entry("error", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MoveAnalysis {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MoveAnalysis");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("result", &self.result);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MoveAnalysis].
pub mod move_analysis {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// Analysis result of moving the target resource.
        Analysis(std::boxed::Box<crate::model::MoveAnalysisResult>),
        /// Description of error encountered when performing the analysis.
        Error(std::boxed::Box<rpc::model::Status>),
    }
}

/// An analysis result including blockers and warnings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveAnalysisResult {
    /// Blocking information that would prevent the target resource from moving
    /// to the specified destination at runtime.
    pub blockers: std::vec::Vec<crate::model::MoveImpact>,

    /// Warning information indicating that moving the target resource to the
    /// specified destination might be unsafe. This can include important policy
    /// information and configuration changes, but will not block moves at runtime.
    pub warnings: std::vec::Vec<crate::model::MoveImpact>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveAnalysisResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blockers][crate::model::MoveAnalysisResult::blockers].
    pub fn set_blockers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MoveImpact>,
    {
        use std::iter::Iterator;
        self.blockers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::MoveAnalysisResult::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MoveImpact>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MoveAnalysisResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.MoveAnalysisResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MoveAnalysisResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __blockers,
            __warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveAnalysisResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "blockers" => Ok(__FieldTag::__blockers),
                            "warnings" => Ok(__FieldTag::__warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MoveAnalysisResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveAnalysisResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__blockers => {
                            if !fields.insert(__FieldTag::__blockers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blockers",
                                ));
                            }
                            result.blockers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MoveImpact>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warnings",
                                ));
                            }
                            result.warnings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MoveImpact>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MoveAnalysisResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.blockers.is_empty() {
            state.serialize_entry("blockers", &self.blockers)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MoveAnalysisResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MoveAnalysisResult");
        debug_struct.field("blockers", &self.blockers);
        debug_struct.field("warnings", &self.warnings);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A message to group impacts of moving the target resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveImpact {
    /// User friendly impact detail in a free form message.
    pub detail: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveImpact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [detail][crate::model::MoveImpact::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }
}

impl wkt::message::Message for MoveImpact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.MoveImpact"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MoveImpact {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __detail,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveImpact")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "detail" => Ok(__FieldTag::__detail),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MoveImpact;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveImpact")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__detail => {
                            if !fields.insert(__FieldTag::__detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detail",
                                ));
                            }
                            result.detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MoveImpact {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.detail.is_empty() {
            state.serialize_entry("detail", &self.detail)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MoveImpact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MoveImpact");
        debug_struct.field("detail", &self.detail);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Output configuration query assets.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryAssetsOutputConfig {
    /// BigQuery destination where the query results will be saved.
    pub bigquery_destination:
        std::option::Option<crate::model::query_assets_output_config::BigQueryDestination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryAssetsOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bigquery_destination][crate::model::QueryAssetsOutputConfig::bigquery_destination].
    pub fn set_bigquery_destination<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::query_assets_output_config::BigQueryDestination>,
    {
        self.bigquery_destination = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bigquery_destination][crate::model::QueryAssetsOutputConfig::bigquery_destination].
    pub fn set_or_clear_bigquery_destination<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::query_assets_output_config::BigQueryDestination>,
    {
        self.bigquery_destination = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for QueryAssetsOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.QueryAssetsOutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryAssetsOutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bigquery_destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryAssetsOutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigqueryDestination" => Ok(__FieldTag::__bigquery_destination),
                            "bigquery_destination" => Ok(__FieldTag::__bigquery_destination),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryAssetsOutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryAssetsOutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bigquery_destination => {
                            if !fields.insert(__FieldTag::__bigquery_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_destination",
                                ));
                            }
                            result.bigquery_destination = map.next_value::<std::option::Option<
                                crate::model::query_assets_output_config::BigQueryDestination,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryAssetsOutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bigquery_destination.is_some() {
            state.serialize_entry("bigqueryDestination", &self.bigquery_destination)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for QueryAssetsOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryAssetsOutputConfig");
        debug_struct.field("bigquery_destination", &self.bigquery_destination);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [QueryAssetsOutputConfig].
pub mod query_assets_output_config {
    #[allow(unused_imports)]
    use super::*;

    /// BigQuery destination.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BigQueryDestination {
        /// Required. The BigQuery dataset where the query results will be saved. It
        /// has the format of "projects/{projectId}/datasets/{datasetId}".
        pub dataset: std::string::String,

        /// Required. The BigQuery table where the query results will be saved. If
        /// this table does not exist, a new table with the given name will be
        /// created.
        pub table: std::string::String,

        /// Specifies the action that occurs if the destination table or partition
        /// already exists. The following values are supported:
        ///
        /// * WRITE_TRUNCATE: If the table or partition already exists, BigQuery
        ///   overwrites the entire table or all the partitions data.
        /// * WRITE_APPEND: If the table or partition already exists, BigQuery
        ///   appends the data to the table or the latest partition.
        /// * WRITE_EMPTY: If the table already exists and contains data, a
        ///   'duplicate' error is returned in the job result.
        ///
        /// The default value is WRITE_EMPTY.
        pub write_disposition: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigQueryDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset][crate::model::query_assets_output_config::BigQueryDestination::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [table][crate::model::query_assets_output_config::BigQueryDestination::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }

        /// Sets the value of [write_disposition][crate::model::query_assets_output_config::BigQueryDestination::write_disposition].
        pub fn set_write_disposition<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.write_disposition = v.into();
            self
        }
    }

    impl wkt::message::Message for BigQueryDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.QueryAssetsOutputConfig.BigQueryDestination"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BigQueryDestination {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dataset,
                __table,
                __write_disposition,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BigQueryDestination")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dataset" => Ok(__FieldTag::__dataset),
                                "table" => Ok(__FieldTag::__table),
                                "writeDisposition" => Ok(__FieldTag::__write_disposition),
                                "write_disposition" => Ok(__FieldTag::__write_disposition),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BigQueryDestination;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BigQueryDestination")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dataset => {
                                if !fields.insert(__FieldTag::__dataset) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataset",
                                    ));
                                }
                                result.dataset = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__table => {
                                if !fields.insert(__FieldTag::__table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table",
                                    ));
                                }
                                result.table = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__write_disposition => {
                                if !fields.insert(__FieldTag::__write_disposition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for write_disposition",
                                    ));
                                }
                                result.write_disposition = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BigQueryDestination {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dataset.is_empty() {
                state.serialize_entry("dataset", &self.dataset)?;
            }
            if !self.table.is_empty() {
                state.serialize_entry("table", &self.table)?;
            }
            if !self.write_disposition.is_empty() {
                state.serialize_entry("writeDisposition", &self.write_disposition)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BigQueryDestination {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BigQueryDestination");
            debug_struct.field("dataset", &self.dataset);
            debug_struct.field("table", &self.table);
            debug_struct.field("write_disposition", &self.write_disposition);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// QueryAssets request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryAssetsRequest {
    /// Required. The relative name of the root asset. This can only be an
    /// organization number (such as "organizations/123"), a project ID (such as
    /// "projects/my-project-id"), or a project number (such as "projects/12345"),
    /// or a folder number (such as "folders/123").
    ///
    /// Only assets belonging to the `parent` will be returned.
    pub parent: std::string::String,

    /// Optional. The maximum number of rows to return in the results. Responses
    /// are limited to 10 MB and 1000 rows.
    ///
    /// By default, the maximum row count is 1000. When the byte or row count limit
    /// is reached, the rest of the query results will be paginated.
    ///
    /// The field will be ignored when [output_config] is specified.
    pub page_size: i32,

    /// Optional. A page token received from previous `QueryAssets`.
    ///
    /// The field will be ignored when [output_config] is specified.
    pub page_token: std::string::String,

    /// Optional. Specifies the maximum amount of time that the client is willing
    /// to wait for the query to complete. By default, this limit is 5 min for the
    /// first query, and 1 minute for the following queries. If the query is
    /// complete, the `done` field in the `QueryAssetsResponse` is true, otherwise
    /// false.
    ///
    /// Like BigQuery [jobs.query
    /// API](https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query#queryrequest)
    /// The call is not guaranteed to wait for the specified timeout; it typically
    /// returns after around 200 seconds (200,000 milliseconds), even if the query
    /// is not complete.
    ///
    /// The field will be ignored when [output_config] is specified.
    pub timeout: std::option::Option<wkt::Duration>,

    /// Optional. Destination where the query results will be saved.
    ///
    /// When this field is specified, the query results won't be saved in the
    /// [QueryAssetsResponse.query_result]. Instead
    /// [QueryAssetsResponse.output_config] will be set.
    ///
    /// Meanwhile, [QueryAssetsResponse.job_reference] will be set and can be used
    /// to check the status of the query job when passed to a following
    /// [QueryAssets] API call.
    pub output_config: std::option::Option<crate::model::QueryAssetsOutputConfig>,

    pub query: std::option::Option<crate::model::query_assets_request::Query>,

    /// Specifies what time period or point in time to query asset metadata at.
    ///
    /// * unset - query asset metadata as it is right now
    /// * [read_time_window] - query asset metadata as it was at any point in time
    ///   between [start_time] and [end_time].
    /// * [read_time] - query asset metadata as it was at that point in time.
    ///   If data for the timestamp/date range selected does not exist,
    ///   it will simply return a valid response with no rows.
    pub time: std::option::Option<crate::model::query_assets_request::Time>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryAssetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::QueryAssetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::QueryAssetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::QueryAssetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::QueryAssetsRequest::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::QueryAssetsRequest::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_config][crate::model::QueryAssetsRequest::output_config].
    pub fn set_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryAssetsOutputConfig>,
    {
        self.output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_config][crate::model::QueryAssetsRequest::output_config].
    pub fn set_or_clear_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryAssetsOutputConfig>,
    {
        self.output_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query][crate::model::QueryAssetsRequest::query].
    ///
    /// Note that all the setters affecting `query` are mutually
    /// exclusive.
    pub fn set_query<
        T: std::convert::Into<std::option::Option<crate::model::query_assets_request::Query>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// The value of [query][crate::model::QueryAssetsRequest::query]
    /// if it holds a `Statement`, `None` if the field is not set or
    /// holds a different branch.
    pub fn statement(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::query_assets_request::Query::Statement(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::QueryAssetsRequest::query]
    /// to hold a `Statement`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_statement<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = std::option::Option::Some(
            crate::model::query_assets_request::Query::Statement(v.into()),
        );
        self
    }

    /// The value of [query][crate::model::QueryAssetsRequest::query]
    /// if it holds a `JobReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn job_reference(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::query_assets_request::Query::JobReference(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::QueryAssetsRequest::query]
    /// to hold a `JobReference`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_job_reference<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = std::option::Option::Some(
            crate::model::query_assets_request::Query::JobReference(v.into()),
        );
        self
    }

    /// Sets the value of [time][crate::model::QueryAssetsRequest::time].
    ///
    /// Note that all the setters affecting `time` are mutually
    /// exclusive.
    pub fn set_time<
        T: std::convert::Into<std::option::Option<crate::model::query_assets_request::Time>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time = v.into();
        self
    }

    /// The value of [time][crate::model::QueryAssetsRequest::time]
    /// if it holds a `ReadTimeWindow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn read_time_window(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimeWindow>> {
        #[allow(unreachable_patterns)]
        self.time.as_ref().and_then(|v| match v {
            crate::model::query_assets_request::Time::ReadTimeWindow(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [time][crate::model::QueryAssetsRequest::time]
    /// to hold a `ReadTimeWindow`.
    ///
    /// Note that all the setters affecting `time` are
    /// mutually exclusive.
    pub fn set_read_time_window<
        T: std::convert::Into<std::boxed::Box<crate::model::TimeWindow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time = std::option::Option::Some(
            crate::model::query_assets_request::Time::ReadTimeWindow(v.into()),
        );
        self
    }

    /// The value of [time][crate::model::QueryAssetsRequest::time]
    /// if it holds a `ReadTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn read_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.time.as_ref().and_then(|v| match v {
            crate::model::query_assets_request::Time::ReadTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [time][crate::model::QueryAssetsRequest::time]
    /// to hold a `ReadTime`.
    ///
    /// Note that all the setters affecting `time` are
    /// mutually exclusive.
    pub fn set_read_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time =
            std::option::Option::Some(crate::model::query_assets_request::Time::ReadTime(v.into()));
        self
    }
}

impl wkt::message::Message for QueryAssetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.QueryAssetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryAssetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __statement,
            __job_reference,
            __page_size,
            __page_token,
            __timeout,
            __read_time_window,
            __read_time,
            __output_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryAssetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "statement" => Ok(__FieldTag::__statement),
                            "jobReference" => Ok(__FieldTag::__job_reference),
                            "job_reference" => Ok(__FieldTag::__job_reference),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "timeout" => Ok(__FieldTag::__timeout),
                            "readTimeWindow" => Ok(__FieldTag::__read_time_window),
                            "read_time_window" => Ok(__FieldTag::__read_time_window),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryAssetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryAssetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__statement => {
                            if !fields.insert(__FieldTag::__statement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statement",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.asset.v1.QueryAssetsRequest.statement, latest field was statement",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::query_assets_request::Query::Statement(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__job_reference => {
                            if !fields.insert(__FieldTag::__job_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_reference",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.asset.v1.QueryAssetsRequest.job_reference, latest field was jobReference",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::query_assets_request::Query::JobReference(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__read_time_window => {
                            if !fields.insert(__FieldTag::__read_time_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time_window",
                                ));
                            }
                            if result.time.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `time`, a oneof with full ID .google.cloud.asset.v1.QueryAssetsRequest.read_time_window, latest field was readTimeWindow",
                                ));
                            }
                            result.time = std::option::Option::Some(
                                crate::model::query_assets_request::Time::ReadTimeWindow(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TimeWindow>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            if result.time.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `time`, a oneof with full ID .google.cloud.asset.v1.QueryAssetsRequest.read_time, latest field was readTime",
                                ));
                            }
                            result.time = std::option::Option::Some(
                                crate::model::query_assets_request::Time::ReadTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            result.output_config = map.next_value::<std::option::Option<crate::model::QueryAssetsOutputConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryAssetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.statement() {
            state.serialize_entry("statement", value)?;
        }
        if let Some(value) = self.job_reference() {
            state.serialize_entry("jobReference", value)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if let Some(value) = self.read_time_window() {
            state.serialize_entry("readTimeWindow", value)?;
        }
        if let Some(value) = self.read_time() {
            state.serialize_entry("readTime", value)?;
        }
        if self.output_config.is_some() {
            state.serialize_entry("outputConfig", &self.output_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for QueryAssetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryAssetsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("timeout", &self.timeout);
        debug_struct.field("output_config", &self.output_config);
        debug_struct.field("query", &self.query);
        debug_struct.field("time", &self.time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [QueryAssetsRequest].
pub mod query_assets_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Query {
        /// Optional. A SQL statement that's compatible with [BigQuery
        /// SQL](https://cloud.google.com/bigquery/docs/introduction-sql).
        Statement(std::string::String),
        /// Optional. Reference to the query job, which is from the
        /// `QueryAssetsResponse` of previous `QueryAssets` call.
        JobReference(std::string::String),
    }

    /// Specifies what time period or point in time to query asset metadata at.
    ///
    /// * unset - query asset metadata as it is right now
    /// * [read_time_window] - query asset metadata as it was at any point in time
    ///   between [start_time] and [end_time].
    /// * [read_time] - query asset metadata as it was at that point in time.
    ///   If data for the timestamp/date range selected does not exist,
    ///   it will simply return a valid response with no rows.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Time {
        /// Optional. [start_time] is required. [start_time] must be less than
        /// [end_time] Defaults [end_time] to now if [start_time] is set and
        /// [end_time] isn't. Maximum permitted time range is 7 days.
        ReadTimeWindow(std::boxed::Box<crate::model::TimeWindow>),
        /// Optional. Queries cloud assets as they appeared at the specified point in
        /// time.
        ReadTime(std::boxed::Box<wkt::Timestamp>),
    }
}

/// QueryAssets response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryAssetsResponse {
    /// Reference to a query job.
    pub job_reference: std::string::String,

    /// The query response, which can be either an `error` or a valid `response`.
    ///
    /// If `done` == `false` and the query result is being saved in an output, the
    /// output_config field will be set.
    /// If `done` == `true`, exactly one of
    /// `error`, `query_result` or `output_config` will be set.
    /// [done] is unset unless the [QueryAssetsResponse] contains a
    /// [QueryAssetsResponse.job_reference].
    pub done: bool,

    pub response: std::option::Option<crate::model::query_assets_response::Response>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryAssetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_reference][crate::model::QueryAssetsResponse::job_reference].
    pub fn set_job_reference<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_reference = v.into();
        self
    }

    /// Sets the value of [done][crate::model::QueryAssetsResponse::done].
    pub fn set_done<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.done = v.into();
        self
    }

    /// Sets the value of [response][crate::model::QueryAssetsResponse::response].
    ///
    /// Note that all the setters affecting `response` are mutually
    /// exclusive.
    pub fn set_response<
        T: std::convert::Into<std::option::Option<crate::model::query_assets_response::Response>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }

    /// The value of [response][crate::model::QueryAssetsResponse::response]
    /// if it holds a `Error`, `None` if the field is not set or
    /// holds a different branch.
    pub fn error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::query_assets_response::Response::Error(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::QueryAssetsResponse::response]
    /// to hold a `Error`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response = std::option::Option::Some(
            crate::model::query_assets_response::Response::Error(v.into()),
        );
        self
    }

    /// The value of [response][crate::model::QueryAssetsResponse::response]
    /// if it holds a `QueryResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_result(&self) -> std::option::Option<&std::boxed::Box<crate::model::QueryResult>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::query_assets_response::Response::QueryResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::QueryAssetsResponse::response]
    /// to hold a `QueryResult`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_query_result<T: std::convert::Into<std::boxed::Box<crate::model::QueryResult>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response = std::option::Option::Some(
            crate::model::query_assets_response::Response::QueryResult(v.into()),
        );
        self
    }

    /// The value of [response][crate::model::QueryAssetsResponse::response]
    /// if it holds a `OutputConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn output_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QueryAssetsOutputConfig>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::query_assets_response::Response::OutputConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::QueryAssetsResponse::response]
    /// to hold a `OutputConfig`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_output_config<
        T: std::convert::Into<std::boxed::Box<crate::model::QueryAssetsOutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = std::option::Option::Some(
            crate::model::query_assets_response::Response::OutputConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for QueryAssetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.QueryAssetsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryAssetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_reference,
            __done,
            __error,
            __query_result,
            __output_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryAssetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobReference" => Ok(__FieldTag::__job_reference),
                            "job_reference" => Ok(__FieldTag::__job_reference),
                            "done" => Ok(__FieldTag::__done),
                            "error" => Ok(__FieldTag::__error),
                            "queryResult" => Ok(__FieldTag::__query_result),
                            "query_result" => Ok(__FieldTag::__query_result),
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryAssetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryAssetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_reference => {
                            if !fields.insert(__FieldTag::__job_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_reference",
                                ));
                            }
                            result.job_reference = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__done => {
                            if !fields.insert(__FieldTag::__done) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for done",
                                ));
                            }
                            result.done = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            if result.response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response`, a oneof with full ID .google.cloud.asset.v1.QueryAssetsResponse.error, latest field was error",
                                ));
                            }
                            result.response =
                                std::option::Option::Some(
                                    crate::model::query_assets_response::Response::Error(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<rpc::model::Status>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__query_result => {
                            if !fields.insert(__FieldTag::__query_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_result",
                                ));
                            }
                            if result.response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response`, a oneof with full ID .google.cloud.asset.v1.QueryAssetsResponse.query_result, latest field was queryResult",
                                ));
                            }
                            result.response = std::option::Option::Some(
                                crate::model::query_assets_response::Response::QueryResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::QueryResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            if result.response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response`, a oneof with full ID .google.cloud.asset.v1.QueryAssetsResponse.output_config, latest field was outputConfig",
                                ));
                            }
                            result.response = std::option::Option::Some(
                                crate::model::query_assets_response::Response::OutputConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::QueryAssetsOutputConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryAssetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.job_reference.is_empty() {
            state.serialize_entry("jobReference", &self.job_reference)?;
        }
        if !wkt::internal::is_default(&self.done) {
            state.serialize_entry("done", &self.done)?;
        }
        if let Some(value) = self.error() {
            state.serialize_entry("error", value)?;
        }
        if let Some(value) = self.query_result() {
            state.serialize_entry("queryResult", value)?;
        }
        if let Some(value) = self.output_config() {
            state.serialize_entry("outputConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for QueryAssetsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryAssetsResponse");
        debug_struct.field("job_reference", &self.job_reference);
        debug_struct.field("done", &self.done);
        debug_struct.field("response", &self.response);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [QueryAssetsResponse].
pub mod query_assets_response {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Response {
        /// Error status.
        Error(std::boxed::Box<rpc::model::Status>),
        /// Result of the query.
        QueryResult(std::boxed::Box<crate::model::QueryResult>),
        /// Output configuration, which indicates that instead of being returned in
        /// an API response on the fly, the query result will be saved in a specific
        /// output.
        OutputConfig(std::boxed::Box<crate::model::QueryAssetsOutputConfig>),
    }
}

/// Execution results of the query.
///
/// The result is formatted as rows represented by BigQuery compatible [schema].
/// When pagination is necessary, it will contains the page token to retrieve
/// the results of following pages.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryResult {
    /// Each row hold a query result in the format of `Struct`.
    pub rows: std::vec::Vec<wkt::Struct>,

    /// Describes the format of the [rows].
    pub schema: std::option::Option<crate::model::TableSchema>,

    /// Token to retrieve the next page of the results.
    pub next_page_token: std::string::String,

    /// Total rows of the whole query results.
    pub total_rows: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rows][crate::model::QueryResult::rows].
    pub fn set_rows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Struct>,
    {
        use std::iter::Iterator;
        self.rows = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [schema][crate::model::QueryResult::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableSchema>,
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::QueryResult::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableSchema>,
    {
        self.schema = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::QueryResult::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_rows][crate::model::QueryResult::total_rows].
    pub fn set_total_rows<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_rows = v.into();
        self
    }
}

impl wkt::message::Message for QueryResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.QueryResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rows,
            __schema,
            __next_page_token,
            __total_rows,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rows" => Ok(__FieldTag::__rows),
                            "schema" => Ok(__FieldTag::__schema),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalRows" => Ok(__FieldTag::__total_rows),
                            "total_rows" => Ok(__FieldTag::__total_rows),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rows => {
                            if !fields.insert(__FieldTag::__rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rows",
                                ));
                            }
                            result.rows = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Struct>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::TableSchema>>()?;
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_rows => {
                            if !fields.insert(__FieldTag::__total_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_rows",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_rows = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rows.is_empty() {
            state.serialize_entry("rows", &self.rows)?;
        }
        if self.schema.is_some() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_rows) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalRows", &__With(&self.total_rows))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for QueryResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryResult");
        debug_struct.field("rows", &self.rows);
        debug_struct.field("schema", &self.schema);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("total_rows", &self.total_rows);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// BigQuery Compatible table schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TableSchema {
    /// Describes the fields in a table.
    pub fields: std::vec::Vec<crate::model::TableFieldSchema>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fields][crate::model::TableSchema::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableFieldSchema>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.TableSchema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fields" => Ok(__FieldTag::__fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TableFieldSchema>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TableSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableSchema");
        debug_struct.field("fields", &self.fields);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A field in TableSchema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TableFieldSchema {
    /// The field name. The name must contain only letters (a-z, A-Z),
    /// numbers (0-9), or underscores (_), and must start with a letter or
    /// underscore. The maximum length is 128 characters.
    pub field: std::string::String,

    /// The field data type. Possible values include
    ///
    /// * STRING
    /// * BYTES
    /// * INTEGER
    /// * FLOAT
    /// * BOOLEAN
    /// * TIMESTAMP
    /// * DATE
    /// * TIME
    /// * DATETIME
    /// * GEOGRAPHY,
    /// * NUMERIC,
    /// * BIGNUMERIC,
    /// * RECORD
    ///   (where RECORD indicates that the field contains a nested schema).
    pub r#type: std::string::String,

    /// The field mode. Possible values include NULLABLE, REQUIRED and
    /// REPEATED. The default value is NULLABLE.
    pub mode: std::string::String,

    /// Describes the nested schema fields if the type property is set
    /// to RECORD.
    pub fields: std::vec::Vec<crate::model::TableFieldSchema>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableFieldSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::TableFieldSchema::field].
    pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::TableFieldSchema::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::TableFieldSchema::mode].
    pub fn set_mode<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::TableFieldSchema::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableFieldSchema>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableFieldSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.TableFieldSchema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableFieldSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            __type,
            __mode,
            __fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableFieldSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            "type" => Ok(__FieldTag::__type),
                            "mode" => Ok(__FieldTag::__mode),
                            "fields" => Ok(__FieldTag::__fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableFieldSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableFieldSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TableFieldSchema>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableFieldSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.field.is_empty() {
            state.serialize_entry("field", &self.field)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.mode.is_empty() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TableFieldSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableFieldSchema");
        debug_struct.field("field", &self.field);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("mode", &self.mode);
        debug_struct.field("fields", &self.fields);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message for
/// [AssetService.BatchGetEffectiveIamPolicies][google.cloud.asset.v1.AssetService.BatchGetEffectiveIamPolicies].
///
/// [google.cloud.asset.v1.AssetService.BatchGetEffectiveIamPolicies]: crate::client::AssetService::batch_get_effective_iam_policies
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchGetEffectiveIamPoliciesRequest {
    /// Required. Only IAM policies on or below the scope will be returned.
    ///
    /// This can only be an organization number (such as "organizations/123"), a
    /// folder number (such as "folders/123"), a project ID (such as
    /// "projects/my-project-id"), or a project number (such as "projects/12345").
    ///
    /// To know how to get organization ID, visit [here
    /// ](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).
    ///
    /// To know how to get folder or project ID, visit [here
    /// ](https://cloud.google.com/resource-manager/docs/creating-managing-folders#viewing_or_listing_folders_and_projects).
    pub scope: std::string::String,

    /// Required. The names refer to the [full_resource_names]
    /// (<https://cloud.google.com/asset-inventory/docs/resource-name-format>)
    /// of the asset types [supported by search
    /// APIs](https://cloud.google.com/asset-inventory/docs/supported-asset-types).
    /// A maximum of 20 resources' effective policies can be retrieved in a batch.
    pub names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchGetEffectiveIamPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scope][crate::model::BatchGetEffectiveIamPoliciesRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [names][crate::model::BatchGetEffectiveIamPoliciesRequest::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchGetEffectiveIamPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.BatchGetEffectiveIamPoliciesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchGetEffectiveIamPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scope,
            __names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchGetEffectiveIamPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scope" => Ok(__FieldTag::__scope),
                            "names" => Ok(__FieldTag::__names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchGetEffectiveIamPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchGetEffectiveIamPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__names => {
                            if !fields.insert(__FieldTag::__names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for names",
                                ));
                            }
                            result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchGetEffectiveIamPoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchGetEffectiveIamPoliciesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchGetEffectiveIamPoliciesRequest");
        debug_struct.field("scope", &self.scope);
        debug_struct.field("names", &self.names);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response message for
/// [AssetService.BatchGetEffectiveIamPolicies][google.cloud.asset.v1.AssetService.BatchGetEffectiveIamPolicies].
///
/// [google.cloud.asset.v1.AssetService.BatchGetEffectiveIamPolicies]: crate::client::AssetService::batch_get_effective_iam_policies
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchGetEffectiveIamPoliciesResponse {
    /// The effective policies for a batch of resources. Note that the results
    /// order is the same as the order of
    /// [BatchGetEffectiveIamPoliciesRequest.names][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesRequest.names].
    /// When a resource does not have any effective IAM policies, its corresponding
    /// policy_result will contain empty
    /// [EffectiveIamPolicy.policies][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.policies].
    ///
    /// [google.cloud.asset.v1.BatchGetEffectiveIamPoliciesRequest.names]: crate::model::BatchGetEffectiveIamPoliciesRequest::names
    /// [google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.policies]: crate::model::batch_get_effective_iam_policies_response::EffectiveIamPolicy::policies
    pub policy_results:
        std::vec::Vec<crate::model::batch_get_effective_iam_policies_response::EffectiveIamPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchGetEffectiveIamPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy_results][crate::model::BatchGetEffectiveIamPoliciesResponse::policy_results].
    pub fn set_policy_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::batch_get_effective_iam_policies_response::EffectiveIamPolicy,
            >,
    {
        use std::iter::Iterator;
        self.policy_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchGetEffectiveIamPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchGetEffectiveIamPoliciesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchGetEffectiveIamPoliciesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policyResults" => Ok(__FieldTag::__policy_results),
                            "policy_results" => Ok(__FieldTag::__policy_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchGetEffectiveIamPoliciesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchGetEffectiveIamPoliciesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy_results => {
                            if !fields.insert(__FieldTag::__policy_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_results",
                                ));
                            }
                            result.policy_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::batch_get_effective_iam_policies_response::EffectiveIamPolicy>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchGetEffectiveIamPoliciesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.policy_results.is_empty() {
            state.serialize_entry("policyResults", &self.policy_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchGetEffectiveIamPoliciesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchGetEffectiveIamPoliciesResponse");
        debug_struct.field("policy_results", &self.policy_results);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BatchGetEffectiveIamPoliciesResponse].
pub mod batch_get_effective_iam_policies_response {
    #[allow(unused_imports)]
    use super::*;

    /// The effective IAM policies on one resource.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EffectiveIamPolicy {

        /// The [full_resource_name]
        /// (<https://cloud.google.com/asset-inventory/docs/resource-name-format>)
        /// for which the
        /// [policies][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.policies]
        /// are computed. This is one of the
        /// [BatchGetEffectiveIamPoliciesRequest.names][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesRequest.names]
        /// the caller provides in the request.
        ///
        /// [google.cloud.asset.v1.BatchGetEffectiveIamPoliciesRequest.names]: crate::model::BatchGetEffectiveIamPoliciesRequest::names
        /// [google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.policies]: crate::model::batch_get_effective_iam_policies_response::EffectiveIamPolicy::policies
        pub full_resource_name: std::string::String,

        /// The effective policies for the
        /// [full_resource_name][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.full_resource_name].
        ///
        /// These policies include the policy set on the
        /// [full_resource_name][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.full_resource_name]
        /// and those set on its parents and ancestors up to the
        /// [BatchGetEffectiveIamPoliciesRequest.scope][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesRequest.scope].
        /// Note that these policies are not filtered according to the resource type
        /// of the
        /// [full_resource_name][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.full_resource_name].
        ///
        /// These policies are hierarchically ordered by
        /// [PolicyInfo.attached_resource][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfo.attached_resource]
        /// starting from
        /// [full_resource_name][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.full_resource_name]
        /// itself to its parents and ancestors, such that policies[i]'s
        /// [PolicyInfo.attached_resource][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfo.attached_resource]
        /// is the child of policies[i+1]'s
        /// [PolicyInfo.attached_resource][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfo.attached_resource],
        /// if policies[i+1] exists.
        ///
        /// [google.cloud.asset.v1.BatchGetEffectiveIamPoliciesRequest.scope]: crate::model::BatchGetEffectiveIamPoliciesRequest::scope
        /// [google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfo.attached_resource]: crate::model::batch_get_effective_iam_policies_response::effective_iam_policy::PolicyInfo::attached_resource
        /// [google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.full_resource_name]: crate::model::batch_get_effective_iam_policies_response::EffectiveIamPolicy::full_resource_name
        pub policies: std::vec::Vec<crate::model::batch_get_effective_iam_policies_response::effective_iam_policy::PolicyInfo>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EffectiveIamPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [full_resource_name][crate::model::batch_get_effective_iam_policies_response::EffectiveIamPolicy::full_resource_name].
        pub fn set_full_resource_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.full_resource_name = v.into();
            self
        }

        /// Sets the value of [policies][crate::model::batch_get_effective_iam_policies_response::EffectiveIamPolicy::policies].
        pub fn set_policies<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::batch_get_effective_iam_policies_response::effective_iam_policy::PolicyInfo>
        {
            use std::iter::Iterator;
            self.policies = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for EffectiveIamPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EffectiveIamPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __full_resource_name,
                __policies,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EffectiveIamPolicy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "fullResourceName" => Ok(__FieldTag::__full_resource_name),
                                "full_resource_name" => Ok(__FieldTag::__full_resource_name),
                                "policies" => Ok(__FieldTag::__policies),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EffectiveIamPolicy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EffectiveIamPolicy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__full_resource_name => {
                                if !fields.insert(__FieldTag::__full_resource_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for full_resource_name",
                                    ));
                                }
                                result.full_resource_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__policies => {
                                if !fields.insert(__FieldTag::__policies) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for policies",
                                    ));
                                }
                                result.policies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::batch_get_effective_iam_policies_response::effective_iam_policy::PolicyInfo>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EffectiveIamPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.full_resource_name.is_empty() {
                state.serialize_entry("fullResourceName", &self.full_resource_name)?;
            }
            if !self.policies.is_empty() {
                state.serialize_entry("policies", &self.policies)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for EffectiveIamPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("EffectiveIamPolicy");
            debug_struct.field("full_resource_name", &self.full_resource_name);
            debug_struct.field("policies", &self.policies);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [EffectiveIamPolicy].
    pub mod effective_iam_policy {
        #[allow(unused_imports)]
        use super::*;

        /// The IAM policy and its attached resource.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct PolicyInfo {
            /// The full resource name the
            /// [policy][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfo.policy]
            /// is directly attached to.
            ///
            /// [google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfo.policy]: crate::model::batch_get_effective_iam_policies_response::effective_iam_policy::PolicyInfo::policy
            pub attached_resource: std::string::String,

            /// The IAM policy that's directly attached to the
            /// [attached_resource][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfo.attached_resource].
            ///
            /// [google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfo.attached_resource]: crate::model::batch_get_effective_iam_policies_response::effective_iam_policy::PolicyInfo::attached_resource
            pub policy: std::option::Option<iam_v1::model::Policy>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PolicyInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [attached_resource][crate::model::batch_get_effective_iam_policies_response::effective_iam_policy::PolicyInfo::attached_resource].
            pub fn set_attached_resource<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.attached_resource = v.into();
                self
            }

            /// Sets the value of [policy][crate::model::batch_get_effective_iam_policies_response::effective_iam_policy::PolicyInfo::policy].
            pub fn set_policy<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<iam_v1::model::Policy>,
            {
                self.policy = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [policy][crate::model::batch_get_effective_iam_policies_response::effective_iam_policy::PolicyInfo::policy].
            pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<iam_v1::model::Policy>,
            {
                self.policy = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for PolicyInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfo"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for PolicyInfo {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __attached_resource,
                    __policy,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for PolicyInfo")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "attachedResource" => Ok(__FieldTag::__attached_resource),
                                    "attached_resource" => Ok(__FieldTag::__attached_resource),
                                    "policy" => Ok(__FieldTag::__policy),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = PolicyInfo;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct PolicyInfo")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__attached_resource => {
                                    if !fields.insert(__FieldTag::__attached_resource) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for attached_resource",
                                            ),
                                        );
                                    }
                                    result.attached_resource = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__policy => {
                                    if !fields.insert(__FieldTag::__policy) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for policy"),
                                        );
                                    }
                                    result.policy = map
                                        .next_value::<std::option::Option<iam_v1::model::Policy>>(
                                        )?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for PolicyInfo {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.attached_resource.is_empty() {
                    state.serialize_entry("attachedResource", &self.attached_resource)?;
                }
                if self.policy.is_some() {
                    state.serialize_entry("policy", &self.policy)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for PolicyInfo {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("PolicyInfo");
                debug_struct.field("attached_resource", &self.attached_resource);
                debug_struct.field("policy", &self.policy);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }
}

/// This organization policy message is a modified version of the one defined in
/// the Organization Policy system. This message contains several fields defined
/// in the original organization policy with some new fields for analysis
/// purpose.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzerOrgPolicy {
    /// The [full resource name]
    /// (<https://cloud.google.com/asset-inventory/docs/resource-name-format>) of
    /// an organization/folder/project resource where this organization policy is
    /// set.
    ///
    /// Notice that some type of constraints are defined with default policy. This
    /// field will be empty for them.
    pub attached_resource: std::string::String,

    /// The [full resource name]
    /// (<https://cloud.google.com/asset-inventory/docs/resource-name-format>) of
    /// an organization/folder/project resource where this organization policy
    /// applies to.
    ///
    /// For any user defined org policies, this field has the same value as
    /// the [attached_resource] field. Only for default policy, this field has
    /// the different value.
    pub applied_resource: std::string::String,

    /// List of rules for this organization policy.
    pub rules: std::vec::Vec<crate::model::analyzer_org_policy::Rule>,

    /// If `inherit_from_parent` is true, Rules set higher up in the
    /// hierarchy (up to the closest root) are inherited and present in the
    /// effective policy. If it is false, then no rules are inherited, and this
    /// policy becomes the effective root for evaluation.
    pub inherit_from_parent: bool,

    /// Ignores policies set above this resource and restores the default behavior
    /// of the constraint at this resource.
    /// This field can be set in policies for either list or boolean
    /// constraints. If set, `rules` must be empty and `inherit_from_parent`
    /// must be set to false.
    pub reset: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzerOrgPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attached_resource][crate::model::AnalyzerOrgPolicy::attached_resource].
    pub fn set_attached_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attached_resource = v.into();
        self
    }

    /// Sets the value of [applied_resource][crate::model::AnalyzerOrgPolicy::applied_resource].
    pub fn set_applied_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.applied_resource = v.into();
        self
    }

    /// Sets the value of [rules][crate::model::AnalyzerOrgPolicy::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::analyzer_org_policy::Rule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [inherit_from_parent][crate::model::AnalyzerOrgPolicy::inherit_from_parent].
    pub fn set_inherit_from_parent<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.inherit_from_parent = v.into();
        self
    }

    /// Sets the value of [reset][crate::model::AnalyzerOrgPolicy::reset].
    pub fn set_reset<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reset = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzerOrgPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzerOrgPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzerOrgPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attached_resource,
            __applied_resource,
            __rules,
            __inherit_from_parent,
            __reset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzerOrgPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attachedResource" => Ok(__FieldTag::__attached_resource),
                            "attached_resource" => Ok(__FieldTag::__attached_resource),
                            "appliedResource" => Ok(__FieldTag::__applied_resource),
                            "applied_resource" => Ok(__FieldTag::__applied_resource),
                            "rules" => Ok(__FieldTag::__rules),
                            "inheritFromParent" => Ok(__FieldTag::__inherit_from_parent),
                            "inherit_from_parent" => Ok(__FieldTag::__inherit_from_parent),
                            "reset" => Ok(__FieldTag::__reset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzerOrgPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzerOrgPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attached_resource => {
                            if !fields.insert(__FieldTag::__attached_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attached_resource",
                                ));
                            }
                            result.attached_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__applied_resource => {
                            if !fields.insert(__FieldTag::__applied_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for applied_resource",
                                ));
                            }
                            result.applied_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rules => {
                            if !fields.insert(__FieldTag::__rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rules",
                                ));
                            }
                            result.rules = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::analyzer_org_policy::Rule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inherit_from_parent => {
                            if !fields.insert(__FieldTag::__inherit_from_parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inherit_from_parent",
                                ));
                            }
                            result.inherit_from_parent = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reset => {
                            if !fields.insert(__FieldTag::__reset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reset",
                                ));
                            }
                            result.reset = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzerOrgPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attached_resource.is_empty() {
            state.serialize_entry("attachedResource", &self.attached_resource)?;
        }
        if !self.applied_resource.is_empty() {
            state.serialize_entry("appliedResource", &self.applied_resource)?;
        }
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if !wkt::internal::is_default(&self.inherit_from_parent) {
            state.serialize_entry("inheritFromParent", &self.inherit_from_parent)?;
        }
        if !wkt::internal::is_default(&self.reset) {
            state.serialize_entry("reset", &self.reset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzerOrgPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzerOrgPolicy");
        debug_struct.field("attached_resource", &self.attached_resource);
        debug_struct.field("applied_resource", &self.applied_resource);
        debug_struct.field("rules", &self.rules);
        debug_struct.field("inherit_from_parent", &self.inherit_from_parent);
        debug_struct.field("reset", &self.reset);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AnalyzerOrgPolicy].
pub mod analyzer_org_policy {
    #[allow(unused_imports)]
    use super::*;

    /// This rule message is a customized version of the one defined in the
    /// Organization Policy system. In addition to the fields defined in the
    /// original organization policy, it contains additional field(s) under
    /// specific circumstances to support analysis results.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Rule {
        /// The evaluating condition for this rule.
        pub condition: std::option::Option<gtype::model::Expr>,

        /// The condition evaluation result for this rule.
        /// Only populated if it meets all the following criteria:
        ///
        /// * There is a
        ///   [condition][google.cloud.asset.v1.AnalyzerOrgPolicy.Rule.condition]
        ///   defined for this rule.
        /// * This rule is within
        ///   [AnalyzeOrgPolicyGovernedContainersResponse.GovernedContainer.consolidated_policy][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.GovernedContainer.consolidated_policy],
        ///   or
        ///   [AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset.consolidated_policy][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset.consolidated_policy]
        ///   when the
        ///   [AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset]
        ///   has
        ///   [AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset.governed_resource][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset.governed_resource].
        ///
        /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset]: crate::model::analyze_org_policy_governed_assets_response::GovernedAsset
        /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset.consolidated_policy]: crate::model::analyze_org_policy_governed_assets_response::GovernedAsset::consolidated_policy
        /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset.governed_resource]: crate::model::analyze_org_policy_governed_assets_response::GovernedAsset::governed_asset
        /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.GovernedContainer.consolidated_policy]: crate::model::analyze_org_policy_governed_containers_response::GovernedContainer::consolidated_policy
        /// [google.cloud.asset.v1.AnalyzerOrgPolicy.Rule.condition]: crate::model::analyzer_org_policy::Rule::condition
        pub condition_evaluation: std::option::Option<crate::model::ConditionEvaluation>,

        pub kind: std::option::Option<crate::model::analyzer_org_policy::rule::Kind>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Rule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [condition][crate::model::analyzer_org_policy::Rule::condition].
        pub fn set_condition<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Expr>,
        {
            self.condition = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [condition][crate::model::analyzer_org_policy::Rule::condition].
        pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Expr>,
        {
            self.condition = v.map(|x| x.into());
            self
        }

        /// Sets the value of [condition_evaluation][crate::model::analyzer_org_policy::Rule::condition_evaluation].
        pub fn set_condition_evaluation<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ConditionEvaluation>,
        {
            self.condition_evaluation = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [condition_evaluation][crate::model::analyzer_org_policy::Rule::condition_evaluation].
        pub fn set_or_clear_condition_evaluation<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ConditionEvaluation>,
        {
            self.condition_evaluation = v.map(|x| x.into());
            self
        }

        /// Sets the value of [kind][crate::model::analyzer_org_policy::Rule::kind].
        ///
        /// Note that all the setters affecting `kind` are mutually
        /// exclusive.
        pub fn set_kind<
            T: std::convert::Into<std::option::Option<crate::model::analyzer_org_policy::rule::Kind>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::analyzer_org_policy::Rule::kind]
        /// if it holds a `Values`, `None` if the field is not set or
        /// holds a different branch.
        pub fn values(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::analyzer_org_policy::rule::StringValues>,
        > {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::analyzer_org_policy::rule::Kind::Values(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::analyzer_org_policy::Rule::kind]
        /// to hold a `Values`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_values<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::analyzer_org_policy::rule::StringValues>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::analyzer_org_policy::rule::Kind::Values(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::analyzer_org_policy::Rule::kind]
        /// if it holds a `AllowAll`, `None` if the field is not set or
        /// holds a different branch.
        pub fn allow_all(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::analyzer_org_policy::rule::Kind::AllowAll(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::analyzer_org_policy::Rule::kind]
        /// to hold a `AllowAll`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_allow_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::analyzer_org_policy::rule::Kind::AllowAll(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::analyzer_org_policy::Rule::kind]
        /// if it holds a `DenyAll`, `None` if the field is not set or
        /// holds a different branch.
        pub fn deny_all(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::analyzer_org_policy::rule::Kind::DenyAll(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::analyzer_org_policy::Rule::kind]
        /// to hold a `DenyAll`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_deny_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::analyzer_org_policy::rule::Kind::DenyAll(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::analyzer_org_policy::Rule::kind]
        /// if it holds a `Enforce`, `None` if the field is not set or
        /// holds a different branch.
        pub fn enforce(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::analyzer_org_policy::rule::Kind::Enforce(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::analyzer_org_policy::Rule::kind]
        /// to hold a `Enforce`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_enforce<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::analyzer_org_policy::rule::Kind::Enforce(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Rule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.AnalyzerOrgPolicy.Rule"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Rule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __values,
                __allow_all,
                __deny_all,
                __enforce,
                __condition,
                __condition_evaluation,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Rule")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "values" => Ok(__FieldTag::__values),
                                "allowAll" => Ok(__FieldTag::__allow_all),
                                "allow_all" => Ok(__FieldTag::__allow_all),
                                "denyAll" => Ok(__FieldTag::__deny_all),
                                "deny_all" => Ok(__FieldTag::__deny_all),
                                "enforce" => Ok(__FieldTag::__enforce),
                                "condition" => Ok(__FieldTag::__condition),
                                "conditionEvaluation" => Ok(__FieldTag::__condition_evaluation),
                                "condition_evaluation" => Ok(__FieldTag::__condition_evaluation),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Rule;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Rule")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.asset.v1.AnalyzerOrgPolicy.Rule.values, latest field was values",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::analyzer_org_policy::rule::Kind::Values(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::analyzer_org_policy::rule::StringValues>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__allow_all => {
                                if !fields.insert(__FieldTag::__allow_all) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_all",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.asset.v1.AnalyzerOrgPolicy.Rule.allow_all, latest field was allowAll",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::analyzer_org_policy::rule::Kind::AllowAll(
                                        map.next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__deny_all => {
                                if !fields.insert(__FieldTag::__deny_all) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for deny_all",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.asset.v1.AnalyzerOrgPolicy.Rule.deny_all, latest field was denyAll",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::analyzer_org_policy::rule::Kind::DenyAll(
                                        map.next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__enforce => {
                                if !fields.insert(__FieldTag::__enforce) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enforce",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.asset.v1.AnalyzerOrgPolicy.Rule.enforce, latest field was enforce",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::analyzer_org_policy::rule::Kind::Enforce(
                                        map.next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__condition => {
                                if !fields.insert(__FieldTag::__condition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition",
                                    ));
                                }
                                result.condition =
                                    map.next_value::<std::option::Option<gtype::model::Expr>>()?;
                            }
                            __FieldTag::__condition_evaluation => {
                                if !fields.insert(__FieldTag::__condition_evaluation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition_evaluation",
                                    ));
                                }
                                result.condition_evaluation = map.next_value::<std::option::Option<crate::model::ConditionEvaluation>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Rule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.values() {
                state.serialize_entry("values", value)?;
            }
            if let Some(value) = self.allow_all() {
                state.serialize_entry("allowAll", value)?;
            }
            if let Some(value) = self.deny_all() {
                state.serialize_entry("denyAll", value)?;
            }
            if let Some(value) = self.enforce() {
                state.serialize_entry("enforce", value)?;
            }
            if self.condition.is_some() {
                state.serialize_entry("condition", &self.condition)?;
            }
            if self.condition_evaluation.is_some() {
                state.serialize_entry("conditionEvaluation", &self.condition_evaluation)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Rule {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Rule");
            debug_struct.field("condition", &self.condition);
            debug_struct.field("condition_evaluation", &self.condition_evaluation);
            debug_struct.field("kind", &self.kind);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Rule].
    pub mod rule {
        #[allow(unused_imports)]
        use super::*;

        /// The string values for the list constraints.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct StringValues {
            /// List of values allowed at this resource.
            pub allowed_values: std::vec::Vec<std::string::String>,

            /// List of values denied at this resource.
            pub denied_values: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl StringValues {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [allowed_values][crate::model::analyzer_org_policy::rule::StringValues::allowed_values].
            pub fn set_allowed_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.allowed_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [denied_values][crate::model::analyzer_org_policy::rule::StringValues::denied_values].
            pub fn set_denied_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.denied_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for StringValues {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.asset.v1.AnalyzerOrgPolicy.Rule.StringValues"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for StringValues {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __allowed_values,
                    __denied_values,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for StringValues")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "allowedValues" => Ok(__FieldTag::__allowed_values),
                                    "allowed_values" => Ok(__FieldTag::__allowed_values),
                                    "deniedValues" => Ok(__FieldTag::__denied_values),
                                    "denied_values" => Ok(__FieldTag::__denied_values),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = StringValues;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct StringValues")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__allowed_values => {
                                    if !fields.insert(__FieldTag::__allowed_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for allowed_values",
                                            ),
                                        );
                                    }
                                    result.allowed_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__denied_values => {
                                    if !fields.insert(__FieldTag::__denied_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for denied_values",
                                            ),
                                        );
                                    }
                                    result.denied_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for StringValues {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.allowed_values.is_empty() {
                    state.serialize_entry("allowedValues", &self.allowed_values)?;
                }
                if !self.denied_values.is_empty() {
                    state.serialize_entry("deniedValues", &self.denied_values)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for StringValues {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("StringValues");
                debug_struct.field("allowed_values", &self.allowed_values);
                debug_struct.field("denied_values", &self.denied_values);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Kind {
            /// List of values to be used for this policy rule. This field can be set
            /// only in policies for list constraints.
            Values(std::boxed::Box<crate::model::analyzer_org_policy::rule::StringValues>),
            /// Setting this to true means that all values are allowed. This field can
            /// be set only in Policies for list constraints.
            AllowAll(bool),
            /// Setting this to true means that all values are denied. This field can
            /// be set only in Policies for list constraints.
            DenyAll(bool),
            /// If `true`, then the `Policy` is enforced. If `false`, then any
            /// configuration is acceptable.
            /// This field can be set only in Policies for boolean constraints.
            Enforce(bool),
        }
    }
}

/// The organization policy constraint definition.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzerOrgPolicyConstraint {
    pub constraint_definition:
        std::option::Option<crate::model::analyzer_org_policy_constraint::ConstraintDefinition>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzerOrgPolicyConstraint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [constraint_definition][crate::model::AnalyzerOrgPolicyConstraint::constraint_definition].
    ///
    /// Note that all the setters affecting `constraint_definition` are mutually
    /// exclusive.
    pub fn set_constraint_definition<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::analyzer_org_policy_constraint::ConstraintDefinition,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_definition = v.into();
        self
    }

    /// The value of [constraint_definition][crate::model::AnalyzerOrgPolicyConstraint::constraint_definition]
    /// if it holds a `GoogleDefinedConstraint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_defined_constraint(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyzer_org_policy_constraint::Constraint>,
    > {
        #[allow(unreachable_patterns)]
        self.constraint_definition.as_ref().and_then(|v| match v {
            crate::model::analyzer_org_policy_constraint::ConstraintDefinition::GoogleDefinedConstraint(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [constraint_definition][crate::model::AnalyzerOrgPolicyConstraint::constraint_definition]
    /// to hold a `GoogleDefinedConstraint`.
    ///
    /// Note that all the setters affecting `constraint_definition` are
    /// mutually exclusive.
    pub fn set_google_defined_constraint<
        T: std::convert::Into<
                std::boxed::Box<crate::model::analyzer_org_policy_constraint::Constraint>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_definition = std::option::Option::Some(
            crate::model::analyzer_org_policy_constraint::ConstraintDefinition::GoogleDefinedConstraint(
                v.into()
            )
        );
        self
    }

    /// The value of [constraint_definition][crate::model::AnalyzerOrgPolicyConstraint::constraint_definition]
    /// if it holds a `CustomConstraint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_constraint(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyzer_org_policy_constraint::CustomConstraint>,
    > {
        #[allow(unreachable_patterns)]
        self.constraint_definition.as_ref().and_then(|v| match v {
            crate::model::analyzer_org_policy_constraint::ConstraintDefinition::CustomConstraint(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [constraint_definition][crate::model::AnalyzerOrgPolicyConstraint::constraint_definition]
    /// to hold a `CustomConstraint`.
    ///
    /// Note that all the setters affecting `constraint_definition` are
    /// mutually exclusive.
    pub fn set_custom_constraint<
        T: std::convert::Into<
                std::boxed::Box<crate::model::analyzer_org_policy_constraint::CustomConstraint>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_definition = std::option::Option::Some(
            crate::model::analyzer_org_policy_constraint::ConstraintDefinition::CustomConstraint(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for AnalyzerOrgPolicyConstraint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzerOrgPolicyConstraint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzerOrgPolicyConstraint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __google_defined_constraint,
            __custom_constraint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzerOrgPolicyConstraint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "googleDefinedConstraint" => {
                                Ok(__FieldTag::__google_defined_constraint)
                            }
                            "google_defined_constraint" => {
                                Ok(__FieldTag::__google_defined_constraint)
                            }
                            "customConstraint" => Ok(__FieldTag::__custom_constraint),
                            "custom_constraint" => Ok(__FieldTag::__custom_constraint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzerOrgPolicyConstraint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzerOrgPolicyConstraint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__google_defined_constraint => {
                            if !fields.insert(__FieldTag::__google_defined_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_defined_constraint",
                                ));
                            }
                            if result.constraint_definition.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `constraint_definition`, a oneof with full ID .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.google_defined_constraint, latest field was googleDefinedConstraint",
                                ));
                            }
                            result.constraint_definition = std::option::Option::Some(
                                crate::model::analyzer_org_policy_constraint::ConstraintDefinition::GoogleDefinedConstraint(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::analyzer_org_policy_constraint::Constraint>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__custom_constraint => {
                            if !fields.insert(__FieldTag::__custom_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_constraint",
                                ));
                            }
                            if result.constraint_definition.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `constraint_definition`, a oneof with full ID .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.custom_constraint, latest field was customConstraint",
                                ));
                            }
                            result.constraint_definition = std::option::Option::Some(
                                crate::model::analyzer_org_policy_constraint::ConstraintDefinition::CustomConstraint(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::analyzer_org_policy_constraint::CustomConstraint>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzerOrgPolicyConstraint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.google_defined_constraint() {
            state.serialize_entry("googleDefinedConstraint", value)?;
        }
        if let Some(value) = self.custom_constraint() {
            state.serialize_entry("customConstraint", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzerOrgPolicyConstraint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzerOrgPolicyConstraint");
        debug_struct.field("constraint_definition", &self.constraint_definition);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AnalyzerOrgPolicyConstraint].
pub mod analyzer_org_policy_constraint {
    #[allow(unused_imports)]
    use super::*;

    /// The definition of a constraint.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Constraint {
        /// The unique name of the constraint. Format of the name should be
        ///
        /// * `constraints/{constraint_name}`
        ///
        /// For example, `constraints/compute.disableSerialPortAccess`.
        pub name: std::string::String,

        /// The human readable name of the constraint.
        pub display_name: std::string::String,

        /// Detailed description of what this `Constraint` controls as well as how
        /// and where it is enforced.
        pub description: std::string::String,

        /// The evaluation behavior of this constraint in the absence of 'Policy'.
        pub constraint_default:
            crate::model::analyzer_org_policy_constraint::constraint::ConstraintDefault,

        /// The type of restrictions for this `Constraint`.
        ///
        /// Immutable after creation.
        pub constraint_type: std::option::Option<
            crate::model::analyzer_org_policy_constraint::constraint::ConstraintType,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Constraint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::analyzer_org_policy_constraint::Constraint::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::analyzer_org_policy_constraint::Constraint::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::analyzer_org_policy_constraint::Constraint::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [constraint_default][crate::model::analyzer_org_policy_constraint::Constraint::constraint_default].
        pub fn set_constraint_default<
            T: std::convert::Into<
                    crate::model::analyzer_org_policy_constraint::constraint::ConstraintDefault,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.constraint_default = v.into();
            self
        }

        /// Sets the value of [constraint_type][crate::model::analyzer_org_policy_constraint::Constraint::constraint_type].
        ///
        /// Note that all the setters affecting `constraint_type` are mutually
        /// exclusive.
        pub fn set_constraint_type<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::analyzer_org_policy_constraint::constraint::ConstraintType,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.constraint_type = v.into();
            self
        }

        /// The value of [constraint_type][crate::model::analyzer_org_policy_constraint::Constraint::constraint_type]
        /// if it holds a `ListConstraint`, `None` if the field is not set or
        /// holds a different branch.
        pub fn list_constraint(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::analyzer_org_policy_constraint::constraint::ListConstraint,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.constraint_type.as_ref().and_then(|v| match v {
                crate::model::analyzer_org_policy_constraint::constraint::ConstraintType::ListConstraint(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [constraint_type][crate::model::analyzer_org_policy_constraint::Constraint::constraint_type]
        /// to hold a `ListConstraint`.
        ///
        /// Note that all the setters affecting `constraint_type` are
        /// mutually exclusive.
        pub fn set_list_constraint<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::analyzer_org_policy_constraint::constraint::ListConstraint,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.constraint_type = std::option::Option::Some(
                crate::model::analyzer_org_policy_constraint::constraint::ConstraintType::ListConstraint(
                    v.into()
                )
            );
            self
        }

        /// The value of [constraint_type][crate::model::analyzer_org_policy_constraint::Constraint::constraint_type]
        /// if it holds a `BooleanConstraint`, `None` if the field is not set or
        /// holds a different branch.
        pub fn boolean_constraint(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::analyzer_org_policy_constraint::constraint::BooleanConstraint,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.constraint_type.as_ref().and_then(|v| match v {
                crate::model::analyzer_org_policy_constraint::constraint::ConstraintType::BooleanConstraint(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [constraint_type][crate::model::analyzer_org_policy_constraint::Constraint::constraint_type]
        /// to hold a `BooleanConstraint`.
        ///
        /// Note that all the setters affecting `constraint_type` are
        /// mutually exclusive.
        pub fn set_boolean_constraint<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::analyzer_org_policy_constraint::constraint::BooleanConstraint,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.constraint_type = std::option::Option::Some(
                crate::model::analyzer_org_policy_constraint::constraint::ConstraintType::BooleanConstraint(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for Constraint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.Constraint"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Constraint {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __display_name,
                __description,
                __constraint_default,
                __list_constraint,
                __boolean_constraint,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Constraint")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "description" => Ok(__FieldTag::__description),
                                "constraintDefault" => Ok(__FieldTag::__constraint_default),
                                "constraint_default" => Ok(__FieldTag::__constraint_default),
                                "listConstraint" => Ok(__FieldTag::__list_constraint),
                                "list_constraint" => Ok(__FieldTag::__list_constraint),
                                "booleanConstraint" => Ok(__FieldTag::__boolean_constraint),
                                "boolean_constraint" => Ok(__FieldTag::__boolean_constraint),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Constraint;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Constraint")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__constraint_default => {
                                if !fields.insert(__FieldTag::__constraint_default) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for constraint_default",
                                    ));
                                }
                                result.constraint_default = map.next_value::<std::option::Option<crate::model::analyzer_org_policy_constraint::constraint::ConstraintDefault>>()?.unwrap_or_default();
                            }
                            __FieldTag::__list_constraint => {
                                if !fields.insert(__FieldTag::__list_constraint) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for list_constraint",
                                    ));
                                }
                                if result.constraint_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `constraint_type`, a oneof with full ID .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.Constraint.list_constraint, latest field was listConstraint",
                                    ));
                                }
                                result.constraint_type = std::option::Option::Some(
                                    crate::model::analyzer_org_policy_constraint::constraint::ConstraintType::ListConstraint(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::analyzer_org_policy_constraint::constraint::ListConstraint>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__boolean_constraint => {
                                if !fields.insert(__FieldTag::__boolean_constraint) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for boolean_constraint",
                                    ));
                                }
                                if result.constraint_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `constraint_type`, a oneof with full ID .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.Constraint.boolean_constraint, latest field was booleanConstraint",
                                    ));
                                }
                                result.constraint_type = std::option::Option::Some(
                                    crate::model::analyzer_org_policy_constraint::constraint::ConstraintType::BooleanConstraint(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::analyzer_org_policy_constraint::constraint::BooleanConstraint>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Constraint {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !wkt::internal::is_default(&self.constraint_default) {
                state.serialize_entry("constraintDefault", &self.constraint_default)?;
            }
            if let Some(value) = self.list_constraint() {
                state.serialize_entry("listConstraint", value)?;
            }
            if let Some(value) = self.boolean_constraint() {
                state.serialize_entry("booleanConstraint", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Constraint {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Constraint");
            debug_struct.field("name", &self.name);
            debug_struct.field("display_name", &self.display_name);
            debug_struct.field("description", &self.description);
            debug_struct.field("constraint_default", &self.constraint_default);
            debug_struct.field("constraint_type", &self.constraint_type);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Constraint].
    pub mod constraint {
        #[allow(unused_imports)]
        use super::*;

        /// A `Constraint` that allows or disallows a list of string values, which
        /// are configured by an organization's policy administrator with a `Policy`.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ListConstraint {
            /// Indicates whether values grouped into categories can be used in
            /// `Policy.allowed_values` and `Policy.denied_values`. For example,
            /// `"in:Python"` would match any value in the 'Python' group.
            pub supports_in: bool,

            /// Indicates whether subtrees of Cloud Resource Manager resource hierarchy
            /// can be used in `Policy.allowed_values` and `Policy.denied_values`. For
            /// example, `"under:folders/123"` would match any resource under the
            /// 'folders/123' folder.
            pub supports_under: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ListConstraint {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [supports_in][crate::model::analyzer_org_policy_constraint::constraint::ListConstraint::supports_in].
            pub fn set_supports_in<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.supports_in = v.into();
                self
            }

            /// Sets the value of [supports_under][crate::model::analyzer_org_policy_constraint::constraint::ListConstraint::supports_under].
            pub fn set_supports_under<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.supports_under = v.into();
                self
            }
        }

        impl wkt::message::Message for ListConstraint {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.Constraint.ListConstraint"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ListConstraint {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __supports_in,
                    __supports_under,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ListConstraint")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "supportsIn" => Ok(__FieldTag::__supports_in),
                                    "supports_in" => Ok(__FieldTag::__supports_in),
                                    "supportsUnder" => Ok(__FieldTag::__supports_under),
                                    "supports_under" => Ok(__FieldTag::__supports_under),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ListConstraint;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ListConstraint")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__supports_in => {
                                    if !fields.insert(__FieldTag::__supports_in) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for supports_in",
                                            ),
                                        );
                                    }
                                    result.supports_in = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__supports_under => {
                                    if !fields.insert(__FieldTag::__supports_under) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for supports_under",
                                            ),
                                        );
                                    }
                                    result.supports_under = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ListConstraint {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.supports_in) {
                    state.serialize_entry("supportsIn", &self.supports_in)?;
                }
                if !wkt::internal::is_default(&self.supports_under) {
                    state.serialize_entry("supportsUnder", &self.supports_under)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for ListConstraint {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("ListConstraint");
                debug_struct.field("supports_in", &self.supports_in);
                debug_struct.field("supports_under", &self.supports_under);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// A `Constraint` that is either enforced or not.
        ///
        /// For example a constraint `constraints/compute.disableSerialPortAccess`.
        /// If it is enforced on a VM instance, serial port connections will not be
        /// opened to that instance.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BooleanConstraint {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BooleanConstraint {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for BooleanConstraint {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.Constraint.BooleanConstraint"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BooleanConstraint {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BooleanConstraint")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BooleanConstraint;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BooleanConstraint")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for BooleanConstraint {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for BooleanConstraint {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("BooleanConstraint");

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Specifies the default behavior in the absence of any `Policy` for the
        /// `Constraint`. This must not be `CONSTRAINT_DEFAULT_UNSPECIFIED`.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ConstraintDefault {
            /// This is only used for distinguishing unset values and should never be
            /// used.
            Unspecified,
            /// Indicate that all values are allowed for list constraints.
            /// Indicate that enforcement is off for boolean constraints.
            Allow,
            /// Indicate that all values are denied for list constraints.
            /// Indicate that enforcement is on for boolean constraints.
            Deny,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ConstraintDefault::value] or
            /// [ConstraintDefault::name].
            UnknownValue(constraint_default::UnknownValue),
        }

        #[doc(hidden)]
        pub mod constraint_default {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ConstraintDefault {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Allow => std::option::Option::Some(1),
                    Self::Deny => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("CONSTRAINT_DEFAULT_UNSPECIFIED")
                    }
                    Self::Allow => std::option::Option::Some("ALLOW"),
                    Self::Deny => std::option::Option::Some("DENY"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ConstraintDefault {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ConstraintDefault {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ConstraintDefault {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Allow,
                    2 => Self::Deny,
                    _ => Self::UnknownValue(constraint_default::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ConstraintDefault {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CONSTRAINT_DEFAULT_UNSPECIFIED" => Self::Unspecified,
                    "ALLOW" => Self::Allow,
                    "DENY" => Self::Deny,
                    _ => Self::UnknownValue(constraint_default::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ConstraintDefault {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Allow => serializer.serialize_i32(1),
                    Self::Deny => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ConstraintDefault {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConstraintDefault>::new(
                    ".google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.Constraint.ConstraintDefault"))
            }
        }

        /// The type of restrictions for this `Constraint`.
        ///
        /// Immutable after creation.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ConstraintType {
            /// Defines this constraint as being a ListConstraint.
            ListConstraint(
                std::boxed::Box<
                    crate::model::analyzer_org_policy_constraint::constraint::ListConstraint,
                >,
            ),
            /// Defines this constraint as being a BooleanConstraint.
            BooleanConstraint(
                std::boxed::Box<
                    crate::model::analyzer_org_policy_constraint::constraint::BooleanConstraint,
                >,
            ),
        }
    }

    /// The definition of a custom constraint.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CustomConstraint {
        /// Name of the constraint. This is unique within the organization. Format of
        /// the name should be
        ///
        /// * `organizations/{organization_id}/customConstraints/{custom_constraint_id}`
        ///
        /// Example :
        /// "organizations/123/customConstraints/custom.createOnlyE2TypeVms"
        pub name: std::string::String,

        /// The Resource Instance type on which this policy applies to. Format will
        /// be of the form : "\<canonical service name\>/\<type\>" Example:
        ///
        /// * `compute.googleapis.com/Instance`.
        pub resource_types: std::vec::Vec<std::string::String>,

        /// All the operations being applied for this constraint.
        pub method_types: std::vec::Vec<
            crate::model::analyzer_org_policy_constraint::custom_constraint::MethodType,
        >,

        /// Organization Policy condition/expression. For example:
        /// `resource.instanceName.matches("[production|test]_.*_(\d)+")'` or,
        /// `resource.management.auto_upgrade == true`
        pub condition: std::string::String,

        /// Allow or deny type.
        pub action_type:
            crate::model::analyzer_org_policy_constraint::custom_constraint::ActionType,

        /// One line display name for the UI.
        pub display_name: std::string::String,

        /// Detailed information about this custom policy constraint.
        pub description: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CustomConstraint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::analyzer_org_policy_constraint::CustomConstraint::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [resource_types][crate::model::analyzer_org_policy_constraint::CustomConstraint::resource_types].
        pub fn set_resource_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.resource_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [method_types][crate::model::analyzer_org_policy_constraint::CustomConstraint::method_types].
        pub fn set_method_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::analyzer_org_policy_constraint::custom_constraint::MethodType,
                >,
        {
            use std::iter::Iterator;
            self.method_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [condition][crate::model::analyzer_org_policy_constraint::CustomConstraint::condition].
        pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.condition = v.into();
            self
        }

        /// Sets the value of [action_type][crate::model::analyzer_org_policy_constraint::CustomConstraint::action_type].
        pub fn set_action_type<
            T: std::convert::Into<
                    crate::model::analyzer_org_policy_constraint::custom_constraint::ActionType,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.action_type = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::analyzer_org_policy_constraint::CustomConstraint::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::analyzer_org_policy_constraint::CustomConstraint::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }
    }

    impl wkt::message::Message for CustomConstraint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.CustomConstraint"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CustomConstraint {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __resource_types,
                __method_types,
                __condition,
                __action_type,
                __display_name,
                __description,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CustomConstraint")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "resourceTypes" => Ok(__FieldTag::__resource_types),
                                "resource_types" => Ok(__FieldTag::__resource_types),
                                "methodTypes" => Ok(__FieldTag::__method_types),
                                "method_types" => Ok(__FieldTag::__method_types),
                                "condition" => Ok(__FieldTag::__condition),
                                "actionType" => Ok(__FieldTag::__action_type),
                                "action_type" => Ok(__FieldTag::__action_type),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "description" => Ok(__FieldTag::__description),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CustomConstraint;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CustomConstraint")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__resource_types => {
                                if !fields.insert(__FieldTag::__resource_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_types",
                                    ));
                                }
                                result.resource_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__method_types => {
                                if !fields.insert(__FieldTag::__method_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for method_types",
                                    ));
                                }
                                result.method_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyzer_org_policy_constraint::custom_constraint::MethodType>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__condition => {
                                if !fields.insert(__FieldTag::__condition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition",
                                    ));
                                }
                                result.condition = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__action_type => {
                                if !fields.insert(__FieldTag::__action_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for action_type",
                                    ));
                                }
                                result.action_type = map.next_value::<std::option::Option<crate::model::analyzer_org_policy_constraint::custom_constraint::ActionType>>()?.unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CustomConstraint {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.resource_types.is_empty() {
                state.serialize_entry("resourceTypes", &self.resource_types)?;
            }
            if !self.method_types.is_empty() {
                state.serialize_entry("methodTypes", &self.method_types)?;
            }
            if !self.condition.is_empty() {
                state.serialize_entry("condition", &self.condition)?;
            }
            if !wkt::internal::is_default(&self.action_type) {
                state.serialize_entry("actionType", &self.action_type)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CustomConstraint {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CustomConstraint");
            debug_struct.field("name", &self.name);
            debug_struct.field("resource_types", &self.resource_types);
            debug_struct.field("method_types", &self.method_types);
            debug_struct.field("condition", &self.condition);
            debug_struct.field("action_type", &self.action_type);
            debug_struct.field("display_name", &self.display_name);
            debug_struct.field("description", &self.description);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [CustomConstraint].
    pub mod custom_constraint {
        #[allow(unused_imports)]
        use super::*;

        /// The operation in which this constraint will be applied. For example:
        /// If the constraint applies only when create VMs, the method_types will be
        /// "CREATE" only. If the constraint applied when create or delete VMs, the
        /// method_types will be "CREATE" and "DELETE".
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MethodType {
            /// Unspecified. Will results in user error.
            Unspecified,
            /// Constraint applied when creating the resource.
            Create,
            /// Constraint applied when updating the resource.
            Update,
            /// Constraint applied when deleting the resource.
            Delete,
            /// Constraint applied when removing an IAM grant.
            RemoveGrant,
            /// Constraint applied when enforcing forced tagging.
            GovernTags,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [MethodType::value] or
            /// [MethodType::name].
            UnknownValue(method_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod method_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl MethodType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Create => std::option::Option::Some(1),
                    Self::Update => std::option::Option::Some(2),
                    Self::Delete => std::option::Option::Some(3),
                    Self::RemoveGrant => std::option::Option::Some(4),
                    Self::GovernTags => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("METHOD_TYPE_UNSPECIFIED"),
                    Self::Create => std::option::Option::Some("CREATE"),
                    Self::Update => std::option::Option::Some("UPDATE"),
                    Self::Delete => std::option::Option::Some("DELETE"),
                    Self::RemoveGrant => std::option::Option::Some("REMOVE_GRANT"),
                    Self::GovernTags => std::option::Option::Some("GOVERN_TAGS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for MethodType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for MethodType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for MethodType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Create,
                    2 => Self::Update,
                    3 => Self::Delete,
                    4 => Self::RemoveGrant,
                    5 => Self::GovernTags,
                    _ => Self::UnknownValue(method_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for MethodType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "METHOD_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "CREATE" => Self::Create,
                    "UPDATE" => Self::Update,
                    "DELETE" => Self::Delete,
                    "REMOVE_GRANT" => Self::RemoveGrant,
                    "GOVERN_TAGS" => Self::GovernTags,
                    _ => Self::UnknownValue(method_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for MethodType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Create => serializer.serialize_i32(1),
                    Self::Update => serializer.serialize_i32(2),
                    Self::Delete => serializer.serialize_i32(3),
                    Self::RemoveGrant => serializer.serialize_i32(4),
                    Self::GovernTags => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for MethodType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<MethodType>::new(
                    ".google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.CustomConstraint.MethodType"))
            }
        }

        /// Allow or deny type.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ActionType {
            /// Unspecified. Will results in user error.
            Unspecified,
            /// Allowed action type.
            Allow,
            /// Deny action type.
            Deny,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ActionType::value] or
            /// [ActionType::name].
            UnknownValue(action_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod action_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ActionType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Allow => std::option::Option::Some(1),
                    Self::Deny => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ACTION_TYPE_UNSPECIFIED"),
                    Self::Allow => std::option::Option::Some("ALLOW"),
                    Self::Deny => std::option::Option::Some("DENY"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ActionType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ActionType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ActionType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Allow,
                    2 => Self::Deny,
                    _ => Self::UnknownValue(action_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ActionType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ACTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "ALLOW" => Self::Allow,
                    "DENY" => Self::Deny,
                    _ => Self::UnknownValue(action_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ActionType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Allow => serializer.serialize_i32(1),
                    Self::Deny => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ActionType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ActionType>::new(
                    ".google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.CustomConstraint.ActionType"))
            }
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConstraintDefinition {
        /// The definition of the canned constraint defined by Google.
        GoogleDefinedConstraint(
            std::boxed::Box<crate::model::analyzer_org_policy_constraint::Constraint>,
        ),
        /// The definition of the custom constraint.
        CustomConstraint(
            std::boxed::Box<crate::model::analyzer_org_policy_constraint::CustomConstraint>,
        ),
    }
}

/// A request message for
/// [AssetService.AnalyzeOrgPolicies][google.cloud.asset.v1.AssetService.AnalyzeOrgPolicies].
///
/// [google.cloud.asset.v1.AssetService.AnalyzeOrgPolicies]: crate::client::AssetService::analyze_org_policies
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeOrgPoliciesRequest {
    /// Required. The organization to scope the request. Only organization
    /// policies within the scope will be analyzed.
    ///
    /// * organizations/{ORGANIZATION_NUMBER} (e.g., "organizations/123456")
    pub scope: std::string::String,

    /// Required. The name of the constraint to analyze organization policies for.
    /// The response only contains analyzed organization policies for the provided
    /// constraint.
    pub constraint: std::string::String,

    /// The expression to filter
    /// [AnalyzeOrgPoliciesResponse.org_policy_results][google.cloud.asset.v1.AnalyzeOrgPoliciesResponse.org_policy_results].
    /// Filtering is currently available for bare literal values and the following
    /// fields:
    ///
    /// * consolidated_policy.attached_resource
    /// * consolidated_policy.rules.enforce
    ///
    /// When filtering by a specific field, the only supported operator is `=`.
    /// For example, filtering by
    /// consolidated_policy.attached_resource="//cloudresourcemanager.googleapis.com/folders/001"
    /// will return all the Organization Policy results attached to "folders/001".
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPoliciesResponse.org_policy_results]: crate::model::AnalyzeOrgPoliciesResponse::org_policy_results
    pub filter: std::string::String,

    /// The maximum number of items to return per page. If unspecified,
    /// [AnalyzeOrgPoliciesResponse.org_policy_results][google.cloud.asset.v1.AnalyzeOrgPoliciesResponse.org_policy_results]
    /// will contain 20 items with a maximum of 200.
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPoliciesResponse.org_policy_results]: crate::model::AnalyzeOrgPoliciesResponse::org_policy_results
    pub page_size: std::option::Option<i32>,

    /// The pagination token to retrieve the next page.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeOrgPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scope][crate::model::AnalyzeOrgPoliciesRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [constraint][crate::model::AnalyzeOrgPoliciesRequest::constraint].
    pub fn set_constraint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.constraint = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::AnalyzeOrgPoliciesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::AnalyzeOrgPoliciesRequest::page_size].
    pub fn set_page_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_size][crate::model::AnalyzeOrgPoliciesRequest::page_size].
    pub fn set_or_clear_page_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_token][crate::model::AnalyzeOrgPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeOrgPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzeOrgPoliciesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeOrgPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scope,
            __constraint,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeOrgPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scope" => Ok(__FieldTag::__scope),
                            "constraint" => Ok(__FieldTag::__constraint),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeOrgPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeOrgPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__constraint => {
                            if !fields.insert(__FieldTag::__constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraint",
                                ));
                            }
                            result.constraint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeOrgPoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self.constraint.is_empty() {
            state.serialize_entry("constraint", &self.constraint)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.page_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeOrgPoliciesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeOrgPoliciesRequest");
        debug_struct.field("scope", &self.scope);
        debug_struct.field("constraint", &self.constraint);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response message for
/// [AssetService.AnalyzeOrgPolicies][google.cloud.asset.v1.AssetService.AnalyzeOrgPolicies].
///
/// [google.cloud.asset.v1.AssetService.AnalyzeOrgPolicies]: crate::client::AssetService::analyze_org_policies
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeOrgPoliciesResponse {
    /// The organization policies under the
    /// [AnalyzeOrgPoliciesRequest.scope][google.cloud.asset.v1.AnalyzeOrgPoliciesRequest.scope]
    /// with the
    /// [AnalyzeOrgPoliciesRequest.constraint][google.cloud.asset.v1.AnalyzeOrgPoliciesRequest.constraint].
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPoliciesRequest.constraint]: crate::model::AnalyzeOrgPoliciesRequest::constraint
    /// [google.cloud.asset.v1.AnalyzeOrgPoliciesRequest.scope]: crate::model::AnalyzeOrgPoliciesRequest::scope
    pub org_policy_results:
        std::vec::Vec<crate::model::analyze_org_policies_response::OrgPolicyResult>,

    /// The definition of the constraint in the request.
    pub constraint: std::option::Option<crate::model::AnalyzerOrgPolicyConstraint>,

    /// The page token to fetch the next page for
    /// [AnalyzeOrgPoliciesResponse.org_policy_results][google.cloud.asset.v1.AnalyzeOrgPoliciesResponse.org_policy_results].
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPoliciesResponse.org_policy_results]: crate::model::AnalyzeOrgPoliciesResponse::org_policy_results
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeOrgPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [org_policy_results][crate::model::AnalyzeOrgPoliciesResponse::org_policy_results].
    pub fn set_org_policy_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::analyze_org_policies_response::OrgPolicyResult>,
    {
        use std::iter::Iterator;
        self.org_policy_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [constraint][crate::model::AnalyzeOrgPoliciesResponse::constraint].
    pub fn set_constraint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnalyzerOrgPolicyConstraint>,
    {
        self.constraint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [constraint][crate::model::AnalyzeOrgPoliciesResponse::constraint].
    pub fn set_or_clear_constraint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnalyzerOrgPolicyConstraint>,
    {
        self.constraint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::AnalyzeOrgPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeOrgPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzeOrgPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for AnalyzeOrgPoliciesResponse {
    type PageItem = crate::model::analyze_org_policies_response::OrgPolicyResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.org_policy_results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeOrgPoliciesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __org_policy_results,
            __constraint,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeOrgPoliciesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "orgPolicyResults" => Ok(__FieldTag::__org_policy_results),
                            "org_policy_results" => Ok(__FieldTag::__org_policy_results),
                            "constraint" => Ok(__FieldTag::__constraint),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeOrgPoliciesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeOrgPoliciesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__org_policy_results => {
                            if !fields.insert(__FieldTag::__org_policy_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for org_policy_results",
                                ));
                            }
                            result.org_policy_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyze_org_policies_response::OrgPolicyResult>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__constraint => {
                            if !fields.insert(__FieldTag::__constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraint",
                                ));
                            }
                            result.constraint = map.next_value::<std::option::Option<crate::model::AnalyzerOrgPolicyConstraint>>()?
                                ;
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeOrgPoliciesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.org_policy_results.is_empty() {
            state.serialize_entry("orgPolicyResults", &self.org_policy_results)?;
        }
        if self.constraint.is_some() {
            state.serialize_entry("constraint", &self.constraint)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeOrgPoliciesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeOrgPoliciesResponse");
        debug_struct.field("org_policy_results", &self.org_policy_results);
        debug_struct.field("constraint", &self.constraint);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AnalyzeOrgPoliciesResponse].
pub mod analyze_org_policies_response {
    #[allow(unused_imports)]
    use super::*;

    /// The organization policy result to the query.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OrgPolicyResult {
        /// The consolidated organization policy for the analyzed resource. The
        /// consolidated organization policy is computed by merging and evaluating
        /// [policy_bundle][google.cloud.asset.v1.AnalyzeOrgPoliciesResponse.OrgPolicyResult.policy_bundle].
        /// The evaluation will respect the organization policy [hierarchy
        /// rules](https://cloud.google.com/resource-manager/docs/organization-policy/understanding-hierarchy).
        ///
        /// [google.cloud.asset.v1.AnalyzeOrgPoliciesResponse.OrgPolicyResult.policy_bundle]: crate::model::analyze_org_policies_response::OrgPolicyResult::policy_bundle
        pub consolidated_policy: std::option::Option<crate::model::AnalyzerOrgPolicy>,

        /// The ordered list of all organization policies from the
        /// [consolidated_policy.attached_resource][google.cloud.asset.v1.AnalyzerOrgPolicy.attached_resource].
        /// to the scope specified in the request.
        ///
        /// If the constraint is defined with default policy, it will also appear in
        /// the list.
        ///
        /// [google.cloud.asset.v1.AnalyzerOrgPolicy.attached_resource]: crate::model::AnalyzerOrgPolicy::attached_resource
        pub policy_bundle: std::vec::Vec<crate::model::AnalyzerOrgPolicy>,

        /// The project that this consolidated policy belongs to, in the format of
        /// projects/{PROJECT_NUMBER}. This field is available when the consolidated
        /// policy belongs to a project.
        pub project: std::string::String,

        /// The folder(s) that this consolidated policy belongs to, in the format of
        /// folders/{FOLDER_NUMBER}. This field is available when the consolidated
        /// policy belongs (directly or cascadingly) to one or more folders.
        pub folders: std::vec::Vec<std::string::String>,

        /// The organization that this consolidated policy belongs to, in the format
        /// of organizations/{ORGANIZATION_NUMBER}. This field is available when the
        /// consolidated policy belongs (directly or cascadingly) to an organization.
        pub organization: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OrgPolicyResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [consolidated_policy][crate::model::analyze_org_policies_response::OrgPolicyResult::consolidated_policy].
        pub fn set_consolidated_policy<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::AnalyzerOrgPolicy>,
        {
            self.consolidated_policy = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [consolidated_policy][crate::model::analyze_org_policies_response::OrgPolicyResult::consolidated_policy].
        pub fn set_or_clear_consolidated_policy<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::AnalyzerOrgPolicy>,
        {
            self.consolidated_policy = v.map(|x| x.into());
            self
        }

        /// Sets the value of [policy_bundle][crate::model::analyze_org_policies_response::OrgPolicyResult::policy_bundle].
        pub fn set_policy_bundle<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::AnalyzerOrgPolicy>,
        {
            use std::iter::Iterator;
            self.policy_bundle = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [project][crate::model::analyze_org_policies_response::OrgPolicyResult::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [folders][crate::model::analyze_org_policies_response::OrgPolicyResult::folders].
        pub fn set_folders<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.folders = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [organization][crate::model::analyze_org_policies_response::OrgPolicyResult::organization].
        pub fn set_organization<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.organization = v.into();
            self
        }
    }

    impl wkt::message::Message for OrgPolicyResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.AnalyzeOrgPoliciesResponse.OrgPolicyResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OrgPolicyResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __consolidated_policy,
                __policy_bundle,
                __project,
                __folders,
                __organization,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OrgPolicyResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "consolidatedPolicy" => Ok(__FieldTag::__consolidated_policy),
                                "consolidated_policy" => Ok(__FieldTag::__consolidated_policy),
                                "policyBundle" => Ok(__FieldTag::__policy_bundle),
                                "policy_bundle" => Ok(__FieldTag::__policy_bundle),
                                "project" => Ok(__FieldTag::__project),
                                "folders" => Ok(__FieldTag::__folders),
                                "organization" => Ok(__FieldTag::__organization),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OrgPolicyResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OrgPolicyResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__consolidated_policy => {
                                if !fields.insert(__FieldTag::__consolidated_policy) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for consolidated_policy",
                                    ));
                                }
                                result.consolidated_policy = map.next_value::<std::option::Option<crate::model::AnalyzerOrgPolicy>>()?
                                    ;
                            }
                            __FieldTag::__policy_bundle => {
                                if !fields.insert(__FieldTag::__policy_bundle) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for policy_bundle",
                                    ));
                                }
                                result.policy_bundle = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::AnalyzerOrgPolicy>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__project => {
                                if !fields.insert(__FieldTag::__project) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project",
                                    ));
                                }
                                result.project = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__folders => {
                                if !fields.insert(__FieldTag::__folders) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for folders",
                                    ));
                                }
                                result.folders = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__organization => {
                                if !fields.insert(__FieldTag::__organization) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for organization",
                                    ));
                                }
                                result.organization = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for OrgPolicyResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.consolidated_policy.is_some() {
                state.serialize_entry("consolidatedPolicy", &self.consolidated_policy)?;
            }
            if !self.policy_bundle.is_empty() {
                state.serialize_entry("policyBundle", &self.policy_bundle)?;
            }
            if !self.project.is_empty() {
                state.serialize_entry("project", &self.project)?;
            }
            if !self.folders.is_empty() {
                state.serialize_entry("folders", &self.folders)?;
            }
            if !self.organization.is_empty() {
                state.serialize_entry("organization", &self.organization)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for OrgPolicyResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("OrgPolicyResult");
            debug_struct.field("consolidated_policy", &self.consolidated_policy);
            debug_struct.field("policy_bundle", &self.policy_bundle);
            debug_struct.field("project", &self.project);
            debug_struct.field("folders", &self.folders);
            debug_struct.field("organization", &self.organization);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// A request message for
/// [AssetService.AnalyzeOrgPolicyGovernedContainers][google.cloud.asset.v1.AssetService.AnalyzeOrgPolicyGovernedContainers].
///
/// [google.cloud.asset.v1.AssetService.AnalyzeOrgPolicyGovernedContainers]: crate::client::AssetService::analyze_org_policy_governed_containers
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeOrgPolicyGovernedContainersRequest {
    /// Required. The organization to scope the request. Only organization
    /// policies within the scope will be analyzed. The output containers will
    /// also be limited to the ones governed by those in-scope organization
    /// policies.
    ///
    /// * organizations/{ORGANIZATION_NUMBER} (e.g., "organizations/123456")
    pub scope: std::string::String,

    /// Required. The name of the constraint to analyze governed containers for.
    /// The analysis only contains organization policies for the provided
    /// constraint.
    pub constraint: std::string::String,

    /// The expression to filter
    /// [AnalyzeOrgPolicyGovernedContainersResponse.governed_containers][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.governed_containers].
    /// Filtering is currently available for bare literal values and the following
    /// fields:
    ///
    /// * parent
    /// * consolidated_policy.rules.enforce
    ///
    /// When filtering by a specific field, the only supported operator is `=`.
    /// For example, filtering by
    /// parent="//cloudresourcemanager.googleapis.com/folders/001"
    /// will return all the containers under "folders/001".
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.governed_containers]: crate::model::AnalyzeOrgPolicyGovernedContainersResponse::governed_containers
    pub filter: std::string::String,

    /// The maximum number of items to return per page. If unspecified,
    /// [AnalyzeOrgPolicyGovernedContainersResponse.governed_containers][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.governed_containers]
    /// will contain 100 items with a maximum of 200.
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.governed_containers]: crate::model::AnalyzeOrgPolicyGovernedContainersResponse::governed_containers
    pub page_size: std::option::Option<i32>,

    /// The pagination token to retrieve the next page.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeOrgPolicyGovernedContainersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scope][crate::model::AnalyzeOrgPolicyGovernedContainersRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [constraint][crate::model::AnalyzeOrgPolicyGovernedContainersRequest::constraint].
    pub fn set_constraint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.constraint = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::AnalyzeOrgPolicyGovernedContainersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::AnalyzeOrgPolicyGovernedContainersRequest::page_size].
    pub fn set_page_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_size][crate::model::AnalyzeOrgPolicyGovernedContainersRequest::page_size].
    pub fn set_or_clear_page_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_token][crate::model::AnalyzeOrgPolicyGovernedContainersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeOrgPolicyGovernedContainersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeOrgPolicyGovernedContainersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scope,
            __constraint,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for AnalyzeOrgPolicyGovernedContainersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scope" => Ok(__FieldTag::__scope),
                            "constraint" => Ok(__FieldTag::__constraint),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeOrgPolicyGovernedContainersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeOrgPolicyGovernedContainersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__constraint => {
                            if !fields.insert(__FieldTag::__constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraint",
                                ));
                            }
                            result.constraint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeOrgPolicyGovernedContainersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self.constraint.is_empty() {
            state.serialize_entry("constraint", &self.constraint)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.page_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeOrgPolicyGovernedContainersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeOrgPolicyGovernedContainersRequest");
        debug_struct.field("scope", &self.scope);
        debug_struct.field("constraint", &self.constraint);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response message for
/// [AssetService.AnalyzeOrgPolicyGovernedContainers][google.cloud.asset.v1.AssetService.AnalyzeOrgPolicyGovernedContainers].
///
/// [google.cloud.asset.v1.AssetService.AnalyzeOrgPolicyGovernedContainers]: crate::client::AssetService::analyze_org_policy_governed_containers
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeOrgPolicyGovernedContainersResponse {
    /// The list of the analyzed governed containers.
    pub governed_containers: std::vec::Vec<
        crate::model::analyze_org_policy_governed_containers_response::GovernedContainer,
    >,

    /// The definition of the constraint in the request.
    pub constraint: std::option::Option<crate::model::AnalyzerOrgPolicyConstraint>,

    /// The page token to fetch the next page for
    /// [AnalyzeOrgPolicyGovernedContainersResponse.governed_containers][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.governed_containers].
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.governed_containers]: crate::model::AnalyzeOrgPolicyGovernedContainersResponse::governed_containers
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeOrgPolicyGovernedContainersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [governed_containers][crate::model::AnalyzeOrgPolicyGovernedContainersResponse::governed_containers].
    pub fn set_governed_containers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::analyze_org_policy_governed_containers_response::GovernedContainer,
            >,
    {
        use std::iter::Iterator;
        self.governed_containers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [constraint][crate::model::AnalyzeOrgPolicyGovernedContainersResponse::constraint].
    pub fn set_constraint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnalyzerOrgPolicyConstraint>,
    {
        self.constraint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [constraint][crate::model::AnalyzeOrgPolicyGovernedContainersResponse::constraint].
    pub fn set_or_clear_constraint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnalyzerOrgPolicyConstraint>,
    {
        self.constraint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::AnalyzeOrgPolicyGovernedContainersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeOrgPolicyGovernedContainersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for AnalyzeOrgPolicyGovernedContainersResponse {
    type PageItem =
        crate::model::analyze_org_policy_governed_containers_response::GovernedContainer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.governed_containers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeOrgPolicyGovernedContainersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __governed_containers,
            __constraint,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for AnalyzeOrgPolicyGovernedContainersResponse",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "governedContainers" => Ok(__FieldTag::__governed_containers),
                            "governed_containers" => Ok(__FieldTag::__governed_containers),
                            "constraint" => Ok(__FieldTag::__constraint),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeOrgPolicyGovernedContainersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeOrgPolicyGovernedContainersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__governed_containers => {
                            if !fields.insert(__FieldTag::__governed_containers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for governed_containers",
                                ));
                            }
                            result.governed_containers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyze_org_policy_governed_containers_response::GovernedContainer>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__constraint => {
                            if !fields.insert(__FieldTag::__constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraint",
                                ));
                            }
                            result.constraint = map.next_value::<std::option::Option<crate::model::AnalyzerOrgPolicyConstraint>>()?
                                ;
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeOrgPolicyGovernedContainersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.governed_containers.is_empty() {
            state.serialize_entry("governedContainers", &self.governed_containers)?;
        }
        if self.constraint.is_some() {
            state.serialize_entry("constraint", &self.constraint)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeOrgPolicyGovernedContainersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeOrgPolicyGovernedContainersResponse");
        debug_struct.field("governed_containers", &self.governed_containers);
        debug_struct.field("constraint", &self.constraint);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AnalyzeOrgPolicyGovernedContainersResponse].
pub mod analyze_org_policy_governed_containers_response {
    #[allow(unused_imports)]
    use super::*;

    /// The organization/folder/project resource governed by organization policies
    /// of
    /// [AnalyzeOrgPolicyGovernedContainersRequest.constraint][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersRequest.constraint].
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersRequest.constraint]: crate::model::AnalyzeOrgPolicyGovernedContainersRequest::constraint
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GovernedContainer {
        /// The [full resource name]
        /// (<https://cloud.google.com/asset-inventory/docs/resource-name-format>) of
        /// an organization/folder/project resource.
        pub full_resource_name: std::string::String,

        /// The [full resource name]
        /// (<https://cloud.google.com/asset-inventory/docs/resource-name-format>) of
        /// the parent of
        /// [AnalyzeOrgPolicyGovernedContainersResponse.GovernedContainer.full_resource_name][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.GovernedContainer.full_resource_name].
        ///
        /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.GovernedContainer.full_resource_name]: crate::model::analyze_org_policy_governed_containers_response::GovernedContainer::full_resource_name
        pub parent: std::string::String,

        /// The consolidated organization policy for the analyzed resource. The
        /// consolidated organization policy is computed by merging and evaluating
        /// [AnalyzeOrgPolicyGovernedContainersResponse.GovernedContainer.policy_bundle][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.GovernedContainer.policy_bundle].
        /// The evaluation will respect the organization policy [hierarchy
        /// rules](https://cloud.google.com/resource-manager/docs/organization-policy/understanding-hierarchy).
        ///
        /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.GovernedContainer.policy_bundle]: crate::model::analyze_org_policy_governed_containers_response::GovernedContainer::policy_bundle
        pub consolidated_policy: std::option::Option<crate::model::AnalyzerOrgPolicy>,

        /// The ordered list of all organization policies from the
        /// [consolidated_policy.attached_resource][google.cloud.asset.v1.AnalyzerOrgPolicy.attached_resource].
        /// to the scope specified in the request.
        ///
        /// If the constraint is defined with default policy, it will also appear in
        /// the list.
        ///
        /// [google.cloud.asset.v1.AnalyzerOrgPolicy.attached_resource]: crate::model::AnalyzerOrgPolicy::attached_resource
        pub policy_bundle: std::vec::Vec<crate::model::AnalyzerOrgPolicy>,

        /// The project that this resource belongs to, in the format of
        /// projects/{PROJECT_NUMBER}. This field is available when the resource
        /// belongs to a project.
        pub project: std::string::String,

        /// The folder(s) that this resource belongs to, in the format of
        /// folders/{FOLDER_NUMBER}. This field is available when the resource
        /// belongs (directly or cascadingly) to one or more folders.
        pub folders: std::vec::Vec<std::string::String>,

        /// The organization that this resource belongs to, in the format of
        /// organizations/{ORGANIZATION_NUMBER}. This field is available when the
        /// resource belongs (directly or cascadingly) to an organization.
        pub organization: std::string::String,

        /// The effective tags on this resource.
        pub effective_tags: std::vec::Vec<crate::model::EffectiveTagDetails>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GovernedContainer {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [full_resource_name][crate::model::analyze_org_policy_governed_containers_response::GovernedContainer::full_resource_name].
        pub fn set_full_resource_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.full_resource_name = v.into();
            self
        }

        /// Sets the value of [parent][crate::model::analyze_org_policy_governed_containers_response::GovernedContainer::parent].
        pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.parent = v.into();
            self
        }

        /// Sets the value of [consolidated_policy][crate::model::analyze_org_policy_governed_containers_response::GovernedContainer::consolidated_policy].
        pub fn set_consolidated_policy<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::AnalyzerOrgPolicy>,
        {
            self.consolidated_policy = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [consolidated_policy][crate::model::analyze_org_policy_governed_containers_response::GovernedContainer::consolidated_policy].
        pub fn set_or_clear_consolidated_policy<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::AnalyzerOrgPolicy>,
        {
            self.consolidated_policy = v.map(|x| x.into());
            self
        }

        /// Sets the value of [policy_bundle][crate::model::analyze_org_policy_governed_containers_response::GovernedContainer::policy_bundle].
        pub fn set_policy_bundle<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::AnalyzerOrgPolicy>,
        {
            use std::iter::Iterator;
            self.policy_bundle = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [project][crate::model::analyze_org_policy_governed_containers_response::GovernedContainer::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [folders][crate::model::analyze_org_policy_governed_containers_response::GovernedContainer::folders].
        pub fn set_folders<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.folders = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [organization][crate::model::analyze_org_policy_governed_containers_response::GovernedContainer::organization].
        pub fn set_organization<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.organization = v.into();
            self
        }

        /// Sets the value of [effective_tags][crate::model::analyze_org_policy_governed_containers_response::GovernedContainer::effective_tags].
        pub fn set_effective_tags<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::EffectiveTagDetails>,
        {
            use std::iter::Iterator;
            self.effective_tags = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GovernedContainer {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.GovernedContainer"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GovernedContainer {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __full_resource_name,
                __parent,
                __consolidated_policy,
                __policy_bundle,
                __project,
                __folders,
                __organization,
                __effective_tags,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GovernedContainer")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "fullResourceName" => Ok(__FieldTag::__full_resource_name),
                                "full_resource_name" => Ok(__FieldTag::__full_resource_name),
                                "parent" => Ok(__FieldTag::__parent),
                                "consolidatedPolicy" => Ok(__FieldTag::__consolidated_policy),
                                "consolidated_policy" => Ok(__FieldTag::__consolidated_policy),
                                "policyBundle" => Ok(__FieldTag::__policy_bundle),
                                "policy_bundle" => Ok(__FieldTag::__policy_bundle),
                                "project" => Ok(__FieldTag::__project),
                                "folders" => Ok(__FieldTag::__folders),
                                "organization" => Ok(__FieldTag::__organization),
                                "effectiveTags" => Ok(__FieldTag::__effective_tags),
                                "effective_tags" => Ok(__FieldTag::__effective_tags),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GovernedContainer;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GovernedContainer")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__full_resource_name => {
                                if !fields.insert(__FieldTag::__full_resource_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for full_resource_name",
                                    ));
                                }
                                result.full_resource_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__parent => {
                                if !fields.insert(__FieldTag::__parent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parent",
                                    ));
                                }
                                result.parent = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__consolidated_policy => {
                                if !fields.insert(__FieldTag::__consolidated_policy) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for consolidated_policy",
                                    ));
                                }
                                result.consolidated_policy = map.next_value::<std::option::Option<crate::model::AnalyzerOrgPolicy>>()?
                                    ;
                            }
                            __FieldTag::__policy_bundle => {
                                if !fields.insert(__FieldTag::__policy_bundle) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for policy_bundle",
                                    ));
                                }
                                result.policy_bundle = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::AnalyzerOrgPolicy>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__project => {
                                if !fields.insert(__FieldTag::__project) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project",
                                    ));
                                }
                                result.project = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__folders => {
                                if !fields.insert(__FieldTag::__folders) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for folders",
                                    ));
                                }
                                result.folders = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__organization => {
                                if !fields.insert(__FieldTag::__organization) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for organization",
                                    ));
                                }
                                result.organization = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__effective_tags => {
                                if !fields.insert(__FieldTag::__effective_tags) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for effective_tags",
                                    ));
                                }
                                result.effective_tags = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::EffectiveTagDetails>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GovernedContainer {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.full_resource_name.is_empty() {
                state.serialize_entry("fullResourceName", &self.full_resource_name)?;
            }
            if !self.parent.is_empty() {
                state.serialize_entry("parent", &self.parent)?;
            }
            if self.consolidated_policy.is_some() {
                state.serialize_entry("consolidatedPolicy", &self.consolidated_policy)?;
            }
            if !self.policy_bundle.is_empty() {
                state.serialize_entry("policyBundle", &self.policy_bundle)?;
            }
            if !self.project.is_empty() {
                state.serialize_entry("project", &self.project)?;
            }
            if !self.folders.is_empty() {
                state.serialize_entry("folders", &self.folders)?;
            }
            if !self.organization.is_empty() {
                state.serialize_entry("organization", &self.organization)?;
            }
            if !self.effective_tags.is_empty() {
                state.serialize_entry("effectiveTags", &self.effective_tags)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GovernedContainer {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GovernedContainer");
            debug_struct.field("full_resource_name", &self.full_resource_name);
            debug_struct.field("parent", &self.parent);
            debug_struct.field("consolidated_policy", &self.consolidated_policy);
            debug_struct.field("policy_bundle", &self.policy_bundle);
            debug_struct.field("project", &self.project);
            debug_struct.field("folders", &self.folders);
            debug_struct.field("organization", &self.organization);
            debug_struct.field("effective_tags", &self.effective_tags);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// A request message for
/// [AssetService.AnalyzeOrgPolicyGovernedAssets][google.cloud.asset.v1.AssetService.AnalyzeOrgPolicyGovernedAssets].
///
/// [google.cloud.asset.v1.AssetService.AnalyzeOrgPolicyGovernedAssets]: crate::client::AssetService::analyze_org_policy_governed_assets
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeOrgPolicyGovernedAssetsRequest {
    /// Required. The organization to scope the request. Only organization
    /// policies within the scope will be analyzed. The output assets will
    /// also be limited to the ones governed by those in-scope organization
    /// policies.
    ///
    /// * organizations/{ORGANIZATION_NUMBER} (e.g., "organizations/123456")
    pub scope: std::string::String,

    /// Required. The name of the constraint to analyze governed assets for. The
    /// analysis only contains analyzed organization policies for the provided
    /// constraint.
    pub constraint: std::string::String,

    /// The expression to filter
    /// [AnalyzeOrgPolicyGovernedAssetsResponse.governed_assets][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.governed_assets].
    ///
    /// For governed resources, filtering is currently available for bare literal
    /// values and the following fields:
    ///
    /// * governed_resource.project
    /// * governed_resource.folders
    /// * consolidated_policy.rules.enforce
    ///   When filtering by `governed_resource.project` or
    ///   `consolidated_policy.rules.enforce`, the only supported operator is `=`.
    ///   When filtering by `governed_resource.folders`, the supported operators
    ///   are `=` and `:`.
    ///   For example, filtering by `governed_resource.project="projects/12345678"`
    ///   will return all the governed resources under "projects/12345678",
    ///   including the project itself if applicable.
    ///
    /// For governed IAM policies, filtering is currently available for bare
    /// literal values and the following fields:
    ///
    /// * governed_iam_policy.project
    /// * governed_iam_policy.folders
    /// * consolidated_policy.rules.enforce
    ///   When filtering by `governed_iam_policy.project` or
    ///   `consolidated_policy.rules.enforce`, the only supported operator is `=`.
    ///   When filtering by `governed_iam_policy.folders`, the supported operators
    ///   are `=` and `:`.
    ///   For example, filtering by `governed_iam_policy.folders:"folders/12345678"`
    ///   will return all the governed IAM policies under "folders/001".
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.governed_assets]: crate::model::AnalyzeOrgPolicyGovernedAssetsResponse::governed_assets
    pub filter: std::string::String,

    /// The maximum number of items to return per page. If unspecified,
    /// [AnalyzeOrgPolicyGovernedAssetsResponse.governed_assets][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.governed_assets]
    /// will contain 100 items with a maximum of 200.
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.governed_assets]: crate::model::AnalyzeOrgPolicyGovernedAssetsResponse::governed_assets
    pub page_size: std::option::Option<i32>,

    /// The pagination token to retrieve the next page.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeOrgPolicyGovernedAssetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scope][crate::model::AnalyzeOrgPolicyGovernedAssetsRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [constraint][crate::model::AnalyzeOrgPolicyGovernedAssetsRequest::constraint].
    pub fn set_constraint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.constraint = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::AnalyzeOrgPolicyGovernedAssetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::AnalyzeOrgPolicyGovernedAssetsRequest::page_size].
    pub fn set_page_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_size][crate::model::AnalyzeOrgPolicyGovernedAssetsRequest::page_size].
    pub fn set_or_clear_page_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_token][crate::model::AnalyzeOrgPolicyGovernedAssetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeOrgPolicyGovernedAssetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeOrgPolicyGovernedAssetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scope,
            __constraint,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for AnalyzeOrgPolicyGovernedAssetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scope" => Ok(__FieldTag::__scope),
                            "constraint" => Ok(__FieldTag::__constraint),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeOrgPolicyGovernedAssetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeOrgPolicyGovernedAssetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__constraint => {
                            if !fields.insert(__FieldTag::__constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraint",
                                ));
                            }
                            result.constraint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeOrgPolicyGovernedAssetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self.constraint.is_empty() {
            state.serialize_entry("constraint", &self.constraint)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.page_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeOrgPolicyGovernedAssetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeOrgPolicyGovernedAssetsRequest");
        debug_struct.field("scope", &self.scope);
        debug_struct.field("constraint", &self.constraint);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response message for
/// [AssetService.AnalyzeOrgPolicyGovernedAssets][google.cloud.asset.v1.AssetService.AnalyzeOrgPolicyGovernedAssets].
///
/// [google.cloud.asset.v1.AssetService.AnalyzeOrgPolicyGovernedAssets]: crate::client::AssetService::analyze_org_policy_governed_assets
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeOrgPolicyGovernedAssetsResponse {
    /// The list of the analyzed governed assets.
    pub governed_assets:
        std::vec::Vec<crate::model::analyze_org_policy_governed_assets_response::GovernedAsset>,

    /// The definition of the constraint in the request.
    pub constraint: std::option::Option<crate::model::AnalyzerOrgPolicyConstraint>,

    /// The page token to fetch the next page for
    /// [AnalyzeOrgPolicyGovernedAssetsResponse.governed_assets][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.governed_assets].
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.governed_assets]: crate::model::AnalyzeOrgPolicyGovernedAssetsResponse::governed_assets
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeOrgPolicyGovernedAssetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [governed_assets][crate::model::AnalyzeOrgPolicyGovernedAssetsResponse::governed_assets].
    pub fn set_governed_assets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::analyze_org_policy_governed_assets_response::GovernedAsset,
            >,
    {
        use std::iter::Iterator;
        self.governed_assets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [constraint][crate::model::AnalyzeOrgPolicyGovernedAssetsResponse::constraint].
    pub fn set_constraint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnalyzerOrgPolicyConstraint>,
    {
        self.constraint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [constraint][crate::model::AnalyzeOrgPolicyGovernedAssetsResponse::constraint].
    pub fn set_or_clear_constraint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnalyzerOrgPolicyConstraint>,
    {
        self.constraint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::AnalyzeOrgPolicyGovernedAssetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeOrgPolicyGovernedAssetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for AnalyzeOrgPolicyGovernedAssetsResponse {
    type PageItem = crate::model::analyze_org_policy_governed_assets_response::GovernedAsset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.governed_assets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeOrgPolicyGovernedAssetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __governed_assets,
            __constraint,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for AnalyzeOrgPolicyGovernedAssetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "governedAssets" => Ok(__FieldTag::__governed_assets),
                            "governed_assets" => Ok(__FieldTag::__governed_assets),
                            "constraint" => Ok(__FieldTag::__constraint),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeOrgPolicyGovernedAssetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeOrgPolicyGovernedAssetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__governed_assets => {
                            if !fields.insert(__FieldTag::__governed_assets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for governed_assets",
                                ));
                            }
                            result.governed_assets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyze_org_policy_governed_assets_response::GovernedAsset>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__constraint => {
                            if !fields.insert(__FieldTag::__constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraint",
                                ));
                            }
                            result.constraint = map.next_value::<std::option::Option<crate::model::AnalyzerOrgPolicyConstraint>>()?
                                ;
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeOrgPolicyGovernedAssetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.governed_assets.is_empty() {
            state.serialize_entry("governedAssets", &self.governed_assets)?;
        }
        if self.constraint.is_some() {
            state.serialize_entry("constraint", &self.constraint)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeOrgPolicyGovernedAssetsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeOrgPolicyGovernedAssetsResponse");
        debug_struct.field("governed_assets", &self.governed_assets);
        debug_struct.field("constraint", &self.constraint);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AnalyzeOrgPolicyGovernedAssetsResponse].
pub mod analyze_org_policy_governed_assets_response {
    #[allow(unused_imports)]
    use super::*;

    /// The Google Cloud resources governed by the organization policies of the
    /// [AnalyzeOrgPolicyGovernedAssetsRequest.constraint][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsRequest.constraint].
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsRequest.constraint]: crate::model::AnalyzeOrgPolicyGovernedAssetsRequest::constraint
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GovernedResource {
        /// The [full resource name]
        /// (<https://cloud.google.com/asset-inventory/docs/resource-name-format>) of
        /// the Google Cloud resource.
        pub full_resource_name: std::string::String,

        /// The [full resource name]
        /// (<https://cloud.google.com/asset-inventory/docs/resource-name-format>) of
        /// the parent of
        /// [AnalyzeOrgPolicyGovernedAssetsResponse.GovernedResource.full_resource_name][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedResource.full_resource_name].
        ///
        /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedResource.full_resource_name]: crate::model::analyze_org_policy_governed_assets_response::GovernedResource::full_resource_name
        pub parent: std::string::String,

        /// The project that this resource belongs to, in the format of
        /// projects/{PROJECT_NUMBER}. This field is available when the resource
        /// belongs to a project.
        pub project: std::string::String,

        /// The folder(s) that this resource belongs to, in the format of
        /// folders/{FOLDER_NUMBER}. This field is available when the resource
        /// belongs (directly or cascadingly) to one or more folders.
        pub folders: std::vec::Vec<std::string::String>,

        /// The organization that this resource belongs to, in the format of
        /// organizations/{ORGANIZATION_NUMBER}. This field is available when the
        /// resource belongs (directly or cascadingly) to an organization.
        pub organization: std::string::String,

        /// The asset type of the
        /// [AnalyzeOrgPolicyGovernedAssetsResponse.GovernedResource.full_resource_name][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedResource.full_resource_name]
        /// Example:
        /// `cloudresourcemanager.googleapis.com/Project`
        /// See [Cloud Asset Inventory Supported Asset
        /// Types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
        /// for all supported asset types.
        ///
        /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedResource.full_resource_name]: crate::model::analyze_org_policy_governed_assets_response::GovernedResource::full_resource_name
        pub asset_type: std::string::String,

        /// The effective tags on this resource.
        pub effective_tags: std::vec::Vec<crate::model::EffectiveTagDetails>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GovernedResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [full_resource_name][crate::model::analyze_org_policy_governed_assets_response::GovernedResource::full_resource_name].
        pub fn set_full_resource_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.full_resource_name = v.into();
            self
        }

        /// Sets the value of [parent][crate::model::analyze_org_policy_governed_assets_response::GovernedResource::parent].
        pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.parent = v.into();
            self
        }

        /// Sets the value of [project][crate::model::analyze_org_policy_governed_assets_response::GovernedResource::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [folders][crate::model::analyze_org_policy_governed_assets_response::GovernedResource::folders].
        pub fn set_folders<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.folders = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [organization][crate::model::analyze_org_policy_governed_assets_response::GovernedResource::organization].
        pub fn set_organization<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.organization = v.into();
            self
        }

        /// Sets the value of [asset_type][crate::model::analyze_org_policy_governed_assets_response::GovernedResource::asset_type].
        pub fn set_asset_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.asset_type = v.into();
            self
        }

        /// Sets the value of [effective_tags][crate::model::analyze_org_policy_governed_assets_response::GovernedResource::effective_tags].
        pub fn set_effective_tags<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::EffectiveTagDetails>,
        {
            use std::iter::Iterator;
            self.effective_tags = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GovernedResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedResource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GovernedResource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __full_resource_name,
                __parent,
                __project,
                __folders,
                __organization,
                __asset_type,
                __effective_tags,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GovernedResource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "fullResourceName" => Ok(__FieldTag::__full_resource_name),
                                "full_resource_name" => Ok(__FieldTag::__full_resource_name),
                                "parent" => Ok(__FieldTag::__parent),
                                "project" => Ok(__FieldTag::__project),
                                "folders" => Ok(__FieldTag::__folders),
                                "organization" => Ok(__FieldTag::__organization),
                                "assetType" => Ok(__FieldTag::__asset_type),
                                "asset_type" => Ok(__FieldTag::__asset_type),
                                "effectiveTags" => Ok(__FieldTag::__effective_tags),
                                "effective_tags" => Ok(__FieldTag::__effective_tags),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GovernedResource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GovernedResource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__full_resource_name => {
                                if !fields.insert(__FieldTag::__full_resource_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for full_resource_name",
                                    ));
                                }
                                result.full_resource_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__parent => {
                                if !fields.insert(__FieldTag::__parent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parent",
                                    ));
                                }
                                result.parent = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__project => {
                                if !fields.insert(__FieldTag::__project) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project",
                                    ));
                                }
                                result.project = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__folders => {
                                if !fields.insert(__FieldTag::__folders) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for folders",
                                    ));
                                }
                                result.folders = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__organization => {
                                if !fields.insert(__FieldTag::__organization) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for organization",
                                    ));
                                }
                                result.organization = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__asset_type => {
                                if !fields.insert(__FieldTag::__asset_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for asset_type",
                                    ));
                                }
                                result.asset_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__effective_tags => {
                                if !fields.insert(__FieldTag::__effective_tags) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for effective_tags",
                                    ));
                                }
                                result.effective_tags = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::EffectiveTagDetails>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GovernedResource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.full_resource_name.is_empty() {
                state.serialize_entry("fullResourceName", &self.full_resource_name)?;
            }
            if !self.parent.is_empty() {
                state.serialize_entry("parent", &self.parent)?;
            }
            if !self.project.is_empty() {
                state.serialize_entry("project", &self.project)?;
            }
            if !self.folders.is_empty() {
                state.serialize_entry("folders", &self.folders)?;
            }
            if !self.organization.is_empty() {
                state.serialize_entry("organization", &self.organization)?;
            }
            if !self.asset_type.is_empty() {
                state.serialize_entry("assetType", &self.asset_type)?;
            }
            if !self.effective_tags.is_empty() {
                state.serialize_entry("effectiveTags", &self.effective_tags)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GovernedResource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GovernedResource");
            debug_struct.field("full_resource_name", &self.full_resource_name);
            debug_struct.field("parent", &self.parent);
            debug_struct.field("project", &self.project);
            debug_struct.field("folders", &self.folders);
            debug_struct.field("organization", &self.organization);
            debug_struct.field("asset_type", &self.asset_type);
            debug_struct.field("effective_tags", &self.effective_tags);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The IAM policies governed by the organization policies of the
    /// [AnalyzeOrgPolicyGovernedAssetsRequest.constraint][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsRequest.constraint].
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsRequest.constraint]: crate::model::AnalyzeOrgPolicyGovernedAssetsRequest::constraint
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GovernedIamPolicy {
        /// The full resource name of the resource on which this IAM policy is set.
        /// Example:
        /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
        /// See [Cloud Asset Inventory Resource Name
        /// Format](https://cloud.google.com/asset-inventory/docs/resource-name-format)
        /// for more information.
        pub attached_resource: std::string::String,

        /// The IAM policy directly set on the given resource.
        pub policy: std::option::Option<iam_v1::model::Policy>,

        /// The project that this IAM policy belongs to, in the format of
        /// projects/{PROJECT_NUMBER}. This field is available when the IAM policy
        /// belongs to a project.
        pub project: std::string::String,

        /// The folder(s) that this IAM policy belongs to, in the format of
        /// folders/{FOLDER_NUMBER}. This field is available when the IAM policy
        /// belongs (directly or cascadingly) to one or more folders.
        pub folders: std::vec::Vec<std::string::String>,

        /// The organization that this IAM policy belongs to, in the format of
        /// organizations/{ORGANIZATION_NUMBER}. This field is available when the
        /// IAM policy belongs (directly or cascadingly) to an organization.
        pub organization: std::string::String,

        /// The asset type of the
        /// [AnalyzeOrgPolicyGovernedAssetsResponse.GovernedIamPolicy.attached_resource][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedIamPolicy.attached_resource].
        /// Example:
        /// `cloudresourcemanager.googleapis.com/Project`
        /// See [Cloud Asset Inventory Supported Asset
        /// Types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
        /// for all supported asset types.
        ///
        /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedIamPolicy.attached_resource]: crate::model::analyze_org_policy_governed_assets_response::GovernedIamPolicy::attached_resource
        pub asset_type: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GovernedIamPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [attached_resource][crate::model::analyze_org_policy_governed_assets_response::GovernedIamPolicy::attached_resource].
        pub fn set_attached_resource<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.attached_resource = v.into();
            self
        }

        /// Sets the value of [policy][crate::model::analyze_org_policy_governed_assets_response::GovernedIamPolicy::policy].
        pub fn set_policy<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<iam_v1::model::Policy>,
        {
            self.policy = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [policy][crate::model::analyze_org_policy_governed_assets_response::GovernedIamPolicy::policy].
        pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<iam_v1::model::Policy>,
        {
            self.policy = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::analyze_org_policy_governed_assets_response::GovernedIamPolicy::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [folders][crate::model::analyze_org_policy_governed_assets_response::GovernedIamPolicy::folders].
        pub fn set_folders<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.folders = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [organization][crate::model::analyze_org_policy_governed_assets_response::GovernedIamPolicy::organization].
        pub fn set_organization<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.organization = v.into();
            self
        }

        /// Sets the value of [asset_type][crate::model::analyze_org_policy_governed_assets_response::GovernedIamPolicy::asset_type].
        pub fn set_asset_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.asset_type = v.into();
            self
        }
    }

    impl wkt::message::Message for GovernedIamPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedIamPolicy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GovernedIamPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __attached_resource,
                __policy,
                __project,
                __folders,
                __organization,
                __asset_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GovernedIamPolicy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "attachedResource" => Ok(__FieldTag::__attached_resource),
                                "attached_resource" => Ok(__FieldTag::__attached_resource),
                                "policy" => Ok(__FieldTag::__policy),
                                "project" => Ok(__FieldTag::__project),
                                "folders" => Ok(__FieldTag::__folders),
                                "organization" => Ok(__FieldTag::__organization),
                                "assetType" => Ok(__FieldTag::__asset_type),
                                "asset_type" => Ok(__FieldTag::__asset_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GovernedIamPolicy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GovernedIamPolicy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__attached_resource => {
                                if !fields.insert(__FieldTag::__attached_resource) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for attached_resource",
                                    ));
                                }
                                result.attached_resource = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__policy => {
                                if !fields.insert(__FieldTag::__policy) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for policy",
                                    ));
                                }
                                result.policy =
                                    map.next_value::<std::option::Option<iam_v1::model::Policy>>()?;
                            }
                            __FieldTag::__project => {
                                if !fields.insert(__FieldTag::__project) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project",
                                    ));
                                }
                                result.project = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__folders => {
                                if !fields.insert(__FieldTag::__folders) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for folders",
                                    ));
                                }
                                result.folders = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__organization => {
                                if !fields.insert(__FieldTag::__organization) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for organization",
                                    ));
                                }
                                result.organization = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__asset_type => {
                                if !fields.insert(__FieldTag::__asset_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for asset_type",
                                    ));
                                }
                                result.asset_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GovernedIamPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.attached_resource.is_empty() {
                state.serialize_entry("attachedResource", &self.attached_resource)?;
            }
            if self.policy.is_some() {
                state.serialize_entry("policy", &self.policy)?;
            }
            if !self.project.is_empty() {
                state.serialize_entry("project", &self.project)?;
            }
            if !self.folders.is_empty() {
                state.serialize_entry("folders", &self.folders)?;
            }
            if !self.organization.is_empty() {
                state.serialize_entry("organization", &self.organization)?;
            }
            if !self.asset_type.is_empty() {
                state.serialize_entry("assetType", &self.asset_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GovernedIamPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GovernedIamPolicy");
            debug_struct.field("attached_resource", &self.attached_resource);
            debug_struct.field("policy", &self.policy);
            debug_struct.field("project", &self.project);
            debug_struct.field("folders", &self.folders);
            debug_struct.field("organization", &self.organization);
            debug_struct.field("asset_type", &self.asset_type);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Represents a Google Cloud asset(resource or IAM policy) governed by the
    /// organization policies of the
    /// [AnalyzeOrgPolicyGovernedAssetsRequest.constraint][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsRequest.constraint].
    ///
    /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsRequest.constraint]: crate::model::AnalyzeOrgPolicyGovernedAssetsRequest::constraint
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GovernedAsset {

        /// The consolidated policy for the analyzed asset. The consolidated
        /// policy is computed by merging and evaluating
        /// [AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset.policy_bundle][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset.policy_bundle].
        /// The evaluation will respect the organization policy [hierarchy
        /// rules](https://cloud.google.com/resource-manager/docs/organization-policy/understanding-hierarchy).
        ///
        /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset.policy_bundle]: crate::model::analyze_org_policy_governed_assets_response::GovernedAsset::policy_bundle
        pub consolidated_policy: std::option::Option<crate::model::AnalyzerOrgPolicy>,

        /// The ordered list of all organization policies from the
        /// [consolidated_policy.attached_resource][google.cloud.asset.v1.AnalyzerOrgPolicy.attached_resource]
        /// to the scope specified in the request.
        ///
        /// If the constraint is defined with default policy, it will also appear in
        /// the list.
        ///
        /// [google.cloud.asset.v1.AnalyzerOrgPolicy.attached_resource]: crate::model::AnalyzerOrgPolicy::attached_resource
        pub policy_bundle: std::vec::Vec<crate::model::AnalyzerOrgPolicy>,

        pub governed_asset: std::option::Option<crate::model::analyze_org_policy_governed_assets_response::governed_asset::GovernedAsset>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GovernedAsset {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [consolidated_policy][crate::model::analyze_org_policy_governed_assets_response::GovernedAsset::consolidated_policy].
        pub fn set_consolidated_policy<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::AnalyzerOrgPolicy>,
        {
            self.consolidated_policy = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [consolidated_policy][crate::model::analyze_org_policy_governed_assets_response::GovernedAsset::consolidated_policy].
        pub fn set_or_clear_consolidated_policy<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::AnalyzerOrgPolicy>,
        {
            self.consolidated_policy = v.map(|x| x.into());
            self
        }

        /// Sets the value of [policy_bundle][crate::model::analyze_org_policy_governed_assets_response::GovernedAsset::policy_bundle].
        pub fn set_policy_bundle<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::AnalyzerOrgPolicy>,
        {
            use std::iter::Iterator;
            self.policy_bundle = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [governed_asset][crate::model::analyze_org_policy_governed_assets_response::GovernedAsset::governed_asset].
        ///
        /// Note that all the setters affecting `governed_asset` are mutually
        /// exclusive.
        pub fn set_governed_asset<T: std::convert::Into<std::option::Option<crate::model::analyze_org_policy_governed_assets_response::governed_asset::GovernedAsset>>>(mut self, v: T) -> Self
        {
            self.governed_asset = v.into();
            self
        }

        /// The value of [governed_asset][crate::model::analyze_org_policy_governed_assets_response::GovernedAsset::governed_asset]
        /// if it holds a `GovernedResource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn governed_resource(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::analyze_org_policy_governed_assets_response::GovernedResource,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.governed_asset.as_ref().and_then(|v| match v {
                crate::model::analyze_org_policy_governed_assets_response::governed_asset::GovernedAsset::GovernedResource(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [governed_asset][crate::model::analyze_org_policy_governed_assets_response::GovernedAsset::governed_asset]
        /// to hold a `GovernedResource`.
        ///
        /// Note that all the setters affecting `governed_asset` are
        /// mutually exclusive.
        pub fn set_governed_resource<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::analyze_org_policy_governed_assets_response::GovernedResource,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.governed_asset = std::option::Option::Some(
                crate::model::analyze_org_policy_governed_assets_response::governed_asset::GovernedAsset::GovernedResource(
                    v.into()
                )
            );
            self
        }

        /// The value of [governed_asset][crate::model::analyze_org_policy_governed_assets_response::GovernedAsset::governed_asset]
        /// if it holds a `GovernedIamPolicy`, `None` if the field is not set or
        /// holds a different branch.
        pub fn governed_iam_policy(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::analyze_org_policy_governed_assets_response::GovernedIamPolicy,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.governed_asset.as_ref().and_then(|v| match v {
                crate::model::analyze_org_policy_governed_assets_response::governed_asset::GovernedAsset::GovernedIamPolicy(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [governed_asset][crate::model::analyze_org_policy_governed_assets_response::GovernedAsset::governed_asset]
        /// to hold a `GovernedIamPolicy`.
        ///
        /// Note that all the setters affecting `governed_asset` are
        /// mutually exclusive.
        pub fn set_governed_iam_policy<T: std::convert::Into<std::boxed::Box<crate::model::analyze_org_policy_governed_assets_response::GovernedIamPolicy>>>(mut self, v: T) -> Self{
            self.governed_asset = std::option::Option::Some(
                crate::model::analyze_org_policy_governed_assets_response::governed_asset::GovernedAsset::GovernedIamPolicy(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for GovernedAsset {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GovernedAsset {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __governed_resource,
                __governed_iam_policy,
                __consolidated_policy,
                __policy_bundle,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GovernedAsset")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "governedResource" => Ok(__FieldTag::__governed_resource),
                                "governed_resource" => Ok(__FieldTag::__governed_resource),
                                "governedIamPolicy" => Ok(__FieldTag::__governed_iam_policy),
                                "governed_iam_policy" => Ok(__FieldTag::__governed_iam_policy),
                                "consolidatedPolicy" => Ok(__FieldTag::__consolidated_policy),
                                "consolidated_policy" => Ok(__FieldTag::__consolidated_policy),
                                "policyBundle" => Ok(__FieldTag::__policy_bundle),
                                "policy_bundle" => Ok(__FieldTag::__policy_bundle),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GovernedAsset;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GovernedAsset")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__governed_resource => {
                                if !fields.insert(__FieldTag::__governed_resource) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for governed_resource",
                                    ));
                                }
                                if result.governed_asset.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `governed_asset`, a oneof with full ID .google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset.governed_resource, latest field was governedResource",
                                    ));
                                }
                                result.governed_asset = std::option::Option::Some(
                                    crate::model::analyze_org_policy_governed_assets_response::governed_asset::GovernedAsset::GovernedResource(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::analyze_org_policy_governed_assets_response::GovernedResource>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__governed_iam_policy => {
                                if !fields.insert(__FieldTag::__governed_iam_policy) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for governed_iam_policy",
                                    ));
                                }
                                if result.governed_asset.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `governed_asset`, a oneof with full ID .google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset.governed_iam_policy, latest field was governedIamPolicy",
                                    ));
                                }
                                result.governed_asset = std::option::Option::Some(
                                    crate::model::analyze_org_policy_governed_assets_response::governed_asset::GovernedAsset::GovernedIamPolicy(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::analyze_org_policy_governed_assets_response::GovernedIamPolicy>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__consolidated_policy => {
                                if !fields.insert(__FieldTag::__consolidated_policy) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for consolidated_policy",
                                    ));
                                }
                                result.consolidated_policy = map.next_value::<std::option::Option<crate::model::AnalyzerOrgPolicy>>()?
                                    ;
                            }
                            __FieldTag::__policy_bundle => {
                                if !fields.insert(__FieldTag::__policy_bundle) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for policy_bundle",
                                    ));
                                }
                                result.policy_bundle = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::AnalyzerOrgPolicy>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GovernedAsset {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.governed_resource() {
                state.serialize_entry("governedResource", value)?;
            }
            if let Some(value) = self.governed_iam_policy() {
                state.serialize_entry("governedIamPolicy", value)?;
            }
            if self.consolidated_policy.is_some() {
                state.serialize_entry("consolidatedPolicy", &self.consolidated_policy)?;
            }
            if !self.policy_bundle.is_empty() {
                state.serialize_entry("policyBundle", &self.policy_bundle)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GovernedAsset {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GovernedAsset");
            debug_struct.field("consolidated_policy", &self.consolidated_policy);
            debug_struct.field("policy_bundle", &self.policy_bundle);
            debug_struct.field("governed_asset", &self.governed_asset);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [GovernedAsset].
    pub mod governed_asset {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum GovernedAsset {
            /// A Google Cloud resource governed by the organization
            /// policies of the
            /// [AnalyzeOrgPolicyGovernedAssetsRequest.constraint][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsRequest.constraint].
            ///
            /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsRequest.constraint]: crate::model::AnalyzeOrgPolicyGovernedAssetsRequest::constraint
            GovernedResource(
                std::boxed::Box<
                    crate::model::analyze_org_policy_governed_assets_response::GovernedResource,
                >,
            ),
            /// An IAM policy governed by the organization
            /// policies of the
            /// [AnalyzeOrgPolicyGovernedAssetsRequest.constraint][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsRequest.constraint].
            ///
            /// [google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsRequest.constraint]: crate::model::AnalyzeOrgPolicyGovernedAssetsRequest::constraint
            GovernedIamPolicy(
                std::boxed::Box<
                    crate::model::analyze_org_policy_governed_assets_response::GovernedIamPolicy,
                >,
            ),
        }
    }
}

/// An asset in Google Cloud and its temporal metadata, including the time window
/// when it was observed and its status during that window.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TemporalAsset {
    /// The time window when the asset data and state was observed.
    pub window: std::option::Option<crate::model::TimeWindow>,

    /// Whether the asset has been deleted or not.
    pub deleted: bool,

    /// An asset in Google Cloud.
    pub asset: std::option::Option<crate::model::Asset>,

    /// State of prior_asset.
    pub prior_asset_state: crate::model::temporal_asset::PriorAssetState,

    /// Prior copy of the asset. Populated if prior_asset_state is PRESENT.
    /// Currently this is only set for responses in Real-Time Feed.
    pub prior_asset: std::option::Option<crate::model::Asset>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TemporalAsset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::TemporalAsset::window].
    pub fn set_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindow>,
    {
        self.window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window][crate::model::TemporalAsset::window].
    pub fn set_or_clear_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindow>,
    {
        self.window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleted][crate::model::TemporalAsset::deleted].
    pub fn set_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deleted = v.into();
        self
    }

    /// Sets the value of [asset][crate::model::TemporalAsset::asset].
    pub fn set_asset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Asset>,
    {
        self.asset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [asset][crate::model::TemporalAsset::asset].
    pub fn set_or_clear_asset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Asset>,
    {
        self.asset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [prior_asset_state][crate::model::TemporalAsset::prior_asset_state].
    pub fn set_prior_asset_state<
        T: std::convert::Into<crate::model::temporal_asset::PriorAssetState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.prior_asset_state = v.into();
        self
    }

    /// Sets the value of [prior_asset][crate::model::TemporalAsset::prior_asset].
    pub fn set_prior_asset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Asset>,
    {
        self.prior_asset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [prior_asset][crate::model::TemporalAsset::prior_asset].
    pub fn set_or_clear_prior_asset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Asset>,
    {
        self.prior_asset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TemporalAsset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.TemporalAsset"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TemporalAsset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __window,
            __deleted,
            __asset,
            __prior_asset_state,
            __prior_asset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TemporalAsset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "window" => Ok(__FieldTag::__window),
                            "deleted" => Ok(__FieldTag::__deleted),
                            "asset" => Ok(__FieldTag::__asset),
                            "priorAssetState" => Ok(__FieldTag::__prior_asset_state),
                            "prior_asset_state" => Ok(__FieldTag::__prior_asset_state),
                            "priorAsset" => Ok(__FieldTag::__prior_asset),
                            "prior_asset" => Ok(__FieldTag::__prior_asset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TemporalAsset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TemporalAsset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__window => {
                            if !fields.insert(__FieldTag::__window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for window",
                                ));
                            }
                            result.window =
                                map.next_value::<std::option::Option<crate::model::TimeWindow>>()?;
                        }
                        __FieldTag::__deleted => {
                            if !fields.insert(__FieldTag::__deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deleted",
                                ));
                            }
                            result.deleted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset => {
                            if !fields.insert(__FieldTag::__asset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset",
                                ));
                            }
                            result.asset =
                                map.next_value::<std::option::Option<crate::model::Asset>>()?;
                        }
                        __FieldTag::__prior_asset_state => {
                            if !fields.insert(__FieldTag::__prior_asset_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prior_asset_state",
                                ));
                            }
                            result.prior_asset_state =
                                map.next_value::<std::option::Option<
                                    crate::model::temporal_asset::PriorAssetState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__prior_asset => {
                            if !fields.insert(__FieldTag::__prior_asset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prior_asset",
                                ));
                            }
                            result.prior_asset =
                                map.next_value::<std::option::Option<crate::model::Asset>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TemporalAsset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.window.is_some() {
            state.serialize_entry("window", &self.window)?;
        }
        if !wkt::internal::is_default(&self.deleted) {
            state.serialize_entry("deleted", &self.deleted)?;
        }
        if self.asset.is_some() {
            state.serialize_entry("asset", &self.asset)?;
        }
        if !wkt::internal::is_default(&self.prior_asset_state) {
            state.serialize_entry("priorAssetState", &self.prior_asset_state)?;
        }
        if self.prior_asset.is_some() {
            state.serialize_entry("priorAsset", &self.prior_asset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TemporalAsset {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TemporalAsset");
        debug_struct.field("window", &self.window);
        debug_struct.field("deleted", &self.deleted);
        debug_struct.field("asset", &self.asset);
        debug_struct.field("prior_asset_state", &self.prior_asset_state);
        debug_struct.field("prior_asset", &self.prior_asset);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TemporalAsset].
pub mod temporal_asset {
    #[allow(unused_imports)]
    use super::*;

    /// State of prior asset.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PriorAssetState {
        /// prior_asset is not applicable for the current asset.
        Unspecified,
        /// prior_asset is populated correctly.
        Present,
        /// Failed to set prior_asset.
        Invalid,
        /// Current asset is the first known state.
        DoesNotExist,
        /// prior_asset is a deletion.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PriorAssetState::value] or
        /// [PriorAssetState::name].
        UnknownValue(prior_asset_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod prior_asset_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PriorAssetState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Present => std::option::Option::Some(1),
                Self::Invalid => std::option::Option::Some(2),
                Self::DoesNotExist => std::option::Option::Some(3),
                Self::Deleted => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIOR_ASSET_STATE_UNSPECIFIED"),
                Self::Present => std::option::Option::Some("PRESENT"),
                Self::Invalid => std::option::Option::Some("INVALID"),
                Self::DoesNotExist => std::option::Option::Some("DOES_NOT_EXIST"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PriorAssetState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PriorAssetState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PriorAssetState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Present,
                2 => Self::Invalid,
                3 => Self::DoesNotExist,
                4 => Self::Deleted,
                _ => Self::UnknownValue(prior_asset_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PriorAssetState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIOR_ASSET_STATE_UNSPECIFIED" => Self::Unspecified,
                "PRESENT" => Self::Present,
                "INVALID" => Self::Invalid,
                "DOES_NOT_EXIST" => Self::DoesNotExist,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(prior_asset_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PriorAssetState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Present => serializer.serialize_i32(1),
                Self::Invalid => serializer.serialize_i32(2),
                Self::DoesNotExist => serializer.serialize_i32(3),
                Self::Deleted => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PriorAssetState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PriorAssetState>::new(
                ".google.cloud.asset.v1.TemporalAsset.PriorAssetState",
            ))
        }
    }
}

/// A time window specified by its `start_time` and `end_time`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeWindow {
    /// Start time of the time window (exclusive).
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// End time of the time window (inclusive). If not specified, the current
    /// timestamp is used instead.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::TimeWindow::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TimeWindow::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TimeWindow::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TimeWindow::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimeWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.TimeWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimeWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeWindow");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The enhanced metadata information for a resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AssetEnrichment {
    pub enrichment_data: std::option::Option<crate::model::asset_enrichment::EnrichmentData>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssetEnrichment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enrichment_data][crate::model::AssetEnrichment::enrichment_data].
    ///
    /// Note that all the setters affecting `enrichment_data` are mutually
    /// exclusive.
    pub fn set_enrichment_data<
        T: std::convert::Into<std::option::Option<crate::model::asset_enrichment::EnrichmentData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enrichment_data = v.into();
        self
    }

    /// The value of [enrichment_data][crate::model::AssetEnrichment::enrichment_data]
    /// if it holds a `ResourceOwners`, `None` if the field is not set or
    /// holds a different branch.
    pub fn resource_owners(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ResourceOwners>> {
        #[allow(unreachable_patterns)]
        self.enrichment_data.as_ref().and_then(|v| match v {
            crate::model::asset_enrichment::EnrichmentData::ResourceOwners(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [enrichment_data][crate::model::AssetEnrichment::enrichment_data]
    /// to hold a `ResourceOwners`.
    ///
    /// Note that all the setters affecting `enrichment_data` are
    /// mutually exclusive.
    pub fn set_resource_owners<
        T: std::convert::Into<std::boxed::Box<crate::model::ResourceOwners>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enrichment_data = std::option::Option::Some(
            crate::model::asset_enrichment::EnrichmentData::ResourceOwners(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AssetEnrichment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AssetEnrichment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AssetEnrichment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_owners,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AssetEnrichment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceOwners" => Ok(__FieldTag::__resource_owners),
                            "resource_owners" => Ok(__FieldTag::__resource_owners),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AssetEnrichment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AssetEnrichment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_owners => {
                            if !fields.insert(__FieldTag::__resource_owners) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_owners",
                                ));
                            }
                            if result.enrichment_data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `enrichment_data`, a oneof with full ID .google.cloud.asset.v1.AssetEnrichment.resource_owners, latest field was resourceOwners",
                                ));
                            }
                            result.enrichment_data = std::option::Option::Some(
                                crate::model::asset_enrichment::EnrichmentData::ResourceOwners(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ResourceOwners>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AssetEnrichment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.resource_owners() {
            state.serialize_entry("resourceOwners", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AssetEnrichment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AssetEnrichment");
        debug_struct.field("enrichment_data", &self.enrichment_data);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AssetEnrichment].
pub mod asset_enrichment {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EnrichmentData {
        /// The resource owners for a resource.
        ///
        /// Note that this field only contains the members that have "roles/owner"
        /// role in the resource's IAM Policy.
        ResourceOwners(std::boxed::Box<crate::model::ResourceOwners>),
    }
}

/// An asset in Google Cloud. An asset can be any resource in the Google Cloud
/// [resource
/// hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
/// a resource outside the Google Cloud resource hierarchy (such as Google
/// Kubernetes Engine clusters and objects), or a policy (e.g. IAM policy),
/// or a relationship (e.g. an INSTANCE_TO_INSTANCEGROUP relationship).
/// See [Supported asset
/// types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
/// for more information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Asset {
    /// The last update timestamp of an asset. update_time is updated when
    /// create/update/delete operation is performed.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The full name of the asset. Example:
    /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`
    ///
    /// See [Resource
    /// names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
    /// for more information.
    pub name: std::string::String,

    /// The type of the asset. Example: `compute.googleapis.com/Disk`
    ///
    /// See [Supported asset
    /// types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
    /// for more information.
    pub asset_type: std::string::String,

    /// A representation of the resource.
    pub resource: std::option::Option<crate::model::Resource>,

    /// A representation of the IAM policy set on a Google Cloud resource.
    /// There can be a maximum of one IAM policy set on any given resource.
    /// In addition, IAM policies inherit their granted access scope from any
    /// policies set on parent resources in the resource hierarchy. Therefore, the
    /// effectively policy is the union of both the policy set on this resource
    /// and each policy set on all of the resource's ancestry resource levels in
    /// the hierarchy. See
    /// [this topic](https://cloud.google.com/iam/help/allow-policies/inheritance)
    /// for more information.
    pub iam_policy: std::option::Option<iam_v1::model::Policy>,

    /// A representation of an [organization
    /// policy](https://cloud.google.com/resource-manager/docs/organization-policy/overview#organization_policy).
    /// There can be more than one organization policy with different constraints
    /// set on a given resource.
    pub org_policy: std::vec::Vec<orgpolicy_v1::model::Policy>,

    /// A representation of runtime OS Inventory information. See [this
    /// topic](https://cloud.google.com/compute/docs/instances/os-inventory-management)
    /// for more information.
    pub os_inventory: std::option::Option<osconfig_v1::model::Inventory>,

    /// DEPRECATED. This field only presents for the purpose of
    /// backward-compatibility. The server will never generate responses with this
    /// field.
    /// The related assets of the asset of one relationship type. One asset
    /// only represents one type of relationship.
    #[deprecated]
    pub related_assets: std::option::Option<crate::model::RelatedAssets>,

    /// One related asset of the current asset.
    pub related_asset: std::option::Option<crate::model::RelatedAsset>,

    /// The ancestry path of an asset in Google Cloud [resource
    /// hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
    /// represented as a list of relative resource names. An ancestry path starts
    /// with the closest ancestor in the hierarchy and ends at root. If the asset
    /// is a project, folder, or organization, the ancestry path starts from the
    /// asset itself.
    ///
    /// Example: `["projects/123456789", "folders/5432", "organizations/1234"]`
    pub ancestors: std::vec::Vec<std::string::String>,

    /// A representation of an [access
    /// policy](https://cloud.google.com/access-context-manager/docs/overview#access-policies).
    pub access_context_policy: std::option::Option<crate::model::asset::AccessContextPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Asset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_time][crate::model::Asset::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Asset::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::Asset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [asset_type][crate::model::Asset::asset_type].
    pub fn set_asset_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_type = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::Asset::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Resource>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::Asset::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Resource>,
    {
        self.resource = v.map(|x| x.into());
        self
    }

    /// Sets the value of [iam_policy][crate::model::Asset::iam_policy].
    pub fn set_iam_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<iam_v1::model::Policy>,
    {
        self.iam_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [iam_policy][crate::model::Asset::iam_policy].
    pub fn set_or_clear_iam_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<iam_v1::model::Policy>,
    {
        self.iam_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [org_policy][crate::model::Asset::org_policy].
    pub fn set_org_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<orgpolicy_v1::model::Policy>,
    {
        use std::iter::Iterator;
        self.org_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [os_inventory][crate::model::Asset::os_inventory].
    pub fn set_os_inventory<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<osconfig_v1::model::Inventory>,
    {
        self.os_inventory = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [os_inventory][crate::model::Asset::os_inventory].
    pub fn set_or_clear_os_inventory<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<osconfig_v1::model::Inventory>,
    {
        self.os_inventory = v.map(|x| x.into());
        self
    }

    /// Sets the value of [related_assets][crate::model::Asset::related_assets].
    #[deprecated]
    pub fn set_related_assets<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RelatedAssets>,
    {
        self.related_assets = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [related_assets][crate::model::Asset::related_assets].
    #[deprecated]
    pub fn set_or_clear_related_assets<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RelatedAssets>,
    {
        self.related_assets = v.map(|x| x.into());
        self
    }

    /// Sets the value of [related_asset][crate::model::Asset::related_asset].
    pub fn set_related_asset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RelatedAsset>,
    {
        self.related_asset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [related_asset][crate::model::Asset::related_asset].
    pub fn set_or_clear_related_asset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RelatedAsset>,
    {
        self.related_asset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ancestors][crate::model::Asset::ancestors].
    pub fn set_ancestors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ancestors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [access_context_policy][crate::model::Asset::access_context_policy].
    ///
    /// Note that all the setters affecting `access_context_policy` are mutually
    /// exclusive.
    pub fn set_access_context_policy<
        T: std::convert::Into<std::option::Option<crate::model::asset::AccessContextPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.access_context_policy = v.into();
        self
    }

    /// The value of [access_context_policy][crate::model::Asset::access_context_policy]
    /// if it holds a `AccessPolicy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn access_policy(
        &self,
    ) -> std::option::Option<&std::boxed::Box<accesscontextmanager_v1::model::AccessPolicy>> {
        #[allow(unreachable_patterns)]
        self.access_context_policy.as_ref().and_then(|v| match v {
            crate::model::asset::AccessContextPolicy::AccessPolicy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [access_context_policy][crate::model::Asset::access_context_policy]
    /// to hold a `AccessPolicy`.
    ///
    /// Note that all the setters affecting `access_context_policy` are
    /// mutually exclusive.
    pub fn set_access_policy<
        T: std::convert::Into<std::boxed::Box<accesscontextmanager_v1::model::AccessPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.access_context_policy = std::option::Option::Some(
            crate::model::asset::AccessContextPolicy::AccessPolicy(v.into()),
        );
        self
    }

    /// The value of [access_context_policy][crate::model::Asset::access_context_policy]
    /// if it holds a `AccessLevel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn access_level(
        &self,
    ) -> std::option::Option<&std::boxed::Box<accesscontextmanager_v1::model::AccessLevel>> {
        #[allow(unreachable_patterns)]
        self.access_context_policy.as_ref().and_then(|v| match v {
            crate::model::asset::AccessContextPolicy::AccessLevel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [access_context_policy][crate::model::Asset::access_context_policy]
    /// to hold a `AccessLevel`.
    ///
    /// Note that all the setters affecting `access_context_policy` are
    /// mutually exclusive.
    pub fn set_access_level<
        T: std::convert::Into<std::boxed::Box<accesscontextmanager_v1::model::AccessLevel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.access_context_policy = std::option::Option::Some(
            crate::model::asset::AccessContextPolicy::AccessLevel(v.into()),
        );
        self
    }

    /// The value of [access_context_policy][crate::model::Asset::access_context_policy]
    /// if it holds a `ServicePerimeter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn service_perimeter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<accesscontextmanager_v1::model::ServicePerimeter>>
    {
        #[allow(unreachable_patterns)]
        self.access_context_policy.as_ref().and_then(|v| match v {
            crate::model::asset::AccessContextPolicy::ServicePerimeter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [access_context_policy][crate::model::Asset::access_context_policy]
    /// to hold a `ServicePerimeter`.
    ///
    /// Note that all the setters affecting `access_context_policy` are
    /// mutually exclusive.
    pub fn set_service_perimeter<
        T: std::convert::Into<std::boxed::Box<accesscontextmanager_v1::model::ServicePerimeter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.access_context_policy = std::option::Option::Some(
            crate::model::asset::AccessContextPolicy::ServicePerimeter(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Asset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.Asset"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Asset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_time,
            __name,
            __asset_type,
            __resource,
            __iam_policy,
            __org_policy,
            __access_policy,
            __access_level,
            __service_perimeter,
            __os_inventory,
            __related_assets,
            __related_asset,
            __ancestors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Asset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "name" => Ok(__FieldTag::__name),
                            "assetType" => Ok(__FieldTag::__asset_type),
                            "asset_type" => Ok(__FieldTag::__asset_type),
                            "resource" => Ok(__FieldTag::__resource),
                            "iamPolicy" => Ok(__FieldTag::__iam_policy),
                            "iam_policy" => Ok(__FieldTag::__iam_policy),
                            "orgPolicy" => Ok(__FieldTag::__org_policy),
                            "org_policy" => Ok(__FieldTag::__org_policy),
                            "accessPolicy" => Ok(__FieldTag::__access_policy),
                            "access_policy" => Ok(__FieldTag::__access_policy),
                            "accessLevel" => Ok(__FieldTag::__access_level),
                            "access_level" => Ok(__FieldTag::__access_level),
                            "servicePerimeter" => Ok(__FieldTag::__service_perimeter),
                            "service_perimeter" => Ok(__FieldTag::__service_perimeter),
                            "osInventory" => Ok(__FieldTag::__os_inventory),
                            "os_inventory" => Ok(__FieldTag::__os_inventory),
                            "relatedAssets" => Ok(__FieldTag::__related_assets),
                            "related_assets" => Ok(__FieldTag::__related_assets),
                            "relatedAsset" => Ok(__FieldTag::__related_asset),
                            "related_asset" => Ok(__FieldTag::__related_asset),
                            "ancestors" => Ok(__FieldTag::__ancestors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Asset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Asset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset_type => {
                            if !fields.insert(__FieldTag::__asset_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_type",
                                ));
                            }
                            result.asset_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource =
                                map.next_value::<std::option::Option<crate::model::Resource>>()?;
                        }
                        __FieldTag::__iam_policy => {
                            if !fields.insert(__FieldTag::__iam_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iam_policy",
                                ));
                            }
                            result.iam_policy =
                                map.next_value::<std::option::Option<iam_v1::model::Policy>>()?;
                        }
                        __FieldTag::__org_policy => {
                            if !fields.insert(__FieldTag::__org_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for org_policy",
                                ));
                            }
                            result.org_policy = map.next_value::<std::option::Option<std::vec::Vec<orgpolicy_v1::model::Policy>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__access_policy => {
                            if !fields.insert(__FieldTag::__access_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_policy",
                                ));
                            }
                            if result.access_context_policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `access_context_policy`, a oneof with full ID .google.cloud.asset.v1.Asset.access_policy, latest field was accessPolicy",
                                ));
                            }
                            result.access_context_policy = std::option::Option::Some(
                                crate::model::asset::AccessContextPolicy::AccessPolicy(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            accesscontextmanager_v1::model::AccessPolicy,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__access_level => {
                            if !fields.insert(__FieldTag::__access_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_level",
                                ));
                            }
                            if result.access_context_policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `access_context_policy`, a oneof with full ID .google.cloud.asset.v1.Asset.access_level, latest field was accessLevel",
                                ));
                            }
                            result.access_context_policy = std::option::Option::Some(
                                crate::model::asset::AccessContextPolicy::AccessLevel(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            accesscontextmanager_v1::model::AccessLevel,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__service_perimeter => {
                            if !fields.insert(__FieldTag::__service_perimeter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_perimeter",
                                ));
                            }
                            if result.access_context_policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `access_context_policy`, a oneof with full ID .google.cloud.asset.v1.Asset.service_perimeter, latest field was servicePerimeter",
                                ));
                            }
                            result.access_context_policy = std::option::Option::Some(
                                crate::model::asset::AccessContextPolicy::ServicePerimeter(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            accesscontextmanager_v1::model::ServicePerimeter,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__os_inventory => {
                            if !fields.insert(__FieldTag::__os_inventory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_inventory",
                                ));
                            }
                            result.os_inventory = map
                                .next_value::<std::option::Option<osconfig_v1::model::Inventory>>(
                                )?;
                        }
                        __FieldTag::__related_assets => {
                            if !fields.insert(__FieldTag::__related_assets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_assets",
                                ));
                            }
                            result.related_assets = map
                                .next_value::<std::option::Option<crate::model::RelatedAssets>>()?;
                        }
                        __FieldTag::__related_asset => {
                            if !fields.insert(__FieldTag::__related_asset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_asset",
                                ));
                            }
                            result.related_asset = map
                                .next_value::<std::option::Option<crate::model::RelatedAsset>>()?;
                        }
                        __FieldTag::__ancestors => {
                            if !fields.insert(__FieldTag::__ancestors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ancestors",
                                ));
                            }
                            result.ancestors = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Asset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.asset_type.is_empty() {
            state.serialize_entry("assetType", &self.asset_type)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if self.iam_policy.is_some() {
            state.serialize_entry("iamPolicy", &self.iam_policy)?;
        }
        if !self.org_policy.is_empty() {
            state.serialize_entry("orgPolicy", &self.org_policy)?;
        }
        if let Some(value) = self.access_policy() {
            state.serialize_entry("accessPolicy", value)?;
        }
        if let Some(value) = self.access_level() {
            state.serialize_entry("accessLevel", value)?;
        }
        if let Some(value) = self.service_perimeter() {
            state.serialize_entry("servicePerimeter", value)?;
        }
        if self.os_inventory.is_some() {
            state.serialize_entry("osInventory", &self.os_inventory)?;
        }
        if self.related_assets.is_some() {
            state.serialize_entry("relatedAssets", &self.related_assets)?;
        }
        if self.related_asset.is_some() {
            state.serialize_entry("relatedAsset", &self.related_asset)?;
        }
        if !self.ancestors.is_empty() {
            state.serialize_entry("ancestors", &self.ancestors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Asset {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Asset");
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("name", &self.name);
        debug_struct.field("asset_type", &self.asset_type);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("iam_policy", &self.iam_policy);
        debug_struct.field("org_policy", &self.org_policy);
        debug_struct.field("os_inventory", &self.os_inventory);
        debug_struct.field("related_assets", &self.related_assets);
        debug_struct.field("related_asset", &self.related_asset);
        debug_struct.field("ancestors", &self.ancestors);
        debug_struct.field("access_context_policy", &self.access_context_policy);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Asset].
pub mod asset {
    #[allow(unused_imports)]
    use super::*;

    /// A representation of an [access
    /// policy](https://cloud.google.com/access-context-manager/docs/overview#access-policies).
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AccessContextPolicy {
        /// Also refer to the [access policy user
        /// guide](https://cloud.google.com/access-context-manager/docs/overview#access-policies).
        AccessPolicy(std::boxed::Box<accesscontextmanager_v1::model::AccessPolicy>),
        /// Also refer to the [access level user
        /// guide](https://cloud.google.com/access-context-manager/docs/overview#access-levels).
        AccessLevel(std::boxed::Box<accesscontextmanager_v1::model::AccessLevel>),
        /// Also refer to the [service perimeter user
        /// guide](https://cloud.google.com/vpc-service-controls/docs/overview).
        ServicePerimeter(std::boxed::Box<accesscontextmanager_v1::model::ServicePerimeter>),
    }
}

/// A representation of a Google Cloud resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Resource {
    /// The API version. Example: `v1`
    pub version: std::string::String,

    /// The URL of the discovery document containing the resource's JSON schema.
    /// Example:
    /// `<https://www.googleapis.com/discovery/v1/apis/compute/v1/rest>`
    ///
    /// This value is unspecified for resources that do not have an API based on a
    /// discovery document, such as Cloud Bigtable.
    pub discovery_document_uri: std::string::String,

    /// The JSON schema name listed in the discovery document. Example:
    /// `Project`
    ///
    /// This value is unspecified for resources that do not have an API based on a
    /// discovery document, such as Cloud Bigtable.
    pub discovery_name: std::string::String,

    /// The REST URL for accessing the resource. An HTTP `GET` request using this
    /// URL returns the resource itself. Example:
    /// `<https://cloudresourcemanager.googleapis.com/v1/projects/my-project-123>`
    ///
    /// This value is unspecified for resources without a REST API.
    pub resource_url: std::string::String,

    /// The full name of the immediate parent of this resource. See
    /// [Resource
    /// Names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
    /// for more information.
    ///
    /// For Google Cloud assets, this value is the parent resource defined in the
    /// [IAM policy
    /// hierarchy](https://cloud.google.com/iam/docs/overview#policy_hierarchy).
    /// Example:
    /// `//cloudresourcemanager.googleapis.com/projects/my_project_123`
    pub parent: std::string::String,

    /// The content of the resource, in which some sensitive fields are removed
    /// and may not be present.
    pub data: std::option::Option<wkt::Struct>,

    /// The location of the resource in Google Cloud, such as its zone and region.
    /// For more information, see <https://cloud.google.com/about/locations/>.
    pub location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Resource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::Resource::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [discovery_document_uri][crate::model::Resource::discovery_document_uri].
    pub fn set_discovery_document_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_document_uri = v.into();
        self
    }

    /// Sets the value of [discovery_name][crate::model::Resource::discovery_name].
    pub fn set_discovery_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.discovery_name = v.into();
        self
    }

    /// Sets the value of [resource_url][crate::model::Resource::resource_url].
    pub fn set_resource_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_url = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::Resource::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data][crate::model::Resource::data].
    pub fn set_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data][crate::model::Resource::data].
    pub fn set_or_clear_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location][crate::model::Resource::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for Resource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.Resource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Resource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __discovery_document_uri,
            __discovery_name,
            __resource_url,
            __parent,
            __data,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Resource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "discoveryDocumentUri" => Ok(__FieldTag::__discovery_document_uri),
                            "discovery_document_uri" => Ok(__FieldTag::__discovery_document_uri),
                            "discoveryName" => Ok(__FieldTag::__discovery_name),
                            "discovery_name" => Ok(__FieldTag::__discovery_name),
                            "resourceUrl" => Ok(__FieldTag::__resource_url),
                            "resource_url" => Ok(__FieldTag::__resource_url),
                            "parent" => Ok(__FieldTag::__parent),
                            "data" => Ok(__FieldTag::__data),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Resource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Resource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__discovery_document_uri => {
                            if !fields.insert(__FieldTag::__discovery_document_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_document_uri",
                                ));
                            }
                            result.discovery_document_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__discovery_name => {
                            if !fields.insert(__FieldTag::__discovery_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_name",
                                ));
                            }
                            result.discovery_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_url => {
                            if !fields.insert(__FieldTag::__resource_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_url",
                                ));
                            }
                            result.resource_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            result.data = map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Resource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.discovery_document_uri.is_empty() {
            state.serialize_entry("discoveryDocumentUri", &self.discovery_document_uri)?;
        }
        if !self.discovery_name.is_empty() {
            state.serialize_entry("discoveryName", &self.discovery_name)?;
        }
        if !self.resource_url.is_empty() {
            state.serialize_entry("resourceUrl", &self.resource_url)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.data.is_some() {
            state.serialize_entry("data", &self.data)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Resource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Resource");
        debug_struct.field("version", &self.version);
        debug_struct.field("discovery_document_uri", &self.discovery_document_uri);
        debug_struct.field("discovery_name", &self.discovery_name);
        debug_struct.field("resource_url", &self.resource_url);
        debug_struct.field("parent", &self.parent);
        debug_struct.field("data", &self.data);
        debug_struct.field("location", &self.location);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DEPRECATED. This message only presents for the purpose of
/// backward-compatibility. The server will never populate this message in
/// responses.
/// The detailed related assets with the `relationship_type`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub struct RelatedAssets {
    /// The detailed relationship attributes.
    pub relationship_attributes: std::option::Option<crate::model::RelationshipAttributes>,

    /// The peer resources of the relationship.
    pub assets: std::vec::Vec<crate::model::RelatedAsset>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedAssets {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [relationship_attributes][crate::model::RelatedAssets::relationship_attributes].
    pub fn set_relationship_attributes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RelationshipAttributes>,
    {
        self.relationship_attributes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [relationship_attributes][crate::model::RelatedAssets::relationship_attributes].
    pub fn set_or_clear_relationship_attributes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RelationshipAttributes>,
    {
        self.relationship_attributes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [assets][crate::model::RelatedAssets::assets].
    pub fn set_assets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedAsset>,
    {
        use std::iter::Iterator;
        self.assets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RelatedAssets {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.RelatedAssets"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RelatedAssets {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __relationship_attributes,
            __assets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RelatedAssets")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "relationshipAttributes" => Ok(__FieldTag::__relationship_attributes),
                            "relationship_attributes" => Ok(__FieldTag::__relationship_attributes),
                            "assets" => Ok(__FieldTag::__assets),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RelatedAssets;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RelatedAssets")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__relationship_attributes => {
                            if !fields.insert(__FieldTag::__relationship_attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relationship_attributes",
                                ));
                            }
                            result.relationship_attributes = map.next_value::<std::option::Option<crate::model::RelationshipAttributes>>()?
                                ;
                        }
                        __FieldTag::__assets => {
                            if !fields.insert(__FieldTag::__assets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assets",
                                ));
                            }
                            result.assets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RelatedAsset>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RelatedAssets {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.relationship_attributes.is_some() {
            state.serialize_entry("relationshipAttributes", &self.relationship_attributes)?;
        }
        if !self.assets.is_empty() {
            state.serialize_entry("assets", &self.assets)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RelatedAssets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RelatedAssets");
        debug_struct.field("relationship_attributes", &self.relationship_attributes);
        debug_struct.field("assets", &self.assets);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DEPRECATED. This message only presents for the purpose of
/// backward-compatibility. The server will never populate this message in
/// responses.
/// The relationship attributes which include  `type`, `source_resource_type`,
/// `target_resource_type` and `action`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub struct RelationshipAttributes {
    /// The unique identifier of the relationship type. Example:
    /// `INSTANCE_TO_INSTANCEGROUP`
    pub r#type: std::string::String,

    /// The source asset type. Example: `compute.googleapis.com/Instance`
    pub source_resource_type: std::string::String,

    /// The target asset type. Example: `compute.googleapis.com/Disk`
    pub target_resource_type: std::string::String,

    /// The detail of the relationship, e.g. `contains`, `attaches`
    pub action: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelationshipAttributes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::RelationshipAttributes::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [source_resource_type][crate::model::RelationshipAttributes::source_resource_type].
    pub fn set_source_resource_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_resource_type = v.into();
        self
    }

    /// Sets the value of [target_resource_type][crate::model::RelationshipAttributes::target_resource_type].
    pub fn set_target_resource_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_resource_type = v.into();
        self
    }

    /// Sets the value of [action][crate::model::RelationshipAttributes::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }
}

impl wkt::message::Message for RelationshipAttributes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.RelationshipAttributes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RelationshipAttributes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __source_resource_type,
            __target_resource_type,
            __action,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RelationshipAttributes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "sourceResourceType" => Ok(__FieldTag::__source_resource_type),
                            "source_resource_type" => Ok(__FieldTag::__source_resource_type),
                            "targetResourceType" => Ok(__FieldTag::__target_resource_type),
                            "target_resource_type" => Ok(__FieldTag::__target_resource_type),
                            "action" => Ok(__FieldTag::__action),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RelationshipAttributes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RelationshipAttributes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_resource_type => {
                            if !fields.insert(__FieldTag::__source_resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_resource_type",
                                ));
                            }
                            result.source_resource_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_resource_type => {
                            if !fields.insert(__FieldTag::__target_resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_resource_type",
                                ));
                            }
                            result.target_resource_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RelationshipAttributes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.source_resource_type.is_empty() {
            state.serialize_entry("sourceResourceType", &self.source_resource_type)?;
        }
        if !self.target_resource_type.is_empty() {
            state.serialize_entry("targetResourceType", &self.target_resource_type)?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RelationshipAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RelationshipAttributes");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("source_resource_type", &self.source_resource_type);
        debug_struct.field("target_resource_type", &self.target_resource_type);
        debug_struct.field("action", &self.action);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An asset identifier in Google Cloud which contains its name, type and
/// ancestors. An asset can be any resource in the Google Cloud [resource
/// hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
/// a resource outside the Google Cloud resource hierarchy (such as Google
/// Kubernetes Engine clusters and objects), or a policy (e.g. IAM policy).
/// See [Supported asset
/// types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
/// for more information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RelatedAsset {
    /// The full name of the asset. Example:
    /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`
    ///
    /// See [Resource
    /// names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
    /// for more information.
    pub asset: std::string::String,

    /// The type of the asset. Example: `compute.googleapis.com/Disk`
    ///
    /// See [Supported asset
    /// types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
    /// for more information.
    pub asset_type: std::string::String,

    /// The ancestors of an asset in Google Cloud [resource
    /// hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
    /// represented as a list of relative resource names. An ancestry path starts
    /// with the closest ancestor in the hierarchy and ends at root.
    ///
    /// Example: `["projects/123456789", "folders/5432", "organizations/1234"]`
    pub ancestors: std::vec::Vec<std::string::String>,

    /// The unique identifier of the relationship type. Example:
    /// `INSTANCE_TO_INSTANCEGROUP`
    pub relationship_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedAsset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [asset][crate::model::RelatedAsset::asset].
    pub fn set_asset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset = v.into();
        self
    }

    /// Sets the value of [asset_type][crate::model::RelatedAsset::asset_type].
    pub fn set_asset_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_type = v.into();
        self
    }

    /// Sets the value of [ancestors][crate::model::RelatedAsset::ancestors].
    pub fn set_ancestors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ancestors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [relationship_type][crate::model::RelatedAsset::relationship_type].
    pub fn set_relationship_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.relationship_type = v.into();
        self
    }
}

impl wkt::message::Message for RelatedAsset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.RelatedAsset"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RelatedAsset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __asset,
            __asset_type,
            __ancestors,
            __relationship_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RelatedAsset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "asset" => Ok(__FieldTag::__asset),
                            "assetType" => Ok(__FieldTag::__asset_type),
                            "asset_type" => Ok(__FieldTag::__asset_type),
                            "ancestors" => Ok(__FieldTag::__ancestors),
                            "relationshipType" => Ok(__FieldTag::__relationship_type),
                            "relationship_type" => Ok(__FieldTag::__relationship_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RelatedAsset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RelatedAsset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__asset => {
                            if !fields.insert(__FieldTag::__asset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset",
                                ));
                            }
                            result.asset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset_type => {
                            if !fields.insert(__FieldTag::__asset_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_type",
                                ));
                            }
                            result.asset_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ancestors => {
                            if !fields.insert(__FieldTag::__ancestors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ancestors",
                                ));
                            }
                            result.ancestors = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__relationship_type => {
                            if !fields.insert(__FieldTag::__relationship_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relationship_type",
                                ));
                            }
                            result.relationship_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RelatedAsset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.asset.is_empty() {
            state.serialize_entry("asset", &self.asset)?;
        }
        if !self.asset_type.is_empty() {
            state.serialize_entry("assetType", &self.asset_type)?;
        }
        if !self.ancestors.is_empty() {
            state.serialize_entry("ancestors", &self.ancestors)?;
        }
        if !self.relationship_type.is_empty() {
            state.serialize_entry("relationshipType", &self.relationship_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RelatedAsset {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RelatedAsset");
        debug_struct.field("asset", &self.asset);
        debug_struct.field("asset_type", &self.asset_type);
        debug_struct.field("ancestors", &self.ancestors);
        debug_struct.field("relationship_type", &self.relationship_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The key and value for a
/// [tag](https://cloud.google.com/resource-manager/docs/tags/tags-overview).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Tag {
    /// TagKey namespaced name, in the format of {ORG_ID}/{TAG_KEY_SHORT_NAME}.
    pub tag_key: std::option::Option<std::string::String>,

    /// TagKey ID, in the format of tagKeys/{TAG_KEY_ID}.
    pub tag_key_id: std::option::Option<std::string::String>,

    /// TagValue namespaced name, in the format of
    /// {ORG_ID}/{TAG_KEY_SHORT_NAME}/{TAG_VALUE_SHORT_NAME}.
    pub tag_value: std::option::Option<std::string::String>,

    /// TagValue ID, in the format of tagValues/{TAG_VALUE_ID}.
    pub tag_value_id: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Tag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag_key][crate::model::Tag::tag_key].
    pub fn set_tag_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.tag_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag_key][crate::model::Tag::tag_key].
    pub fn set_or_clear_tag_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.tag_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tag_key_id][crate::model::Tag::tag_key_id].
    pub fn set_tag_key_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.tag_key_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag_key_id][crate::model::Tag::tag_key_id].
    pub fn set_or_clear_tag_key_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.tag_key_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tag_value][crate::model::Tag::tag_value].
    pub fn set_tag_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.tag_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag_value][crate::model::Tag::tag_value].
    pub fn set_or_clear_tag_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.tag_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tag_value_id][crate::model::Tag::tag_value_id].
    pub fn set_tag_value_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.tag_value_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag_value_id][crate::model::Tag::tag_value_id].
    pub fn set_or_clear_tag_value_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.tag_value_id = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Tag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.Tag"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Tag {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tag_key,
            __tag_key_id,
            __tag_value,
            __tag_value_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Tag")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tagKey" => Ok(__FieldTag::__tag_key),
                            "tag_key" => Ok(__FieldTag::__tag_key),
                            "tagKeyId" => Ok(__FieldTag::__tag_key_id),
                            "tag_key_id" => Ok(__FieldTag::__tag_key_id),
                            "tagValue" => Ok(__FieldTag::__tag_value),
                            "tag_value" => Ok(__FieldTag::__tag_value),
                            "tagValueId" => Ok(__FieldTag::__tag_value_id),
                            "tag_value_id" => Ok(__FieldTag::__tag_value_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Tag;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Tag")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tag_key => {
                            if !fields.insert(__FieldTag::__tag_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_key",
                                ));
                            }
                            result.tag_key =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__tag_key_id => {
                            if !fields.insert(__FieldTag::__tag_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_key_id",
                                ));
                            }
                            result.tag_key_id =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__tag_value => {
                            if !fields.insert(__FieldTag::__tag_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_value",
                                ));
                            }
                            result.tag_value =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__tag_value_id => {
                            if !fields.insert(__FieldTag::__tag_value_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_value_id",
                                ));
                            }
                            result.tag_value_id =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Tag {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.tag_key.is_some() {
            state.serialize_entry("tagKey", &self.tag_key)?;
        }
        if self.tag_key_id.is_some() {
            state.serialize_entry("tagKeyId", &self.tag_key_id)?;
        }
        if self.tag_value.is_some() {
            state.serialize_entry("tagValue", &self.tag_value)?;
        }
        if self.tag_value_id.is_some() {
            state.serialize_entry("tagValueId", &self.tag_value_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Tag");
        debug_struct.field("tag_key", &self.tag_key);
        debug_struct.field("tag_key_id", &self.tag_key_id);
        debug_struct.field("tag_value", &self.tag_value);
        debug_struct.field("tag_value_id", &self.tag_value_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The effective tags and the ancestor resources from which they were inherited.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EffectiveTagDetails {
    /// The [full resource
    /// name](https://cloud.google.com/asset-inventory/docs/resource-name-format)
    /// of the ancestor from which
    /// [effective_tags][google.cloud.asset.v1.EffectiveTagDetails.effective_tags]
    /// are inherited, according to [tag
    /// inheritance](https://cloud.google.com/resource-manager/docs/tags/tags-overview#inheritance).
    ///
    /// [google.cloud.asset.v1.EffectiveTagDetails.effective_tags]: crate::model::EffectiveTagDetails::effective_tags
    pub attached_resource: std::option::Option<std::string::String>,

    /// The effective tags inherited from the
    /// [attached_resource][google.cloud.asset.v1.EffectiveTagDetails.attached_resource].
    /// Note that tags with the same key but different values may attach to
    /// resources at a different hierarchy levels. The lower hierarchy tag value
    /// will overwrite the higher hierarchy tag value of the same tag key. In this
    /// case, the tag value at the higher hierarchy level will be removed. For more
    /// information, see [tag
    /// inheritance](https://cloud.google.com/resource-manager/docs/tags/tags-overview#inheritance).
    ///
    /// [google.cloud.asset.v1.EffectiveTagDetails.attached_resource]: crate::model::EffectiveTagDetails::attached_resource
    pub effective_tags: std::vec::Vec<crate::model::Tag>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EffectiveTagDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attached_resource][crate::model::EffectiveTagDetails::attached_resource].
    pub fn set_attached_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.attached_resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attached_resource][crate::model::EffectiveTagDetails::attached_resource].
    pub fn set_or_clear_attached_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.attached_resource = v.map(|x| x.into());
        self
    }

    /// Sets the value of [effective_tags][crate::model::EffectiveTagDetails::effective_tags].
    pub fn set_effective_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.effective_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EffectiveTagDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.EffectiveTagDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EffectiveTagDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attached_resource,
            __effective_tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EffectiveTagDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attachedResource" => Ok(__FieldTag::__attached_resource),
                            "attached_resource" => Ok(__FieldTag::__attached_resource),
                            "effectiveTags" => Ok(__FieldTag::__effective_tags),
                            "effective_tags" => Ok(__FieldTag::__effective_tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EffectiveTagDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EffectiveTagDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attached_resource => {
                            if !fields.insert(__FieldTag::__attached_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attached_resource",
                                ));
                            }
                            result.attached_resource =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__effective_tags => {
                            if !fields.insert(__FieldTag::__effective_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effective_tags",
                                ));
                            }
                            result.effective_tags = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Tag>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EffectiveTagDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.attached_resource.is_some() {
            state.serialize_entry("attachedResource", &self.attached_resource)?;
        }
        if !self.effective_tags.is_empty() {
            state.serialize_entry("effectiveTags", &self.effective_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EffectiveTagDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EffectiveTagDetails");
        debug_struct.field("attached_resource", &self.attached_resource);
        debug_struct.field("effective_tags", &self.effective_tags);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A result of Resource Search, containing information of a cloud resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceSearchResult {
    /// The full resource name of this resource. Example:
    /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
    /// See [Cloud Asset Inventory Resource Name
    /// Format](https://cloud.google.com/asset-inventory/docs/resource-name-format)
    /// for more information.
    ///
    /// To search against the `name`:
    ///
    /// * Use a field query. Example: `name:instance1`
    /// * Use a free text query. Example: `instance1`
    pub name: std::string::String,

    /// The type of this resource. Example: `compute.googleapis.com/Disk`.
    ///
    /// To search against the `asset_type`:
    ///
    /// * Specify the `asset_type` field in your search request.
    pub asset_type: std::string::String,

    /// The project that this resource belongs to, in the form of
    /// projects/{PROJECT_NUMBER}. This field is available when the resource
    /// belongs to a project.
    ///
    /// To search against `project`:
    ///
    /// * Use a field query. Example: `project:12345`
    /// * Use a free text query. Example: `12345`
    /// * Specify the `scope` field as this project in your search request.
    pub project: std::string::String,

    /// The folder(s) that this resource belongs to, in the form of
    /// folders/{FOLDER_NUMBER}. This field is available when the resource
    /// belongs to one or more folders.
    ///
    /// To search against `folders`:
    ///
    /// * Use a field query. Example: `folders:(123 OR 456)`
    /// * Use a free text query. Example: `123`
    /// * Specify the `scope` field as this folder in your search request.
    pub folders: std::vec::Vec<std::string::String>,

    /// The organization that this resource belongs to, in the form of
    /// organizations/{ORGANIZATION_NUMBER}. This field is available when the
    /// resource belongs to an organization.
    ///
    /// To search against `organization`:
    ///
    /// * Use a field query. Example: `organization:123`
    /// * Use a free text query. Example: `123`
    /// * Specify the `scope` field as this organization in your search request.
    pub organization: std::string::String,

    /// The display name of this resource. This field is available only when the
    /// resource's Protobuf contains it.
    ///
    /// To search against the `display_name`:
    ///
    /// * Use a field query. Example: `displayName:"My Instance"`
    /// * Use a free text query. Example: `"My Instance"`
    pub display_name: std::string::String,

    /// One or more paragraphs of text description of this resource. Maximum length
    /// could be up to 1M bytes. This field is available only when the resource's
    /// Protobuf contains it.
    ///
    /// To search against the `description`:
    ///
    /// * Use a field query. Example: `description:"important instance"`
    /// * Use a free text query. Example: `"important instance"`
    pub description: std::string::String,

    /// Location can be `global`, regional like `us-east1`, or zonal like
    /// `us-west1-b`. This field is available only when the resource's Protobuf
    /// contains it.
    ///
    /// To search against the `location`:
    ///
    /// * Use a field query. Example: `location:us-west*`
    /// * Use a free text query. Example: `us-west*`
    pub location: std::string::String,

    /// User labels associated with this resource. See [Labelling and grouping
    /// Google Cloud
    /// resources](https://cloud.google.com/blog/products/gcp/labelling-and-grouping-your-google-cloud-platform-resources)
    /// for more information. This field is available only when the resource's
    /// Protobuf contains it.
    ///
    /// To search against the `labels`:
    ///
    /// * Use a field query:
    ///   - query on any label's key or value. Example: `labels:prod`
    ///   - query by a given label. Example: `labels.env:prod`
    ///   - query by a given label's existence. Example: `labels.env:*`
    /// * Use a free text query. Example: `prod`
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Network tags associated with this resource. Like labels, network tags are a
    /// type of annotations used to group Google Cloud resources. See [Labelling
    /// Google Cloud
    /// resources](https://cloud.google.com/blog/products/gcp/labelling-and-grouping-your-google-cloud-platform-resources)
    /// for more information. This field is available only when the resource's
    /// Protobuf contains it.
    ///
    /// To search against the `network_tags`:
    ///
    /// * Use a field query. Example: `networkTags:internal`
    /// * Use a free text query. Example: `internal`
    pub network_tags: std::vec::Vec<std::string::String>,

    /// The Cloud KMS
    /// [CryptoKey](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys)
    /// name or
    /// [CryptoKeyVersion](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys.cryptoKeyVersions)
    /// name.
    ///
    /// This field only presents for the purpose of backward compatibility.
    /// Use the `kms_keys` field to retrieve Cloud KMS key information. This field
    /// is available only when the resource's Protobuf contains it and will only be
    /// populated for [these resource
    /// types](https://cloud.google.com/asset-inventory/docs/legacy-field-names#resource_types_with_the_to_be_deprecated_kmskey_field)
    /// for backward compatible purposes.
    ///
    /// To search against the `kms_key`:
    ///
    /// * Use a field query. Example: `kmsKey:key`
    /// * Use a free text query. Example: `key`
    #[deprecated]
    pub kms_key: std::string::String,

    /// The Cloud KMS
    /// [CryptoKey](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys)
    /// names or
    /// [CryptoKeyVersion](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys.cryptoKeyVersions)
    /// names. This field is available only when the resource's Protobuf contains
    /// it.
    ///
    /// To search against the `kms_keys`:
    ///
    /// * Use a field query. Example: `kmsKeys:key`
    /// * Use a free text query. Example: `key`
    pub kms_keys: std::vec::Vec<std::string::String>,

    /// The create timestamp of this resource, at which the resource was created.
    /// The granularity is in seconds. Timestamp.nanos will always be 0. This field
    /// is available only when the resource's Protobuf contains it.
    ///
    /// To search against `create_time`:
    ///
    /// * Use a field query.
    ///   - value in seconds since unix epoch. Example: `createTime > 1609459200`
    ///   - value in date string. Example: `createTime > 2021-01-01`
    ///   - value in date-time string (must be quoted). Example: `createTime >
    ///     "2021-01-01T00:00:00"`
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update timestamp of this resource, at which the resource was last
    /// modified or deleted. The granularity is in seconds. Timestamp.nanos will
    /// always be 0. This field is available only when the resource's Protobuf
    /// contains it.
    ///
    /// To search against `update_time`:
    ///
    /// * Use a field query.
    ///   - value in seconds since unix epoch. Example: `updateTime < 1609459200`
    ///   - value in date string. Example: `updateTime < 2021-01-01`
    ///   - value in date-time string (must be quoted). Example: `updateTime <
    ///     "2021-01-01T00:00:00"`
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The state of this resource. Different resources types have different state
    /// definitions that are mapped from various fields of different resource
    /// types. This field is available only when the resource's Protobuf contains
    /// it.
    ///
    /// Example:
    /// If the resource is an instance provided by Compute Engine,
    /// its state will include PROVISIONING, STAGING, RUNNING, STOPPING,
    /// SUSPENDING, SUSPENDED, REPAIRING, and TERMINATED. See `status` definition
    /// in [API
    /// Reference](https://cloud.google.com/compute/docs/reference/rest/v1/instances).
    /// If the resource is a project provided by Resource Manager, its state
    /// will include LIFECYCLE_STATE_UNSPECIFIED, ACTIVE, DELETE_REQUESTED and
    /// DELETE_IN_PROGRESS. See `lifecycleState` definition in [API
    /// Reference](https://cloud.google.com/resource-manager/reference/rest/v1/projects).
    ///
    /// To search against the `state`:
    ///
    /// * Use a field query. Example: `state:RUNNING`
    /// * Use a free text query. Example: `RUNNING`
    pub state: std::string::String,

    /// The additional searchable attributes of this resource. The attributes may
    /// vary from one resource type to another. Examples: `projectId` for Project,
    /// `dnsName` for DNS ManagedZone. This field contains a subset of the resource
    /// metadata fields that are returned by the List or Get APIs provided by the
    /// corresponding Google Cloud service (e.g., Compute Engine). see [API
    /// references and supported searchable
    /// attributes](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
    /// to see which fields are included.
    ///
    /// You can search values of these fields through free text search. However,
    /// you should not consume the field programically as the field names and
    /// values may change as the Google Cloud service updates to a new incompatible
    /// API version.
    ///
    /// To search against the `additional_attributes`:
    ///
    /// * Use a free text query to match the attributes values. Example: to search
    ///   `additional_attributes = { dnsName: "foobar" }`, you can issue a query
    ///   `foobar`.
    pub additional_attributes: std::option::Option<wkt::Struct>,

    /// The full resource name of this resource's parent, if it has one.
    /// To search against the `parent_full_resource_name`:
    ///
    /// * Use a field query. Example:
    ///   `parentFullResourceName:"project-name"`
    /// * Use a free text query. Example:
    ///   `project-name`
    pub parent_full_resource_name: std::string::String,

    /// Versioned resource representations of this resource. This is repeated
    /// because there could be multiple versions of resource representations during
    /// version migration.
    ///
    /// This `versioned_resources` field is not searchable. Some attributes of the
    /// resource representations are exposed in `additional_attributes` field, so
    /// as to allow users to search on them.
    pub versioned_resources: std::vec::Vec<crate::model::VersionedResource>,

    /// Attached resources of this resource. For example, an OSConfig
    /// Inventory is an attached resource of a Compute Instance. This field is
    /// repeated because a resource could have multiple attached resources.
    ///
    /// This `attached_resources` field is not searchable. Some attributes
    /// of the attached resources are exposed in `additional_attributes` field, so
    /// as to allow users to search on them.
    pub attached_resources: std::vec::Vec<crate::model::AttachedResource>,

    /// A map of related resources of this resource, keyed by the
    /// relationship type. A relationship type is in the format of
    /// {SourceType}_{ACTION}_{DestType}. Example: `DISK_TO_INSTANCE`,
    /// `DISK_TO_NETWORK`, `INSTANCE_TO_INSTANCEGROUP`.
    /// See [supported relationship
    /// types](https://cloud.google.com/asset-inventory/docs/supported-asset-types#supported_relationship_types).
    pub relationships:
        std::collections::HashMap<std::string::String, crate::model::RelatedResources>,

    /// This field is only present for the purpose of backward compatibility.
    /// Use the `tags` field instead.
    ///
    /// TagKey namespaced names, in the format of {ORG_ID}/{TAG_KEY_SHORT_NAME}.
    /// To search against the `tagKeys`:
    ///
    /// * Use a field query. Example:
    ///
    ///   - `tagKeys:"123456789/env*"`
    ///   - `tagKeys="123456789/env"`
    ///   - `tagKeys:"env"`
    /// * Use a free text query. Example:
    ///
    ///   - `env`
    #[deprecated]
    pub tag_keys: std::vec::Vec<std::string::String>,

    /// This field is only present for the purpose of backward compatibility.
    /// Use the `tags` field instead.
    ///
    /// TagValue namespaced names, in the format of
    /// {ORG_ID}/{TAG_KEY_SHORT_NAME}/{TAG_VALUE_SHORT_NAME}.
    /// To search against the `tagValues`:
    ///
    /// * Use a field query. Example:
    ///
    ///   - `tagValues:"env"`
    ///   - `tagValues:"env/prod"`
    ///   - `tagValues:"123456789/env/prod*"`
    ///   - `tagValues="123456789/env/prod"`
    /// * Use a free text query. Example:
    ///
    ///   - `prod`
    #[deprecated]
    pub tag_values: std::vec::Vec<std::string::String>,

    /// This field is only present for the purpose of backward compatibility.
    /// Use the `tags` field instead.
    ///
    /// TagValue IDs, in the format of tagValues/{TAG_VALUE_ID}.
    /// To search against the `tagValueIds`:
    ///
    /// * Use a field query. Example:
    ///
    ///   - `tagValueIds="tagValues/456"`
    /// * Use a free text query. Example:
    ///
    ///   - `456`
    #[deprecated]
    pub tag_value_ids: std::vec::Vec<std::string::String>,

    /// The tags directly attached to this resource.
    ///
    /// To search against the `tags`:
    ///
    /// * Use a field query. Example:
    ///
    ///   - `tagKeys:"123456789/env*"`
    ///   - `tagKeys="123456789/env"`
    ///   - `tagKeys:"env"`
    ///   - `tagKeyIds="tagKeys/123"`
    ///   - `tagValues:"env"`
    ///   - `tagValues:"env/prod"`
    ///   - `tagValues:"123456789/env/prod*"`
    ///   - `tagValues="123456789/env/prod"`
    ///   - `tagValueIds="tagValues/456"`
    /// * Use a free text query. Example:
    ///
    ///   - `env/prod`
    pub tags: std::vec::Vec<crate::model::Tag>,

    /// The effective tags on this resource. All of the tags that are both attached
    /// to and inherited by a resource are collectively called the effective
    /// tags. For more information, see [tag
    /// inheritance](https://cloud.google.com/resource-manager/docs/tags/tags-overview#inheritance).
    ///
    /// To search against the `effective_tags`:
    ///
    /// * Use a field query. Example:
    ///   - `effectiveTagKeys:"123456789/env*"`
    ///   - `effectiveTagKeys="123456789/env"`
    ///   - `effectiveTagKeys:"env"`
    ///   - `effectiveTagKeyIds="tagKeys/123"`
    ///   - `effectiveTagValues:"env"`
    ///   - `effectiveTagValues:"env/prod"`
    ///   - `effectiveTagValues:"123456789/env/prod*"`
    ///   - `effectiveTagValues="123456789/env/prod"`
    ///   - `effectiveTagValueIds="tagValues/456"`
    pub effective_tags: std::vec::Vec<crate::model::EffectiveTagDetails>,

    /// Enrichments of the asset. Currently supported enrichment types with
    /// SearchAllResources API:
    ///
    /// * RESOURCE_OWNERS
    ///
    /// The corresponding read masks in order to get the enrichment:
    ///
    /// * enrichments.resource_owners
    ///
    /// The corresponding required permissions:
    ///
    /// * cloudasset.assets.searchEnrichmentResourceOwners
    ///
    /// Example query to get resource owner enrichment:
    ///
    /// ```norust
    ///   scope: "projects/my-project"
    ///   query: "name: my-project"
    ///   assetTypes: "cloudresourcemanager.googleapis.com/Project"
    ///   readMask: {
    ///      paths: "asset_type"
    ///      paths: "name"
    ///      paths: "enrichments.resource_owners"
    ///   }
    /// ```
    pub enrichments: std::vec::Vec<crate::model::AssetEnrichment>,

    /// The type of this resource's immediate parent, if there is one.
    ///
    /// To search against the `parent_asset_type`:
    ///
    /// * Use a field query. Example:
    ///   `parentAssetType:"cloudresourcemanager.googleapis.com/Project"`
    /// * Use a free text query. Example:
    ///   `cloudresourcemanager.googleapis.com/Project`
    pub parent_asset_type: std::string::String,

    /// The actual content of Security Command Center security marks associated
    /// with the asset.
    ///
    /// To search against SCC SecurityMarks field:
    ///
    /// * Use a field query:
    ///   - query by a given key value pair. Example: `sccSecurityMarks.foo=bar`
    ///   - query by a given key's existence. Example: `sccSecurityMarks.foo:*`
    pub scc_security_marks: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceSearchResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResourceSearchResult::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [asset_type][crate::model::ResourceSearchResult::asset_type].
    pub fn set_asset_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_type = v.into();
        self
    }

    /// Sets the value of [project][crate::model::ResourceSearchResult::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [folders][crate::model::ResourceSearchResult::folders].
    pub fn set_folders<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.folders = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [organization][crate::model::ResourceSearchResult::organization].
    pub fn set_organization<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.organization = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ResourceSearchResult::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ResourceSearchResult::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ResourceSearchResult::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ResourceSearchResult::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [network_tags][crate::model::ResourceSearchResult::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kms_key][crate::model::ResourceSearchResult::kms_key].
    #[deprecated]
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [kms_keys][crate::model::ResourceSearchResult::kms_keys].
    pub fn set_kms_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.kms_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::ResourceSearchResult::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ResourceSearchResult::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ResourceSearchResult::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ResourceSearchResult::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ResourceSearchResult::state].
    pub fn set_state<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [additional_attributes][crate::model::ResourceSearchResult::additional_attributes].
    pub fn set_additional_attributes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.additional_attributes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [additional_attributes][crate::model::ResourceSearchResult::additional_attributes].
    pub fn set_or_clear_additional_attributes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.additional_attributes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parent_full_resource_name][crate::model::ResourceSearchResult::parent_full_resource_name].
    pub fn set_parent_full_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_full_resource_name = v.into();
        self
    }

    /// Sets the value of [versioned_resources][crate::model::ResourceSearchResult::versioned_resources].
    pub fn set_versioned_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VersionedResource>,
    {
        use std::iter::Iterator;
        self.versioned_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [attached_resources][crate::model::ResourceSearchResult::attached_resources].
    pub fn set_attached_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedResource>,
    {
        use std::iter::Iterator;
        self.attached_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [relationships][crate::model::ResourceSearchResult::relationships].
    pub fn set_relationships<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::RelatedResources>,
    {
        use std::iter::Iterator;
        self.relationships = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tag_keys][crate::model::ResourceSearchResult::tag_keys].
    #[deprecated]
    pub fn set_tag_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tag_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tag_values][crate::model::ResourceSearchResult::tag_values].
    #[deprecated]
    pub fn set_tag_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tag_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tag_value_ids][crate::model::ResourceSearchResult::tag_value_ids].
    #[deprecated]
    pub fn set_tag_value_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tag_value_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::ResourceSearchResult::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [effective_tags][crate::model::ResourceSearchResult::effective_tags].
    pub fn set_effective_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EffectiveTagDetails>,
    {
        use std::iter::Iterator;
        self.effective_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enrichments][crate::model::ResourceSearchResult::enrichments].
    pub fn set_enrichments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AssetEnrichment>,
    {
        use std::iter::Iterator;
        self.enrichments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [parent_asset_type][crate::model::ResourceSearchResult::parent_asset_type].
    pub fn set_parent_asset_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_asset_type = v.into();
        self
    }

    /// Sets the value of [scc_security_marks][crate::model::ResourceSearchResult::scc_security_marks].
    pub fn set_scc_security_marks<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scc_security_marks = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ResourceSearchResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.ResourceSearchResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceSearchResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __asset_type,
            __project,
            __folders,
            __organization,
            __display_name,
            __description,
            __location,
            __labels,
            __network_tags,
            __kms_key,
            __kms_keys,
            __create_time,
            __update_time,
            __state,
            __additional_attributes,
            __parent_full_resource_name,
            __versioned_resources,
            __attached_resources,
            __relationships,
            __tag_keys,
            __tag_values,
            __tag_value_ids,
            __tags,
            __effective_tags,
            __enrichments,
            __parent_asset_type,
            __scc_security_marks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceSearchResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "assetType" => Ok(__FieldTag::__asset_type),
                            "asset_type" => Ok(__FieldTag::__asset_type),
                            "project" => Ok(__FieldTag::__project),
                            "folders" => Ok(__FieldTag::__folders),
                            "organization" => Ok(__FieldTag::__organization),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "location" => Ok(__FieldTag::__location),
                            "labels" => Ok(__FieldTag::__labels),
                            "networkTags" => Ok(__FieldTag::__network_tags),
                            "network_tags" => Ok(__FieldTag::__network_tags),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            "kmsKeys" => Ok(__FieldTag::__kms_keys),
                            "kms_keys" => Ok(__FieldTag::__kms_keys),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "state" => Ok(__FieldTag::__state),
                            "additionalAttributes" => Ok(__FieldTag::__additional_attributes),
                            "additional_attributes" => Ok(__FieldTag::__additional_attributes),
                            "parentFullResourceName" => Ok(__FieldTag::__parent_full_resource_name),
                            "parent_full_resource_name" => {
                                Ok(__FieldTag::__parent_full_resource_name)
                            }
                            "versionedResources" => Ok(__FieldTag::__versioned_resources),
                            "versioned_resources" => Ok(__FieldTag::__versioned_resources),
                            "attachedResources" => Ok(__FieldTag::__attached_resources),
                            "attached_resources" => Ok(__FieldTag::__attached_resources),
                            "relationships" => Ok(__FieldTag::__relationships),
                            "tagKeys" => Ok(__FieldTag::__tag_keys),
                            "tag_keys" => Ok(__FieldTag::__tag_keys),
                            "tagValues" => Ok(__FieldTag::__tag_values),
                            "tag_values" => Ok(__FieldTag::__tag_values),
                            "tagValueIds" => Ok(__FieldTag::__tag_value_ids),
                            "tag_value_ids" => Ok(__FieldTag::__tag_value_ids),
                            "tags" => Ok(__FieldTag::__tags),
                            "effectiveTags" => Ok(__FieldTag::__effective_tags),
                            "effective_tags" => Ok(__FieldTag::__effective_tags),
                            "enrichments" => Ok(__FieldTag::__enrichments),
                            "parentAssetType" => Ok(__FieldTag::__parent_asset_type),
                            "parent_asset_type" => Ok(__FieldTag::__parent_asset_type),
                            "sccSecurityMarks" => Ok(__FieldTag::__scc_security_marks),
                            "scc_security_marks" => Ok(__FieldTag::__scc_security_marks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceSearchResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceSearchResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset_type => {
                            if !fields.insert(__FieldTag::__asset_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_type",
                                ));
                            }
                            result.asset_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__folders => {
                            if !fields.insert(__FieldTag::__folders) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for folders",
                                ));
                            }
                            result.folders = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__organization => {
                            if !fields.insert(__FieldTag::__organization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organization",
                                ));
                            }
                            result.organization = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_tags => {
                            if !fields.insert(__FieldTag::__network_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_tags",
                                ));
                            }
                            result.network_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_keys => {
                            if !fields.insert(__FieldTag::__kms_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_keys",
                                ));
                            }
                            result.kms_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_attributes => {
                            if !fields.insert(__FieldTag::__additional_attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_attributes",
                                ));
                            }
                            result.additional_attributes =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__parent_full_resource_name => {
                            if !fields.insert(__FieldTag::__parent_full_resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_full_resource_name",
                                ));
                            }
                            result.parent_full_resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__versioned_resources => {
                            if !fields.insert(__FieldTag::__versioned_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versioned_resources",
                                ));
                            }
                            result.versioned_resources =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VersionedResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attached_resources => {
                            if !fields.insert(__FieldTag::__attached_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attached_resources",
                                ));
                            }
                            result.attached_resources =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AttachedResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relationships => {
                            if !fields.insert(__FieldTag::__relationships) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relationships",
                                ));
                            }
                            result.relationships = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::RelatedResources,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag_keys => {
                            if !fields.insert(__FieldTag::__tag_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_keys",
                                ));
                            }
                            result.tag_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__tag_values => {
                            if !fields.insert(__FieldTag::__tag_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_values",
                                ));
                            }
                            result.tag_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__tag_value_ids => {
                            if !fields.insert(__FieldTag::__tag_value_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_value_ids",
                                ));
                            }
                            result.tag_value_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Tag>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__effective_tags => {
                            if !fields.insert(__FieldTag::__effective_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effective_tags",
                                ));
                            }
                            result.effective_tags = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EffectiveTagDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enrichments => {
                            if !fields.insert(__FieldTag::__enrichments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enrichments",
                                ));
                            }
                            result.enrichments =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AssetEnrichment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_asset_type => {
                            if !fields.insert(__FieldTag::__parent_asset_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_asset_type",
                                ));
                            }
                            result.parent_asset_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scc_security_marks => {
                            if !fields.insert(__FieldTag::__scc_security_marks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scc_security_marks",
                                ));
                            }
                            result.scc_security_marks = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceSearchResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.asset_type.is_empty() {
            state.serialize_entry("assetType", &self.asset_type)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.folders.is_empty() {
            state.serialize_entry("folders", &self.folders)?;
        }
        if !self.organization.is_empty() {
            state.serialize_entry("organization", &self.organization)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.network_tags.is_empty() {
            state.serialize_entry("networkTags", &self.network_tags)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !self.kms_keys.is_empty() {
            state.serialize_entry("kmsKeys", &self.kms_keys)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.state.is_empty() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.additional_attributes.is_some() {
            state.serialize_entry("additionalAttributes", &self.additional_attributes)?;
        }
        if !self.parent_full_resource_name.is_empty() {
            state.serialize_entry("parentFullResourceName", &self.parent_full_resource_name)?;
        }
        if !self.versioned_resources.is_empty() {
            state.serialize_entry("versionedResources", &self.versioned_resources)?;
        }
        if !self.attached_resources.is_empty() {
            state.serialize_entry("attachedResources", &self.attached_resources)?;
        }
        if !self.relationships.is_empty() {
            state.serialize_entry("relationships", &self.relationships)?;
        }
        if !self.tag_keys.is_empty() {
            state.serialize_entry("tagKeys", &self.tag_keys)?;
        }
        if !self.tag_values.is_empty() {
            state.serialize_entry("tagValues", &self.tag_values)?;
        }
        if !self.tag_value_ids.is_empty() {
            state.serialize_entry("tagValueIds", &self.tag_value_ids)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.effective_tags.is_empty() {
            state.serialize_entry("effectiveTags", &self.effective_tags)?;
        }
        if !self.enrichments.is_empty() {
            state.serialize_entry("enrichments", &self.enrichments)?;
        }
        if !self.parent_asset_type.is_empty() {
            state.serialize_entry("parentAssetType", &self.parent_asset_type)?;
        }
        if !self.scc_security_marks.is_empty() {
            state.serialize_entry("sccSecurityMarks", &self.scc_security_marks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResourceSearchResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceSearchResult");
        debug_struct.field("name", &self.name);
        debug_struct.field("asset_type", &self.asset_type);
        debug_struct.field("project", &self.project);
        debug_struct.field("folders", &self.folders);
        debug_struct.field("organization", &self.organization);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("location", &self.location);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("network_tags", &self.network_tags);
        debug_struct.field("kms_key", &self.kms_key);
        debug_struct.field("kms_keys", &self.kms_keys);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("additional_attributes", &self.additional_attributes);
        debug_struct.field("parent_full_resource_name", &self.parent_full_resource_name);
        debug_struct.field("versioned_resources", &self.versioned_resources);
        debug_struct.field("attached_resources", &self.attached_resources);
        debug_struct.field("relationships", &self.relationships);
        debug_struct.field("tag_keys", &self.tag_keys);
        debug_struct.field("tag_values", &self.tag_values);
        debug_struct.field("tag_value_ids", &self.tag_value_ids);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("effective_tags", &self.effective_tags);
        debug_struct.field("enrichments", &self.enrichments);
        debug_struct.field("parent_asset_type", &self.parent_asset_type);
        debug_struct.field("scc_security_marks", &self.scc_security_marks);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Resource representation as defined by the corresponding service providing the
/// resource for a given API version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VersionedResource {
    /// API version of the resource.
    ///
    /// Example:
    /// If the resource is an instance provided by Compute Engine v1 API as defined
    /// in `<https://cloud.google.com/compute/docs/reference/rest/v1/instances>`,
    /// version will be "v1".
    pub version: std::string::String,

    /// JSON representation of the resource as defined by the corresponding
    /// service providing this resource.
    ///
    /// Example:
    /// If the resource is an instance provided by Compute Engine, this field will
    /// contain the JSON representation of the instance as defined by Compute
    /// Engine:
    /// `<https://cloud.google.com/compute/docs/reference/rest/v1/instances>`.
    ///
    /// You can find the resource definition for each supported resource type in
    /// this table:
    /// `<https://cloud.google.com/asset-inventory/docs/supported-asset-types>`
    pub resource: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VersionedResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::VersionedResource::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::VersionedResource::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::VersionedResource::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.resource = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VersionedResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.VersionedResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VersionedResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VersionedResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VersionedResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VersionedResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VersionedResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VersionedResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VersionedResource");
        debug_struct.field("version", &self.version);
        debug_struct.field("resource", &self.resource);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Attached resource representation, which is defined by the corresponding
/// service provider. It represents an attached resource's payload.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedResource {
    /// The type of this attached resource.
    ///
    /// Example: `osconfig.googleapis.com/Inventory`
    ///
    /// You can find the supported attached asset types of each resource in this
    /// table:
    /// `<https://cloud.google.com/asset-inventory/docs/supported-asset-types>`
    pub asset_type: std::string::String,

    /// Versioned resource representations of this attached resource. This is
    /// repeated because there could be multiple versions of the attached resource
    /// representations during version migration.
    pub versioned_resources: std::vec::Vec<crate::model::VersionedResource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachedResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [asset_type][crate::model::AttachedResource::asset_type].
    pub fn set_asset_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_type = v.into();
        self
    }

    /// Sets the value of [versioned_resources][crate::model::AttachedResource::versioned_resources].
    pub fn set_versioned_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VersionedResource>,
    {
        use std::iter::Iterator;
        self.versioned_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AttachedResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.AttachedResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttachedResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __asset_type,
            __versioned_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttachedResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "assetType" => Ok(__FieldTag::__asset_type),
                            "asset_type" => Ok(__FieldTag::__asset_type),
                            "versionedResources" => Ok(__FieldTag::__versioned_resources),
                            "versioned_resources" => Ok(__FieldTag::__versioned_resources),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttachedResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttachedResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__asset_type => {
                            if !fields.insert(__FieldTag::__asset_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_type",
                                ));
                            }
                            result.asset_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__versioned_resources => {
                            if !fields.insert(__FieldTag::__versioned_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versioned_resources",
                                ));
                            }
                            result.versioned_resources =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VersionedResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttachedResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.asset_type.is_empty() {
            state.serialize_entry("assetType", &self.asset_type)?;
        }
        if !self.versioned_resources.is_empty() {
            state.serialize_entry("versionedResources", &self.versioned_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AttachedResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AttachedResource");
        debug_struct.field("asset_type", &self.asset_type);
        debug_struct.field("versioned_resources", &self.versioned_resources);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The related resources of the primary resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RelatedResources {
    /// The detailed related resources of the primary resource.
    pub related_resources: std::vec::Vec<crate::model::RelatedResource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [related_resources][crate::model::RelatedResources::related_resources].
    pub fn set_related_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedResource>,
    {
        use std::iter::Iterator;
        self.related_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RelatedResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.RelatedResources"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RelatedResources {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __related_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RelatedResources")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "relatedResources" => Ok(__FieldTag::__related_resources),
                            "related_resources" => Ok(__FieldTag::__related_resources),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RelatedResources;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RelatedResources")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__related_resources => {
                            if !fields.insert(__FieldTag::__related_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_resources",
                                ));
                            }
                            result.related_resources =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RelatedResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RelatedResources {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.related_resources.is_empty() {
            state.serialize_entry("relatedResources", &self.related_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RelatedResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RelatedResources");
        debug_struct.field("related_resources", &self.related_resources);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The detailed related resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RelatedResource {
    /// The type of the asset. Example: `compute.googleapis.com/Instance`
    pub asset_type: std::string::String,

    /// The full resource name of the related resource. Example:
    /// `//compute.googleapis.com/projects/my_proj_123/zones/instance/instance123`
    pub full_resource_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [asset_type][crate::model::RelatedResource::asset_type].
    pub fn set_asset_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_type = v.into();
        self
    }

    /// Sets the value of [full_resource_name][crate::model::RelatedResource::full_resource_name].
    pub fn set_full_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.full_resource_name = v.into();
        self
    }
}

impl wkt::message::Message for RelatedResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.RelatedResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RelatedResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __asset_type,
            __full_resource_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RelatedResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "assetType" => Ok(__FieldTag::__asset_type),
                            "asset_type" => Ok(__FieldTag::__asset_type),
                            "fullResourceName" => Ok(__FieldTag::__full_resource_name),
                            "full_resource_name" => Ok(__FieldTag::__full_resource_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RelatedResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RelatedResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__asset_type => {
                            if !fields.insert(__FieldTag::__asset_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_type",
                                ));
                            }
                            result.asset_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__full_resource_name => {
                            if !fields.insert(__FieldTag::__full_resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_resource_name",
                                ));
                            }
                            result.full_resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RelatedResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.asset_type.is_empty() {
            state.serialize_entry("assetType", &self.asset_type)?;
        }
        if !self.full_resource_name.is_empty() {
            state.serialize_entry("fullResourceName", &self.full_resource_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RelatedResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RelatedResource");
        debug_struct.field("asset_type", &self.asset_type);
        debug_struct.field("full_resource_name", &self.full_resource_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A result of IAM Policy search, containing information of an IAM policy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IamPolicySearchResult {
    /// The full resource name of the resource associated with this IAM policy.
    /// Example:
    /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
    /// See [Cloud Asset Inventory Resource Name
    /// Format](https://cloud.google.com/asset-inventory/docs/resource-name-format)
    /// for more information.
    ///
    /// To search against the `resource`:
    ///
    /// * use a field query. Example: `resource:organizations/123`
    pub resource: std::string::String,

    /// The type of the resource associated with this IAM policy. Example:
    /// `compute.googleapis.com/Disk`.
    ///
    /// To search against the `asset_type`:
    ///
    /// * specify the `asset_types` field in your search request.
    pub asset_type: std::string::String,

    /// The project that the associated Google Cloud resource belongs to, in the
    /// form of projects/{PROJECT_NUMBER}. If an IAM policy is set on a resource
    /// (like VM instance, Cloud Storage bucket), the project field will indicate
    /// the project that contains the resource. If an IAM policy is set on a folder
    /// or organization, this field will be empty.
    ///
    /// To search against the `project`:
    ///
    /// * specify the `scope` field as this project in your search request.
    pub project: std::string::String,

    /// The folder(s) that the IAM policy belongs to, in the form of
    /// folders/{FOLDER_NUMBER}. This field is available when the IAM policy
    /// belongs to one or more folders.
    ///
    /// To search against `folders`:
    ///
    /// * use a field query. Example: `folders:(123 OR 456)`
    /// * use a free text query. Example: `123`
    /// * specify the `scope` field as this folder in your search request.
    pub folders: std::vec::Vec<std::string::String>,

    /// The organization that the IAM policy belongs to, in the form
    /// of organizations/{ORGANIZATION_NUMBER}. This field is available when the
    /// IAM policy belongs to an organization.
    ///
    /// To search against `organization`:
    ///
    /// * use a field query. Example: `organization:123`
    /// * use a free text query. Example: `123`
    /// * specify the `scope` field as this organization in your search request.
    pub organization: std::string::String,

    /// The IAM policy directly set on the given resource. Note that the original
    /// IAM policy can contain multiple bindings. This only contains the bindings
    /// that match the given query. For queries that don't contain a constrain on
    /// policies (e.g., an empty query), this contains all the bindings.
    ///
    /// To search against the `policy` bindings:
    ///
    /// * use a field query:
    ///   - query by the policy contained members. Example:
    ///     `policy:amy@gmail.com`
    ///   - query by the policy contained roles. Example:
    ///     `policy:roles/compute.admin`
    ///   - query by the policy contained roles' included permissions. Example:
    ///     `policy.role.permissions:compute.instances.create`
    pub policy: std::option::Option<iam_v1::model::Policy>,

    /// Explanation about the IAM policy search result. It contains additional
    /// information to explain why the search result matches the query.
    pub explanation: std::option::Option<crate::model::iam_policy_search_result::Explanation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IamPolicySearchResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource][crate::model::IamPolicySearchResult::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [asset_type][crate::model::IamPolicySearchResult::asset_type].
    pub fn set_asset_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_type = v.into();
        self
    }

    /// Sets the value of [project][crate::model::IamPolicySearchResult::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [folders][crate::model::IamPolicySearchResult::folders].
    pub fn set_folders<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.folders = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [organization][crate::model::IamPolicySearchResult::organization].
    pub fn set_organization<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.organization = v.into();
        self
    }

    /// Sets the value of [policy][crate::model::IamPolicySearchResult::policy].
    pub fn set_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<iam_v1::model::Policy>,
    {
        self.policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy][crate::model::IamPolicySearchResult::policy].
    pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<iam_v1::model::Policy>,
    {
        self.policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [explanation][crate::model::IamPolicySearchResult::explanation].
    pub fn set_explanation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_search_result::Explanation>,
    {
        self.explanation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [explanation][crate::model::IamPolicySearchResult::explanation].
    pub fn set_or_clear_explanation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_search_result::Explanation>,
    {
        self.explanation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IamPolicySearchResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.IamPolicySearchResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IamPolicySearchResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource,
            __asset_type,
            __project,
            __folders,
            __organization,
            __policy,
            __explanation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IamPolicySearchResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resource" => Ok(__FieldTag::__resource),
                            "assetType" => Ok(__FieldTag::__asset_type),
                            "asset_type" => Ok(__FieldTag::__asset_type),
                            "project" => Ok(__FieldTag::__project),
                            "folders" => Ok(__FieldTag::__folders),
                            "organization" => Ok(__FieldTag::__organization),
                            "policy" => Ok(__FieldTag::__policy),
                            "explanation" => Ok(__FieldTag::__explanation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IamPolicySearchResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IamPolicySearchResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset_type => {
                            if !fields.insert(__FieldTag::__asset_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_type",
                                ));
                            }
                            result.asset_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__folders => {
                            if !fields.insert(__FieldTag::__folders) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for folders",
                                ));
                            }
                            result.folders = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__organization => {
                            if !fields.insert(__FieldTag::__organization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organization",
                                ));
                            }
                            result.organization = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy =
                                map.next_value::<std::option::Option<iam_v1::model::Policy>>()?;
                        }
                        __FieldTag::__explanation => {
                            if !fields.insert(__FieldTag::__explanation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explanation",
                                ));
                            }
                            result.explanation = map.next_value::<std::option::Option<
                                crate::model::iam_policy_search_result::Explanation,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IamPolicySearchResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self.asset_type.is_empty() {
            state.serialize_entry("assetType", &self.asset_type)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.folders.is_empty() {
            state.serialize_entry("folders", &self.folders)?;
        }
        if !self.organization.is_empty() {
            state.serialize_entry("organization", &self.organization)?;
        }
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if self.explanation.is_some() {
            state.serialize_entry("explanation", &self.explanation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IamPolicySearchResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IamPolicySearchResult");
        debug_struct.field("resource", &self.resource);
        debug_struct.field("asset_type", &self.asset_type);
        debug_struct.field("project", &self.project);
        debug_struct.field("folders", &self.folders);
        debug_struct.field("organization", &self.organization);
        debug_struct.field("policy", &self.policy);
        debug_struct.field("explanation", &self.explanation);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [IamPolicySearchResult].
pub mod iam_policy_search_result {
    #[allow(unused_imports)]
    use super::*;

    /// Explanation about the IAM policy search result.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Explanation {
        /// The map from roles to their included permissions that match the
        /// permission query (i.e., a query containing `policy.role.permissions:`).
        /// Example: if query `policy.role.permissions:compute.disk.get`
        /// matches a policy binding that contains owner role, the
        /// matched_permissions will be `{"roles/owner": ["compute.disk.get"]}`. The
        /// roles can also be found in the returned `policy` bindings. Note that the
        /// map is populated only for requests with permission queries.
        pub matched_permissions: std::collections::HashMap<
            std::string::String,
            crate::model::iam_policy_search_result::explanation::Permissions,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Explanation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [matched_permissions][crate::model::iam_policy_search_result::Explanation::matched_permissions].
        pub fn set_matched_permissions<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::iam_policy_search_result::explanation::Permissions>,
        {
            use std::iter::Iterator;
            self.matched_permissions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for Explanation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicySearchResult.Explanation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Explanation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __matched_permissions,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Explanation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "matchedPermissions" => Ok(__FieldTag::__matched_permissions),
                                "matched_permissions" => Ok(__FieldTag::__matched_permissions),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Explanation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Explanation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__matched_permissions => {
                                if !fields.insert(__FieldTag::__matched_permissions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for matched_permissions",
                                    ));
                                }
                                result.matched_permissions = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::iam_policy_search_result::explanation::Permissions>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Explanation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.matched_permissions.is_empty() {
                state.serialize_entry("matchedPermissions", &self.matched_permissions)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Explanation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Explanation");
            debug_struct.field("matched_permissions", &self.matched_permissions);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Explanation].
    pub mod explanation {
        #[allow(unused_imports)]
        use super::*;

        /// IAM permissions
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Permissions {
            /// A list of permissions. A sample permission string: `compute.disk.get`.
            pub permissions: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Permissions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [permissions][crate::model::iam_policy_search_result::explanation::Permissions::permissions].
            pub fn set_permissions<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.permissions = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for Permissions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.asset.v1.IamPolicySearchResult.Explanation.Permissions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Permissions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __permissions,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Permissions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "permissions" => Ok(__FieldTag::__permissions),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Permissions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Permissions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__permissions => {
                                    if !fields.insert(__FieldTag::__permissions) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for permissions",
                                            ),
                                        );
                                    }
                                    result.permissions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Permissions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.permissions.is_empty() {
                    state.serialize_entry("permissions", &self.permissions)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Permissions {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Permissions");
                debug_struct.field("permissions", &self.permissions);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }
}

/// Represents the detailed state of an entity under analysis, such as a
/// resource, an identity or an access.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IamPolicyAnalysisState {
    /// The Google standard error code that best describes the state.
    /// For example:
    ///
    /// - OK means the analysis on this entity has been successfully finished;
    /// - PERMISSION_DENIED means an access denied error is encountered;
    /// - DEADLINE_EXCEEDED means the analysis on this entity hasn't been started
    ///   in time;
    pub code: rpc::model::Code,

    /// The human-readable description of the cause of failure.
    pub cause: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IamPolicyAnalysisState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::IamPolicyAnalysisState::code].
    pub fn set_code<T: std::convert::Into<rpc::model::Code>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [cause][crate::model::IamPolicyAnalysisState::cause].
    pub fn set_cause<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cause = v.into();
        self
    }
}

impl wkt::message::Message for IamPolicyAnalysisState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisState"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IamPolicyAnalysisState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __cause,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IamPolicyAnalysisState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "cause" => Ok(__FieldTag::__cause),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IamPolicyAnalysisState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IamPolicyAnalysisState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<rpc::model::Code>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cause => {
                            if !fields.insert(__FieldTag::__cause) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cause",
                                ));
                            }
                            result.cause = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IamPolicyAnalysisState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.cause.is_empty() {
            state.serialize_entry("cause", &self.cause)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IamPolicyAnalysisState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IamPolicyAnalysisState");
        debug_struct.field("code", &self.code);
        debug_struct.field("cause", &self.cause);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The condition evaluation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConditionEvaluation {
    /// The evaluation result.
    pub evaluation_value: crate::model::condition_evaluation::EvaluationValue,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConditionEvaluation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [evaluation_value][crate::model::ConditionEvaluation::evaluation_value].
    pub fn set_evaluation_value<
        T: std::convert::Into<crate::model::condition_evaluation::EvaluationValue>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_value = v.into();
        self
    }
}

impl wkt::message::Message for ConditionEvaluation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.ConditionEvaluation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConditionEvaluation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __evaluation_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConditionEvaluation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "evaluationValue" => Ok(__FieldTag::__evaluation_value),
                            "evaluation_value" => Ok(__FieldTag::__evaluation_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConditionEvaluation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConditionEvaluation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__evaluation_value => {
                            if !fields.insert(__FieldTag::__evaluation_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluation_value",
                                ));
                            }
                            result.evaluation_value = map
                                .next_value::<std::option::Option<
                                    crate::model::condition_evaluation::EvaluationValue,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConditionEvaluation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.evaluation_value) {
            state.serialize_entry("evaluationValue", &self.evaluation_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConditionEvaluation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConditionEvaluation");
        debug_struct.field("evaluation_value", &self.evaluation_value);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConditionEvaluation].
pub mod condition_evaluation {
    #[allow(unused_imports)]
    use super::*;

    /// Value of this expression.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EvaluationValue {
        /// Reserved for future use.
        Unspecified,
        /// The evaluation result is `true`.
        True,
        /// The evaluation result is `false`.
        False,
        /// The evaluation result is `conditional` when the condition expression
        /// contains variables that are either missing input values or have not been
        /// supported by Policy Analyzer yet.
        Conditional,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EvaluationValue::value] or
        /// [EvaluationValue::name].
        UnknownValue(evaluation_value::UnknownValue),
    }

    #[doc(hidden)]
    pub mod evaluation_value {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EvaluationValue {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::True => std::option::Option::Some(1),
                Self::False => std::option::Option::Some(2),
                Self::Conditional => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVALUATION_VALUE_UNSPECIFIED"),
                Self::True => std::option::Option::Some("TRUE"),
                Self::False => std::option::Option::Some("FALSE"),
                Self::Conditional => std::option::Option::Some("CONDITIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EvaluationValue {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EvaluationValue {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EvaluationValue {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::True,
                2 => Self::False,
                3 => Self::Conditional,
                _ => Self::UnknownValue(evaluation_value::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EvaluationValue {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVALUATION_VALUE_UNSPECIFIED" => Self::Unspecified,
                "TRUE" => Self::True,
                "FALSE" => Self::False,
                "CONDITIONAL" => Self::Conditional,
                _ => Self::UnknownValue(evaluation_value::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EvaluationValue {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::True => serializer.serialize_i32(1),
                Self::False => serializer.serialize_i32(2),
                Self::Conditional => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EvaluationValue {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EvaluationValue>::new(
                ".google.cloud.asset.v1.ConditionEvaluation.EvaluationValue",
            ))
        }
    }
}

/// IAM Policy analysis result, consisting of one IAM policy binding and derived
/// access control lists.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IamPolicyAnalysisResult {
    /// The [full resource
    /// name](https://cloud.google.com/asset-inventory/docs/resource-name-format)
    /// of the resource to which the
    /// [iam_binding][google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding]
    /// policy attaches.
    ///
    /// [google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding]: crate::model::IamPolicyAnalysisResult::iam_binding
    pub attached_resource_full_name: std::string::String,

    /// The IAM policy binding under analysis.
    pub iam_binding: std::option::Option<iam_v1::model::Binding>,

    /// The access control lists derived from the
    /// [iam_binding][google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding]
    /// that match or potentially match resource and access selectors specified in
    /// the request.
    ///
    /// [google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding]: crate::model::IamPolicyAnalysisResult::iam_binding
    pub access_control_lists:
        std::vec::Vec<crate::model::iam_policy_analysis_result::AccessControlList>,

    /// The identity list derived from members of the
    /// [iam_binding][google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding]
    /// that match or potentially match identity selector specified in the request.
    ///
    /// [google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding]: crate::model::IamPolicyAnalysisResult::iam_binding
    pub identity_list: std::option::Option<crate::model::iam_policy_analysis_result::IdentityList>,

    /// Represents whether all analyses on the
    /// [iam_binding][google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding]
    /// have successfully finished.
    ///
    /// [google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding]: crate::model::IamPolicyAnalysisResult::iam_binding
    pub fully_explored: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IamPolicyAnalysisResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attached_resource_full_name][crate::model::IamPolicyAnalysisResult::attached_resource_full_name].
    pub fn set_attached_resource_full_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attached_resource_full_name = v.into();
        self
    }

    /// Sets the value of [iam_binding][crate::model::IamPolicyAnalysisResult::iam_binding].
    pub fn set_iam_binding<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<iam_v1::model::Binding>,
    {
        self.iam_binding = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [iam_binding][crate::model::IamPolicyAnalysisResult::iam_binding].
    pub fn set_or_clear_iam_binding<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<iam_v1::model::Binding>,
    {
        self.iam_binding = v.map(|x| x.into());
        self
    }

    /// Sets the value of [access_control_lists][crate::model::IamPolicyAnalysisResult::access_control_lists].
    pub fn set_access_control_lists<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::iam_policy_analysis_result::AccessControlList>,
    {
        use std::iter::Iterator;
        self.access_control_lists = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [identity_list][crate::model::IamPolicyAnalysisResult::identity_list].
    pub fn set_identity_list<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_analysis_result::IdentityList>,
    {
        self.identity_list = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [identity_list][crate::model::IamPolicyAnalysisResult::identity_list].
    pub fn set_or_clear_identity_list<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::iam_policy_analysis_result::IdentityList>,
    {
        self.identity_list = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fully_explored][crate::model::IamPolicyAnalysisResult::fully_explored].
    pub fn set_fully_explored<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.fully_explored = v.into();
        self
    }
}

impl wkt::message::Message for IamPolicyAnalysisResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IamPolicyAnalysisResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attached_resource_full_name,
            __iam_binding,
            __access_control_lists,
            __identity_list,
            __fully_explored,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IamPolicyAnalysisResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attachedResourceFullName" => {
                                Ok(__FieldTag::__attached_resource_full_name)
                            }
                            "attached_resource_full_name" => {
                                Ok(__FieldTag::__attached_resource_full_name)
                            }
                            "iamBinding" => Ok(__FieldTag::__iam_binding),
                            "iam_binding" => Ok(__FieldTag::__iam_binding),
                            "accessControlLists" => Ok(__FieldTag::__access_control_lists),
                            "access_control_lists" => Ok(__FieldTag::__access_control_lists),
                            "identityList" => Ok(__FieldTag::__identity_list),
                            "identity_list" => Ok(__FieldTag::__identity_list),
                            "fullyExplored" => Ok(__FieldTag::__fully_explored),
                            "fully_explored" => Ok(__FieldTag::__fully_explored),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IamPolicyAnalysisResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IamPolicyAnalysisResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attached_resource_full_name => {
                            if !fields.insert(__FieldTag::__attached_resource_full_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attached_resource_full_name",
                                ));
                            }
                            result.attached_resource_full_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__iam_binding => {
                            if !fields.insert(__FieldTag::__iam_binding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iam_binding",
                                ));
                            }
                            result.iam_binding =
                                map.next_value::<std::option::Option<iam_v1::model::Binding>>()?;
                        }
                        __FieldTag::__access_control_lists => {
                            if !fields.insert(__FieldTag::__access_control_lists) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_control_lists",
                                ));
                            }
                            result.access_control_lists = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::iam_policy_analysis_result::AccessControlList,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__identity_list => {
                            if !fields.insert(__FieldTag::__identity_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity_list",
                                ));
                            }
                            result.identity_list = map.next_value::<std::option::Option<
                                crate::model::iam_policy_analysis_result::IdentityList,
                            >>()?;
                        }
                        __FieldTag::__fully_explored => {
                            if !fields.insert(__FieldTag::__fully_explored) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fully_explored",
                                ));
                            }
                            result.fully_explored = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IamPolicyAnalysisResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attached_resource_full_name.is_empty() {
            state.serialize_entry(
                "attachedResourceFullName",
                &self.attached_resource_full_name,
            )?;
        }
        if self.iam_binding.is_some() {
            state.serialize_entry("iamBinding", &self.iam_binding)?;
        }
        if !self.access_control_lists.is_empty() {
            state.serialize_entry("accessControlLists", &self.access_control_lists)?;
        }
        if self.identity_list.is_some() {
            state.serialize_entry("identityList", &self.identity_list)?;
        }
        if !wkt::internal::is_default(&self.fully_explored) {
            state.serialize_entry("fullyExplored", &self.fully_explored)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IamPolicyAnalysisResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IamPolicyAnalysisResult");
        debug_struct.field(
            "attached_resource_full_name",
            &self.attached_resource_full_name,
        );
        debug_struct.field("iam_binding", &self.iam_binding);
        debug_struct.field("access_control_lists", &self.access_control_lists);
        debug_struct.field("identity_list", &self.identity_list);
        debug_struct.field("fully_explored", &self.fully_explored);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [IamPolicyAnalysisResult].
pub mod iam_policy_analysis_result {
    #[allow(unused_imports)]
    use super::*;

    /// A Google Cloud resource under analysis.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Resource {
        /// The [full resource
        /// name](https://cloud.google.com/asset-inventory/docs/resource-name-format)
        pub full_resource_name: std::string::String,

        /// The analysis state of this resource.
        pub analysis_state: std::option::Option<crate::model::IamPolicyAnalysisState>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Resource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [full_resource_name][crate::model::iam_policy_analysis_result::Resource::full_resource_name].
        pub fn set_full_resource_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.full_resource_name = v.into();
            self
        }

        /// Sets the value of [analysis_state][crate::model::iam_policy_analysis_result::Resource::analysis_state].
        pub fn set_analysis_state<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::IamPolicyAnalysisState>,
        {
            self.analysis_state = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [analysis_state][crate::model::iam_policy_analysis_result::Resource::analysis_state].
        pub fn set_or_clear_analysis_state<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::IamPolicyAnalysisState>,
        {
            self.analysis_state = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Resource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisResult.Resource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Resource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __full_resource_name,
                __analysis_state,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Resource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "fullResourceName" => Ok(__FieldTag::__full_resource_name),
                                "full_resource_name" => Ok(__FieldTag::__full_resource_name),
                                "analysisState" => Ok(__FieldTag::__analysis_state),
                                "analysis_state" => Ok(__FieldTag::__analysis_state),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Resource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Resource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__full_resource_name => {
                                if !fields.insert(__FieldTag::__full_resource_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for full_resource_name",
                                    ));
                                }
                                result.full_resource_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__analysis_state => {
                                if !fields.insert(__FieldTag::__analysis_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for analysis_state",
                                    ));
                                }
                                result.analysis_state = map.next_value::<std::option::Option<crate::model::IamPolicyAnalysisState>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Resource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.full_resource_name.is_empty() {
                state.serialize_entry("fullResourceName", &self.full_resource_name)?;
            }
            if self.analysis_state.is_some() {
                state.serialize_entry("analysisState", &self.analysis_state)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Resource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Resource");
            debug_struct.field("full_resource_name", &self.full_resource_name);
            debug_struct.field("analysis_state", &self.analysis_state);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// An IAM role or permission under analysis.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Access {
        /// The analysis state of this access.
        pub analysis_state: std::option::Option<crate::model::IamPolicyAnalysisState>,

        pub oneof_access:
            std::option::Option<crate::model::iam_policy_analysis_result::access::OneofAccess>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Access {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [analysis_state][crate::model::iam_policy_analysis_result::Access::analysis_state].
        pub fn set_analysis_state<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::IamPolicyAnalysisState>,
        {
            self.analysis_state = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [analysis_state][crate::model::iam_policy_analysis_result::Access::analysis_state].
        pub fn set_or_clear_analysis_state<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::IamPolicyAnalysisState>,
        {
            self.analysis_state = v.map(|x| x.into());
            self
        }

        /// Sets the value of [oneof_access][crate::model::iam_policy_analysis_result::Access::oneof_access].
        ///
        /// Note that all the setters affecting `oneof_access` are mutually
        /// exclusive.
        pub fn set_oneof_access<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::iam_policy_analysis_result::access::OneofAccess,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.oneof_access = v.into();
            self
        }

        /// The value of [oneof_access][crate::model::iam_policy_analysis_result::Access::oneof_access]
        /// if it holds a `Role`, `None` if the field is not set or
        /// holds a different branch.
        pub fn role(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.oneof_access.as_ref().and_then(|v| match v {
                crate::model::iam_policy_analysis_result::access::OneofAccess::Role(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [oneof_access][crate::model::iam_policy_analysis_result::Access::oneof_access]
        /// to hold a `Role`.
        ///
        /// Note that all the setters affecting `oneof_access` are
        /// mutually exclusive.
        pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.oneof_access = std::option::Option::Some(
                crate::model::iam_policy_analysis_result::access::OneofAccess::Role(v.into()),
            );
            self
        }

        /// The value of [oneof_access][crate::model::iam_policy_analysis_result::Access::oneof_access]
        /// if it holds a `Permission`, `None` if the field is not set or
        /// holds a different branch.
        pub fn permission(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.oneof_access.as_ref().and_then(|v| match v {
                crate::model::iam_policy_analysis_result::access::OneofAccess::Permission(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [oneof_access][crate::model::iam_policy_analysis_result::Access::oneof_access]
        /// to hold a `Permission`.
        ///
        /// Note that all the setters affecting `oneof_access` are
        /// mutually exclusive.
        pub fn set_permission<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.oneof_access = std::option::Option::Some(
                crate::model::iam_policy_analysis_result::access::OneofAccess::Permission(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Access {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisResult.Access"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Access {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __role,
                __permission,
                __analysis_state,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Access")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "role" => Ok(__FieldTag::__role),
                                "permission" => Ok(__FieldTag::__permission),
                                "analysisState" => Ok(__FieldTag::__analysis_state),
                                "analysis_state" => Ok(__FieldTag::__analysis_state),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Access;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Access")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__role => {
                                if !fields.insert(__FieldTag::__role) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for role",
                                    ));
                                }
                                if result.oneof_access.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `oneof_access`, a oneof with full ID .google.cloud.asset.v1.IamPolicyAnalysisResult.Access.role, latest field was role",
                                    ));
                                }
                                result.oneof_access = std::option::Option::Some(
                                    crate::model::iam_policy_analysis_result::access::OneofAccess::Role(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__permission => {
                                if !fields.insert(__FieldTag::__permission) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for permission",
                                    ));
                                }
                                if result.oneof_access.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `oneof_access`, a oneof with full ID .google.cloud.asset.v1.IamPolicyAnalysisResult.Access.permission, latest field was permission",
                                    ));
                                }
                                result.oneof_access = std::option::Option::Some(
                                    crate::model::iam_policy_analysis_result::access::OneofAccess::Permission(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__analysis_state => {
                                if !fields.insert(__FieldTag::__analysis_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for analysis_state",
                                    ));
                                }
                                result.analysis_state = map.next_value::<std::option::Option<crate::model::IamPolicyAnalysisState>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Access {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.role() {
                state.serialize_entry("role", value)?;
            }
            if let Some(value) = self.permission() {
                state.serialize_entry("permission", value)?;
            }
            if self.analysis_state.is_some() {
                state.serialize_entry("analysisState", &self.analysis_state)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Access {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Access");
            debug_struct.field("analysis_state", &self.analysis_state);
            debug_struct.field("oneof_access", &self.oneof_access);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Access].
    pub mod access {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum OneofAccess {
            /// The role.
            Role(std::string::String),
            /// The permission.
            Permission(std::string::String),
        }
    }

    /// An identity under analysis.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Identity {
        /// The identity of members, formatted as appear in an
        /// [IAM policy
        /// binding](https://cloud.google.com/iam/reference/rest/v1/Binding). For
        /// example, they might be formatted like the following:
        ///
        /// - user:foo@google.com
        /// - group:group1@google.com
        /// - serviceAccount:s1@prj1.iam.gserviceaccount.com
        /// - projectOwner:some_project_id
        /// - domain:google.com
        /// - allUsers
        pub name: std::string::String,

        /// The analysis state of this identity.
        pub analysis_state: std::option::Option<crate::model::IamPolicyAnalysisState>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Identity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::iam_policy_analysis_result::Identity::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [analysis_state][crate::model::iam_policy_analysis_result::Identity::analysis_state].
        pub fn set_analysis_state<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::IamPolicyAnalysisState>,
        {
            self.analysis_state = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [analysis_state][crate::model::iam_policy_analysis_result::Identity::analysis_state].
        pub fn set_or_clear_analysis_state<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::IamPolicyAnalysisState>,
        {
            self.analysis_state = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Identity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisResult.Identity"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Identity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __analysis_state,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Identity")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "analysisState" => Ok(__FieldTag::__analysis_state),
                                "analysis_state" => Ok(__FieldTag::__analysis_state),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Identity;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Identity")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__analysis_state => {
                                if !fields.insert(__FieldTag::__analysis_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for analysis_state",
                                    ));
                                }
                                result.analysis_state = map.next_value::<std::option::Option<crate::model::IamPolicyAnalysisState>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Identity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if self.analysis_state.is_some() {
                state.serialize_entry("analysisState", &self.analysis_state)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Identity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Identity");
            debug_struct.field("name", &self.name);
            debug_struct.field("analysis_state", &self.analysis_state);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A directional edge.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Edge {
        /// The source node of the edge. For example, it could be a full resource
        /// name for a resource node or an email of an identity.
        pub source_node: std::string::String,

        /// The target node of the edge. For example, it could be a full resource
        /// name for a resource node or an email of an identity.
        pub target_node: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Edge {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_node][crate::model::iam_policy_analysis_result::Edge::source_node].
        pub fn set_source_node<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source_node = v.into();
            self
        }

        /// Sets the value of [target_node][crate::model::iam_policy_analysis_result::Edge::target_node].
        pub fn set_target_node<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.target_node = v.into();
            self
        }
    }

    impl wkt::message::Message for Edge {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisResult.Edge"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Edge {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source_node,
                __target_node,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Edge")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sourceNode" => Ok(__FieldTag::__source_node),
                                "source_node" => Ok(__FieldTag::__source_node),
                                "targetNode" => Ok(__FieldTag::__target_node),
                                "target_node" => Ok(__FieldTag::__target_node),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Edge;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Edge")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source_node => {
                                if !fields.insert(__FieldTag::__source_node) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_node",
                                    ));
                                }
                                result.source_node = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__target_node => {
                                if !fields.insert(__FieldTag::__target_node) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for target_node",
                                    ));
                                }
                                result.target_node = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Edge {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.source_node.is_empty() {
                state.serialize_entry("sourceNode", &self.source_node)?;
            }
            if !self.target_node.is_empty() {
                state.serialize_entry("targetNode", &self.target_node)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Edge {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Edge");
            debug_struct.field("source_node", &self.source_node);
            debug_struct.field("target_node", &self.target_node);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// An access control list, derived from the above IAM policy binding, which
    /// contains a set of resources and accesses. May include one
    /// item from each set to compose an access control entry.
    ///
    /// NOTICE that there could be multiple access control lists for one IAM policy
    /// binding. The access control lists are created based on resource and access
    /// combinations.
    ///
    /// For example, assume we have the following cases in one IAM policy binding:
    ///
    /// - Permission P1 and P2 apply to resource R1 and R2;
    /// - Permission P3 applies to resource R2 and R3;
    ///
    /// This will result in the following access control lists:
    ///
    /// - AccessControlList 1: [R1, R2], [P1, P2]
    /// - AccessControlList 2: [R2, R3], [P3]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AccessControlList {
        /// The resources that match one of the following conditions:
        ///
        /// - The resource_selector, if it is specified in request;
        /// - Otherwise, resources reachable from the policy attached resource.
        pub resources: std::vec::Vec<crate::model::iam_policy_analysis_result::Resource>,

        /// The accesses that match one of the following conditions:
        ///
        /// - The access_selector, if it is specified in request;
        /// - Otherwise, access specifiers reachable from the policy binding's role.
        pub accesses: std::vec::Vec<crate::model::iam_policy_analysis_result::Access>,

        /// Resource edges of the graph starting from the policy attached
        /// resource to any descendant resources. The
        /// [Edge.source_node][google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.source_node]
        /// contains the full resource name of a parent resource and
        /// [Edge.target_node][google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.target_node]
        /// contains the full resource name of a child resource. This field is
        /// present only if the output_resource_edges option is enabled in request.
        ///
        /// [google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.source_node]: crate::model::iam_policy_analysis_result::Edge::source_node
        /// [google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.target_node]: crate::model::iam_policy_analysis_result::Edge::target_node
        pub resource_edges: std::vec::Vec<crate::model::iam_policy_analysis_result::Edge>,

        /// Condition evaluation for this AccessControlList, if there is a condition
        /// defined in the above IAM policy binding.
        pub condition_evaluation: std::option::Option<crate::model::ConditionEvaluation>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AccessControlList {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resources][crate::model::iam_policy_analysis_result::AccessControlList::resources].
        pub fn set_resources<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::iam_policy_analysis_result::Resource>,
        {
            use std::iter::Iterator;
            self.resources = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [accesses][crate::model::iam_policy_analysis_result::AccessControlList::accesses].
        pub fn set_accesses<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::iam_policy_analysis_result::Access>,
        {
            use std::iter::Iterator;
            self.accesses = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [resource_edges][crate::model::iam_policy_analysis_result::AccessControlList::resource_edges].
        pub fn set_resource_edges<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::iam_policy_analysis_result::Edge>,
        {
            use std::iter::Iterator;
            self.resource_edges = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [condition_evaluation][crate::model::iam_policy_analysis_result::AccessControlList::condition_evaluation].
        pub fn set_condition_evaluation<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ConditionEvaluation>,
        {
            self.condition_evaluation = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [condition_evaluation][crate::model::iam_policy_analysis_result::AccessControlList::condition_evaluation].
        pub fn set_or_clear_condition_evaluation<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ConditionEvaluation>,
        {
            self.condition_evaluation = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AccessControlList {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisResult.AccessControlList"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AccessControlList {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __resources,
                __accesses,
                __resource_edges,
                __condition_evaluation,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AccessControlList")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "resources" => Ok(__FieldTag::__resources),
                                "accesses" => Ok(__FieldTag::__accesses),
                                "resourceEdges" => Ok(__FieldTag::__resource_edges),
                                "resource_edges" => Ok(__FieldTag::__resource_edges),
                                "conditionEvaluation" => Ok(__FieldTag::__condition_evaluation),
                                "condition_evaluation" => Ok(__FieldTag::__condition_evaluation),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AccessControlList;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AccessControlList")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__resources => {
                                if !fields.insert(__FieldTag::__resources) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resources",
                                    ));
                                }
                                result.resources = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::iam_policy_analysis_result::Resource,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__accesses => {
                                if !fields.insert(__FieldTag::__accesses) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for accesses",
                                    ));
                                }
                                result.accesses = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::iam_policy_analysis_result::Access,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__resource_edges => {
                                if !fields.insert(__FieldTag::__resource_edges) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_edges",
                                    ));
                                }
                                result.resource_edges = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::iam_policy_analysis_result::Edge,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__condition_evaluation => {
                                if !fields.insert(__FieldTag::__condition_evaluation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition_evaluation",
                                    ));
                                }
                                result.condition_evaluation = map.next_value::<std::option::Option<crate::model::ConditionEvaluation>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AccessControlList {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.resources.is_empty() {
                state.serialize_entry("resources", &self.resources)?;
            }
            if !self.accesses.is_empty() {
                state.serialize_entry("accesses", &self.accesses)?;
            }
            if !self.resource_edges.is_empty() {
                state.serialize_entry("resourceEdges", &self.resource_edges)?;
            }
            if self.condition_evaluation.is_some() {
                state.serialize_entry("conditionEvaluation", &self.condition_evaluation)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AccessControlList {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AccessControlList");
            debug_struct.field("resources", &self.resources);
            debug_struct.field("accesses", &self.accesses);
            debug_struct.field("resource_edges", &self.resource_edges);
            debug_struct.field("condition_evaluation", &self.condition_evaluation);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The identities and group edges.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IdentityList {
        /// Only the identities that match one of the following conditions will be
        /// presented:
        ///
        /// - The identity_selector, if it is specified in request;
        /// - Otherwise, identities reachable from the policy binding's members.
        pub identities: std::vec::Vec<crate::model::iam_policy_analysis_result::Identity>,

        /// Group identity edges of the graph starting from the binding's
        /// group members to any node of the
        /// [identities][google.cloud.asset.v1.IamPolicyAnalysisResult.IdentityList.identities].
        /// The
        /// [Edge.source_node][google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.source_node]
        /// contains a group, such as `group:parent@google.com`. The
        /// [Edge.target_node][google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.target_node]
        /// contains a member of the group, such as `group:child@google.com` or
        /// `user:foo@google.com`. This field is present only if the
        /// output_group_edges option is enabled in request.
        ///
        /// [google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.source_node]: crate::model::iam_policy_analysis_result::Edge::source_node
        /// [google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.target_node]: crate::model::iam_policy_analysis_result::Edge::target_node
        /// [google.cloud.asset.v1.IamPolicyAnalysisResult.IdentityList.identities]: crate::model::iam_policy_analysis_result::IdentityList::identities
        pub group_edges: std::vec::Vec<crate::model::iam_policy_analysis_result::Edge>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IdentityList {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [identities][crate::model::iam_policy_analysis_result::IdentityList::identities].
        pub fn set_identities<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::iam_policy_analysis_result::Identity>,
        {
            use std::iter::Iterator;
            self.identities = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [group_edges][crate::model::iam_policy_analysis_result::IdentityList::group_edges].
        pub fn set_group_edges<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::iam_policy_analysis_result::Edge>,
        {
            use std::iter::Iterator;
            self.group_edges = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for IdentityList {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.asset.v1.IamPolicyAnalysisResult.IdentityList"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IdentityList {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __identities,
                __group_edges,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IdentityList")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "identities" => Ok(__FieldTag::__identities),
                                "groupEdges" => Ok(__FieldTag::__group_edges),
                                "group_edges" => Ok(__FieldTag::__group_edges),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IdentityList;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IdentityList")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__identities => {
                                if !fields.insert(__FieldTag::__identities) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for identities",
                                    ));
                                }
                                result.identities = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::iam_policy_analysis_result::Identity,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__group_edges => {
                                if !fields.insert(__FieldTag::__group_edges) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for group_edges",
                                    ));
                                }
                                result.group_edges = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::iam_policy_analysis_result::Edge,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IdentityList {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.identities.is_empty() {
                state.serialize_entry("identities", &self.identities)?;
            }
            if !self.group_edges.is_empty() {
                state.serialize_entry("groupEdges", &self.group_edges)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for IdentityList {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("IdentityList");
            debug_struct.field("identities", &self.identities);
            debug_struct.field("group_edges", &self.group_edges);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Asset content type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ContentType {
    /// Unspecified content type.
    Unspecified,
    /// Resource metadata.
    Resource,
    /// The actual IAM policy set on a resource.
    IamPolicy,
    /// The organization policy set on an asset.
    OrgPolicy,
    /// The Access Context Manager policy set on an asset.
    AccessPolicy,
    /// The runtime OS Inventory information.
    OsInventory,
    /// The related resources.
    Relationship,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ContentType::value] or
    /// [ContentType::name].
    UnknownValue(content_type::UnknownValue),
}

#[doc(hidden)]
pub mod content_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ContentType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Resource => std::option::Option::Some(1),
            Self::IamPolicy => std::option::Option::Some(2),
            Self::OrgPolicy => std::option::Option::Some(4),
            Self::AccessPolicy => std::option::Option::Some(5),
            Self::OsInventory => std::option::Option::Some(6),
            Self::Relationship => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CONTENT_TYPE_UNSPECIFIED"),
            Self::Resource => std::option::Option::Some("RESOURCE"),
            Self::IamPolicy => std::option::Option::Some("IAM_POLICY"),
            Self::OrgPolicy => std::option::Option::Some("ORG_POLICY"),
            Self::AccessPolicy => std::option::Option::Some("ACCESS_POLICY"),
            Self::OsInventory => std::option::Option::Some("OS_INVENTORY"),
            Self::Relationship => std::option::Option::Some("RELATIONSHIP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ContentType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ContentType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ContentType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Resource,
            2 => Self::IamPolicy,
            4 => Self::OrgPolicy,
            5 => Self::AccessPolicy,
            6 => Self::OsInventory,
            7 => Self::Relationship,
            _ => Self::UnknownValue(content_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ContentType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONTENT_TYPE_UNSPECIFIED" => Self::Unspecified,
            "RESOURCE" => Self::Resource,
            "IAM_POLICY" => Self::IamPolicy,
            "ORG_POLICY" => Self::OrgPolicy,
            "ACCESS_POLICY" => Self::AccessPolicy,
            "OS_INVENTORY" => Self::OsInventory,
            "RELATIONSHIP" => Self::Relationship,
            _ => Self::UnknownValue(content_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ContentType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Resource => serializer.serialize_i32(1),
            Self::IamPolicy => serializer.serialize_i32(2),
            Self::OrgPolicy => serializer.serialize_i32(4),
            Self::AccessPolicy => serializer.serialize_i32(5),
            Self::OsInventory => serializer.serialize_i32(6),
            Self::Relationship => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ContentType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContentType>::new(
            ".google.cloud.asset.v1.ContentType",
        ))
    }
}
