// Copyright 2026 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
use crate::Result;

/// Implements a [Changes](super::stub::Changes) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Changes<T>
where
    T: super::stub::Changes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Changes<T>
where
    T: super::stub::Changes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::Changes for Changes<T>
where
    T: super::stub::Changes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create(
        &self,
        req: crate::model::changes::CreateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Change>> {
        self.inner.create(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::changes::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Change>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::changes::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ChangesListResponse>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [DnsKeys](super::stub::DnsKeys) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct DnsKeys<T>
where
    T: super::stub::DnsKeys + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> DnsKeys<T>
where
    T: super::stub::DnsKeys + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::DnsKeys for DnsKeys<T>
where
    T: super::stub::DnsKeys + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::dns_keys::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DnsKey>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::dns_keys::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DnsKeysListResponse>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [ManagedZoneOperations](super::stub::ManagedZoneOperations) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ManagedZoneOperations<T>
where
    T: super::stub::ManagedZoneOperations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ManagedZoneOperations<T>
where
    T: super::stub::ManagedZoneOperations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::ManagedZoneOperations for ManagedZoneOperations<T>
where
    T: super::stub::ManagedZoneOperations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::managed_zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::managed_zone_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ManagedZoneOperationsListResponse>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [ManagedZones](super::stub::ManagedZones) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ManagedZones<T>
where
    T: super::stub::ManagedZones + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ManagedZones<T>
where
    T: super::stub::ManagedZones + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::ManagedZones for ManagedZones<T>
where
    T: super::stub::ManagedZones + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create(
        &self,
        req: crate::model::managed_zones::CreateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ManagedZone>> {
        self.inner.create(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::managed_zones::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::managed_zones::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ManagedZone>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::managed_zones::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GoogleIamV1Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::managed_zones::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ManagedZonesListResponse>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::managed_zones::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::managed_zones::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GoogleIamV1Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::managed_zones::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GoogleIamV1TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::managed_zones::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }
}

/// Implements a [Policies](super::stub::Policies) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Policies<T>
where
    T: super::stub::Policies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Policies<T>
where
    T: super::stub::Policies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::Policies for Policies<T>
where
    T: super::stub::Policies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create(
        &self,
        req: crate::model::policies::CreateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.create(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PoliciesListResponse>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PoliciesPatchResponse>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::policies::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PoliciesUpdateResponse>> {
        self.inner.update(req, options).await
    }
}

/// Implements a [Projects](super::stub::Projects) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Projects<T>
where
    T: super::stub::Projects + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Projects<T>
where
    T: super::stub::Projects + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::Projects for Projects<T>
where
    T: super::stub::Projects + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::projects::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Project>> {
        self.inner.get(req, options).await
    }
}

/// Implements a [ResourceRecordSets](super::stub::ResourceRecordSets) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ResourceRecordSets<T>
where
    T: super::stub::ResourceRecordSets + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ResourceRecordSets<T>
where
    T: super::stub::ResourceRecordSets + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::ResourceRecordSets for ResourceRecordSets<T>
where
    T: super::stub::ResourceRecordSets + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create(
        &self,
        req: crate::model::resource_record_sets::CreateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResourceRecordSet>> {
        self.inner.create(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::resource_record_sets::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResourceRecordSetsDeleteResponse>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::resource_record_sets::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResourceRecordSet>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::resource_record_sets::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResourceRecordSetsListResponse>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::resource_record_sets::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResourceRecordSet>> {
        self.inner.patch(req, options).await
    }
}

/// Implements a [ResponsePolicies](super::stub::ResponsePolicies) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ResponsePolicies<T>
where
    T: super::stub::ResponsePolicies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ResponsePolicies<T>
where
    T: super::stub::ResponsePolicies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::ResponsePolicies for ResponsePolicies<T>
where
    T: super::stub::ResponsePolicies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create(
        &self,
        req: crate::model::response_policies::CreateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResponsePolicy>> {
        self.inner.create(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::response_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::response_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResponsePolicy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::response_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResponsePoliciesListResponse>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::response_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResponsePoliciesPatchResponse>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::response_policies::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResponsePoliciesUpdateResponse>> {
        self.inner.update(req, options).await
    }
}

/// Implements a [ResponsePolicyRules](super::stub::ResponsePolicyRules) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ResponsePolicyRules<T>
where
    T: super::stub::ResponsePolicyRules + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ResponsePolicyRules<T>
where
    T: super::stub::ResponsePolicyRules + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::ResponsePolicyRules for ResponsePolicyRules<T>
where
    T: super::stub::ResponsePolicyRules + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create(
        &self,
        req: crate::model::response_policy_rules::CreateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResponsePolicyRule>> {
        self.inner.create(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::response_policy_rules::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::response_policy_rules::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResponsePolicyRule>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::response_policy_rules::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResponsePolicyRulesListResponse>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::response_policy_rules::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResponsePolicyRulesPatchResponse>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::response_policy_rules::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResponsePolicyRulesUpdateResponse>> {
        self.inner.update(req, options).await
    }
}
