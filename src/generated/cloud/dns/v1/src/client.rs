// Copyright 2026 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]

/// Implements a client for the Cloud DNS API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_dns_v1::client::Changes;
/// let client = Changes::builder().build().await?;
/// // use `client` to make requests to the Cloud DNS API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for the `changes` resource.
///
/// # Configuration
///
/// To configure `Changes` use the `with_*` methods in the type returned
/// by [builder()][Changes::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://dns.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::changes::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::changes::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Changes` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Changes` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct Changes {
    inner: std::sync::Arc<dyn super::stub::dynamic::Changes>,
}

impl Changes {
    /// Returns a builder for [Changes].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_dns_v1::client::Changes;
    /// let client = Changes::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::changes::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::changes::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Changes + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Changes>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Changes> {
        super::transport::Changes::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Changes> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Changes::new)
    }

    /// Atomically updates the ResourceRecordSet collection.
    pub fn create(&self) -> super::builder::changes::Create {
        super::builder::changes::Create::new(self.inner.clone())
    }

    /// Fetches the representation of an existing Change.
    pub fn get(&self) -> super::builder::changes::Get {
        super::builder::changes::Get::new(self.inner.clone())
    }

    /// Enumerates Changes to a ResourceRecordSet collection.
    pub fn list(&self) -> super::builder::changes::List {
        super::builder::changes::List::new(self.inner.clone())
    }
}

/// Implements a client for the Cloud DNS API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_dns_v1::client::DnsKeys;
/// let client = DnsKeys::builder().build().await?;
/// // use `client` to make requests to the Cloud DNS API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for the `dnsKeys` resource.
///
/// # Configuration
///
/// To configure `DnsKeys` use the `with_*` methods in the type returned
/// by [builder()][DnsKeys::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://dns.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::dns_keys::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::dns_keys::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `DnsKeys` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `DnsKeys` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct DnsKeys {
    inner: std::sync::Arc<dyn super::stub::dynamic::DnsKeys>,
}

impl DnsKeys {
    /// Returns a builder for [DnsKeys].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_dns_v1::client::DnsKeys;
    /// let client = DnsKeys::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::dns_keys::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::dns_keys::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::DnsKeys + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::DnsKeys>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::DnsKeys> {
        super::transport::DnsKeys::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::DnsKeys> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::DnsKeys::new)
    }

    /// Fetches the representation of an existing DnsKey.
    pub fn get(&self) -> super::builder::dns_keys::Get {
        super::builder::dns_keys::Get::new(self.inner.clone())
    }

    /// Enumerates DnsKeys to a ResourceRecordSet collection.
    pub fn list(&self) -> super::builder::dns_keys::List {
        super::builder::dns_keys::List::new(self.inner.clone())
    }
}

/// Implements a client for the Cloud DNS API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_dns_v1::client::ManagedZoneOperations;
/// let client = ManagedZoneOperations::builder().build().await?;
/// // use `client` to make requests to the Cloud DNS API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for the `managedZoneOperations` resource.
///
/// # Configuration
///
/// To configure `ManagedZoneOperations` use the `with_*` methods in the type returned
/// by [builder()][ManagedZoneOperations::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://dns.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::managed_zone_operations::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::managed_zone_operations::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ManagedZoneOperations` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ManagedZoneOperations` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct ManagedZoneOperations {
    inner: std::sync::Arc<dyn super::stub::dynamic::ManagedZoneOperations>,
}

impl ManagedZoneOperations {
    /// Returns a builder for [ManagedZoneOperations].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_dns_v1::client::ManagedZoneOperations;
    /// let client = ManagedZoneOperations::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::managed_zone_operations::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::managed_zone_operations::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ManagedZoneOperations + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ManagedZoneOperations>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ManagedZoneOperations> {
        super::transport::ManagedZoneOperations::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ManagedZoneOperations> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ManagedZoneOperations::new)
    }

    /// Fetches the representation of an existing Operation.
    pub fn get(&self) -> super::builder::managed_zone_operations::Get {
        super::builder::managed_zone_operations::Get::new(self.inner.clone())
    }

    /// Enumerates Operations for the given ManagedZone.
    pub fn list(&self) -> super::builder::managed_zone_operations::List {
        super::builder::managed_zone_operations::List::new(self.inner.clone())
    }
}

/// Implements a client for the Cloud DNS API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_dns_v1::client::ManagedZones;
/// let client = ManagedZones::builder().build().await?;
/// // use `client` to make requests to the Cloud DNS API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for the `managedZones` resource.
///
/// # Configuration
///
/// To configure `ManagedZones` use the `with_*` methods in the type returned
/// by [builder()][ManagedZones::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://dns.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::managed_zones::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::managed_zones::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ManagedZones` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ManagedZones` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct ManagedZones {
    inner: std::sync::Arc<dyn super::stub::dynamic::ManagedZones>,
}

impl ManagedZones {
    /// Returns a builder for [ManagedZones].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_dns_v1::client::ManagedZones;
    /// let client = ManagedZones::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::managed_zones::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::managed_zones::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ManagedZones + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ManagedZones>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ManagedZones> {
        super::transport::ManagedZones::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ManagedZones> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ManagedZones::new)
    }

    /// Creates a new ManagedZone.
    pub fn create(&self) -> super::builder::managed_zones::Create {
        super::builder::managed_zones::Create::new(self.inner.clone())
    }

    /// Deletes a previously created ManagedZone.
    pub fn delete(&self) -> super::builder::managed_zones::Delete {
        super::builder::managed_zones::Delete::new(self.inner.clone())
    }

    /// Fetches the representation of an existing ManagedZone.
    pub fn get(&self) -> super::builder::managed_zones::Get {
        super::builder::managed_zones::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set.
    pub fn get_iam_policy(&self) -> super::builder::managed_zones::GetIamPolicy {
        super::builder::managed_zones::GetIamPolicy::new(self.inner.clone())
    }

    /// Enumerates ManagedZones that have been created but not yet deleted.
    pub fn list(&self) -> super::builder::managed_zones::List {
        super::builder::managed_zones::List::new(self.inner.clone())
    }

    /// Applies a partial update to an existing ManagedZone.
    pub fn patch(&self) -> super::builder::managed_zones::Patch {
        super::builder::managed_zones::Patch::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource. Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
    pub fn set_iam_policy(&self) -> super::builder::managed_zones::SetIamPolicy {
        super::builder::managed_zones::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource. If the resource does not exist, this returns an empty set of permissions, not a `NOT_FOUND` error. Note: This operation is designed to be used for building permission-aware UIs and command-line tools, not for authorization checking. This operation may "fail open" without warning.
    pub fn test_iam_permissions(&self) -> super::builder::managed_zones::TestIamPermissions {
        super::builder::managed_zones::TestIamPermissions::new(self.inner.clone())
    }

    /// Updates an existing ManagedZone.
    pub fn update(&self) -> super::builder::managed_zones::Update {
        super::builder::managed_zones::Update::new(self.inner.clone())
    }

    /// Fetches the representation of an existing Operation.
    pub fn get_operation(&self) -> super::builder::managed_zones::GetOperation {
        super::builder::managed_zones::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Cloud DNS API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_dns_v1::client::Policies;
/// let client = Policies::builder().build().await?;
/// // use `client` to make requests to the Cloud DNS API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for the `policies` resource.
///
/// # Configuration
///
/// To configure `Policies` use the `with_*` methods in the type returned
/// by [builder()][Policies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://dns.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::policies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::policies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Policies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Policies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct Policies {
    inner: std::sync::Arc<dyn super::stub::dynamic::Policies>,
}

impl Policies {
    /// Returns a builder for [Policies].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_dns_v1::client::Policies;
    /// let client = Policies::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::policies::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::policies::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Policies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Policies>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Policies> {
        super::transport::Policies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Policies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Policies::new)
    }

    /// Creates a new policy.
    pub fn create(&self) -> super::builder::policies::Create {
        super::builder::policies::Create::new(self.inner.clone())
    }

    /// Deletes a previously created policy. Fails if the policy is still being referenced by a network.
    pub fn delete(&self) -> super::builder::policies::Delete {
        super::builder::policies::Delete::new(self.inner.clone())
    }

    /// Fetches the representation of an existing policy.
    pub fn get(&self) -> super::builder::policies::Get {
        super::builder::policies::Get::new(self.inner.clone())
    }

    /// Enumerates all policies associated with a project.
    pub fn list(&self) -> super::builder::policies::List {
        super::builder::policies::List::new(self.inner.clone())
    }

    /// Applies a partial update to an existing policy.
    pub fn patch(&self) -> super::builder::policies::Patch {
        super::builder::policies::Patch::new(self.inner.clone())
    }

    /// Updates an existing policy.
    pub fn update(&self) -> super::builder::policies::Update {
        super::builder::policies::Update::new(self.inner.clone())
    }
}

/// Implements a client for the Cloud DNS API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_dns_v1::client::Projects;
/// let client = Projects::builder().build().await?;
/// // use `client` to make requests to the Cloud DNS API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for the `projects` resource.
///
/// # Configuration
///
/// To configure `Projects` use the `with_*` methods in the type returned
/// by [builder()][Projects::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://dns.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::projects::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::projects::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Projects` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Projects` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct Projects {
    inner: std::sync::Arc<dyn super::stub::dynamic::Projects>,
}

impl Projects {
    /// Returns a builder for [Projects].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_dns_v1::client::Projects;
    /// let client = Projects::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::projects::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::projects::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Projects + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Projects>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Projects> {
        super::transport::Projects::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Projects> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Projects::new)
    }

    /// Fetches the representation of an existing Project.
    pub fn get(&self) -> super::builder::projects::Get {
        super::builder::projects::Get::new(self.inner.clone())
    }
}

/// Implements a client for the Cloud DNS API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_dns_v1::client::ResourceRecordSets;
/// let client = ResourceRecordSets::builder().build().await?;
/// // use `client` to make requests to the Cloud DNS API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for the `resourceRecordSets` resource.
///
/// # Configuration
///
/// To configure `ResourceRecordSets` use the `with_*` methods in the type returned
/// by [builder()][ResourceRecordSets::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://dns.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::resource_record_sets::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::resource_record_sets::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ResourceRecordSets` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ResourceRecordSets` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct ResourceRecordSets {
    inner: std::sync::Arc<dyn super::stub::dynamic::ResourceRecordSets>,
}

impl ResourceRecordSets {
    /// Returns a builder for [ResourceRecordSets].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_dns_v1::client::ResourceRecordSets;
    /// let client = ResourceRecordSets::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::resource_record_sets::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::resource_record_sets::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ResourceRecordSets + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ResourceRecordSets>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ResourceRecordSets> {
        super::transport::ResourceRecordSets::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ResourceRecordSets> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ResourceRecordSets::new)
    }

    /// Creates a new ResourceRecordSet.
    pub fn create(&self) -> super::builder::resource_record_sets::Create {
        super::builder::resource_record_sets::Create::new(self.inner.clone())
    }

    /// Deletes a previously created ResourceRecordSet.
    pub fn delete(&self) -> super::builder::resource_record_sets::Delete {
        super::builder::resource_record_sets::Delete::new(self.inner.clone())
    }

    /// Fetches the representation of an existing ResourceRecordSet.
    pub fn get(&self) -> super::builder::resource_record_sets::Get {
        super::builder::resource_record_sets::Get::new(self.inner.clone())
    }

    /// Enumerates ResourceRecordSets that you have created but not yet deleted.
    pub fn list(&self) -> super::builder::resource_record_sets::List {
        super::builder::resource_record_sets::List::new(self.inner.clone())
    }

    /// Applies a partial update to an existing ResourceRecordSet.
    pub fn patch(&self) -> super::builder::resource_record_sets::Patch {
        super::builder::resource_record_sets::Patch::new(self.inner.clone())
    }
}

/// Implements a client for the Cloud DNS API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_dns_v1::client::ResponsePolicies;
/// let client = ResponsePolicies::builder().build().await?;
/// // use `client` to make requests to the Cloud DNS API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for the `responsePolicies` resource.
///
/// # Configuration
///
/// To configure `ResponsePolicies` use the `with_*` methods in the type returned
/// by [builder()][ResponsePolicies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://dns.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::response_policies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::response_policies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ResponsePolicies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ResponsePolicies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct ResponsePolicies {
    inner: std::sync::Arc<dyn super::stub::dynamic::ResponsePolicies>,
}

impl ResponsePolicies {
    /// Returns a builder for [ResponsePolicies].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_dns_v1::client::ResponsePolicies;
    /// let client = ResponsePolicies::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::response_policies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::response_policies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ResponsePolicies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ResponsePolicies>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ResponsePolicies> {
        super::transport::ResponsePolicies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ResponsePolicies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ResponsePolicies::new)
    }

    /// Creates a new Response Policy
    pub fn create(&self) -> super::builder::response_policies::Create {
        super::builder::response_policies::Create::new(self.inner.clone())
    }

    /// Deletes a previously created Response Policy. Fails if the response policy is non-empty or still being referenced by a network.
    pub fn delete(&self) -> super::builder::response_policies::Delete {
        super::builder::response_policies::Delete::new(self.inner.clone())
    }

    /// Fetches the representation of an existing Response Policy.
    pub fn get(&self) -> super::builder::response_policies::Get {
        super::builder::response_policies::Get::new(self.inner.clone())
    }

    /// Enumerates all Response Policies associated with a project.
    pub fn list(&self) -> super::builder::response_policies::List {
        super::builder::response_policies::List::new(self.inner.clone())
    }

    /// Applies a partial update to an existing Response Policy.
    pub fn patch(&self) -> super::builder::response_policies::Patch {
        super::builder::response_policies::Patch::new(self.inner.clone())
    }

    /// Updates an existing Response Policy.
    pub fn update(&self) -> super::builder::response_policies::Update {
        super::builder::response_policies::Update::new(self.inner.clone())
    }
}

/// Implements a client for the Cloud DNS API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_dns_v1::client::ResponsePolicyRules;
/// let client = ResponsePolicyRules::builder().build().await?;
/// // use `client` to make requests to the Cloud DNS API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for the `responsePolicyRules` resource.
///
/// # Configuration
///
/// To configure `ResponsePolicyRules` use the `with_*` methods in the type returned
/// by [builder()][ResponsePolicyRules::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://dns.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::response_policy_rules::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::response_policy_rules::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ResponsePolicyRules` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ResponsePolicyRules` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct ResponsePolicyRules {
    inner: std::sync::Arc<dyn super::stub::dynamic::ResponsePolicyRules>,
}

impl ResponsePolicyRules {
    /// Returns a builder for [ResponsePolicyRules].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_dns_v1::client::ResponsePolicyRules;
    /// let client = ResponsePolicyRules::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::response_policy_rules::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::response_policy_rules::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ResponsePolicyRules + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ResponsePolicyRules>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ResponsePolicyRules> {
        super::transport::ResponsePolicyRules::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ResponsePolicyRules> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ResponsePolicyRules::new)
    }

    /// Creates a new Response Policy Rule.
    pub fn create(&self) -> super::builder::response_policy_rules::Create {
        super::builder::response_policy_rules::Create::new(self.inner.clone())
    }

    /// Deletes a previously created Response Policy Rule.
    pub fn delete(&self) -> super::builder::response_policy_rules::Delete {
        super::builder::response_policy_rules::Delete::new(self.inner.clone())
    }

    /// Fetches the representation of an existing Response Policy Rule.
    pub fn get(&self) -> super::builder::response_policy_rules::Get {
        super::builder::response_policy_rules::Get::new(self.inner.clone())
    }

    /// Enumerates all Response Policy Rules associated with a project.
    pub fn list(&self) -> super::builder::response_policy_rules::List {
        super::builder::response_policy_rules::List::new(self.inner.clone())
    }

    /// Applies a partial update to an existing Response Policy Rule.
    pub fn patch(&self) -> super::builder::response_policy_rules::Patch {
        super::builder::response_policy_rules::Patch::new(self.inner.clone())
    }

    /// Updates an existing Response Policy Rule.
    pub fn update(&self) -> super::builder::response_policy_rules::Update {
        super::builder::response_policy_rules::Update::new(self.inner.clone())
    }
}
