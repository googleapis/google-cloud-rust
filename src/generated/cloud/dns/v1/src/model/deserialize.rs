// Copyright 2026 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Change {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __additions,
            __deletions,
            __id,
            __is_serving,
            __kind,
            __start_time,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Change")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "additions" => Ok(__FieldTag::__additions),
                            "deletions" => Ok(__FieldTag::__deletions),
                            "id" => Ok(__FieldTag::__id),
                            "isServing" => Ok(__FieldTag::__is_serving),
                            "kind" => Ok(__FieldTag::__kind),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Change;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Change")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__additions => {
                            if !fields.insert(__FieldTag::__additions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additions",
                                ));
                            }
                            result.additions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResourceRecordSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deletions => {
                            if !fields.insert(__FieldTag::__deletions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletions",
                                ));
                            }
                            result.deletions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResourceRecordSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__is_serving => {
                            if !fields.insert(__FieldTag::__is_serving) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_serving",
                                ));
                            }
                            result.is_serving = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::change::Status>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ChangesListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __changes,
            __kind,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ChangesListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "changes" => Ok(__FieldTag::__changes),
                            "kind" => Ok(__FieldTag::__kind),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ChangesListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ChangesListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__changes => {
                            if !fields.insert(__FieldTag::__changes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for changes",
                                ));
                            }
                            result.changes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Change>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DnsKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __algorithm,
            __creation_time,
            __description,
            __digests,
            __id,
            __is_active,
            __key_length,
            __key_tag,
            __kind,
            __public_key,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DnsKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "algorithm" => Ok(__FieldTag::__algorithm),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "description" => Ok(__FieldTag::__description),
                            "digests" => Ok(__FieldTag::__digests),
                            "id" => Ok(__FieldTag::__id),
                            "isActive" => Ok(__FieldTag::__is_active),
                            "keyLength" => Ok(__FieldTag::__key_length),
                            "keyTag" => Ok(__FieldTag::__key_tag),
                            "kind" => Ok(__FieldTag::__kind),
                            "publicKey" => Ok(__FieldTag::__public_key),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DnsKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DnsKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__algorithm => {
                            if !fields.insert(__FieldTag::__algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for algorithm",
                                ));
                            }
                            result.algorithm = map.next_value::<std::option::Option<crate::model::dns_key::Algorithm>>()?
                                ;
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            result.creation_time =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__digests => {
                            if !fields.insert(__FieldTag::__digests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digests",
                                ));
                            }
                            result.digests = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DnsKeyDigest>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__is_active => {
                            if !fields.insert(__FieldTag::__is_active) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_active",
                                ));
                            }
                            result.is_active = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__key_length => {
                            if !fields.insert(__FieldTag::__key_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_length",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.key_length = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__key_tag => {
                            if !fields.insert(__FieldTag::__key_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_tag",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.key_tag = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key",
                                ));
                            }
                            result.public_key =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::dns_key::Type>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DnsKeyDigest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __digest,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DnsKeyDigest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "digest" => Ok(__FieldTag::__digest),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DnsKeyDigest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DnsKeyDigest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::dns_key_digest::Type>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DnsKeySpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __algorithm,
            __key_length,
            __key_type,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DnsKeySpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "algorithm" => Ok(__FieldTag::__algorithm),
                            "keyLength" => Ok(__FieldTag::__key_length),
                            "keyType" => Ok(__FieldTag::__key_type),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DnsKeySpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DnsKeySpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__algorithm => {
                            if !fields.insert(__FieldTag::__algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for algorithm",
                                ));
                            }
                            result.algorithm = map.next_value::<std::option::Option<crate::model::dns_key_spec::Algorithm>>()?
                                ;
                        }
                        __FieldTag::__key_length => {
                            if !fields.insert(__FieldTag::__key_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_length",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.key_length = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__key_type => {
                            if !fields.insert(__FieldTag::__key_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_type",
                                ));
                            }
                            result.key_type = map.next_value::<std::option::Option<crate::model::dns_key_spec::KeyType>>()?
                                ;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DnsKeysListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dns_keys,
            __kind,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DnsKeysListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dnsKeys" => Ok(__FieldTag::__dns_keys),
                            "kind" => Ok(__FieldTag::__kind),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DnsKeysListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DnsKeysListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dns_keys => {
                            if !fields.insert(__FieldTag::__dns_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_keys",
                                ));
                            }
                            result.dns_keys = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DnsKey>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Expr {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __description,
            __expression,
            __location,
            __title,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Expr")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "description" => Ok(__FieldTag::__description),
                            "expression" => Ok(__FieldTag::__expression),
                            "location" => Ok(__FieldTag::__location),
                            "title" => Ok(__FieldTag::__title),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Expr;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Expr")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__expression => {
                            if !fields.insert(__FieldTag::__expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expression",
                                ));
                            }
                            result.expression =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GoogleIamV1AuditConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audit_log_configs,
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleIamV1AuditConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "auditLogConfigs" => Ok(__FieldTag::__audit_log_configs),
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GoogleIamV1AuditConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleIamV1AuditConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audit_log_configs => {
                            if !fields.insert(__FieldTag::__audit_log_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audit_log_configs",
                                ));
                            }
                            result.audit_log_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::GoogleIamV1AuditLogConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GoogleIamV1AuditLogConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __exempted_members,
            __log_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleIamV1AuditLogConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "exemptedMembers" => Ok(__FieldTag::__exempted_members),
                            "logType" => Ok(__FieldTag::__log_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GoogleIamV1AuditLogConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleIamV1AuditLogConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__exempted_members => {
                            if !fields.insert(__FieldTag::__exempted_members) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exempted_members",
                                ));
                            }
                            result.exempted_members = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__log_type => {
                            if !fields.insert(__FieldTag::__log_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_type",
                                ));
                            }
                            result.log_type = map.next_value::<std::option::Option<
                                crate::model::google_iam_v_1_audit_log_config::LogType,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GoogleIamV1Binding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __condition,
            __members,
            __role,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleIamV1Binding")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "condition" => Ok(__FieldTag::__condition),
                            "members" => Ok(__FieldTag::__members),
                            "role" => Ok(__FieldTag::__role),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GoogleIamV1Binding;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleIamV1Binding")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition =
                                map.next_value::<std::option::Option<crate::model::Expr>>()?;
                        }
                        __FieldTag::__members => {
                            if !fields.insert(__FieldTag::__members) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for members",
                                ));
                            }
                            result.members = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GoogleIamV1GetIamPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleIamV1GetIamPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "options" => Ok(__FieldTag::__options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GoogleIamV1GetIamPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleIamV1GetIamPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__options => {
                            if !fields.insert(__FieldTag::__options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for options",
                                ));
                            }
                            result.options = map.next_value::<std::option::Option<crate::model::GoogleIamV1GetPolicyOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GoogleIamV1GetPolicyOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __requested_policy_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleIamV1GetPolicyOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requestedPolicyVersion" => Ok(__FieldTag::__requested_policy_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GoogleIamV1GetPolicyOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleIamV1GetPolicyOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__requested_policy_version => {
                            if !fields.insert(__FieldTag::__requested_policy_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_policy_version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.requested_policy_version = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GoogleIamV1Policy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audit_configs,
            __bindings,
            __etag,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleIamV1Policy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "auditConfigs" => Ok(__FieldTag::__audit_configs),
                            "bindings" => Ok(__FieldTag::__bindings),
                            "etag" => Ok(__FieldTag::__etag),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GoogleIamV1Policy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleIamV1Policy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audit_configs => {
                            if !fields.insert(__FieldTag::__audit_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audit_configs",
                                ));
                            }
                            result.audit_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::GoogleIamV1AuditConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bindings => {
                            if !fields.insert(__FieldTag::__bindings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bindings",
                                ));
                            }
                            result.bindings = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::GoogleIamV1Binding>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.etag = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GoogleIamV1SetIamPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleIamV1SetIamPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policy" => Ok(__FieldTag::__policy),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GoogleIamV1SetIamPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleIamV1SetIamPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<crate::model::GoogleIamV1Policy>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GoogleIamV1TestIamPermissionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __permissions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleIamV1TestIamPermissionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "permissions" => Ok(__FieldTag::__permissions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GoogleIamV1TestIamPermissionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleIamV1TestIamPermissionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__permissions => {
                            if !fields.insert(__FieldTag::__permissions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permissions",
                                ));
                            }
                            result.permissions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GoogleIamV1TestIamPermissionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __permissions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GoogleIamV1TestIamPermissionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "permissions" => Ok(__FieldTag::__permissions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GoogleIamV1TestIamPermissionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleIamV1TestIamPermissionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__permissions => {
                            if !fields.insert(__FieldTag::__permissions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permissions",
                                ));
                            }
                            result.permissions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZone {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_logging_config,
            __creation_time,
            __description,
            __dns_name,
            __dnssec_config,
            __forwarding_config,
            __id,
            __kind,
            __labels,
            __name,
            __name_server_set,
            __name_servers,
            __peering_config,
            __private_visibility_config,
            __reverse_lookup_config,
            __service_directory_config,
            __visibility,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedZone")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudLoggingConfig" => Ok(__FieldTag::__cloud_logging_config),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "description" => Ok(__FieldTag::__description),
                            "dnsName" => Ok(__FieldTag::__dns_name),
                            "dnssecConfig" => Ok(__FieldTag::__dnssec_config),
                            "forwardingConfig" => Ok(__FieldTag::__forwarding_config),
                            "id" => Ok(__FieldTag::__id),
                            "kind" => Ok(__FieldTag::__kind),
                            "labels" => Ok(__FieldTag::__labels),
                            "name" => Ok(__FieldTag::__name),
                            "nameServerSet" => Ok(__FieldTag::__name_server_set),
                            "nameServers" => Ok(__FieldTag::__name_servers),
                            "peeringConfig" => Ok(__FieldTag::__peering_config),
                            "privateVisibilityConfig" => {
                                Ok(__FieldTag::__private_visibility_config)
                            }
                            "reverseLookupConfig" => Ok(__FieldTag::__reverse_lookup_config),
                            "serviceDirectoryConfig" => Ok(__FieldTag::__service_directory_config),
                            "visibility" => Ok(__FieldTag::__visibility),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZone;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZone")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_logging_config => {
                            if !fields.insert(__FieldTag::__cloud_logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_logging_config",
                                ));
                            }
                            result.cloud_logging_config =
                                map.next_value::<std::option::Option<
                                    crate::model::ManagedZoneCloudLoggingConfig,
                                >>()?;
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            result.creation_time =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__dns_name => {
                            if !fields.insert(__FieldTag::__dns_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_name",
                                ));
                            }
                            result.dns_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__dnssec_config => {
                            if !fields.insert(__FieldTag::__dnssec_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dnssec_config",
                                ));
                            }
                            result.dnssec_config = map.next_value::<std::option::Option<crate::model::ManagedZoneDnsSecConfig>>()?
                                ;
                        }
                        __FieldTag::__forwarding_config => {
                            if !fields.insert(__FieldTag::__forwarding_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forwarding_config",
                                ));
                            }
                            result.forwarding_config = map.next_value::<std::option::Option<crate::model::ManagedZoneForwardingConfig>>()?
                                ;
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.id = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__name_server_set => {
                            if !fields.insert(__FieldTag::__name_server_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name_server_set",
                                ));
                            }
                            result.name_server_set =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__name_servers => {
                            if !fields.insert(__FieldTag::__name_servers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name_servers",
                                ));
                            }
                            result.name_servers = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__peering_config => {
                            if !fields.insert(__FieldTag::__peering_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peering_config",
                                ));
                            }
                            result.peering_config = map.next_value::<std::option::Option<crate::model::ManagedZonePeeringConfig>>()?
                                ;
                        }
                        __FieldTag::__private_visibility_config => {
                            if !fields.insert(__FieldTag::__private_visibility_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_visibility_config",
                                ));
                            }
                            result.private_visibility_config = map
                                .next_value::<std::option::Option<
                                    crate::model::ManagedZonePrivateVisibilityConfig,
                                >>()?;
                        }
                        __FieldTag::__reverse_lookup_config => {
                            if !fields.insert(__FieldTag::__reverse_lookup_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reverse_lookup_config",
                                ));
                            }
                            result.reverse_lookup_config =
                                map.next_value::<std::option::Option<
                                    crate::model::ManagedZoneReverseLookupConfig,
                                >>()?;
                        }
                        __FieldTag::__service_directory_config => {
                            if !fields.insert(__FieldTag::__service_directory_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_directory_config",
                                ));
                            }
                            result.service_directory_config = map
                                .next_value::<std::option::Option<
                                    crate::model::ManagedZoneServiceDirectoryConfig,
                                >>()?;
                        }
                        __FieldTag::__visibility => {
                            if !fields.insert(__FieldTag::__visibility) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visibility",
                                ));
                            }
                            result.visibility = map.next_value::<std::option::Option<crate::model::managed_zone::Visibility>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZoneCloudLoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_logging,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedZoneCloudLoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableLogging" => Ok(__FieldTag::__enable_logging),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZoneCloudLoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZoneCloudLoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_logging => {
                            if !fields.insert(__FieldTag::__enable_logging) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_logging",
                                ));
                            }
                            result.enable_logging =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZoneDnsSecConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __default_key_specs,
            __kind,
            __non_existence,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedZoneDnsSecConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "defaultKeySpecs" => Ok(__FieldTag::__default_key_specs),
                            "kind" => Ok(__FieldTag::__kind),
                            "nonExistence" => Ok(__FieldTag::__non_existence),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZoneDnsSecConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZoneDnsSecConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__default_key_specs => {
                            if !fields.insert(__FieldTag::__default_key_specs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_key_specs",
                                ));
                            }
                            result.default_key_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DnsKeySpec>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__non_existence => {
                            if !fields.insert(__FieldTag::__non_existence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for non_existence",
                                ));
                            }
                            result.non_existence = map.next_value::<std::option::Option<
                                crate::model::managed_zone_dns_sec_config::NonExistence,
                            >>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<
                                crate::model::managed_zone_dns_sec_config::State,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZoneForwardingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __target_name_servers,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedZoneForwardingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "targetNameServers" => Ok(__FieldTag::__target_name_servers),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZoneForwardingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZoneForwardingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__target_name_servers => {
                            if !fields.insert(__FieldTag::__target_name_servers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_name_servers",
                                ));
                            }
                            result.target_name_servers = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::ManagedZoneForwardingConfigNameServerTarget,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZoneForwardingConfigNameServerTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __domain_name,
            __forwarding_path,
            __ipv_4_address,
            __ipv_6_address,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for ManagedZoneForwardingConfigNameServerTarget",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "domainName" => Ok(__FieldTag::__domain_name),
                            "forwardingPath" => Ok(__FieldTag::__forwarding_path),
                            "ipv4Address" => Ok(__FieldTag::__ipv_4_address),
                            "ipv6Address" => Ok(__FieldTag::__ipv_6_address),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZoneForwardingConfigNameServerTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZoneForwardingConfigNameServerTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__domain_name => {
                            if !fields.insert(__FieldTag::__domain_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain_name",
                                ));
                            }
                            result.domain_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__forwarding_path => {
                            if !fields.insert(__FieldTag::__forwarding_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forwarding_path",
                                ));
                            }
                            result.forwarding_path = map.next_value::<std::option::Option<crate::model::managed_zone_forwarding_config_name_server_target::ForwardingPath>>()?
                                ;
                        }
                        __FieldTag::__ipv_4_address => {
                            if !fields.insert(__FieldTag::__ipv_4_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ipv_4_address",
                                ));
                            }
                            result.ipv_4_address =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__ipv_6_address => {
                            if !fields.insert(__FieldTag::__ipv_6_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ipv_6_address",
                                ));
                            }
                            result.ipv_6_address =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZoneOperationsListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __next_page_token,
            __operations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedZoneOperationsListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "operations" => Ok(__FieldTag::__operations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZoneOperationsListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZoneOperationsListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__operations => {
                            if !fields.insert(__FieldTag::__operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operations",
                                ));
                            }
                            result.operations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Operation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZonePeeringConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __target_network,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedZonePeeringConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "targetNetwork" => Ok(__FieldTag::__target_network),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZonePeeringConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZonePeeringConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__target_network => {
                            if !fields.insert(__FieldTag::__target_network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_network",
                                ));
                            }
                            result.target_network = map.next_value::<std::option::Option<
                                crate::model::ManagedZonePeeringConfigTargetNetwork,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZonePeeringConfigTargetNetwork {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deactivate_time,
            __kind,
            __network_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ManagedZonePeeringConfigTargetNetwork")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deactivateTime" => Ok(__FieldTag::__deactivate_time),
                            "kind" => Ok(__FieldTag::__kind),
                            "networkUrl" => Ok(__FieldTag::__network_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZonePeeringConfigTargetNetwork;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZonePeeringConfigTargetNetwork")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deactivate_time => {
                            if !fields.insert(__FieldTag::__deactivate_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deactivate_time",
                                ));
                            }
                            result.deactivate_time =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__network_url => {
                            if !fields.insert(__FieldTag::__network_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_url",
                                ));
                            }
                            result.network_url =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZonePrivateVisibilityConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gke_clusters,
            __kind,
            __networks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedZonePrivateVisibilityConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gkeClusters" => Ok(__FieldTag::__gke_clusters),
                            "kind" => Ok(__FieldTag::__kind),
                            "networks" => Ok(__FieldTag::__networks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZonePrivateVisibilityConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZonePrivateVisibilityConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gke_clusters => {
                            if !fields.insert(__FieldTag::__gke_clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_clusters",
                                ));
                            }
                            result.gke_clusters = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::ManagedZonePrivateVisibilityConfigGKECluster,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__networks => {
                            if !fields.insert(__FieldTag::__networks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networks",
                                ));
                            }
                            result.networks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::ManagedZonePrivateVisibilityConfigNetwork,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZonePrivateVisibilityConfigGKECluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gke_cluster_name,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for ManagedZonePrivateVisibilityConfigGKECluster",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gkeClusterName" => Ok(__FieldTag::__gke_cluster_name),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZonePrivateVisibilityConfigGKECluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZonePrivateVisibilityConfigGKECluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gke_cluster_name => {
                            if !fields.insert(__FieldTag::__gke_cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_cluster_name",
                                ));
                            }
                            result.gke_cluster_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZonePrivateVisibilityConfigNetwork {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __network_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ManagedZonePrivateVisibilityConfigNetwork")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "networkUrl" => Ok(__FieldTag::__network_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZonePrivateVisibilityConfigNetwork;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZonePrivateVisibilityConfigNetwork")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__network_url => {
                            if !fields.insert(__FieldTag::__network_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_url",
                                ));
                            }
                            result.network_url =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZoneReverseLookupConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedZoneReverseLookupConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZoneReverseLookupConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZoneReverseLookupConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZoneServiceDirectoryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __namespace,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedZoneServiceDirectoryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "namespace" => Ok(__FieldTag::__namespace),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZoneServiceDirectoryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZoneServiceDirectoryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__namespace => {
                            if !fields.insert(__FieldTag::__namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace",
                                ));
                            }
                            result.namespace = map.next_value::<std::option::Option<
                                crate::model::ManagedZoneServiceDirectoryConfigNamespace,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZoneServiceDirectoryConfigNamespace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deletion_time,
            __kind,
            __namespace_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for ManagedZoneServiceDirectoryConfigNamespace",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deletionTime" => Ok(__FieldTag::__deletion_time),
                            "kind" => Ok(__FieldTag::__kind),
                            "namespaceUrl" => Ok(__FieldTag::__namespace_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZoneServiceDirectoryConfigNamespace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZoneServiceDirectoryConfigNamespace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deletion_time => {
                            if !fields.insert(__FieldTag::__deletion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletion_time",
                                ));
                            }
                            result.deletion_time =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__namespace_url => {
                            if !fields.insert(__FieldTag::__namespace_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace_url",
                                ));
                            }
                            result.namespace_url =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedZonesListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __managed_zones,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedZonesListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "managedZones" => Ok(__FieldTag::__managed_zones),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedZonesListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedZonesListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__managed_zones => {
                            if !fields.insert(__FieldTag::__managed_zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_zones",
                                ));
                            }
                            result.managed_zones = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ManagedZone>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Operation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dns_key_context,
            __id,
            __kind,
            __start_time,
            __status,
            __type,
            __user,
            __zone_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Operation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dnsKeyContext" => Ok(__FieldTag::__dns_key_context),
                            "id" => Ok(__FieldTag::__id),
                            "kind" => Ok(__FieldTag::__kind),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "status" => Ok(__FieldTag::__status),
                            "type" => Ok(__FieldTag::__type),
                            "user" => Ok(__FieldTag::__user),
                            "zoneContext" => Ok(__FieldTag::__zone_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Operation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Operation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dns_key_context => {
                            if !fields.insert(__FieldTag::__dns_key_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_key_context",
                                ));
                            }
                            result.dns_key_context = map.next_value::<std::option::Option<crate::model::OperationDnsKeyContext>>()?
                                ;
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::operation::Status>>(
                                )?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__zone_context => {
                            if !fields.insert(__FieldTag::__zone_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone_context",
                                ));
                            }
                            result.zone_context = map.next_value::<std::option::Option<crate::model::OperationManagedZoneContext>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OperationDnsKeyContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __new_value,
            __old_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationDnsKeyContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "newValue" => Ok(__FieldTag::__new_value),
                            "oldValue" => Ok(__FieldTag::__old_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OperationDnsKeyContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationDnsKeyContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__new_value => {
                            if !fields.insert(__FieldTag::__new_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_value",
                                ));
                            }
                            result.new_value =
                                map.next_value::<std::option::Option<crate::model::DnsKey>>()?;
                        }
                        __FieldTag::__old_value => {
                            if !fields.insert(__FieldTag::__old_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_value",
                                ));
                            }
                            result.old_value =
                                map.next_value::<std::option::Option<crate::model::DnsKey>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OperationManagedZoneContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __new_value,
            __old_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationManagedZoneContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "newValue" => Ok(__FieldTag::__new_value),
                            "oldValue" => Ok(__FieldTag::__old_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OperationManagedZoneContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationManagedZoneContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__new_value => {
                            if !fields.insert(__FieldTag::__new_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_value",
                                ));
                            }
                            result.new_value =
                                map.next_value::<std::option::Option<crate::model::ManagedZone>>()?;
                        }
                        __FieldTag::__old_value => {
                            if !fields.insert(__FieldTag::__old_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_value",
                                ));
                            }
                            result.old_value =
                                map.next_value::<std::option::Option<crate::model::ManagedZone>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PoliciesListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __next_page_token,
            __policies,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PoliciesListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "policies" => Ok(__FieldTag::__policies),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PoliciesListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PoliciesListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__policies => {
                            if !fields.insert(__FieldTag::__policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policies",
                                ));
                            }
                            result.policies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Policy>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PoliciesPatchResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PoliciesPatchResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policy" => Ok(__FieldTag::__policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PoliciesPatchResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PoliciesPatchResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy =
                                map.next_value::<std::option::Option<crate::model::Policy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PoliciesUpdateResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PoliciesUpdateResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policy" => Ok(__FieldTag::__policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PoliciesUpdateResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PoliciesUpdateResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy =
                                map.next_value::<std::option::Option<crate::model::Policy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Policy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __alternative_name_server_config,
            __description,
            __dns_64_config,
            __enable_inbound_forwarding,
            __enable_logging,
            __id,
            __kind,
            __name,
            __networks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Policy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "alternativeNameServerConfig" => {
                                Ok(__FieldTag::__alternative_name_server_config)
                            }
                            "description" => Ok(__FieldTag::__description),
                            "dns64Config" => Ok(__FieldTag::__dns_64_config),
                            "enableInboundForwarding" => {
                                Ok(__FieldTag::__enable_inbound_forwarding)
                            }
                            "enableLogging" => Ok(__FieldTag::__enable_logging),
                            "id" => Ok(__FieldTag::__id),
                            "kind" => Ok(__FieldTag::__kind),
                            "name" => Ok(__FieldTag::__name),
                            "networks" => Ok(__FieldTag::__networks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Policy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Policy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__alternative_name_server_config => {
                            if !fields.insert(__FieldTag::__alternative_name_server_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alternative_name_server_config",
                                ));
                            }
                            result.alternative_name_server_config = map
                                .next_value::<std::option::Option<
                                    crate::model::PolicyAlternativeNameServerConfig,
                                >>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__dns_64_config => {
                            if !fields.insert(__FieldTag::__dns_64_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_64_config",
                                ));
                            }
                            result.dns_64_config = map
                                .next_value::<std::option::Option<crate::model::PolicyDns64Config>>(
                                )?;
                        }
                        __FieldTag::__enable_inbound_forwarding => {
                            if !fields.insert(__FieldTag::__enable_inbound_forwarding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_inbound_forwarding",
                                ));
                            }
                            result.enable_inbound_forwarding =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__enable_logging => {
                            if !fields.insert(__FieldTag::__enable_logging) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_logging",
                                ));
                            }
                            result.enable_logging =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.id = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__networks => {
                            if !fields.insert(__FieldTag::__networks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networks",
                                ));
                            }
                            result.networks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::PolicyNetwork>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PolicyAlternativeNameServerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __target_name_servers,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicyAlternativeNameServerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "targetNameServers" => Ok(__FieldTag::__target_name_servers),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PolicyAlternativeNameServerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyAlternativeNameServerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__target_name_servers => {
                            if !fields.insert(__FieldTag::__target_name_servers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_name_servers",
                                ));
                            }
                            result.target_name_servers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::PolicyAlternativeNameServerConfigTargetNameServer>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PolicyAlternativeNameServerConfigTargetNameServer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __forwarding_path,
            __ipv_4_address,
            __ipv_6_address,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for PolicyAlternativeNameServerConfigTargetNameServer",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "forwardingPath" => Ok(__FieldTag::__forwarding_path),
                            "ipv4Address" => Ok(__FieldTag::__ipv_4_address),
                            "ipv6Address" => Ok(__FieldTag::__ipv_6_address),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PolicyAlternativeNameServerConfigTargetNameServer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyAlternativeNameServerConfigTargetNameServer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__forwarding_path => {
                            if !fields.insert(__FieldTag::__forwarding_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forwarding_path",
                                ));
                            }
                            result.forwarding_path = map.next_value::<std::option::Option<crate::model::policy_alternative_name_server_config_target_name_server::ForwardingPath>>()?
                                ;
                        }
                        __FieldTag::__ipv_4_address => {
                            if !fields.insert(__FieldTag::__ipv_4_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ipv_4_address",
                                ));
                            }
                            result.ipv_4_address =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__ipv_6_address => {
                            if !fields.insert(__FieldTag::__ipv_6_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ipv_6_address",
                                ));
                            }
                            result.ipv_6_address =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PolicyDns64Config {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicyDns64Config")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "scope" => Ok(__FieldTag::__scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PolicyDns64Config;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyDns64Config")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map.next_value::<std::option::Option<crate::model::PolicyDns64ConfigScope>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PolicyDns64ConfigScope {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __all_queries,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicyDns64ConfigScope")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allQueries" => Ok(__FieldTag::__all_queries),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PolicyDns64ConfigScope;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyDns64ConfigScope")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__all_queries => {
                            if !fields.insert(__FieldTag::__all_queries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all_queries",
                                ));
                            }
                            result.all_queries = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PolicyNetwork {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __network_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicyNetwork")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "networkUrl" => Ok(__FieldTag::__network_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PolicyNetwork;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyNetwork")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__network_url => {
                            if !fields.insert(__FieldTag::__network_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_url",
                                ));
                            }
                            result.network_url =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Project {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __kind,
            __number,
            __quota,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Project")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "kind" => Ok(__FieldTag::__kind),
                            "number" => Ok(__FieldTag::__number),
                            "quota" => Ok(__FieldTag::__quota),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Project;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Project")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__number => {
                            if !fields.insert(__FieldTag::__number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for number",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.number = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__quota => {
                            if !fields.insert(__FieldTag::__quota) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota",
                                ));
                            }
                            result.quota =
                                map.next_value::<std::option::Option<crate::model::Quota>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Quota {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dns_keys_per_managed_zone,
            __gke_clusters_per_managed_zone,
            __gke_clusters_per_policy,
            __gke_clusters_per_response_policy,
            __internet_health_checks_per_managed_zone,
            __items_per_routing_policy,
            __kind,
            __managed_zones,
            __managed_zones_per_gke_cluster,
            __managed_zones_per_network,
            __nameservers_per_delegation,
            __networks_per_managed_zone,
            __networks_per_policy,
            __networks_per_response_policy,
            __peering_zones_per_target_network,
            __policies,
            __resource_records_per_rrset,
            __response_policies,
            __response_policy_rules_per_response_policy,
            __rrset_additions_per_change,
            __rrset_deletions_per_change,
            __rrsets_per_managed_zone,
            __target_name_servers_per_managed_zone,
            __target_name_servers_per_policy,
            __total_rrdata_size_per_change,
            __whitelisted_key_specs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Quota")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dnsKeysPerManagedZone" => Ok(__FieldTag::__dns_keys_per_managed_zone),
                            "gkeClustersPerManagedZone" => {
                                Ok(__FieldTag::__gke_clusters_per_managed_zone)
                            }
                            "gkeClustersPerPolicy" => Ok(__FieldTag::__gke_clusters_per_policy),
                            "gkeClustersPerResponsePolicy" => {
                                Ok(__FieldTag::__gke_clusters_per_response_policy)
                            }
                            "internetHealthChecksPerManagedZone" => {
                                Ok(__FieldTag::__internet_health_checks_per_managed_zone)
                            }
                            "itemsPerRoutingPolicy" => Ok(__FieldTag::__items_per_routing_policy),
                            "kind" => Ok(__FieldTag::__kind),
                            "managedZones" => Ok(__FieldTag::__managed_zones),
                            "managedZonesPerGkeCluster" => {
                                Ok(__FieldTag::__managed_zones_per_gke_cluster)
                            }
                            "managedZonesPerNetwork" => Ok(__FieldTag::__managed_zones_per_network),
                            "nameserversPerDelegation" => {
                                Ok(__FieldTag::__nameservers_per_delegation)
                            }
                            "networksPerManagedZone" => Ok(__FieldTag::__networks_per_managed_zone),
                            "networksPerPolicy" => Ok(__FieldTag::__networks_per_policy),
                            "networksPerResponsePolicy" => {
                                Ok(__FieldTag::__networks_per_response_policy)
                            }
                            "peeringZonesPerTargetNetwork" => {
                                Ok(__FieldTag::__peering_zones_per_target_network)
                            }
                            "policies" => Ok(__FieldTag::__policies),
                            "resourceRecordsPerRrset" => {
                                Ok(__FieldTag::__resource_records_per_rrset)
                            }
                            "responsePolicies" => Ok(__FieldTag::__response_policies),
                            "responsePolicyRulesPerResponsePolicy" => {
                                Ok(__FieldTag::__response_policy_rules_per_response_policy)
                            }
                            "rrsetAdditionsPerChange" => {
                                Ok(__FieldTag::__rrset_additions_per_change)
                            }
                            "rrsetDeletionsPerChange" => {
                                Ok(__FieldTag::__rrset_deletions_per_change)
                            }
                            "rrsetsPerManagedZone" => Ok(__FieldTag::__rrsets_per_managed_zone),
                            "targetNameServersPerManagedZone" => {
                                Ok(__FieldTag::__target_name_servers_per_managed_zone)
                            }
                            "targetNameServersPerPolicy" => {
                                Ok(__FieldTag::__target_name_servers_per_policy)
                            }
                            "totalRrdataSizePerChange" => {
                                Ok(__FieldTag::__total_rrdata_size_per_change)
                            }
                            "whitelistedKeySpecs" => Ok(__FieldTag::__whitelisted_key_specs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Quota;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Quota")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dns_keys_per_managed_zone => {
                            if !fields.insert(__FieldTag::__dns_keys_per_managed_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_keys_per_managed_zone",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.dns_keys_per_managed_zone = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__gke_clusters_per_managed_zone => {
                            if !fields.insert(__FieldTag::__gke_clusters_per_managed_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_clusters_per_managed_zone",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.gke_clusters_per_managed_zone = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__gke_clusters_per_policy => {
                            if !fields.insert(__FieldTag::__gke_clusters_per_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_clusters_per_policy",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.gke_clusters_per_policy = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__gke_clusters_per_response_policy => {
                            if !fields.insert(__FieldTag::__gke_clusters_per_response_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_clusters_per_response_policy",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.gke_clusters_per_response_policy = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__internet_health_checks_per_managed_zone => {
                            if !fields.insert(__FieldTag::__internet_health_checks_per_managed_zone)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internet_health_checks_per_managed_zone",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.internet_health_checks_per_managed_zone =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__items_per_routing_policy => {
                            if !fields.insert(__FieldTag::__items_per_routing_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items_per_routing_policy",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.items_per_routing_policy = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__managed_zones => {
                            if !fields.insert(__FieldTag::__managed_zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_zones",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.managed_zones = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__managed_zones_per_gke_cluster => {
                            if !fields.insert(__FieldTag::__managed_zones_per_gke_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_zones_per_gke_cluster",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.managed_zones_per_gke_cluster = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__managed_zones_per_network => {
                            if !fields.insert(__FieldTag::__managed_zones_per_network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_zones_per_network",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.managed_zones_per_network = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__nameservers_per_delegation => {
                            if !fields.insert(__FieldTag::__nameservers_per_delegation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nameservers_per_delegation",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.nameservers_per_delegation = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__networks_per_managed_zone => {
                            if !fields.insert(__FieldTag::__networks_per_managed_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networks_per_managed_zone",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.networks_per_managed_zone = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__networks_per_policy => {
                            if !fields.insert(__FieldTag::__networks_per_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networks_per_policy",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.networks_per_policy = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__networks_per_response_policy => {
                            if !fields.insert(__FieldTag::__networks_per_response_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networks_per_response_policy",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.networks_per_response_policy = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__peering_zones_per_target_network => {
                            if !fields.insert(__FieldTag::__peering_zones_per_target_network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peering_zones_per_target_network",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.peering_zones_per_target_network = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__policies => {
                            if !fields.insert(__FieldTag::__policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policies",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.policies = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__resource_records_per_rrset => {
                            if !fields.insert(__FieldTag::__resource_records_per_rrset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_records_per_rrset",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.resource_records_per_rrset = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__response_policies => {
                            if !fields.insert(__FieldTag::__response_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_policies",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.response_policies = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__response_policy_rules_per_response_policy => {
                            if !fields
                                .insert(__FieldTag::__response_policy_rules_per_response_policy)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_policy_rules_per_response_policy",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.response_policy_rules_per_response_policy =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__rrset_additions_per_change => {
                            if !fields.insert(__FieldTag::__rrset_additions_per_change) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rrset_additions_per_change",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.rrset_additions_per_change = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__rrset_deletions_per_change => {
                            if !fields.insert(__FieldTag::__rrset_deletions_per_change) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rrset_deletions_per_change",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.rrset_deletions_per_change = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__rrsets_per_managed_zone => {
                            if !fields.insert(__FieldTag::__rrsets_per_managed_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rrsets_per_managed_zone",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.rrsets_per_managed_zone = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__target_name_servers_per_managed_zone => {
                            if !fields.insert(__FieldTag::__target_name_servers_per_managed_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_name_servers_per_managed_zone",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_name_servers_per_managed_zone =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__target_name_servers_per_policy => {
                            if !fields.insert(__FieldTag::__target_name_servers_per_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_name_servers_per_policy",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_name_servers_per_policy = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__total_rrdata_size_per_change => {
                            if !fields.insert(__FieldTag::__total_rrdata_size_per_change) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_rrdata_size_per_change",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_rrdata_size_per_change = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__whitelisted_key_specs => {
                            if !fields.insert(__FieldTag::__whitelisted_key_specs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for whitelisted_key_specs",
                                ));
                            }
                            result.whitelisted_key_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DnsKeySpec>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RRSetRoutingPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __geo,
            __health_check,
            __kind,
            __primary_backup,
            __wrr,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RRSetRoutingPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "geo" => Ok(__FieldTag::__geo),
                            "healthCheck" => Ok(__FieldTag::__health_check),
                            "kind" => Ok(__FieldTag::__kind),
                            "primaryBackup" => Ok(__FieldTag::__primary_backup),
                            "wrr" => Ok(__FieldTag::__wrr),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RRSetRoutingPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RRSetRoutingPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__geo => {
                            if !fields.insert(__FieldTag::__geo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for geo",
                                ));
                            }
                            result.geo = map.next_value::<std::option::Option<crate::model::RRSetRoutingPolicyGeoPolicy>>()?
                                ;
                        }
                        __FieldTag::__health_check => {
                            if !fields.insert(__FieldTag::__health_check) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check",
                                ));
                            }
                            result.health_check =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__primary_backup => {
                            if !fields.insert(__FieldTag::__primary_backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_backup",
                                ));
                            }
                            result.primary_backup = map.next_value::<std::option::Option<
                                crate::model::RRSetRoutingPolicyPrimaryBackupPolicy,
                            >>()?;
                        }
                        __FieldTag::__wrr => {
                            if !fields.insert(__FieldTag::__wrr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wrr",
                                ));
                            }
                            result.wrr = map.next_value::<std::option::Option<crate::model::RRSetRoutingPolicyWrrPolicy>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RRSetRoutingPolicyGeoPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_fencing,
            __items,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RRSetRoutingPolicyGeoPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableFencing" => Ok(__FieldTag::__enable_fencing),
                            "items" => Ok(__FieldTag::__items),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RRSetRoutingPolicyGeoPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RRSetRoutingPolicyGeoPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_fencing => {
                            if !fields.insert(__FieldTag::__enable_fencing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_fencing",
                                ));
                            }
                            result.enable_fencing =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::RRSetRoutingPolicyGeoPolicyGeoPolicyItem,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RRSetRoutingPolicyGeoPolicyGeoPolicyItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __health_checked_targets,
            __kind,
            __location,
            __rrdatas,
            __signature_rrdatas,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for RRSetRoutingPolicyGeoPolicyGeoPolicyItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "healthCheckedTargets" => Ok(__FieldTag::__health_checked_targets),
                            "kind" => Ok(__FieldTag::__kind),
                            "location" => Ok(__FieldTag::__location),
                            "rrdatas" => Ok(__FieldTag::__rrdatas),
                            "signatureRrdatas" => Ok(__FieldTag::__signature_rrdatas),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RRSetRoutingPolicyGeoPolicyGeoPolicyItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RRSetRoutingPolicyGeoPolicyGeoPolicyItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__health_checked_targets => {
                            if !fields.insert(__FieldTag::__health_checked_targets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_checked_targets",
                                ));
                            }
                            result.health_checked_targets = map.next_value::<std::option::Option<
                                crate::model::RRSetRoutingPolicyHealthCheckTargets,
                            >>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__rrdatas => {
                            if !fields.insert(__FieldTag::__rrdatas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rrdatas",
                                ));
                            }
                            result.rrdatas = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__signature_rrdatas => {
                            if !fields.insert(__FieldTag::__signature_rrdatas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signature_rrdatas",
                                ));
                            }
                            result.signature_rrdatas = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RRSetRoutingPolicyHealthCheckTargets {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __external_endpoints,
            __internal_load_balancers,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RRSetRoutingPolicyHealthCheckTargets")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "externalEndpoints" => Ok(__FieldTag::__external_endpoints),
                            "internalLoadBalancers" => Ok(__FieldTag::__internal_load_balancers),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RRSetRoutingPolicyHealthCheckTargets;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RRSetRoutingPolicyHealthCheckTargets")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__external_endpoints => {
                            if !fields.insert(__FieldTag::__external_endpoints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_endpoints",
                                ));
                            }
                            result.external_endpoints = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__internal_load_balancers => {
                            if !fields.insert(__FieldTag::__internal_load_balancers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_load_balancers",
                                ));
                            }
                            result.internal_load_balancers = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::RRSetRoutingPolicyLoadBalancerTarget,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RRSetRoutingPolicyLoadBalancerTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ip_address,
            __ip_protocol,
            __kind,
            __load_balancer_type,
            __network_url,
            __port,
            __project,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RRSetRoutingPolicyLoadBalancerTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ipProtocol" => Ok(__FieldTag::__ip_protocol),
                            "kind" => Ok(__FieldTag::__kind),
                            "loadBalancerType" => Ok(__FieldTag::__load_balancer_type),
                            "networkUrl" => Ok(__FieldTag::__network_url),
                            "port" => Ok(__FieldTag::__port),
                            "project" => Ok(__FieldTag::__project),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RRSetRoutingPolicyLoadBalancerTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RRSetRoutingPolicyLoadBalancerTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__ip_protocol => {
                            if !fields.insert(__FieldTag::__ip_protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_protocol",
                                ));
                            }
                            result.ip_protocol = map.next_value::<std::option::Option<crate::model::rr_set_routing_policy_load_balancer_target::IpProtocol>>()?
                                ;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__load_balancer_type => {
                            if !fields.insert(__FieldTag::__load_balancer_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer_type",
                                ));
                            }
                            result.load_balancer_type = map.next_value::<std::option::Option<crate::model::rr_set_routing_policy_load_balancer_target::LoadBalancerType>>()?
                                ;
                        }
                        __FieldTag::__network_url => {
                            if !fields.insert(__FieldTag::__network_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_url",
                                ));
                            }
                            result.network_url =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            result.port =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RRSetRoutingPolicyPrimaryBackupPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_geo_targets,
            __kind,
            __primary_targets,
            __trickle_traffic,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for RRSetRoutingPolicyPrimaryBackupPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupGeoTargets" => Ok(__FieldTag::__backup_geo_targets),
                            "kind" => Ok(__FieldTag::__kind),
                            "primaryTargets" => Ok(__FieldTag::__primary_targets),
                            "trickleTraffic" => Ok(__FieldTag::__trickle_traffic),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RRSetRoutingPolicyPrimaryBackupPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RRSetRoutingPolicyPrimaryBackupPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_geo_targets => {
                            if !fields.insert(__FieldTag::__backup_geo_targets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_geo_targets",
                                ));
                            }
                            result.backup_geo_targets = map.next_value::<std::option::Option<crate::model::RRSetRoutingPolicyGeoPolicy>>()?
                                ;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__primary_targets => {
                            if !fields.insert(__FieldTag::__primary_targets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_targets",
                                ));
                            }
                            result.primary_targets = map.next_value::<std::option::Option<
                                crate::model::RRSetRoutingPolicyHealthCheckTargets,
                            >>()?;
                        }
                        __FieldTag::__trickle_traffic => {
                            if !fields.insert(__FieldTag::__trickle_traffic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trickle_traffic",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.trickle_traffic = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RRSetRoutingPolicyWrrPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __items,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RRSetRoutingPolicyWrrPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "items" => Ok(__FieldTag::__items),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RRSetRoutingPolicyWrrPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RRSetRoutingPolicyWrrPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::RRSetRoutingPolicyWrrPolicyWrrPolicyItem,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RRSetRoutingPolicyWrrPolicyWrrPolicyItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __health_checked_targets,
            __kind,
            __rrdatas,
            __signature_rrdatas,
            __weight,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for RRSetRoutingPolicyWrrPolicyWrrPolicyItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "healthCheckedTargets" => Ok(__FieldTag::__health_checked_targets),
                            "kind" => Ok(__FieldTag::__kind),
                            "rrdatas" => Ok(__FieldTag::__rrdatas),
                            "signatureRrdatas" => Ok(__FieldTag::__signature_rrdatas),
                            "weight" => Ok(__FieldTag::__weight),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RRSetRoutingPolicyWrrPolicyWrrPolicyItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RRSetRoutingPolicyWrrPolicyWrrPolicyItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__health_checked_targets => {
                            if !fields.insert(__FieldTag::__health_checked_targets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_checked_targets",
                                ));
                            }
                            result.health_checked_targets = map.next_value::<std::option::Option<
                                crate::model::RRSetRoutingPolicyHealthCheckTargets,
                            >>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__rrdatas => {
                            if !fields.insert(__FieldTag::__rrdatas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rrdatas",
                                ));
                            }
                            result.rrdatas = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__signature_rrdatas => {
                            if !fields.insert(__FieldTag::__signature_rrdatas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signature_rrdatas",
                                ));
                            }
                            result.signature_rrdatas = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__weight => {
                            if !fields.insert(__FieldTag::__weight) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weight",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.weight = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResourceRecordSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __name,
            __routing_policy,
            __rrdatas,
            __signature_rrdatas,
            __ttl,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceRecordSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "name" => Ok(__FieldTag::__name),
                            "routingPolicy" => Ok(__FieldTag::__routing_policy),
                            "rrdatas" => Ok(__FieldTag::__rrdatas),
                            "signatureRrdatas" => Ok(__FieldTag::__signature_rrdatas),
                            "ttl" => Ok(__FieldTag::__ttl),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResourceRecordSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceRecordSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__routing_policy => {
                            if !fields.insert(__FieldTag::__routing_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routing_policy",
                                ));
                            }
                            result.routing_policy = map.next_value::<std::option::Option<crate::model::RRSetRoutingPolicy>>()?
                                ;
                        }
                        __FieldTag::__rrdatas => {
                            if !fields.insert(__FieldTag::__rrdatas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rrdatas",
                                ));
                            }
                            result.rrdatas = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__signature_rrdatas => {
                            if !fields.insert(__FieldTag::__signature_rrdatas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signature_rrdatas",
                                ));
                            }
                            result.signature_rrdatas = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ttl = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResourceRecordSetsDeleteResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceRecordSetsDeleteResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResourceRecordSetsDeleteResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceRecordSetsDeleteResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResourceRecordSetsListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __next_page_token,
            __rrsets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceRecordSetsListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "rrsets" => Ok(__FieldTag::__rrsets),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResourceRecordSetsListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceRecordSetsListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__rrsets => {
                            if !fields.insert(__FieldTag::__rrsets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rrsets",
                                ));
                            }
                            result.rrsets =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResourceRecordSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResponsePoliciesListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __next_page_token,
            __response_policies,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponsePoliciesListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "responsePolicies" => Ok(__FieldTag::__response_policies),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResponsePoliciesListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponsePoliciesListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__response_policies => {
                            if !fields.insert(__FieldTag::__response_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_policies",
                                ));
                            }
                            result.response_policies =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResponsePolicy>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResponsePoliciesPatchResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponsePoliciesPatchResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responsePolicy" => Ok(__FieldTag::__response_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResponsePoliciesPatchResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponsePoliciesPatchResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_policy => {
                            if !fields.insert(__FieldTag::__response_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_policy",
                                ));
                            }
                            result.response_policy = map
                                .next_value::<std::option::Option<crate::model::ResponsePolicy>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResponsePoliciesUpdateResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponsePoliciesUpdateResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responsePolicy" => Ok(__FieldTag::__response_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResponsePoliciesUpdateResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponsePoliciesUpdateResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_policy => {
                            if !fields.insert(__FieldTag::__response_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_policy",
                                ));
                            }
                            result.response_policy = map
                                .next_value::<std::option::Option<crate::model::ResponsePolicy>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResponsePolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __description,
            __gke_clusters,
            __id,
            __kind,
            __labels,
            __networks,
            __response_policy_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponsePolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "description" => Ok(__FieldTag::__description),
                            "gkeClusters" => Ok(__FieldTag::__gke_clusters),
                            "id" => Ok(__FieldTag::__id),
                            "kind" => Ok(__FieldTag::__kind),
                            "labels" => Ok(__FieldTag::__labels),
                            "networks" => Ok(__FieldTag::__networks),
                            "responsePolicyName" => Ok(__FieldTag::__response_policy_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResponsePolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponsePolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__gke_clusters => {
                            if !fields.insert(__FieldTag::__gke_clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_clusters",
                                ));
                            }
                            result.gke_clusters = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResponsePolicyGKECluster>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.id = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__networks => {
                            if !fields.insert(__FieldTag::__networks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networks",
                                ));
                            }
                            result.networks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResponsePolicyNetwork>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__response_policy_name => {
                            if !fields.insert(__FieldTag::__response_policy_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_policy_name",
                                ));
                            }
                            result.response_policy_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResponsePolicyGKECluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gke_cluster_name,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponsePolicyGKECluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gkeClusterName" => Ok(__FieldTag::__gke_cluster_name),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResponsePolicyGKECluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponsePolicyGKECluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gke_cluster_name => {
                            if !fields.insert(__FieldTag::__gke_cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_cluster_name",
                                ));
                            }
                            result.gke_cluster_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResponsePolicyNetwork {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __network_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponsePolicyNetwork")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "networkUrl" => Ok(__FieldTag::__network_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResponsePolicyNetwork;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponsePolicyNetwork")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__network_url => {
                            if !fields.insert(__FieldTag::__network_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_url",
                                ));
                            }
                            result.network_url =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResponsePolicyRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __behavior,
            __dns_name,
            __kind,
            __local_data,
            __rule_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponsePolicyRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "behavior" => Ok(__FieldTag::__behavior),
                            "dnsName" => Ok(__FieldTag::__dns_name),
                            "kind" => Ok(__FieldTag::__kind),
                            "localData" => Ok(__FieldTag::__local_data),
                            "ruleName" => Ok(__FieldTag::__rule_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResponsePolicyRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponsePolicyRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__behavior => {
                            if !fields.insert(__FieldTag::__behavior) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for behavior",
                                ));
                            }
                            result.behavior =
                                map.next_value::<std::option::Option<
                                    crate::model::response_policy_rule::Behavior,
                                >>()?;
                        }
                        __FieldTag::__dns_name => {
                            if !fields.insert(__FieldTag::__dns_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_name",
                                ));
                            }
                            result.dns_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__local_data => {
                            if !fields.insert(__FieldTag::__local_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_data",
                                ));
                            }
                            result.local_data = map.next_value::<std::option::Option<crate::model::ResponsePolicyRuleLocalData>>()?
                                ;
                        }
                        __FieldTag::__rule_name => {
                            if !fields.insert(__FieldTag::__rule_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_name",
                                ));
                            }
                            result.rule_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResponsePolicyRuleLocalData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __local_datas,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponsePolicyRuleLocalData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "localDatas" => Ok(__FieldTag::__local_datas),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResponsePolicyRuleLocalData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponsePolicyRuleLocalData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__local_datas => {
                            if !fields.insert(__FieldTag::__local_datas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_datas",
                                ));
                            }
                            result.local_datas =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResourceRecordSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResponsePolicyRulesListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __next_page_token,
            __response_policy_rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponsePolicyRulesListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "responsePolicyRules" => Ok(__FieldTag::__response_policy_rules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResponsePolicyRulesListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponsePolicyRulesListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__response_policy_rules => {
                            if !fields.insert(__FieldTag::__response_policy_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_policy_rules",
                                ));
                            }
                            result.response_policy_rules = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResponsePolicyRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResponsePolicyRulesPatchResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_policy_rule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponsePolicyRulesPatchResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responsePolicyRule" => Ok(__FieldTag::__response_policy_rule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResponsePolicyRulesPatchResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponsePolicyRulesPatchResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_policy_rule => {
                            if !fields.insert(__FieldTag::__response_policy_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_policy_rule",
                                ));
                            }
                            result.response_policy_rule = map.next_value::<std::option::Option<crate::model::ResponsePolicyRule>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResponsePolicyRulesUpdateResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_policy_rule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponsePolicyRulesUpdateResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responsePolicyRule" => Ok(__FieldTag::__response_policy_rule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResponsePolicyRulesUpdateResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponsePolicyRulesUpdateResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_policy_rule => {
                            if !fields.insert(__FieldTag::__response_policy_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_policy_rule",
                                ));
                            }
                            result.response_policy_rule = map.next_value::<std::option::Option<crate::model::ResponsePolicyRule>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
