// Copyright 2026 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use crate::Error;
use crate::Result;

/// Implements [Changes](super::stub::Changes) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Changes {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Changes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Changes")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Changes {
    pub async fn new(config: gaxi::options::ClientConfig) -> crate::ClientBuilderResult<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Changes for Changes {
    async fn create(
        &self,
        req: crate::model::changes::CreateRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::Change>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}/changes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::POST, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::changes::GetRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::Change>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}/changes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.change_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.change_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "change_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::changes::ListRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ChangesListResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}/changes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .sort_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("sortBy", p)]));
                let builder = req
                    .sort_order
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("sortOrder", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [DnsKeys](super::stub::DnsKeys) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct DnsKeys {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for DnsKeys {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("DnsKeys")
            .field("inner", &self.inner)
            .finish()
    }
}

impl DnsKeys {
    pub async fn new(config: gaxi::options::ClientConfig) -> crate::ClientBuilderResult<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::DnsKeys for DnsKeys {
    async fn get(
        &self,
        req: crate::model::dns_keys::GetRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::DnsKey>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}/dnsKeys/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.dns_key_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = req
                    .digest_type
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("digestType", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.dns_key_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "dns_key_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::dns_keys::ListRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::DnsKeysListResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}/dnsKeys",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req
                    .digest_type
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("digestType", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [ManagedZoneOperations](super::stub::ManagedZoneOperations) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ManagedZoneOperations {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ManagedZoneOperations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ManagedZoneOperations")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ManagedZoneOperations {
    pub async fn new(config: gaxi::options::ClientConfig) -> crate::ClientBuilderResult<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ManagedZoneOperations for ManagedZoneOperations {
    async fn get(
        &self,
        req: crate::model::managed_zone_operations::GetRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::Operation>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::managed_zone_operations::ListRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ManagedZoneOperationsListResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}/operations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .sort_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("sortBy", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [ManagedZones](super::stub::ManagedZones) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ManagedZones {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ManagedZones {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ManagedZones")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ManagedZones {
    pub async fn new(config: gaxi::options::ClientConfig) -> crate::ClientBuilderResult<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ManagedZones for ManagedZones {
    async fn create(
        &self,
        req: crate::model::managed_zones::CreateRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ManagedZone>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::POST, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::managed_zones::DeleteRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<()>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::DELETE, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner
            .execute(builder, body, options)
            .await
            .map(|r: crate::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                crate::Response::from_parts(parts, ())
            })
    }

    async fn get(
        &self,
        req: crate::model::managed_zones::GetRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ManagedZone>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::managed_zones::GetIamPolicyRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::GoogleIamV1Policy>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/{}:getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::MultiWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::MultiWildcard],
                        "resource",
                        "**",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::managed_zones::ListRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ManagedZonesListResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req
                    .dns_name
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("dnsName", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::managed_zones::PatchRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::Operation>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::PATCH, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::managed_zones::SetIamPolicyRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::GoogleIamV1Policy>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/{}:setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::MultiWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::MultiWildcard],
                        "resource",
                        "**",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::managed_zones::TestIamPermissionsRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::GoogleIamV1TestIamPermissionsResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/{}:testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::MultiWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::MultiWildcard],
                        "resource",
                        "**",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::managed_zones::UpdateRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::Operation>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::PUT, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::managed_zone_operations::GetRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::Operation>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &crate::RequestOptions,
    ) -> std::sync::Arc<dyn google_cloud_gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &crate::RequestOptions,
    ) -> std::sync::Arc<dyn google_cloud_gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Policies](super::stub::Policies) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Policies {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Policies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Policies")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Policies {
    pub async fn new(config: gaxi::options::ClientConfig) -> crate::ClientBuilderResult<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Policies for Policies {
    async fn create(
        &self,
        req: crate::model::policies::CreateRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::Policy>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/policies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::POST, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::policies::DeleteRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<()>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/policies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::DELETE, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner
            .execute(builder, body, options)
            .await
            .map(|r: crate::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                crate::Response::from_parts(parts, ())
            })
    }

    async fn get(
        &self,
        req: crate::model::policies::GetRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::Policy>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/policies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::policies::ListRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::PoliciesListResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/policies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::policies::PatchRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::PoliciesPatchResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/policies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::PATCH, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::policies::UpdateRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::PoliciesUpdateResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/policies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::PUT, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [Projects](super::stub::Projects) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Projects {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Projects {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Projects")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Projects {
    pub async fn new(config: gaxi::options::ClientConfig) -> crate::ClientBuilderResult<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Projects for Projects {
    async fn get(
        &self,
        req: crate::model::projects::GetRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::Project>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [ResourceRecordSets](super::stub::ResourceRecordSets) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ResourceRecordSets {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ResourceRecordSets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ResourceRecordSets")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ResourceRecordSets {
    pub async fn new(config: gaxi::options::ClientConfig) -> crate::ClientBuilderResult<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ResourceRecordSets for ResourceRecordSets {
    async fn create(
        &self,
        req: crate::model::resource_record_sets::CreateRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResourceRecordSet>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}/rrsets",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::POST, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::resource_record_sets::DeleteRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResourceRecordSetsDeleteResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}/rrsets/{}/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.r#type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::DELETE, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "name",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.r#type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "r#type",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::resource_record_sets::GetRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResourceRecordSet>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}/rrsets/{}/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.r#type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "name",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.r#type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "r#type",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::resource_record_sets::ListRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResourceRecordSetsListResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}/rrsets",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .name
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("name", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .r#type
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("type", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::resource_record_sets::PatchRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResourceRecordSet>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/managedZones/{}/rrsets/{}/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.r#type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::PATCH, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.managed_zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "managed_zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "name",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.r#type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "r#type",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [ResponsePolicies](super::stub::ResponsePolicies) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ResponsePolicies {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ResponsePolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ResponsePolicies")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ResponsePolicies {
    pub async fn new(config: gaxi::options::ClientConfig) -> crate::ClientBuilderResult<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ResponsePolicies for ResponsePolicies {
    async fn create(
        &self,
        req: crate::model::response_policies::CreateRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResponsePolicy>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/responsePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::POST, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::response_policies::DeleteRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<()>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/responsePolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::DELETE, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner
            .execute(builder, body, options)
            .await
            .map(|r: crate::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                crate::Response::from_parts(parts, ())
            })
    }

    async fn get(
        &self,
        req: crate::model::response_policies::GetRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResponsePolicy>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/responsePolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::response_policies::ListRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResponsePoliciesListResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/responsePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::response_policies::PatchRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResponsePoliciesPatchResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/responsePolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::PATCH, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::response_policies::UpdateRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResponsePoliciesUpdateResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/responsePolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::PUT, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [ResponsePolicyRules](super::stub::ResponsePolicyRules) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ResponsePolicyRules {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ResponsePolicyRules {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ResponsePolicyRules")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ResponsePolicyRules {
    pub async fn new(config: gaxi::options::ClientConfig) -> crate::ClientBuilderResult<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ResponsePolicyRules for ResponsePolicyRules {
    async fn create(
        &self,
        req: crate::model::response_policy_rules::CreateRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResponsePolicyRule>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/responsePolicies/{}/rules",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::POST, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::response_policy_rules::DeleteRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<()>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/responsePolicies/{}/rules/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.response_policy_rule)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::DELETE, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.response_policy_rule)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy_rule",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner
            .execute(builder, body, options)
            .await
            .map(|r: crate::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                crate::Response::from_parts(parts, ())
            })
    }

    async fn get(
        &self,
        req: crate::model::response_policy_rules::GetRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResponsePolicyRule>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/responsePolicies/{}/rules/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.response_policy_rule)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.response_policy_rule)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy_rule",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::response_policy_rules::ListRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResponsePolicyRulesListResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/responsePolicies/{}/rules",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::GET, path);
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::response_policy_rules::PatchRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResponsePolicyRulesPatchResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/responsePolicies/{}/rules/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.response_policy_rule)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::PATCH, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.response_policy_rule)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy_rule",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::response_policy_rules::UpdateRequest,
        options: crate::RequestOptions,
    ) -> Result<crate::Response<crate::model::ResponsePolicyRulesUpdateResponse>> {
        use gaxi::http::reqwest::{HeaderValue, Method};
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        use google_cloud_gax::error::binding::BindingError;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/dns/v1/projects/{}/responsePolicies/{}/rules/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.response_policy_rule)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(Method::PUT, path);
                let builder = req.client_operation_id.iter().fold(builder, |builder, p| {
                    builder.query(&[("clientOperationId", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.response_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.response_policy_rule)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "response_policy_rule",
                        "*",
                    );
                    paths.push(builder.build());
                }
                google_cloud_gax::error::Error::binding(BindingError { paths })
            })??;
        let options = google_cloud_gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }
}
