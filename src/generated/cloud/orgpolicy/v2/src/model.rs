// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A constraint describes a way to restrict resource's configuration. For
/// example, you could enforce a constraint that controls which Google Cloud
/// services can be activated across an organization, or whether a Compute Engine
/// instance can have serial port connections established. Constraints can be
/// configured by the organization policy administrator to fit the needs of the
/// organization by setting a policy that includes constraints at different
/// locations in the organization's resource hierarchy. Policies are inherited
/// down the resource hierarchy from higher levels, but can also be overridden.
/// For details about the inheritance rules, see
/// [`Policy`][google.cloud.orgpolicy.v2.Policy].
///
/// Constraints have a default behavior determined by the `constraint_default`
/// field, which is the enforcement behavior that is used in the absence of a
/// policy being defined or inherited for the resource in question.
///
/// [google.cloud.orgpolicy.v2.Policy]: crate::model::Policy
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Constraint {
    /// Immutable. The resource name of the constraint. Must be in one of
    /// the following forms:
    ///
    /// * `projects/{project_number}/constraints/{constraint_name}`
    /// * `folders/{folder_id}/constraints/{constraint_name}`
    /// * `organizations/{organization_id}/constraints/{constraint_name}`
    ///
    /// For example, "/projects/123/constraints/compute.disableSerialPortAccess".
    pub name: std::string::String,

    /// The human readable name.
    ///
    /// Mutable.
    pub display_name: std::string::String,

    /// Detailed description of what this constraint controls as well as how and
    /// where it is enforced.
    ///
    /// Mutable.
    pub description: std::string::String,

    /// The evaluation behavior of this constraint in the absence of a policy.
    pub constraint_default: crate::model::constraint::ConstraintDefault,

    /// Shows if dry run is supported for this constraint or not.
    pub supports_dry_run: bool,

    /// Managed constraint and canned constraint sometimes can have
    /// equivalents. This field is used to store the equivalent constraint name.
    pub equivalent_constraint: std::string::String,

    /// Shows if simulation is supported for this constraint or not.
    pub supports_simulation: bool,

    /// The type of restrictions for this `Constraint`.
    ///
    /// Immutable after creation.
    pub constraint_type: std::option::Option<crate::model::constraint::ConstraintType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Constraint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Constraint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Constraint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Constraint::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [constraint_default][crate::model::Constraint::constraint_default].
    pub fn set_constraint_default<
        T: std::convert::Into<crate::model::constraint::ConstraintDefault>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_default = v.into();
        self
    }

    /// Sets the value of [supports_dry_run][crate::model::Constraint::supports_dry_run].
    pub fn set_supports_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.supports_dry_run = v.into();
        self
    }

    /// Sets the value of [equivalent_constraint][crate::model::Constraint::equivalent_constraint].
    pub fn set_equivalent_constraint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.equivalent_constraint = v.into();
        self
    }

    /// Sets the value of [supports_simulation][crate::model::Constraint::supports_simulation].
    pub fn set_supports_simulation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.supports_simulation = v.into();
        self
    }

    /// Sets the value of [constraint_type][crate::model::Constraint::constraint_type].
    ///
    /// Note that all the setters affecting `constraint_type` are mutually
    /// exclusive.
    pub fn set_constraint_type<
        T: std::convert::Into<std::option::Option<crate::model::constraint::ConstraintType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_type = v.into();
        self
    }

    /// The value of [constraint_type][crate::model::Constraint::constraint_type]
    /// if it holds a `ListConstraint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn list_constraint(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::constraint::ListConstraint>> {
        #[allow(unreachable_patterns)]
        self.constraint_type.as_ref().and_then(|v| match v {
            crate::model::constraint::ConstraintType::ListConstraint(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [constraint_type][crate::model::Constraint::constraint_type]
    /// to hold a `ListConstraint`.
    ///
    /// Note that all the setters affecting `constraint_type` are
    /// mutually exclusive.
    pub fn set_list_constraint<
        T: std::convert::Into<std::boxed::Box<crate::model::constraint::ListConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_type = std::option::Option::Some(
            crate::model::constraint::ConstraintType::ListConstraint(v.into()),
        );
        self
    }

    /// The value of [constraint_type][crate::model::Constraint::constraint_type]
    /// if it holds a `BooleanConstraint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn boolean_constraint(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::constraint::BooleanConstraint>> {
        #[allow(unreachable_patterns)]
        self.constraint_type.as_ref().and_then(|v| match v {
            crate::model::constraint::ConstraintType::BooleanConstraint(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [constraint_type][crate::model::Constraint::constraint_type]
    /// to hold a `BooleanConstraint`.
    ///
    /// Note that all the setters affecting `constraint_type` are
    /// mutually exclusive.
    pub fn set_boolean_constraint<
        T: std::convert::Into<std::boxed::Box<crate::model::constraint::BooleanConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_type = std::option::Option::Some(
            crate::model::constraint::ConstraintType::BooleanConstraint(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Constraint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Constraint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __constraint_default,
            __list_constraint,
            __boolean_constraint,
            __supports_dry_run,
            __equivalent_constraint,
            __supports_simulation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Constraint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "constraintDefault" => Ok(__FieldTag::__constraint_default),
                            "constraint_default" => Ok(__FieldTag::__constraint_default),
                            "listConstraint" => Ok(__FieldTag::__list_constraint),
                            "list_constraint" => Ok(__FieldTag::__list_constraint),
                            "booleanConstraint" => Ok(__FieldTag::__boolean_constraint),
                            "boolean_constraint" => Ok(__FieldTag::__boolean_constraint),
                            "supportsDryRun" => Ok(__FieldTag::__supports_dry_run),
                            "supports_dry_run" => Ok(__FieldTag::__supports_dry_run),
                            "equivalentConstraint" => Ok(__FieldTag::__equivalent_constraint),
                            "equivalent_constraint" => Ok(__FieldTag::__equivalent_constraint),
                            "supportsSimulation" => Ok(__FieldTag::__supports_simulation),
                            "supports_simulation" => Ok(__FieldTag::__supports_simulation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Constraint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Constraint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__constraint_default => {
                            if !fields.insert(__FieldTag::__constraint_default) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraint_default",
                                ));
                            }
                            result.constraint_default =
                                map.next_value::<std::option::Option<
                                    crate::model::constraint::ConstraintDefault,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__list_constraint => {
                            if !fields.insert(__FieldTag::__list_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for list_constraint",
                                ));
                            }
                            if result.constraint_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `constraint_type`, a oneof with full ID .google.cloud.orgpolicy.v2.Constraint.list_constraint, latest field was listConstraint",
                                ));
                            }
                            result.constraint_type = std::option::Option::Some(
                                crate::model::constraint::ConstraintType::ListConstraint(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::constraint::ListConstraint>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__boolean_constraint => {
                            if !fields.insert(__FieldTag::__boolean_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boolean_constraint",
                                ));
                            }
                            if result.constraint_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `constraint_type`, a oneof with full ID .google.cloud.orgpolicy.v2.Constraint.boolean_constraint, latest field was booleanConstraint",
                                ));
                            }
                            result.constraint_type = std::option::Option::Some(
                                crate::model::constraint::ConstraintType::BooleanConstraint(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::constraint::BooleanConstraint,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__supports_dry_run => {
                            if !fields.insert(__FieldTag::__supports_dry_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supports_dry_run",
                                ));
                            }
                            result.supports_dry_run = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__equivalent_constraint => {
                            if !fields.insert(__FieldTag::__equivalent_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for equivalent_constraint",
                                ));
                            }
                            result.equivalent_constraint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supports_simulation => {
                            if !fields.insert(__FieldTag::__supports_simulation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supports_simulation",
                                ));
                            }
                            result.supports_simulation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Constraint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.constraint_default) {
            state.serialize_entry("constraintDefault", &self.constraint_default)?;
        }
        if let Some(value) = self.list_constraint() {
            state.serialize_entry("listConstraint", value)?;
        }
        if let Some(value) = self.boolean_constraint() {
            state.serialize_entry("booleanConstraint", value)?;
        }
        if !wkt::internal::is_default(&self.supports_dry_run) {
            state.serialize_entry("supportsDryRun", &self.supports_dry_run)?;
        }
        if !self.equivalent_constraint.is_empty() {
            state.serialize_entry("equivalentConstraint", &self.equivalent_constraint)?;
        }
        if !wkt::internal::is_default(&self.supports_simulation) {
            state.serialize_entry("supportsSimulation", &self.supports_simulation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Constraint].
pub mod constraint {
    #[allow(unused_imports)]
    use super::*;

    /// A constraint type that allows or disallows a list of string values, which
    /// are configured in the
    /// [`PolicyRule`][google.cloud.orgpolicy.v2.PolicySpec.PolicyRule].
    ///
    /// [google.cloud.orgpolicy.v2.PolicySpec.PolicyRule]: crate::model::policy_spec::PolicyRule
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListConstraint {
        /// Indicates whether values grouped into categories can be used in
        /// `Policy.allowed_values` and `Policy.denied_values`. For example,
        /// `"in:Python"` would match any value in the 'Python' group.
        pub supports_in: bool,

        /// Indicates whether subtrees of the Resource Manager resource hierarchy
        /// can be used in `Policy.allowed_values` and `Policy.denied_values`. For
        /// example, `"under:folders/123"` would match any resource under the
        /// 'folders/123' folder.
        pub supports_under: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ListConstraint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [supports_in][crate::model::constraint::ListConstraint::supports_in].
        pub fn set_supports_in<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.supports_in = v.into();
            self
        }

        /// Sets the value of [supports_under][crate::model::constraint::ListConstraint::supports_under].
        pub fn set_supports_under<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.supports_under = v.into();
            self
        }
    }

    impl wkt::message::Message for ListConstraint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint.ListConstraint"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ListConstraint {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __supports_in,
                __supports_under,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ListConstraint")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "supportsIn" => Ok(__FieldTag::__supports_in),
                                "supports_in" => Ok(__FieldTag::__supports_in),
                                "supportsUnder" => Ok(__FieldTag::__supports_under),
                                "supports_under" => Ok(__FieldTag::__supports_under),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ListConstraint;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ListConstraint")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__supports_in => {
                                if !fields.insert(__FieldTag::__supports_in) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for supports_in",
                                    ));
                                }
                                result.supports_in = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__supports_under => {
                                if !fields.insert(__FieldTag::__supports_under) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for supports_under",
                                    ));
                                }
                                result.supports_under = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ListConstraint {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.supports_in) {
                state.serialize_entry("supportsIn", &self.supports_in)?;
            }
            if !wkt::internal::is_default(&self.supports_under) {
                state.serialize_entry("supportsUnder", &self.supports_under)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Custom constraint definition. Defines this as a managed constraint.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CustomConstraintDefinition {
        /// The resource instance type on which this policy applies. Format will be
        /// of the form : `<service name>/<type>` Example:
        ///
        /// * `compute.googleapis.com/Instance`.
        pub resource_types: std::vec::Vec<std::string::String>,

        /// All the operations being applied for this constraint.
        pub method_types:
            std::vec::Vec<crate::model::constraint::custom_constraint_definition::MethodType>,

        /// Org policy condition/expression. For example:
        /// `resource.instanceName.matches("[production|test]_.*_(\d)+")` or,
        /// `resource.management.auto_upgrade == true`
        ///
        /// The max length of the condition is 1000 characters.
        pub condition: std::string::String,

        /// Allow or deny type.
        pub action_type: crate::model::constraint::custom_constraint_definition::ActionType,

        /// Stores the structure of
        /// [`Parameters`][google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.Parameter]
        /// used by the constraint condition. The key of `map` represents the name of
        /// the parameter.
        ///
        /// [google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.Parameter]: crate::model::constraint::custom_constraint_definition::Parameter
        pub parameters: std::collections::HashMap<
            std::string::String,
            crate::model::constraint::custom_constraint_definition::Parameter,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CustomConstraintDefinition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resource_types][crate::model::constraint::CustomConstraintDefinition::resource_types].
        pub fn set_resource_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.resource_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [method_types][crate::model::constraint::CustomConstraintDefinition::method_types].
        pub fn set_method_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::constraint::custom_constraint_definition::MethodType,
                >,
        {
            use std::iter::Iterator;
            self.method_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [condition][crate::model::constraint::CustomConstraintDefinition::condition].
        pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.condition = v.into();
            self
        }

        /// Sets the value of [action_type][crate::model::constraint::CustomConstraintDefinition::action_type].
        pub fn set_action_type<
            T: std::convert::Into<crate::model::constraint::custom_constraint_definition::ActionType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.action_type = v.into();
            self
        }

        /// Sets the value of [parameters][crate::model::constraint::CustomConstraintDefinition::parameters].
        pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<
                    crate::model::constraint::custom_constraint_definition::Parameter,
                >,
        {
            use std::iter::Iterator;
            self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for CustomConstraintDefinition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CustomConstraintDefinition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __resource_types,
                __method_types,
                __condition,
                __action_type,
                __parameters,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CustomConstraintDefinition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "resourceTypes" => Ok(__FieldTag::__resource_types),
                                "resource_types" => Ok(__FieldTag::__resource_types),
                                "methodTypes" => Ok(__FieldTag::__method_types),
                                "method_types" => Ok(__FieldTag::__method_types),
                                "condition" => Ok(__FieldTag::__condition),
                                "actionType" => Ok(__FieldTag::__action_type),
                                "action_type" => Ok(__FieldTag::__action_type),
                                "parameters" => Ok(__FieldTag::__parameters),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CustomConstraintDefinition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CustomConstraintDefinition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__resource_types => {
                                if !fields.insert(__FieldTag::__resource_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_types",
                                    ));
                                }
                                result.resource_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__method_types => {
                                if !fields.insert(__FieldTag::__method_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for method_types",
                                    ));
                                }
                                result.method_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::constraint::custom_constraint_definition::MethodType>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__condition => {
                                if !fields.insert(__FieldTag::__condition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition",
                                    ));
                                }
                                result.condition = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__action_type => {
                                if !fields.insert(__FieldTag::__action_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for action_type",
                                    ));
                                }
                                result.action_type = map.next_value::<std::option::Option<crate::model::constraint::custom_constraint_definition::ActionType>>()?.unwrap_or_default();
                            }
                            __FieldTag::__parameters => {
                                if !fields.insert(__FieldTag::__parameters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parameters",
                                    ));
                                }
                                result.parameters = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::constraint::custom_constraint_definition::Parameter>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CustomConstraintDefinition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.resource_types.is_empty() {
                state.serialize_entry("resourceTypes", &self.resource_types)?;
            }
            if !self.method_types.is_empty() {
                state.serialize_entry("methodTypes", &self.method_types)?;
            }
            if !self.condition.is_empty() {
                state.serialize_entry("condition", &self.condition)?;
            }
            if !wkt::internal::is_default(&self.action_type) {
                state.serialize_entry("actionType", &self.action_type)?;
            }
            if !self.parameters.is_empty() {
                state.serialize_entry("parameters", &self.parameters)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [CustomConstraintDefinition].
    pub mod custom_constraint_definition {
        #[allow(unused_imports)]
        use super::*;

        /// Defines a parameter structure.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Parameter {
            /// Type of the parameter.
            pub r#type: crate::model::constraint::custom_constraint_definition::parameter::Type,

            /// Sets the value of the parameter in an assignment if no value is given.
            pub default_value: std::option::Option<wkt::Value>,

            /// Provides a CEL expression to specify the acceptable parameter values
            /// during assignment.
            /// For example, parameterName in ("parameterValue1", "parameterValue2")
            pub valid_values_expr: std::string::String,

            /// Defines subproperties primarily used by the UI to display user-friendly
            /// information.
            pub metadata: std::option::Option<
                crate::model::constraint::custom_constraint_definition::parameter::Metadata,
            >,

            /// Determines the parameter's value structure.
            /// For example, `LIST<STRING>` can be specified by defining `type: LIST`,
            /// and `item: STRING`.
            pub item: crate::model::constraint::custom_constraint_definition::parameter::Type,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Parameter {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [r#type][crate::model::constraint::custom_constraint_definition::Parameter::type].
            pub fn set_type<
                T: std::convert::Into<
                        crate::model::constraint::custom_constraint_definition::parameter::Type,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// Sets the value of [default_value][crate::model::constraint::custom_constraint_definition::Parameter::default_value].
            pub fn set_default_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Value>,
            {
                self.default_value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [default_value][crate::model::constraint::custom_constraint_definition::Parameter::default_value].
            pub fn set_or_clear_default_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Value>,
            {
                self.default_value = v.map(|x| x.into());
                self
            }

            /// Sets the value of [valid_values_expr][crate::model::constraint::custom_constraint_definition::Parameter::valid_values_expr].
            pub fn set_valid_values_expr<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.valid_values_expr = v.into();
                self
            }

            /// Sets the value of [metadata][crate::model::constraint::custom_constraint_definition::Parameter::metadata].
            pub fn set_metadata<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<
                        crate::model::constraint::custom_constraint_definition::parameter::Metadata,
                    >,
            {
                self.metadata = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [metadata][crate::model::constraint::custom_constraint_definition::Parameter::metadata].
            pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<
                        crate::model::constraint::custom_constraint_definition::parameter::Metadata,
                    >,
            {
                self.metadata = v.map(|x| x.into());
                self
            }

            /// Sets the value of [item][crate::model::constraint::custom_constraint_definition::Parameter::item].
            pub fn set_item<
                T: std::convert::Into<
                        crate::model::constraint::custom_constraint_definition::parameter::Type,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.item = v.into();
                self
            }
        }

        impl wkt::message::Message for Parameter {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.Parameter"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Parameter {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __type,
                    __default_value,
                    __valid_values_expr,
                    __metadata,
                    __item,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Parameter")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "type" => Ok(__FieldTag::__type),
                                    "defaultValue" => Ok(__FieldTag::__default_value),
                                    "default_value" => Ok(__FieldTag::__default_value),
                                    "validValuesExpr" => Ok(__FieldTag::__valid_values_expr),
                                    "valid_values_expr" => Ok(__FieldTag::__valid_values_expr),
                                    "metadata" => Ok(__FieldTag::__metadata),
                                    "item" => Ok(__FieldTag::__item),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Parameter;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Parameter")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__type => {
                                    if !fields.insert(__FieldTag::__type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for type"),
                                        );
                                    }
                                    result.r#type = map.next_value::<std::option::Option<crate::model::constraint::custom_constraint_definition::parameter::Type>>()?.unwrap_or_default();
                                }
                                __FieldTag::__default_value => {
                                    if !fields.insert(__FieldTag::__default_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for default_value",
                                            ),
                                        );
                                    }
                                    result.default_value = map
                                        .next_value::<std::option::Option<wkt::Value>>()?
                                        .or(Some(wkt::Value::Null));
                                }
                                __FieldTag::__valid_values_expr => {
                                    if !fields.insert(__FieldTag::__valid_values_expr) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for valid_values_expr",
                                            ),
                                        );
                                    }
                                    result.valid_values_expr = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__metadata => {
                                    if !fields.insert(__FieldTag::__metadata) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for metadata",
                                            ),
                                        );
                                    }
                                    result.metadata = map.next_value::<std::option::Option<crate::model::constraint::custom_constraint_definition::parameter::Metadata>>()?
                                        ;
                                }
                                __FieldTag::__item => {
                                    if !fields.insert(__FieldTag::__item) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for item"),
                                        );
                                    }
                                    result.item = map.next_value::<std::option::Option<crate::model::constraint::custom_constraint_definition::parameter::Type>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Parameter {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.r#type) {
                    state.serialize_entry("type", &self.r#type)?;
                }
                if self.default_value.is_some() {
                    state.serialize_entry("defaultValue", &self.default_value)?;
                }
                if !self.valid_values_expr.is_empty() {
                    state.serialize_entry("validValuesExpr", &self.valid_values_expr)?;
                }
                if self.metadata.is_some() {
                    state.serialize_entry("metadata", &self.metadata)?;
                }
                if !wkt::internal::is_default(&self.item) {
                    state.serialize_entry("item", &self.item)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Parameter].
        pub mod parameter {
            #[allow(unused_imports)]
            use super::*;

            /// Defines Metadata structure.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Metadata {
                /// Detailed description of what this `parameter` is and use of it.
                /// Mutable.
                pub description: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Metadata {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [description][crate::model::constraint::custom_constraint_definition::parameter::Metadata::description].
                pub fn set_description<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.description = v.into();
                    self
                }
            }

            impl wkt::message::Message for Metadata {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.Parameter.Metadata"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Metadata {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __description,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Metadata")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "description" => Ok(__FieldTag::__description),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Metadata;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Metadata")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__description => {
                                        if !fields.insert(__FieldTag::__description) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for description",
                                                ),
                                            );
                                        }
                                        result.description = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Metadata {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.description.is_empty() {
                        state.serialize_entry("description", &self.description)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// All valid types of parameter.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Type {
                /// This is only used for distinguishing unset values and should never be
                /// used. Results in an error.
                Unspecified,
                /// List parameter type.
                List,
                /// String parameter type.
                String,
                /// Boolean parameter type.
                Boolean,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [Type::value] or
                /// [Type::name].
                UnknownValue(r#type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod r#type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl Type {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::List => std::option::Option::Some(1),
                        Self::String => std::option::Option::Some(2),
                        Self::Boolean => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                        Self::List => std::option::Option::Some("LIST"),
                        Self::String => std::option::Option::Some("STRING"),
                        Self::Boolean => std::option::Option::Some("BOOLEAN"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for Type {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for Type {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for Type {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::List,
                        2 => Self::String,
                        3 => Self::Boolean,
                        _ => Self::UnknownValue(r#type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for Type {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "TYPE_UNSPECIFIED" => Self::Unspecified,
                        "LIST" => Self::List,
                        "STRING" => Self::String,
                        "BOOLEAN" => Self::Boolean,
                        _ => Self::UnknownValue(r#type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for Type {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::List => serializer.serialize_i32(1),
                        Self::String => serializer.serialize_i32(2),
                        Self::Boolean => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for Type {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                        ".google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.Parameter.Type"))
                }
            }
        }

        /// The operation for which this constraint will be applied. To apply this
        /// constraint only when creating new resources, the `method_types` should be
        /// `CREATE` only. To apply this constraint when creating or deleting
        /// resources, the `method_types` should be `CREATE` and `DELETE`.
        ///
        /// `UPDATE`-only custom constraints are not supported. Use `CREATE` or
        /// `CREATE, UPDATE`.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MethodType {
            /// This is only used for distinguishing unset values and should never be
            /// used. Results in an error.
            Unspecified,
            /// Constraint applied when creating the resource.
            Create,
            /// Constraint applied when updating the resource.
            Update,
            /// Constraint applied when deleting the resource.
            /// Not currently supported.
            Delete,
            /// Constraint applied when removing an IAM grant.
            RemoveGrant,
            /// Constraint applied when enforcing forced tagging.
            GovernTags,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [MethodType::value] or
            /// [MethodType::name].
            UnknownValue(method_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod method_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl MethodType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Create => std::option::Option::Some(1),
                    Self::Update => std::option::Option::Some(2),
                    Self::Delete => std::option::Option::Some(3),
                    Self::RemoveGrant => std::option::Option::Some(4),
                    Self::GovernTags => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("METHOD_TYPE_UNSPECIFIED"),
                    Self::Create => std::option::Option::Some("CREATE"),
                    Self::Update => std::option::Option::Some("UPDATE"),
                    Self::Delete => std::option::Option::Some("DELETE"),
                    Self::RemoveGrant => std::option::Option::Some("REMOVE_GRANT"),
                    Self::GovernTags => std::option::Option::Some("GOVERN_TAGS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for MethodType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for MethodType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for MethodType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Create,
                    2 => Self::Update,
                    3 => Self::Delete,
                    4 => Self::RemoveGrant,
                    5 => Self::GovernTags,
                    _ => Self::UnknownValue(method_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for MethodType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "METHOD_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "CREATE" => Self::Create,
                    "UPDATE" => Self::Update,
                    "DELETE" => Self::Delete,
                    "REMOVE_GRANT" => Self::RemoveGrant,
                    "GOVERN_TAGS" => Self::GovernTags,
                    _ => Self::UnknownValue(method_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for MethodType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Create => serializer.serialize_i32(1),
                    Self::Update => serializer.serialize_i32(2),
                    Self::Delete => serializer.serialize_i32(3),
                    Self::RemoveGrant => serializer.serialize_i32(4),
                    Self::GovernTags => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for MethodType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<MethodType>::new(
                    ".google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.MethodType",
                ))
            }
        }

        /// Allow or deny type.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ActionType {
            /// This is only used for distinguishing unset values and should never be
            /// used. Results in an error.
            Unspecified,
            /// Allowed action type.
            Allow,
            /// Deny action type.
            Deny,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ActionType::value] or
            /// [ActionType::name].
            UnknownValue(action_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod action_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ActionType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Allow => std::option::Option::Some(1),
                    Self::Deny => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ACTION_TYPE_UNSPECIFIED"),
                    Self::Allow => std::option::Option::Some("ALLOW"),
                    Self::Deny => std::option::Option::Some("DENY"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ActionType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ActionType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ActionType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Allow,
                    2 => Self::Deny,
                    _ => Self::UnknownValue(action_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ActionType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ACTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "ALLOW" => Self::Allow,
                    "DENY" => Self::Deny,
                    _ => Self::UnknownValue(action_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ActionType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Allow => serializer.serialize_i32(1),
                    Self::Deny => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ActionType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ActionType>::new(
                    ".google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.ActionType",
                ))
            }
        }
    }

    /// A constraint type is enforced or not enforced, which is configured in the
    /// [`PolicyRule`][google.cloud.orgpolicy.v2.PolicySpec.PolicyRule].
    ///
    /// If `customConstraintDefinition` is defined, this constraint is a managed
    /// constraint.
    ///
    /// [google.cloud.orgpolicy.v2.PolicySpec.PolicyRule]: crate::model::policy_spec::PolicyRule
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BooleanConstraint {
        /// Custom constraint definition. Defines this as a managed constraint.
        pub custom_constraint_definition:
            std::option::Option<crate::model::constraint::CustomConstraintDefinition>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BooleanConstraint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [custom_constraint_definition][crate::model::constraint::BooleanConstraint::custom_constraint_definition].
        pub fn set_custom_constraint_definition<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::constraint::CustomConstraintDefinition>,
        {
            self.custom_constraint_definition = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [custom_constraint_definition][crate::model::constraint::BooleanConstraint::custom_constraint_definition].
        pub fn set_or_clear_custom_constraint_definition<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::constraint::CustomConstraintDefinition>,
        {
            self.custom_constraint_definition = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for BooleanConstraint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint.BooleanConstraint"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BooleanConstraint {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __custom_constraint_definition,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BooleanConstraint")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "customConstraintDefinition" => {
                                    Ok(__FieldTag::__custom_constraint_definition)
                                }
                                "custom_constraint_definition" => {
                                    Ok(__FieldTag::__custom_constraint_definition)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BooleanConstraint;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BooleanConstraint")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__custom_constraint_definition => {
                                if !fields.insert(__FieldTag::__custom_constraint_definition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for custom_constraint_definition",
                                    ));
                                }
                                result.custom_constraint_definition = map
                                    .next_value::<std::option::Option<
                                        crate::model::constraint::CustomConstraintDefinition,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BooleanConstraint {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.custom_constraint_definition.is_some() {
                state.serialize_entry(
                    "customConstraintDefinition",
                    &self.custom_constraint_definition,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Specifies the default behavior in the absence of any policy for the
    /// constraint. This must not be `CONSTRAINT_DEFAULT_UNSPECIFIED`.
    ///
    /// Immutable after creation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConstraintDefault {
        /// This is only used for distinguishing unset values and should never be
        /// used. Results in an error.
        Unspecified,
        /// Indicate that all values are allowed for list constraints.
        /// Indicate that enforcement is off for boolean constraints.
        Allow,
        /// Indicate that all values are denied for list constraints.
        /// Indicate that enforcement is on for boolean constraints.
        Deny,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConstraintDefault::value] or
        /// [ConstraintDefault::name].
        UnknownValue(constraint_default::UnknownValue),
    }

    #[doc(hidden)]
    pub mod constraint_default {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConstraintDefault {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Allow => std::option::Option::Some(1),
                Self::Deny => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONSTRAINT_DEFAULT_UNSPECIFIED"),
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::Deny => std::option::Option::Some("DENY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConstraintDefault {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConstraintDefault {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConstraintDefault {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Allow,
                2 => Self::Deny,
                _ => Self::UnknownValue(constraint_default::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConstraintDefault {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONSTRAINT_DEFAULT_UNSPECIFIED" => Self::Unspecified,
                "ALLOW" => Self::Allow,
                "DENY" => Self::Deny,
                _ => Self::UnknownValue(constraint_default::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConstraintDefault {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Allow => serializer.serialize_i32(1),
                Self::Deny => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConstraintDefault {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConstraintDefault>::new(
                ".google.cloud.orgpolicy.v2.Constraint.ConstraintDefault",
            ))
        }
    }

    /// The type of restrictions for this `Constraint`.
    ///
    /// Immutable after creation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConstraintType {
        /// Defines this constraint as being a list constraint.
        ListConstraint(std::boxed::Box<crate::model::constraint::ListConstraint>),
        /// Defines this constraint as being a boolean constraint.
        BooleanConstraint(std::boxed::Box<crate::model::constraint::BooleanConstraint>),
    }
}

/// A custom constraint defined by customers which can *only* be applied to the
/// given resource types and organization.
///
/// By creating a custom constraint, customers can apply policies of this
/// custom constraint. *Creating a custom constraint itself does NOT apply any
/// policy enforcement*.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomConstraint {
    /// Immutable. Name of the constraint. This is unique within the organization.
    /// Format of the name should be
    ///
    /// * `organizations/{organization_id}/customConstraints/{custom_constraint_id}`
    ///
    /// Example: `organizations/123/customConstraints/custom.createOnlyE2TypeVms`
    ///
    /// The max length is 70 characters and the minimum length is 1. Note that the
    /// prefix `organizations/{organization_id}/customConstraints/` is not counted.
    pub name: std::string::String,

    /// Immutable. The resource instance type on which this policy applies. Format
    /// will be of the form : `<service name>/<type>` Example:
    ///
    /// * `compute.googleapis.com/Instance`.
    pub resource_types: std::vec::Vec<std::string::String>,

    /// All the operations being applied for this constraint.
    pub method_types: std::vec::Vec<crate::model::custom_constraint::MethodType>,

    /// A Common Expression Language (CEL) condition which is used in the
    /// evaluation of the constraint. For example:
    /// `resource.instanceName.matches("[production|test]_.*_(\d)+")` or,
    /// `resource.management.auto_upgrade == true`
    ///
    /// The max length of the condition is 1000 characters.
    pub condition: std::string::String,

    /// Allow or deny type.
    pub action_type: crate::model::custom_constraint::ActionType,

    /// One line display name for the UI.
    /// The max length of the display_name is 200 characters.
    pub display_name: std::string::String,

    /// Detailed information about this custom policy constraint.
    /// The max length of the description is 2000 characters.
    pub description: std::string::String,

    /// Output only. The last time this custom constraint was updated. This
    /// represents the last time that the `CreateCustomConstraint` or
    /// `UpdateCustomConstraint` methods were called.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomConstraint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CustomConstraint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [resource_types][crate::model::CustomConstraint::resource_types].
    pub fn set_resource_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [method_types][crate::model::CustomConstraint::method_types].
    pub fn set_method_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::custom_constraint::MethodType>,
    {
        use std::iter::Iterator;
        self.method_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [condition][crate::model::CustomConstraint::condition].
    pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [action_type][crate::model::CustomConstraint::action_type].
    pub fn set_action_type<T: std::convert::Into<crate::model::custom_constraint::ActionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.action_type = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CustomConstraint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::CustomConstraint::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CustomConstraint::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CustomConstraint::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CustomConstraint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.CustomConstraint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomConstraint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __resource_types,
            __method_types,
            __condition,
            __action_type,
            __display_name,
            __description,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomConstraint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "resourceTypes" => Ok(__FieldTag::__resource_types),
                            "resource_types" => Ok(__FieldTag::__resource_types),
                            "methodTypes" => Ok(__FieldTag::__method_types),
                            "method_types" => Ok(__FieldTag::__method_types),
                            "condition" => Ok(__FieldTag::__condition),
                            "actionType" => Ok(__FieldTag::__action_type),
                            "action_type" => Ok(__FieldTag::__action_type),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomConstraint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomConstraint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_types => {
                            if !fields.insert(__FieldTag::__resource_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_types",
                                ));
                            }
                            result.resource_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__method_types => {
                            if !fields.insert(__FieldTag::__method_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for method_types",
                                ));
                            }
                            result.method_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::custom_constraint::MethodType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action_type => {
                            if !fields.insert(__FieldTag::__action_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_type",
                                ));
                            }
                            result.action_type =
                                map.next_value::<std::option::Option<
                                    crate::model::custom_constraint::ActionType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomConstraint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.resource_types.is_empty() {
            state.serialize_entry("resourceTypes", &self.resource_types)?;
        }
        if !self.method_types.is_empty() {
            state.serialize_entry("methodTypes", &self.method_types)?;
        }
        if !self.condition.is_empty() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !wkt::internal::is_default(&self.action_type) {
            state.serialize_entry("actionType", &self.action_type)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CustomConstraint].
pub mod custom_constraint {
    #[allow(unused_imports)]
    use super::*;

    /// The operation for which this constraint will be applied. To apply this
    /// constraint only when creating new resources, the `method_types` should be
    /// `CREATE` only. To apply this constraint when creating or deleting
    /// resources, the `method_types` should be `CREATE` and `DELETE`.
    ///
    /// `UPDATE` only custom constraints are not supported. Use `CREATE` or
    /// `CREATE, UPDATE`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MethodType {
        /// This is only used for distinguishing unset values and should never be
        /// used. Results in an error.
        Unspecified,
        /// Constraint applied when creating the resource.
        Create,
        /// Constraint applied when updating the resource.
        Update,
        /// Constraint applied when deleting the resource.
        /// Not currently supported.
        Delete,
        /// Constraint applied when removing an IAM grant.
        RemoveGrant,
        /// Constraint applied when enforcing forced tagging.
        GovernTags,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MethodType::value] or
        /// [MethodType::name].
        UnknownValue(method_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod method_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MethodType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Create => std::option::Option::Some(1),
                Self::Update => std::option::Option::Some(2),
                Self::Delete => std::option::Option::Some(3),
                Self::RemoveGrant => std::option::Option::Some(4),
                Self::GovernTags => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METHOD_TYPE_UNSPECIFIED"),
                Self::Create => std::option::Option::Some("CREATE"),
                Self::Update => std::option::Option::Some("UPDATE"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::RemoveGrant => std::option::Option::Some("REMOVE_GRANT"),
                Self::GovernTags => std::option::Option::Some("GOVERN_TAGS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MethodType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MethodType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MethodType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Create,
                2 => Self::Update,
                3 => Self::Delete,
                4 => Self::RemoveGrant,
                5 => Self::GovernTags,
                _ => Self::UnknownValue(method_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MethodType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METHOD_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CREATE" => Self::Create,
                "UPDATE" => Self::Update,
                "DELETE" => Self::Delete,
                "REMOVE_GRANT" => Self::RemoveGrant,
                "GOVERN_TAGS" => Self::GovernTags,
                _ => Self::UnknownValue(method_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MethodType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Create => serializer.serialize_i32(1),
                Self::Update => serializer.serialize_i32(2),
                Self::Delete => serializer.serialize_i32(3),
                Self::RemoveGrant => serializer.serialize_i32(4),
                Self::GovernTags => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MethodType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MethodType>::new(
                ".google.cloud.orgpolicy.v2.CustomConstraint.MethodType",
            ))
        }
    }

    /// Allow or deny type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ActionType {
        /// This is only used for distinguishing unset values and should never be
        /// used. Results in an error.
        Unspecified,
        /// Allowed action type.
        Allow,
        /// Deny action type.
        Deny,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ActionType::value] or
        /// [ActionType::name].
        UnknownValue(action_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod action_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ActionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Allow => std::option::Option::Some(1),
                Self::Deny => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACTION_TYPE_UNSPECIFIED"),
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::Deny => std::option::Option::Some("DENY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ActionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ActionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ActionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Allow,
                2 => Self::Deny,
                _ => Self::UnknownValue(action_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ActionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ALLOW" => Self::Allow,
                "DENY" => Self::Deny,
                _ => Self::UnknownValue(action_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ActionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Allow => serializer.serialize_i32(1),
                Self::Deny => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ActionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ActionType>::new(
                ".google.cloud.orgpolicy.v2.CustomConstraint.ActionType",
            ))
        }
    }
}

/// Defines an organization policy which is used to specify constraints
/// for configurations of Google Cloud resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Policy {
    /// Immutable. The resource name of the policy. Must be one of the following
    /// forms, where `constraint_name` is the name of the constraint which this
    /// policy configures:
    ///
    /// * `projects/{project_number}/policies/{constraint_name}`
    /// * `folders/{folder_id}/policies/{constraint_name}`
    /// * `organizations/{organization_id}/policies/{constraint_name}`
    ///
    /// For example, `projects/123/policies/compute.disableSerialPortAccess`.
    ///
    /// Note: `projects/{project_id}/policies/{constraint_name}` is also an
    /// acceptable name for API requests, but responses will return the name using
    /// the equivalent project number.
    pub name: std::string::String,

    /// Basic information about the organization policy.
    pub spec: std::option::Option<crate::model::PolicySpec>,

    /// Deprecated.
    #[deprecated]
    pub alternate: std::option::Option<crate::model::AlternatePolicySpec>,

    /// Dry-run policy.
    /// Audit-only policy, can be used to monitor how the policy would have
    /// impacted the existing and future resources if it's enforced.
    pub dry_run_spec: std::option::Option<crate::model::PolicySpec>,

    /// Optional. An opaque tag indicating the current state of the policy, used
    /// for concurrency control. This 'etag' is computed by the server based on the
    /// value of other fields, and may be sent on update and delete requests to
    /// ensure the client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Policy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Policy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::Policy::spec].
    pub fn set_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PolicySpec>,
    {
        self.spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spec][crate::model::Policy::spec].
    pub fn set_or_clear_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PolicySpec>,
    {
        self.spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [alternate][crate::model::Policy::alternate].
    #[deprecated]
    pub fn set_alternate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AlternatePolicySpec>,
    {
        self.alternate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [alternate][crate::model::Policy::alternate].
    #[deprecated]
    pub fn set_or_clear_alternate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AlternatePolicySpec>,
    {
        self.alternate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dry_run_spec][crate::model::Policy::dry_run_spec].
    pub fn set_dry_run_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PolicySpec>,
    {
        self.dry_run_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dry_run_spec][crate::model::Policy::dry_run_spec].
    pub fn set_or_clear_dry_run_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PolicySpec>,
    {
        self.dry_run_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Policy::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Policy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.Policy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Policy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __spec,
            __alternate,
            __dry_run_spec,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Policy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "spec" => Ok(__FieldTag::__spec),
                            "alternate" => Ok(__FieldTag::__alternate),
                            "dryRunSpec" => Ok(__FieldTag::__dry_run_spec),
                            "dry_run_spec" => Ok(__FieldTag::__dry_run_spec),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Policy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Policy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__spec => {
                            if !fields.insert(__FieldTag::__spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec",
                                ));
                            }
                            result.spec =
                                map.next_value::<std::option::Option<crate::model::PolicySpec>>()?;
                        }
                        __FieldTag::__alternate => {
                            if !fields.insert(__FieldTag::__alternate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alternate",
                                ));
                            }
                            result.alternate = map.next_value::<std::option::Option<crate::model::AlternatePolicySpec>>()?
                                ;
                        }
                        __FieldTag::__dry_run_spec => {
                            if !fields.insert(__FieldTag::__dry_run_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dry_run_spec",
                                ));
                            }
                            result.dry_run_spec =
                                map.next_value::<std::option::Option<crate::model::PolicySpec>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Policy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.spec.is_some() {
            state.serialize_entry("spec", &self.spec)?;
        }
        if self.alternate.is_some() {
            state.serialize_entry("alternate", &self.alternate)?;
        }
        if self.dry_run_spec.is_some() {
            state.serialize_entry("dryRunSpec", &self.dry_run_spec)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Similar to PolicySpec but with an extra 'launch' field for launch reference.
/// The PolicySpec here is specific for dry-run.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AlternatePolicySpec {
    /// Reference to the launch that will be used while audit logging and to
    /// control the launch.
    /// Should be set only in the alternate policy.
    pub launch: std::string::String,

    /// Specify constraint for configurations of Google Cloud resources.
    pub spec: std::option::Option<crate::model::PolicySpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AlternatePolicySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [launch][crate::model::AlternatePolicySpec::launch].
    pub fn set_launch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.launch = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::AlternatePolicySpec::spec].
    pub fn set_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PolicySpec>,
    {
        self.spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spec][crate::model::AlternatePolicySpec::spec].
    pub fn set_or_clear_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PolicySpec>,
    {
        self.spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AlternatePolicySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.AlternatePolicySpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AlternatePolicySpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __launch,
            __spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AlternatePolicySpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "launch" => Ok(__FieldTag::__launch),
                            "spec" => Ok(__FieldTag::__spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AlternatePolicySpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AlternatePolicySpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__launch => {
                            if !fields.insert(__FieldTag::__launch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for launch",
                                ));
                            }
                            result.launch = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__spec => {
                            if !fields.insert(__FieldTag::__spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec",
                                ));
                            }
                            result.spec =
                                map.next_value::<std::option::Option<crate::model::PolicySpec>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AlternatePolicySpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.launch.is_empty() {
            state.serialize_entry("launch", &self.launch)?;
        }
        if self.spec.is_some() {
            state.serialize_entry("spec", &self.spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines a Google Cloud policy specification which is used to specify
/// constraints for configurations of Google Cloud resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PolicySpec {
    /// An opaque tag indicating the current version of the policySpec, used for
    /// concurrency control.
    ///
    /// This field is ignored if used in a `CreatePolicy` request.
    ///
    /// When the policy is returned from either a `GetPolicy` or a
    /// `ListPolicies` request, this `etag` indicates the version of the
    /// current policySpec to use when executing a read-modify-write loop.
    ///
    /// When the policy is returned from a `GetEffectivePolicy` request, the
    /// `etag` will be unset.
    pub etag: std::string::String,

    /// Output only. The time stamp this was previously updated. This
    /// represents the last time a call to `CreatePolicy` or `UpdatePolicy` was
    /// made for that policy.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// In policies for boolean constraints, the following requirements apply:
    ///
    /// - There must be one and only one policy rule where condition is unset.
    /// - Boolean policy rules with conditions must set `enforced` to the
    ///   opposite of the policy rule without a condition.
    /// - During policy evaluation, policy rules with conditions that are
    ///   true for a target resource take precedence.
    pub rules: std::vec::Vec<crate::model::policy_spec::PolicyRule>,

    /// Determines the inheritance behavior for this policy.
    ///
    /// If `inherit_from_parent` is true, policy rules set higher up in the
    /// hierarchy (up to the closest root) are inherited and present in the
    /// effective policy. If it is false, then no rules are inherited, and this
    /// policy becomes the new root for evaluation.
    /// This field can be set only for policies which configure list constraints.
    pub inherit_from_parent: bool,

    /// Ignores policies set above this resource and restores the
    /// `constraint_default` enforcement behavior of the specific constraint at
    /// this resource.
    /// This field can be set in policies for either list or boolean
    /// constraints. If set, `rules` must be empty and `inherit_from_parent`
    /// must be set to false.
    pub reset: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PolicySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [etag][crate::model::PolicySpec::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PolicySpec::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PolicySpec::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rules][crate::model::PolicySpec::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::policy_spec::PolicyRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [inherit_from_parent][crate::model::PolicySpec::inherit_from_parent].
    pub fn set_inherit_from_parent<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.inherit_from_parent = v.into();
        self
    }

    /// Sets the value of [reset][crate::model::PolicySpec::reset].
    pub fn set_reset<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reset = v.into();
        self
    }
}

impl wkt::message::Message for PolicySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.PolicySpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PolicySpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __etag,
            __update_time,
            __rules,
            __inherit_from_parent,
            __reset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicySpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "etag" => Ok(__FieldTag::__etag),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "rules" => Ok(__FieldTag::__rules),
                            "inheritFromParent" => Ok(__FieldTag::__inherit_from_parent),
                            "inherit_from_parent" => Ok(__FieldTag::__inherit_from_parent),
                            "reset" => Ok(__FieldTag::__reset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PolicySpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicySpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__rules => {
                            if !fields.insert(__FieldTag::__rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rules",
                                ));
                            }
                            result.rules = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::policy_spec::PolicyRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inherit_from_parent => {
                            if !fields.insert(__FieldTag::__inherit_from_parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inherit_from_parent",
                                ));
                            }
                            result.inherit_from_parent = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reset => {
                            if !fields.insert(__FieldTag::__reset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reset",
                                ));
                            }
                            result.reset = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PolicySpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if !wkt::internal::is_default(&self.inherit_from_parent) {
            state.serialize_entry("inheritFromParent", &self.inherit_from_parent)?;
        }
        if !wkt::internal::is_default(&self.reset) {
            state.serialize_entry("reset", &self.reset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PolicySpec].
pub mod policy_spec {
    #[allow(unused_imports)]
    use super::*;

    /// A rule used to express this policy.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PolicyRule {
        /// A condition which determines whether this rule is used
        /// in the evaluation of the policy. When set, the `expression` field in
        /// the `Expr' must include from 1 to 10 subexpressions, joined by the "||"
        /// or "&&" operators. Each subexpression must be of the form
        /// "resource.matchTag('<ORG_ID>/tag_key_short_name,
        /// 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id',
        /// 'tagValues/value_id')". where key_name and value_name are the resource
        /// names for Label Keys and Values. These names are available from the Tag
        /// Manager Service. An example expression is:
        /// "resource.matchTag('123456789/environment,
        /// 'prod')". or "resource.matchTagId('tagKeys/123',
        /// 'tagValues/456')".
        pub condition: std::option::Option<gtype::model::Expr>,

        /// Optional. Required for managed constraints if parameters are defined.
        /// Passes parameter values when policy enforcement is enabled. Ensure that
        /// parameter value types match those defined in the constraint definition.
        /// For example:
        /// {
        /// "allowedLocations" : ["us-east1", "us-west1"],
        /// "allowAll" : true
        /// }
        pub parameters: std::option::Option<wkt::Struct>,

        pub kind: std::option::Option<crate::model::policy_spec::policy_rule::Kind>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PolicyRule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [condition][crate::model::policy_spec::PolicyRule::condition].
        pub fn set_condition<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Expr>,
        {
            self.condition = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [condition][crate::model::policy_spec::PolicyRule::condition].
        pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Expr>,
        {
            self.condition = v.map(|x| x.into());
            self
        }

        /// Sets the value of [parameters][crate::model::policy_spec::PolicyRule::parameters].
        pub fn set_parameters<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.parameters = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [parameters][crate::model::policy_spec::PolicyRule::parameters].
        pub fn set_or_clear_parameters<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.parameters = v.map(|x| x.into());
            self
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind].
        ///
        /// Note that all the setters affecting `kind` are mutually
        /// exclusive.
        pub fn set_kind<
            T: std::convert::Into<std::option::Option<crate::model::policy_spec::policy_rule::Kind>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// if it holds a `Values`, `None` if the field is not set or
        /// holds a different branch.
        pub fn values(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::policy_spec::policy_rule::StringValues>,
        > {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::policy_spec::policy_rule::Kind::Values(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// to hold a `Values`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_values<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::policy_spec::policy_rule::StringValues>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::policy_spec::policy_rule::Kind::Values(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// if it holds a `AllowAll`, `None` if the field is not set or
        /// holds a different branch.
        pub fn allow_all(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::policy_spec::policy_rule::Kind::AllowAll(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// to hold a `AllowAll`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_allow_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::policy_spec::policy_rule::Kind::AllowAll(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// if it holds a `DenyAll`, `None` if the field is not set or
        /// holds a different branch.
        pub fn deny_all(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::policy_spec::policy_rule::Kind::DenyAll(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// to hold a `DenyAll`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_deny_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::policy_spec::policy_rule::Kind::DenyAll(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// if it holds a `Enforce`, `None` if the field is not set or
        /// holds a different branch.
        pub fn enforce(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::policy_spec::policy_rule::Kind::Enforce(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// to hold a `Enforce`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_enforce<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::policy_spec::policy_rule::Kind::Enforce(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for PolicyRule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orgpolicy.v2.PolicySpec.PolicyRule"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PolicyRule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __values,
                __allow_all,
                __deny_all,
                __enforce,
                __condition,
                __parameters,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PolicyRule")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "values" => Ok(__FieldTag::__values),
                                "allowAll" => Ok(__FieldTag::__allow_all),
                                "allow_all" => Ok(__FieldTag::__allow_all),
                                "denyAll" => Ok(__FieldTag::__deny_all),
                                "deny_all" => Ok(__FieldTag::__deny_all),
                                "enforce" => Ok(__FieldTag::__enforce),
                                "condition" => Ok(__FieldTag::__condition),
                                "parameters" => Ok(__FieldTag::__parameters),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PolicyRule;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PolicyRule")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.orgpolicy.v2.PolicySpec.PolicyRule.values, latest field was values",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::policy_spec::policy_rule::Kind::Values(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::policy_spec::policy_rule::StringValues>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__allow_all => {
                                if !fields.insert(__FieldTag::__allow_all) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_all",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.orgpolicy.v2.PolicySpec.PolicyRule.allow_all, latest field was allowAll",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::policy_spec::policy_rule::Kind::AllowAll(
                                        map.next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__deny_all => {
                                if !fields.insert(__FieldTag::__deny_all) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for deny_all",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.orgpolicy.v2.PolicySpec.PolicyRule.deny_all, latest field was denyAll",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::policy_spec::policy_rule::Kind::DenyAll(
                                        map.next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__enforce => {
                                if !fields.insert(__FieldTag::__enforce) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enforce",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.orgpolicy.v2.PolicySpec.PolicyRule.enforce, latest field was enforce",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::policy_spec::policy_rule::Kind::Enforce(
                                        map.next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__condition => {
                                if !fields.insert(__FieldTag::__condition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition",
                                    ));
                                }
                                result.condition =
                                    map.next_value::<std::option::Option<gtype::model::Expr>>()?;
                            }
                            __FieldTag::__parameters => {
                                if !fields.insert(__FieldTag::__parameters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parameters",
                                    ));
                                }
                                result.parameters =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PolicyRule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.values() {
                state.serialize_entry("values", value)?;
            }
            if let Some(value) = self.allow_all() {
                state.serialize_entry("allowAll", value)?;
            }
            if let Some(value) = self.deny_all() {
                state.serialize_entry("denyAll", value)?;
            }
            if let Some(value) = self.enforce() {
                state.serialize_entry("enforce", value)?;
            }
            if self.condition.is_some() {
                state.serialize_entry("condition", &self.condition)?;
            }
            if self.parameters.is_some() {
                state.serialize_entry("parameters", &self.parameters)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PolicyRule].
    pub mod policy_rule {
        #[allow(unused_imports)]
        use super::*;

        /// A message that holds specific allowed and denied values.
        /// This message can define specific values and subtrees of the Resource
        /// Manager resource hierarchy (`Organizations`, `Folders`, `Projects`) that
        /// are allowed or denied. This is achieved by using the `under:` and
        /// optional `is:` prefixes.
        /// The `under:` prefix is used to denote resource subtree values.
        /// The `is:` prefix is used to denote specific values, and is required only
        /// if the value contains a ":". Values prefixed with "is:" are treated the
        /// same as values with no prefix.
        /// Ancestry subtrees must be in one of the following formats:
        ///
        /// - `projects/<project-id>` (for example, `projects/tokyo-rain-123`)
        /// - `folders/<folder-id>` (for example, `folders/1234`)
        /// - `organizations/<organization-id>` (for example, `organizations/1234`)
        ///
        /// The `supports_under` field of the associated `Constraint`  defines
        /// whether ancestry prefixes can be used.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct StringValues {
            /// List of values allowed at this resource.
            pub allowed_values: std::vec::Vec<std::string::String>,

            /// List of values denied at this resource.
            pub denied_values: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl StringValues {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [allowed_values][crate::model::policy_spec::policy_rule::StringValues::allowed_values].
            pub fn set_allowed_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.allowed_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [denied_values][crate::model::policy_spec::policy_rule::StringValues::denied_values].
            pub fn set_denied_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.denied_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for StringValues {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.orgpolicy.v2.PolicySpec.PolicyRule.StringValues"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for StringValues {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __allowed_values,
                    __denied_values,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for StringValues")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "allowedValues" => Ok(__FieldTag::__allowed_values),
                                    "allowed_values" => Ok(__FieldTag::__allowed_values),
                                    "deniedValues" => Ok(__FieldTag::__denied_values),
                                    "denied_values" => Ok(__FieldTag::__denied_values),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = StringValues;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct StringValues")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__allowed_values => {
                                    if !fields.insert(__FieldTag::__allowed_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for allowed_values",
                                            ),
                                        );
                                    }
                                    result.allowed_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__denied_values => {
                                    if !fields.insert(__FieldTag::__denied_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for denied_values",
                                            ),
                                        );
                                    }
                                    result.denied_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for StringValues {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.allowed_values.is_empty() {
                    state.serialize_entry("allowedValues", &self.allowed_values)?;
                }
                if !self.denied_values.is_empty() {
                    state.serialize_entry("deniedValues", &self.denied_values)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Kind {
            /// List of values to be used for this policy rule. This field can be set
            /// only in policies for list constraints.
            Values(std::boxed::Box<crate::model::policy_spec::policy_rule::StringValues>),
            /// Setting this to true means that all values are allowed. This field can
            /// be set only in policies for list constraints.
            AllowAll(bool),
            /// Setting this to true means that all values are denied. This field can
            /// be set only in policies for list constraints.
            DenyAll(bool),
            /// If `true`, then the policy is enforced. If `false`, then any
            /// configuration is acceptable.
            /// This field can be set only in policies for boolean constraints.
            Enforce(bool),
        }
    }
}

/// The request sent to the [ListConstraints]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListConstraints] method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConstraintsRequest {
    /// Required. The Google Cloud resource that parents the constraint. Must be in
    /// one of the following forms:
    ///
    /// * `projects/{project_number}`
    /// * `projects/{project_id}`
    /// * `folders/{folder_id}`
    /// * `organizations/{organization_id}`
    pub parent: std::string::String,

    /// Size of the pages to be returned. This is currently unsupported and will
    /// be ignored. The server may at any point start using this field to limit
    /// page size.
    pub page_size: i32,

    /// Page token used to retrieve the next page. This is currently unsupported
    /// and will be ignored. The server may at any point start using this field.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConstraintsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConstraintsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConstraintsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConstraintsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConstraintsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListConstraintsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConstraintsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConstraintsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConstraintsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConstraintsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConstraintsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response returned from the [ListConstraints]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListConstraints] method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConstraintsResponse {
    /// The collection of constraints that are available on the targeted resource.
    pub constraints: std::vec::Vec<crate::model::Constraint>,

    /// Page token used to retrieve the next page. This is currently not used.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConstraintsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [constraints][crate::model::ListConstraintsResponse::constraints].
    pub fn set_constraints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Constraint>,
    {
        use std::iter::Iterator;
        self.constraints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConstraintsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConstraintsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListConstraintsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConstraintsResponse {
    type PageItem = crate::model::Constraint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.constraints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConstraintsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __constraints,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConstraintsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "constraints" => Ok(__FieldTag::__constraints),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConstraintsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConstraintsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__constraints => {
                            if !fields.insert(__FieldTag::__constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraints",
                                ));
                            }
                            result.constraints = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Constraint>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConstraintsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.constraints.is_empty() {
            state.serialize_entry("constraints", &self.constraints)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to the [ListPolicies]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListPolicies] method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPoliciesRequest {
    /// Required. The target Google Cloud resource that parents the set of
    /// constraints and policies that will be returned from this call. Must be in
    /// one of the following forms:
    ///
    /// * `projects/{project_number}`
    /// * `projects/{project_id}`
    /// * `folders/{folder_id}`
    /// * `organizations/{organization_id}`
    pub parent: std::string::String,

    /// Size of the pages to be returned. This is currently unsupported and will
    /// be ignored. The server may at any point start using this field to limit
    /// page size.
    pub page_size: i32,

    /// Page token used to retrieve the next page. This is currently unsupported
    /// and will be ignored. The server may at any point start using this field.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListPoliciesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response returned from the [ListPolicies]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListPolicies] method. It will be empty
/// if no policies are set on the resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPoliciesResponse {
    /// All policies that exist on the resource. It will be empty if no
    /// policies are set.
    pub policies: std::vec::Vec<crate::model::Policy>,

    /// Page token used to retrieve the next page. This is currently not used, but
    /// the server may at any point start supplying a valid token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policies][crate::model::ListPoliciesResponse::policies].
    pub fn set_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Policy>,
    {
        use std::iter::Iterator;
        self.policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPoliciesResponse {
    type PageItem = crate::model::Policy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPoliciesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policies,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPoliciesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policies" => Ok(__FieldTag::__policies),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPoliciesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPoliciesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policies => {
                            if !fields.insert(__FieldTag::__policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policies",
                                ));
                            }
                            result.policies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Policy>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPoliciesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.policies.is_empty() {
            state.serialize_entry("policies", &self.policies)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to the [GetPolicy]
/// [google.cloud.orgpolicy.v2.OrgPolicy.GetPolicy] method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPolicyRequest {
    /// Required. Resource name of the policy. See
    /// [Policy][google.cloud.orgpolicy.v2.Policy] for naming requirements.
    ///
    /// [google.cloud.orgpolicy.v2.Policy]: crate::model::Policy
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.GetPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to the [GetEffectivePolicy]
/// [google.cloud.orgpolicy.v2.OrgPolicy.GetEffectivePolicy] method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEffectivePolicyRequest {
    /// Required. The effective policy to compute. See
    /// [Policy][google.cloud.orgpolicy.v2.Policy] for naming requirements.
    ///
    /// [google.cloud.orgpolicy.v2.Policy]: crate::model::Policy
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEffectivePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEffectivePolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEffectivePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.GetEffectivePolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEffectivePolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEffectivePolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEffectivePolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEffectivePolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEffectivePolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to the [CreatePolicyRequest]
/// [google.cloud.orgpolicy.v2.OrgPolicy.CreatePolicy] method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePolicyRequest {
    /// Required. The Google Cloud resource that will parent the new policy. Must
    /// be in one of the following forms:
    ///
    /// * `projects/{project_number}`
    /// * `projects/{project_id}`
    /// * `folders/{folder_id}`
    /// * `organizations/{organization_id}`
    pub parent: std::string::String,

    /// Required. Policy to create.
    pub policy: std::option::Option<crate::model::Policy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePolicyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [policy][crate::model::CreatePolicyRequest::policy].
    pub fn set_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Policy>,
    {
        self.policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy][crate::model::CreatePolicyRequest::policy].
    pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Policy>,
    {
        self.policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreatePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.CreatePolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatePolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "policy" => Ok(__FieldTag::__policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatePolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy =
                                map.next_value::<std::option::Option<crate::model::Policy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatePolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to the [UpdatePolicyRequest]
/// [google.cloud.orgpolicy.v2.OrgPolicy.UpdatePolicy] method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdatePolicyRequest {
    /// Required. Policy to update.
    pub policy: std::option::Option<crate::model::Policy>,

    /// Field mask used to specify the fields to be overwritten in the policy
    /// by the set. The fields specified in the update_mask are relative to the
    /// policy, not the full request.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy][crate::model::UpdatePolicyRequest::policy].
    pub fn set_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Policy>,
    {
        self.policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy][crate::model::UpdatePolicyRequest::policy].
    pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Policy>,
    {
        self.policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePolicyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePolicyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdatePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.UpdatePolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdatePolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdatePolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policy" => Ok(__FieldTag::__policy),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdatePolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdatePolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy =
                                map.next_value::<std::option::Option<crate::model::Policy>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdatePolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to the [DeletePolicy]
/// [google.cloud.orgpolicy.v2.OrgPolicy.DeletePolicy] method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePolicyRequest {
    /// Required. Name of the policy to delete.
    /// See the policy entry for naming rules.
    pub name: std::string::String,

    /// Optional. The current etag of policy. If an etag is provided and does not
    /// match the current etag of the policy, deletion will be blocked and an
    /// ABORTED error will be returned.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeletePolicyRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeletePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.DeletePolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeletePolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeletePolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeletePolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to the [CreateCustomConstraintRequest]
/// [google.cloud.orgpolicy.v2.OrgPolicy.CreateCustomConstraint] method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCustomConstraintRequest {
    /// Required. Must be in the following form:
    ///
    /// * `organizations/{organization_id}`
    pub parent: std::string::String,

    /// Required. Custom constraint to create.
    pub custom_constraint: std::option::Option<crate::model::CustomConstraint>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCustomConstraintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCustomConstraintRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [custom_constraint][crate::model::CreateCustomConstraintRequest::custom_constraint].
    pub fn set_custom_constraint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomConstraint>,
    {
        self.custom_constraint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_constraint][crate::model::CreateCustomConstraintRequest::custom_constraint].
    pub fn set_or_clear_custom_constraint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomConstraint>,
    {
        self.custom_constraint = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateCustomConstraintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.CreateCustomConstraintRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCustomConstraintRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __custom_constraint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCustomConstraintRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "customConstraint" => Ok(__FieldTag::__custom_constraint),
                            "custom_constraint" => Ok(__FieldTag::__custom_constraint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCustomConstraintRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCustomConstraintRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_constraint => {
                            if !fields.insert(__FieldTag::__custom_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_constraint",
                                ));
                            }
                            result.custom_constraint = map
                                .next_value::<std::option::Option<crate::model::CustomConstraint>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCustomConstraintRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.custom_constraint.is_some() {
            state.serialize_entry("customConstraint", &self.custom_constraint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to the [GetCustomConstraint]
/// [google.cloud.orgpolicy.v2.OrgPolicy.GetCustomConstraint] method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCustomConstraintRequest {
    /// Required. Resource name of the custom or managed constraint. See the custom
    /// constraint entry for naming requirements.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCustomConstraintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCustomConstraintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCustomConstraintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.GetCustomConstraintRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCustomConstraintRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCustomConstraintRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCustomConstraintRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCustomConstraintRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCustomConstraintRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to the [ListCustomConstraints]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListCustomConstraints] method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCustomConstraintsRequest {
    /// Required. The target Google Cloud resource that parents the set of custom
    /// constraints that will be returned from this call. Must be in one of the
    /// following forms:
    ///
    /// * `organizations/{organization_id}`
    pub parent: std::string::String,

    /// Size of the pages to be returned. This is currently unsupported and will
    /// be ignored. The server may at any point start using this field to limit
    /// page size.
    pub page_size: i32,

    /// Page token used to retrieve the next page. This is currently unsupported
    /// and will be ignored. The server may at any point start using this field.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomConstraintsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCustomConstraintsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCustomConstraintsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCustomConstraintsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomConstraintsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListCustomConstraintsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCustomConstraintsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCustomConstraintsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCustomConstraintsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCustomConstraintsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCustomConstraintsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response returned from the [ListCustomConstraints]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListCustomConstraints] method. It will
/// be empty if no custom or managed constraints are set on the organization
/// resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCustomConstraintsResponse {
    /// All custom and managed constraints that exist on the organization resource.
    /// It will be empty if no custom constraints are set.
    pub custom_constraints: std::vec::Vec<crate::model::CustomConstraint>,

    /// Page token used to retrieve the next page. This is currently not used, but
    /// the server may at any point start supplying a valid token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomConstraintsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_constraints][crate::model::ListCustomConstraintsResponse::custom_constraints].
    pub fn set_custom_constraints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomConstraint>,
    {
        use std::iter::Iterator;
        self.custom_constraints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCustomConstraintsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomConstraintsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListCustomConstraintsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCustomConstraintsResponse {
    type PageItem = crate::model::CustomConstraint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.custom_constraints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCustomConstraintsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __custom_constraints,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCustomConstraintsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "customConstraints" => Ok(__FieldTag::__custom_constraints),
                            "custom_constraints" => Ok(__FieldTag::__custom_constraints),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCustomConstraintsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCustomConstraintsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__custom_constraints => {
                            if !fields.insert(__FieldTag::__custom_constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_constraints",
                                ));
                            }
                            result.custom_constraints =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CustomConstraint>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCustomConstraintsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.custom_constraints.is_empty() {
            state.serialize_entry("customConstraints", &self.custom_constraints)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to the [UpdateCustomConstraintRequest]
/// [google.cloud.orgpolicy.v2.OrgPolicy.UpdateCustomConstraint] method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCustomConstraintRequest {
    /// Required. `CustomConstraint` to update.
    pub custom_constraint: std::option::Option<crate::model::CustomConstraint>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCustomConstraintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_constraint][crate::model::UpdateCustomConstraintRequest::custom_constraint].
    pub fn set_custom_constraint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomConstraint>,
    {
        self.custom_constraint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_constraint][crate::model::UpdateCustomConstraintRequest::custom_constraint].
    pub fn set_or_clear_custom_constraint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomConstraint>,
    {
        self.custom_constraint = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCustomConstraintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.UpdateCustomConstraintRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCustomConstraintRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __custom_constraint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCustomConstraintRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "customConstraint" => Ok(__FieldTag::__custom_constraint),
                            "custom_constraint" => Ok(__FieldTag::__custom_constraint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCustomConstraintRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCustomConstraintRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__custom_constraint => {
                            if !fields.insert(__FieldTag::__custom_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_constraint",
                                ));
                            }
                            result.custom_constraint = map
                                .next_value::<std::option::Option<crate::model::CustomConstraint>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCustomConstraintRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.custom_constraint.is_some() {
            state.serialize_entry("customConstraint", &self.custom_constraint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to the [DeleteCustomConstraint]
/// [google.cloud.orgpolicy.v2.OrgPolicy.DeleteCustomConstraint] method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCustomConstraintRequest {
    /// Required. Name of the custom constraint to delete.
    /// See the custom constraint entry for naming rules.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCustomConstraintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCustomConstraintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCustomConstraintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.DeleteCustomConstraintRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCustomConstraintRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCustomConstraintRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCustomConstraintRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCustomConstraintRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCustomConstraintRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
