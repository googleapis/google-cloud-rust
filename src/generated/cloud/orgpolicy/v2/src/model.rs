// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A constraint describes a way to restrict resource's configuration. For
/// example, you could enforce a constraint that controls which Google Cloud
/// services can be activated across an organization, or whether a Compute Engine
/// instance can have serial port connections established. Constraints can be
/// configured by the organization policy administrator to fit the needs of the
/// organization by setting a policy that includes constraints at different
/// locations in the organization's resource hierarchy. Policies are inherited
/// down the resource hierarchy from higher levels, but can also be overridden.
/// For details about the inheritance rules, see
/// [`Policy`][google.cloud.orgpolicy.v2.Policy].
///
/// Constraints have a default behavior determined by the `constraint_default`
/// field, which is the enforcement behavior that is used in the absence of a
/// policy being defined or inherited for the resource in question.
///
/// [google.cloud.orgpolicy.v2.Policy]: crate::model::Policy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Constraint {
    /// Immutable. The resource name of the constraint. Must be in one of
    /// the following forms:
    ///
    /// * `projects/{project_number}/constraints/{constraint_name}`
    /// * `folders/{folder_id}/constraints/{constraint_name}`
    /// * `organizations/{organization_id}/constraints/{constraint_name}`
    ///
    /// For example, "/projects/123/constraints/compute.disableSerialPortAccess".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The human readable name.
    ///
    /// Mutable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Detailed description of what this constraint controls as well as how and
    /// where it is enforced.
    ///
    /// Mutable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The evaluation behavior of this constraint in the absence of a policy.
    pub constraint_default: crate::model::constraint::ConstraintDefault,

    /// Shows if dry run is supported for this constraint or not.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub supports_dry_run: bool,

    /// Managed constraint and canned constraint sometimes can have
    /// equivalents. This field is used to store the equivalent constraint name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub equivalent_constraint: std::string::String,

    /// Shows if simulation is supported for this constraint or not.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub supports_simulation: bool,

    /// The type of restrictions for this `Constraint`.
    ///
    /// Immutable after creation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub constraint_type: std::option::Option<crate::model::constraint::ConstraintType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Constraint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Constraint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Constraint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Constraint::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [constraint_default][crate::model::Constraint::constraint_default].
    pub fn set_constraint_default<
        T: std::convert::Into<crate::model::constraint::ConstraintDefault>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_default = v.into();
        self
    }

    /// Sets the value of [supports_dry_run][crate::model::Constraint::supports_dry_run].
    pub fn set_supports_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.supports_dry_run = v.into();
        self
    }

    /// Sets the value of [equivalent_constraint][crate::model::Constraint::equivalent_constraint].
    pub fn set_equivalent_constraint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.equivalent_constraint = v.into();
        self
    }

    /// Sets the value of [supports_simulation][crate::model::Constraint::supports_simulation].
    pub fn set_supports_simulation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.supports_simulation = v.into();
        self
    }

    /// Sets the value of [constraint_type][crate::model::Constraint::constraint_type].
    ///
    /// Note that all the setters affecting `constraint_type` are mutually
    /// exclusive.
    pub fn set_constraint_type<
        T: std::convert::Into<std::option::Option<crate::model::constraint::ConstraintType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_type = v.into();
        self
    }

    /// The value of [constraint_type][crate::model::Constraint::constraint_type]
    /// if it holds a `ListConstraint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn list_constraint(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::constraint::ListConstraint>> {
        #[allow(unreachable_patterns)]
        self.constraint_type.as_ref().and_then(|v| match v {
            crate::model::constraint::ConstraintType::ListConstraint(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [constraint_type][crate::model::Constraint::constraint_type]
    /// to hold a `ListConstraint`.
    ///
    /// Note that all the setters affecting `constraint_type` are
    /// mutually exclusive.
    pub fn set_list_constraint<
        T: std::convert::Into<std::boxed::Box<crate::model::constraint::ListConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_type = std::option::Option::Some(
            crate::model::constraint::ConstraintType::ListConstraint(v.into()),
        );
        self
    }

    /// The value of [constraint_type][crate::model::Constraint::constraint_type]
    /// if it holds a `BooleanConstraint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn boolean_constraint(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::constraint::BooleanConstraint>> {
        #[allow(unreachable_patterns)]
        self.constraint_type.as_ref().and_then(|v| match v {
            crate::model::constraint::ConstraintType::BooleanConstraint(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [constraint_type][crate::model::Constraint::constraint_type]
    /// to hold a `BooleanConstraint`.
    ///
    /// Note that all the setters affecting `constraint_type` are
    /// mutually exclusive.
    pub fn set_boolean_constraint<
        T: std::convert::Into<std::boxed::Box<crate::model::constraint::BooleanConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_type = std::option::Option::Some(
            crate::model::constraint::ConstraintType::BooleanConstraint(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Constraint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint"
    }
}

/// Defines additional types related to [Constraint].
pub mod constraint {
    #[allow(unused_imports)]
    use super::*;

    /// A constraint type that allows or disallows a list of string values, which
    /// are configured in the
    /// [`PolicyRule`][google.cloud.orgpolicy.v2.PolicySpec.PolicyRule].
    ///
    /// [google.cloud.orgpolicy.v2.PolicySpec.PolicyRule]: crate::model::policy_spec::PolicyRule
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ListConstraint {
        /// Indicates whether values grouped into categories can be used in
        /// `Policy.allowed_values` and `Policy.denied_values`. For example,
        /// `"in:Python"` would match any value in the 'Python' group.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub supports_in: bool,

        /// Indicates whether subtrees of the Resource Manager resource hierarchy
        /// can be used in `Policy.allowed_values` and `Policy.denied_values`. For
        /// example, `"under:folders/123"` would match any resource under the
        /// 'folders/123' folder.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub supports_under: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ListConstraint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [supports_in][crate::model::constraint::ListConstraint::supports_in].
        pub fn set_supports_in<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.supports_in = v.into();
            self
        }

        /// Sets the value of [supports_under][crate::model::constraint::ListConstraint::supports_under].
        pub fn set_supports_under<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.supports_under = v.into();
            self
        }
    }

    impl wkt::message::Message for ListConstraint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint.ListConstraint"
        }
    }

    /// Custom constraint definition. Defines this as a managed constraint.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CustomConstraintDefinition {
        /// The resource instance type on which this policy applies. Format will be
        /// of the form : `<service name>/<type>` Example:
        ///
        /// * `compute.googleapis.com/Instance`.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub resource_types: std::vec::Vec<std::string::String>,

        /// All the operations being applied for this constraint.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub method_types:
            std::vec::Vec<crate::model::constraint::custom_constraint_definition::MethodType>,

        /// Org policy condition/expression. For example:
        /// `resource.instanceName.matches("[production|test]_.*_(\d)+")` or,
        /// `resource.management.auto_upgrade == true`
        ///
        /// The max length of the condition is 1000 characters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub condition: std::string::String,

        /// Allow or deny type.
        pub action_type: crate::model::constraint::custom_constraint_definition::ActionType,

        /// Stores the structure of
        /// [`Parameters`][google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.Parameter]
        /// used by the constraint condition. The key of `map` represents the name of
        /// the parameter.
        ///
        /// [google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.Parameter]: crate::model::constraint::custom_constraint_definition::Parameter
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub parameters: std::collections::HashMap<
            std::string::String,
            crate::model::constraint::custom_constraint_definition::Parameter,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CustomConstraintDefinition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resource_types][crate::model::constraint::CustomConstraintDefinition::resource_types].
        pub fn set_resource_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.resource_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [method_types][crate::model::constraint::CustomConstraintDefinition::method_types].
        pub fn set_method_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::constraint::custom_constraint_definition::MethodType,
                >,
        {
            use std::iter::Iterator;
            self.method_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [condition][crate::model::constraint::CustomConstraintDefinition::condition].
        pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.condition = v.into();
            self
        }

        /// Sets the value of [action_type][crate::model::constraint::CustomConstraintDefinition::action_type].
        pub fn set_action_type<
            T: std::convert::Into<crate::model::constraint::custom_constraint_definition::ActionType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.action_type = v.into();
            self
        }

        /// Sets the value of [parameters][crate::model::constraint::CustomConstraintDefinition::parameters].
        pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<
                    crate::model::constraint::custom_constraint_definition::Parameter,
                >,
        {
            use std::iter::Iterator;
            self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for CustomConstraintDefinition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition"
        }
    }

    /// Defines additional types related to [CustomConstraintDefinition].
    pub mod custom_constraint_definition {
        #[allow(unused_imports)]
        use super::*;

        /// Defines a parameter structure.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Parameter {
            /// Type of the parameter.
            #[serde(rename = "type")]
            pub r#type: crate::model::constraint::custom_constraint_definition::parameter::Type,

            /// Sets the value of the parameter in an assignment if no value is given.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub default_value: std::option::Option<wkt::Value>,

            /// Provides a CEL expression to specify the acceptable parameter values
            /// during assignment.
            /// For example, parameterName in ("parameterValue1", "parameterValue2")
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub valid_values_expr: std::string::String,

            /// Defines subproperties primarily used by the UI to display user-friendly
            /// information.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub metadata: std::option::Option<
                crate::model::constraint::custom_constraint_definition::parameter::Metadata,
            >,

            /// Determines the parameter's value structure.
            /// For example, `LIST<STRING>` can be specified by defining `type: LIST`,
            /// and `item: STRING`.
            pub item: crate::model::constraint::custom_constraint_definition::parameter::Type,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Parameter {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [r#type][crate::model::constraint::custom_constraint_definition::Parameter::type].
            pub fn set_type<
                T: std::convert::Into<
                        crate::model::constraint::custom_constraint_definition::parameter::Type,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// Sets the value of [default_value][crate::model::constraint::custom_constraint_definition::Parameter::default_value].
            pub fn set_default_value<T: std::convert::Into<std::option::Option<wkt::Value>>>(
                mut self,
                v: T,
            ) -> Self {
                self.default_value = v.into();
                self
            }

            /// Sets the value of [valid_values_expr][crate::model::constraint::custom_constraint_definition::Parameter::valid_values_expr].
            pub fn set_valid_values_expr<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.valid_values_expr = v.into();
                self
            }

            /// Sets the value of [metadata][crate::model::constraint::custom_constraint_definition::Parameter::metadata].
            pub fn set_metadata<T: std::convert::Into<std::option::Option<crate::model::constraint::custom_constraint_definition::parameter::Metadata>>>(mut self, v: T) -> Self{
                self.metadata = v.into();
                self
            }

            /// Sets the value of [item][crate::model::constraint::custom_constraint_definition::Parameter::item].
            pub fn set_item<
                T: std::convert::Into<
                        crate::model::constraint::custom_constraint_definition::parameter::Type,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.item = v.into();
                self
            }
        }

        impl wkt::message::Message for Parameter {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.Parameter"
            }
        }

        /// Defines additional types related to [Parameter].
        pub mod parameter {
            #[allow(unused_imports)]
            use super::*;

            /// Defines Metadata structure.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Metadata {
                /// Detailed description of what this `parameter` is and use of it.
                /// Mutable.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub description: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Metadata {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [description][crate::model::constraint::custom_constraint_definition::parameter::Metadata::description].
                pub fn set_description<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.description = v.into();
                    self
                }
            }

            impl wkt::message::Message for Metadata {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.Parameter.Metadata"
                }
            }

            /// All valid types of parameter.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Type {
                /// This is only used for distinguishing unset values and should never be
                /// used. Results in an error.
                Unspecified,
                /// List parameter type.
                List,
                /// String parameter type.
                String,
                /// Boolean parameter type.
                Boolean,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [Type::value] or
                /// [Type::name].
                UnknownValue(r#type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod r#type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl Type {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::List => std::option::Option::Some(1),
                        Self::String => std::option::Option::Some(2),
                        Self::Boolean => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                        Self::List => std::option::Option::Some("LIST"),
                        Self::String => std::option::Option::Some("STRING"),
                        Self::Boolean => std::option::Option::Some("BOOLEAN"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for Type {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for Type {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for Type {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::List,
                        2 => Self::String,
                        3 => Self::Boolean,
                        _ => Self::UnknownValue(r#type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for Type {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "TYPE_UNSPECIFIED" => Self::Unspecified,
                        "LIST" => Self::List,
                        "STRING" => Self::String,
                        "BOOLEAN" => Self::Boolean,
                        _ => Self::UnknownValue(r#type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for Type {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::List => serializer.serialize_i32(1),
                        Self::String => serializer.serialize_i32(2),
                        Self::Boolean => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for Type {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                        ".google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.Parameter.Type"))
                }
            }
        }

        /// The operation for which this constraint will be applied. To apply this
        /// constraint only when creating new resources, the `method_types` should be
        /// `CREATE` only. To apply this constraint when creating or deleting
        /// resources, the `method_types` should be `CREATE` and `DELETE`.
        ///
        /// `UPDATE`-only custom constraints are not supported. Use `CREATE` or
        /// `CREATE, UPDATE`.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MethodType {
            /// This is only used for distinguishing unset values and should never be
            /// used. Results in an error.
            Unspecified,
            /// Constraint applied when creating the resource.
            Create,
            /// Constraint applied when updating the resource.
            Update,
            /// Constraint applied when deleting the resource.
            /// Not currently supported.
            Delete,
            /// Constraint applied when removing an IAM grant.
            RemoveGrant,
            /// Constraint applied when enforcing forced tagging.
            GovernTags,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [MethodType::value] or
            /// [MethodType::name].
            UnknownValue(method_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod method_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl MethodType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Create => std::option::Option::Some(1),
                    Self::Update => std::option::Option::Some(2),
                    Self::Delete => std::option::Option::Some(3),
                    Self::RemoveGrant => std::option::Option::Some(4),
                    Self::GovernTags => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("METHOD_TYPE_UNSPECIFIED"),
                    Self::Create => std::option::Option::Some("CREATE"),
                    Self::Update => std::option::Option::Some("UPDATE"),
                    Self::Delete => std::option::Option::Some("DELETE"),
                    Self::RemoveGrant => std::option::Option::Some("REMOVE_GRANT"),
                    Self::GovernTags => std::option::Option::Some("GOVERN_TAGS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for MethodType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for MethodType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for MethodType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Create,
                    2 => Self::Update,
                    3 => Self::Delete,
                    4 => Self::RemoveGrant,
                    5 => Self::GovernTags,
                    _ => Self::UnknownValue(method_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for MethodType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "METHOD_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "CREATE" => Self::Create,
                    "UPDATE" => Self::Update,
                    "DELETE" => Self::Delete,
                    "REMOVE_GRANT" => Self::RemoveGrant,
                    "GOVERN_TAGS" => Self::GovernTags,
                    _ => Self::UnknownValue(method_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for MethodType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Create => serializer.serialize_i32(1),
                    Self::Update => serializer.serialize_i32(2),
                    Self::Delete => serializer.serialize_i32(3),
                    Self::RemoveGrant => serializer.serialize_i32(4),
                    Self::GovernTags => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for MethodType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<MethodType>::new(
                    ".google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.MethodType",
                ))
            }
        }

        /// Allow or deny type.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ActionType {
            /// This is only used for distinguishing unset values and should never be
            /// used. Results in an error.
            Unspecified,
            /// Allowed action type.
            Allow,
            /// Deny action type.
            Deny,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ActionType::value] or
            /// [ActionType::name].
            UnknownValue(action_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod action_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ActionType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Allow => std::option::Option::Some(1),
                    Self::Deny => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ACTION_TYPE_UNSPECIFIED"),
                    Self::Allow => std::option::Option::Some("ALLOW"),
                    Self::Deny => std::option::Option::Some("DENY"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ActionType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ActionType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ActionType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Allow,
                    2 => Self::Deny,
                    _ => Self::UnknownValue(action_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ActionType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ACTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "ALLOW" => Self::Allow,
                    "DENY" => Self::Deny,
                    _ => Self::UnknownValue(action_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ActionType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Allow => serializer.serialize_i32(1),
                    Self::Deny => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ActionType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ActionType>::new(
                    ".google.cloud.orgpolicy.v2.Constraint.CustomConstraintDefinition.ActionType",
                ))
            }
        }
    }

    /// A constraint type is enforced or not enforced, which is configured in the
    /// [`PolicyRule`][google.cloud.orgpolicy.v2.PolicySpec.PolicyRule].
    ///
    /// If `customConstraintDefinition` is defined, this constraint is a managed
    /// constraint.
    ///
    /// [google.cloud.orgpolicy.v2.PolicySpec.PolicyRule]: crate::model::policy_spec::PolicyRule
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BooleanConstraint {
        /// Custom constraint definition. Defines this as a managed constraint.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub custom_constraint_definition:
            std::option::Option<crate::model::constraint::CustomConstraintDefinition>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BooleanConstraint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [custom_constraint_definition][crate::model::constraint::BooleanConstraint::custom_constraint_definition].
        pub fn set_custom_constraint_definition<
            T: std::convert::Into<
                    std::option::Option<crate::model::constraint::CustomConstraintDefinition>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.custom_constraint_definition = v.into();
            self
        }
    }

    impl wkt::message::Message for BooleanConstraint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint.BooleanConstraint"
        }
    }

    /// Specifies the default behavior in the absence of any policy for the
    /// constraint. This must not be `CONSTRAINT_DEFAULT_UNSPECIFIED`.
    ///
    /// Immutable after creation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConstraintDefault {
        /// This is only used for distinguishing unset values and should never be
        /// used. Results in an error.
        Unspecified,
        /// Indicate that all values are allowed for list constraints.
        /// Indicate that enforcement is off for boolean constraints.
        Allow,
        /// Indicate that all values are denied for list constraints.
        /// Indicate that enforcement is on for boolean constraints.
        Deny,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConstraintDefault::value] or
        /// [ConstraintDefault::name].
        UnknownValue(constraint_default::UnknownValue),
    }

    #[doc(hidden)]
    pub mod constraint_default {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConstraintDefault {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Allow => std::option::Option::Some(1),
                Self::Deny => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONSTRAINT_DEFAULT_UNSPECIFIED"),
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::Deny => std::option::Option::Some("DENY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConstraintDefault {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConstraintDefault {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConstraintDefault {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Allow,
                2 => Self::Deny,
                _ => Self::UnknownValue(constraint_default::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConstraintDefault {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONSTRAINT_DEFAULT_UNSPECIFIED" => Self::Unspecified,
                "ALLOW" => Self::Allow,
                "DENY" => Self::Deny,
                _ => Self::UnknownValue(constraint_default::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConstraintDefault {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Allow => serializer.serialize_i32(1),
                Self::Deny => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConstraintDefault {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConstraintDefault>::new(
                ".google.cloud.orgpolicy.v2.Constraint.ConstraintDefault",
            ))
        }
    }

    /// The type of restrictions for this `Constraint`.
    ///
    /// Immutable after creation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ConstraintType {
        /// Defines this constraint as being a list constraint.
        ListConstraint(std::boxed::Box<crate::model::constraint::ListConstraint>),
        /// Defines this constraint as being a boolean constraint.
        BooleanConstraint(std::boxed::Box<crate::model::constraint::BooleanConstraint>),
    }
}

/// A custom constraint defined by customers which can *only* be applied to the
/// given resource types and organization.
///
/// By creating a custom constraint, customers can apply policies of this
/// custom constraint. *Creating a custom constraint itself does NOT apply any
/// policy enforcement*.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomConstraint {
    /// Immutable. Name of the constraint. This is unique within the organization.
    /// Format of the name should be
    ///
    /// * `organizations/{organization_id}/customConstraints/{custom_constraint_id}`
    ///
    /// Example: `organizations/123/customConstraints/custom.createOnlyE2TypeVms`
    ///
    /// The max length is 70 characters and the minimum length is 1. Note that the
    /// prefix `organizations/{organization_id}/customConstraints/` is not counted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Immutable. The resource instance type on which this policy applies. Format
    /// will be of the form : `<service name>/<type>` Example:
    ///
    /// * `compute.googleapis.com/Instance`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_types: std::vec::Vec<std::string::String>,

    /// All the operations being applied for this constraint.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub method_types: std::vec::Vec<crate::model::custom_constraint::MethodType>,

    /// A Common Expression Language (CEL) condition which is used in the
    /// evaluation of the constraint. For example:
    /// `resource.instanceName.matches("[production|test]_.*_(\d)+")` or,
    /// `resource.management.auto_upgrade == true`
    ///
    /// The max length of the condition is 1000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub condition: std::string::String,

    /// Allow or deny type.
    pub action_type: crate::model::custom_constraint::ActionType,

    /// One line display name for the UI.
    /// The max length of the display_name is 200 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Detailed information about this custom policy constraint.
    /// The max length of the description is 2000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The last time this custom constraint was updated. This
    /// represents the last time that the `CreateCustomConstraint` or
    /// `UpdateCustomConstraint` methods were called.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomConstraint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CustomConstraint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [resource_types][crate::model::CustomConstraint::resource_types].
    pub fn set_resource_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [method_types][crate::model::CustomConstraint::method_types].
    pub fn set_method_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::custom_constraint::MethodType>,
    {
        use std::iter::Iterator;
        self.method_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [condition][crate::model::CustomConstraint::condition].
    pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [action_type][crate::model::CustomConstraint::action_type].
    pub fn set_action_type<T: std::convert::Into<crate::model::custom_constraint::ActionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.action_type = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CustomConstraint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::CustomConstraint::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CustomConstraint::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for CustomConstraint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.CustomConstraint"
    }
}

/// Defines additional types related to [CustomConstraint].
pub mod custom_constraint {
    #[allow(unused_imports)]
    use super::*;

    /// The operation for which this constraint will be applied. To apply this
    /// constraint only when creating new resources, the `method_types` should be
    /// `CREATE` only. To apply this constraint when creating or deleting
    /// resources, the `method_types` should be `CREATE` and `DELETE`.
    ///
    /// `UPDATE` only custom constraints are not supported. Use `CREATE` or
    /// `CREATE, UPDATE`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MethodType {
        /// This is only used for distinguishing unset values and should never be
        /// used. Results in an error.
        Unspecified,
        /// Constraint applied when creating the resource.
        Create,
        /// Constraint applied when updating the resource.
        Update,
        /// Constraint applied when deleting the resource.
        /// Not currently supported.
        Delete,
        /// Constraint applied when removing an IAM grant.
        RemoveGrant,
        /// Constraint applied when enforcing forced tagging.
        GovernTags,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MethodType::value] or
        /// [MethodType::name].
        UnknownValue(method_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod method_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MethodType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Create => std::option::Option::Some(1),
                Self::Update => std::option::Option::Some(2),
                Self::Delete => std::option::Option::Some(3),
                Self::RemoveGrant => std::option::Option::Some(4),
                Self::GovernTags => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METHOD_TYPE_UNSPECIFIED"),
                Self::Create => std::option::Option::Some("CREATE"),
                Self::Update => std::option::Option::Some("UPDATE"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::RemoveGrant => std::option::Option::Some("REMOVE_GRANT"),
                Self::GovernTags => std::option::Option::Some("GOVERN_TAGS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MethodType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MethodType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MethodType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Create,
                2 => Self::Update,
                3 => Self::Delete,
                4 => Self::RemoveGrant,
                5 => Self::GovernTags,
                _ => Self::UnknownValue(method_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MethodType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METHOD_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CREATE" => Self::Create,
                "UPDATE" => Self::Update,
                "DELETE" => Self::Delete,
                "REMOVE_GRANT" => Self::RemoveGrant,
                "GOVERN_TAGS" => Self::GovernTags,
                _ => Self::UnknownValue(method_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MethodType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Create => serializer.serialize_i32(1),
                Self::Update => serializer.serialize_i32(2),
                Self::Delete => serializer.serialize_i32(3),
                Self::RemoveGrant => serializer.serialize_i32(4),
                Self::GovernTags => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MethodType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MethodType>::new(
                ".google.cloud.orgpolicy.v2.CustomConstraint.MethodType",
            ))
        }
    }

    /// Allow or deny type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ActionType {
        /// This is only used for distinguishing unset values and should never be
        /// used. Results in an error.
        Unspecified,
        /// Allowed action type.
        Allow,
        /// Deny action type.
        Deny,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ActionType::value] or
        /// [ActionType::name].
        UnknownValue(action_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod action_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ActionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Allow => std::option::Option::Some(1),
                Self::Deny => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACTION_TYPE_UNSPECIFIED"),
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::Deny => std::option::Option::Some("DENY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ActionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ActionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ActionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Allow,
                2 => Self::Deny,
                _ => Self::UnknownValue(action_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ActionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ALLOW" => Self::Allow,
                "DENY" => Self::Deny,
                _ => Self::UnknownValue(action_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ActionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Allow => serializer.serialize_i32(1),
                Self::Deny => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ActionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ActionType>::new(
                ".google.cloud.orgpolicy.v2.CustomConstraint.ActionType",
            ))
        }
    }
}

/// Defines an organization policy which is used to specify constraints
/// for configurations of Google Cloud resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Policy {
    /// Immutable. The resource name of the policy. Must be one of the following
    /// forms, where `constraint_name` is the name of the constraint which this
    /// policy configures:
    ///
    /// * `projects/{project_number}/policies/{constraint_name}`
    /// * `folders/{folder_id}/policies/{constraint_name}`
    /// * `organizations/{organization_id}/policies/{constraint_name}`
    ///
    /// For example, `projects/123/policies/compute.disableSerialPortAccess`.
    ///
    /// Note: `projects/{project_id}/policies/{constraint_name}` is also an
    /// acceptable name for API requests, but responses will return the name using
    /// the equivalent project number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Basic information about the organization policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spec: std::option::Option<crate::model::PolicySpec>,

    /// Deprecated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub alternate: std::option::Option<crate::model::AlternatePolicySpec>,

    /// Dry-run policy.
    /// Audit-only policy, can be used to monitor how the policy would have
    /// impacted the existing and future resources if it's enforced.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dry_run_spec: std::option::Option<crate::model::PolicySpec>,

    /// Optional. An opaque tag indicating the current state of the policy, used
    /// for concurrency control. This 'etag' is computed by the server based on the
    /// value of other fields, and may be sent on update and delete requests to
    /// ensure the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Policy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Policy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::Policy::spec].
    pub fn set_spec<T: std::convert::Into<std::option::Option<crate::model::PolicySpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }

    /// Sets the value of [alternate][crate::model::Policy::alternate].
    #[deprecated]
    pub fn set_alternate<
        T: std::convert::Into<std::option::Option<crate::model::AlternatePolicySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alternate = v.into();
        self
    }

    /// Sets the value of [dry_run_spec][crate::model::Policy::dry_run_spec].
    pub fn set_dry_run_spec<
        T: std::convert::Into<std::option::Option<crate::model::PolicySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dry_run_spec = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Policy::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Policy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.Policy"
    }
}

/// Similar to PolicySpec but with an extra 'launch' field for launch reference.
/// The PolicySpec here is specific for dry-run.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AlternatePolicySpec {
    /// Reference to the launch that will be used while audit logging and to
    /// control the launch.
    /// Should be set only in the alternate policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub launch: std::string::String,

    /// Specify constraint for configurations of Google Cloud resources.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spec: std::option::Option<crate::model::PolicySpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AlternatePolicySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [launch][crate::model::AlternatePolicySpec::launch].
    pub fn set_launch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.launch = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::AlternatePolicySpec::spec].
    pub fn set_spec<T: std::convert::Into<std::option::Option<crate::model::PolicySpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }
}

impl wkt::message::Message for AlternatePolicySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.AlternatePolicySpec"
    }
}

/// Defines a Google Cloud policy specification which is used to specify
/// constraints for configurations of Google Cloud resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PolicySpec {
    /// An opaque tag indicating the current version of the policySpec, used for
    /// concurrency control.
    ///
    /// This field is ignored if used in a `CreatePolicy` request.
    ///
    /// When the policy is returned from either a `GetPolicy` or a
    /// `ListPolicies` request, this `etag` indicates the version of the
    /// current policySpec to use when executing a read-modify-write loop.
    ///
    /// When the policy is returned from a `GetEffectivePolicy` request, the
    /// `etag` will be unset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. The time stamp this was previously updated. This
    /// represents the last time a call to `CreatePolicy` or `UpdatePolicy` was
    /// made for that policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// In policies for boolean constraints, the following requirements apply:
    ///
    /// - There must be one and only one policy rule where condition is unset.
    /// - Boolean policy rules with conditions must set `enforced` to the
    ///   opposite of the policy rule without a condition.
    /// - During policy evaluation, policy rules with conditions that are
    ///   true for a target resource take precedence.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rules: std::vec::Vec<crate::model::policy_spec::PolicyRule>,

    /// Determines the inheritance behavior for this policy.
    ///
    /// If `inherit_from_parent` is true, policy rules set higher up in the
    /// hierarchy (up to the closest root) are inherited and present in the
    /// effective policy. If it is false, then no rules are inherited, and this
    /// policy becomes the new root for evaluation.
    /// This field can be set only for policies which configure list constraints.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub inherit_from_parent: bool,

    /// Ignores policies set above this resource and restores the
    /// `constraint_default` enforcement behavior of the specific constraint at
    /// this resource.
    /// This field can be set in policies for either list or boolean
    /// constraints. If set, `rules` must be empty and `inherit_from_parent`
    /// must be set to false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub reset: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PolicySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [etag][crate::model::PolicySpec::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PolicySpec::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [rules][crate::model::PolicySpec::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::policy_spec::PolicyRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [inherit_from_parent][crate::model::PolicySpec::inherit_from_parent].
    pub fn set_inherit_from_parent<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.inherit_from_parent = v.into();
        self
    }

    /// Sets the value of [reset][crate::model::PolicySpec::reset].
    pub fn set_reset<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reset = v.into();
        self
    }
}

impl wkt::message::Message for PolicySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.PolicySpec"
    }
}

/// Defines additional types related to [PolicySpec].
pub mod policy_spec {
    #[allow(unused_imports)]
    use super::*;

    /// A rule used to express this policy.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PolicyRule {
        /// A condition which determines whether this rule is used
        /// in the evaluation of the policy. When set, the `expression` field in
        /// the `Expr' must include from 1 to 10 subexpressions, joined by the "||"
        /// or "&&" operators. Each subexpression must be of the form
        /// "resource.matchTag('<ORG_ID>/tag_key_short_name,
        /// 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id',
        /// 'tagValues/value_id')". where key_name and value_name are the resource
        /// names for Label Keys and Values. These names are available from the Tag
        /// Manager Service. An example expression is:
        /// "resource.matchTag('123456789/environment,
        /// 'prod')". or "resource.matchTagId('tagKeys/123',
        /// 'tagValues/456')".
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub condition: std::option::Option<gtype::model::Expr>,

        /// Optional. Required for managed constraints if parameters are defined.
        /// Passes parameter values when policy enforcement is enabled. Ensure that
        /// parameter value types match those defined in the constraint definition.
        /// For example:
        /// {
        /// "allowedLocations" : ["us-east1", "us-west1"],
        /// "allowAll" : true
        /// }
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub parameters: std::option::Option<wkt::Struct>,

        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub kind: std::option::Option<crate::model::policy_spec::policy_rule::Kind>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PolicyRule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [condition][crate::model::policy_spec::PolicyRule::condition].
        pub fn set_condition<T: std::convert::Into<std::option::Option<gtype::model::Expr>>>(
            mut self,
            v: T,
        ) -> Self {
            self.condition = v.into();
            self
        }

        /// Sets the value of [parameters][crate::model::policy_spec::PolicyRule::parameters].
        pub fn set_parameters<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
            mut self,
            v: T,
        ) -> Self {
            self.parameters = v.into();
            self
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind].
        ///
        /// Note that all the setters affecting `kind` are mutually
        /// exclusive.
        pub fn set_kind<
            T: std::convert::Into<std::option::Option<crate::model::policy_spec::policy_rule::Kind>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// if it holds a `Values`, `None` if the field is not set or
        /// holds a different branch.
        pub fn values(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::policy_spec::policy_rule::StringValues>,
        > {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::policy_spec::policy_rule::Kind::Values(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// to hold a `Values`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_values<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::policy_spec::policy_rule::StringValues>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::policy_spec::policy_rule::Kind::Values(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// if it holds a `AllowAll`, `None` if the field is not set or
        /// holds a different branch.
        pub fn allow_all(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::policy_spec::policy_rule::Kind::AllowAll(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// to hold a `AllowAll`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_allow_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::policy_spec::policy_rule::Kind::AllowAll(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// if it holds a `DenyAll`, `None` if the field is not set or
        /// holds a different branch.
        pub fn deny_all(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::policy_spec::policy_rule::Kind::DenyAll(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// to hold a `DenyAll`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_deny_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::policy_spec::policy_rule::Kind::DenyAll(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// if it holds a `Enforce`, `None` if the field is not set or
        /// holds a different branch.
        pub fn enforce(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::policy_spec::policy_rule::Kind::Enforce(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// to hold a `Enforce`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_enforce<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::policy_spec::policy_rule::Kind::Enforce(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for PolicyRule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orgpolicy.v2.PolicySpec.PolicyRule"
        }
    }

    /// Defines additional types related to [PolicyRule].
    pub mod policy_rule {
        #[allow(unused_imports)]
        use super::*;

        /// A message that holds specific allowed and denied values.
        /// This message can define specific values and subtrees of the Resource
        /// Manager resource hierarchy (`Organizations`, `Folders`, `Projects`) that
        /// are allowed or denied. This is achieved by using the `under:` and
        /// optional `is:` prefixes.
        /// The `under:` prefix is used to denote resource subtree values.
        /// The `is:` prefix is used to denote specific values, and is required only
        /// if the value contains a ":". Values prefixed with "is:" are treated the
        /// same as values with no prefix.
        /// Ancestry subtrees must be in one of the following formats:
        ///
        /// - `projects/<project-id>` (for example, `projects/tokyo-rain-123`)
        /// - `folders/<folder-id>` (for example, `folders/1234`)
        /// - `organizations/<organization-id>` (for example, `organizations/1234`)
        ///
        /// The `supports_under` field of the associated `Constraint`  defines
        /// whether ancestry prefixes can be used.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct StringValues {
            /// List of values allowed at this resource.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub allowed_values: std::vec::Vec<std::string::String>,

            /// List of values denied at this resource.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub denied_values: std::vec::Vec<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl StringValues {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [allowed_values][crate::model::policy_spec::policy_rule::StringValues::allowed_values].
            pub fn set_allowed_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.allowed_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [denied_values][crate::model::policy_spec::policy_rule::StringValues::denied_values].
            pub fn set_denied_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.denied_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for StringValues {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.orgpolicy.v2.PolicySpec.PolicyRule.StringValues"
            }
        }

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Kind {
            /// List of values to be used for this policy rule. This field can be set
            /// only in policies for list constraints.
            Values(std::boxed::Box<crate::model::policy_spec::policy_rule::StringValues>),
            /// Setting this to true means that all values are allowed. This field can
            /// be set only in policies for list constraints.
            AllowAll(bool),
            /// Setting this to true means that all values are denied. This field can
            /// be set only in policies for list constraints.
            DenyAll(bool),
            /// If `true`, then the policy is enforced. If `false`, then any
            /// configuration is acceptable.
            /// This field can be set only in policies for boolean constraints.
            Enforce(bool),
        }
    }
}

/// The request sent to the [ListConstraints]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListConstraints] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConstraintsRequest {
    /// Required. The Google Cloud resource that parents the constraint. Must be in
    /// one of the following forms:
    ///
    /// * `projects/{project_number}`
    /// * `projects/{project_id}`
    /// * `folders/{folder_id}`
    /// * `organizations/{organization_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Size of the pages to be returned. This is currently unsupported and will
    /// be ignored. The server may at any point start using this field to limit
    /// page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Page token used to retrieve the next page. This is currently unsupported
    /// and will be ignored. The server may at any point start using this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConstraintsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConstraintsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConstraintsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConstraintsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConstraintsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListConstraintsRequest"
    }
}

/// The response returned from the [ListConstraints]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListConstraints] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConstraintsResponse {
    /// The collection of constraints that are available on the targeted resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub constraints: std::vec::Vec<crate::model::Constraint>,

    /// Page token used to retrieve the next page. This is currently not used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConstraintsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [constraints][crate::model::ListConstraintsResponse::constraints].
    pub fn set_constraints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Constraint>,
    {
        use std::iter::Iterator;
        self.constraints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConstraintsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConstraintsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListConstraintsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConstraintsResponse {
    type PageItem = crate::model::Constraint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.constraints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request sent to the [ListPolicies]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListPolicies] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPoliciesRequest {
    /// Required. The target Google Cloud resource that parents the set of
    /// constraints and policies that will be returned from this call. Must be in
    /// one of the following forms:
    ///
    /// * `projects/{project_number}`
    /// * `projects/{project_id}`
    /// * `folders/{folder_id}`
    /// * `organizations/{organization_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Size of the pages to be returned. This is currently unsupported and will
    /// be ignored. The server may at any point start using this field to limit
    /// page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Page token used to retrieve the next page. This is currently unsupported
    /// and will be ignored. The server may at any point start using this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListPoliciesRequest"
    }
}

/// The response returned from the [ListPolicies]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListPolicies] method. It will be empty
/// if no policies are set on the resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPoliciesResponse {
    /// All policies that exist on the resource. It will be empty if no
    /// policies are set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub policies: std::vec::Vec<crate::model::Policy>,

    /// Page token used to retrieve the next page. This is currently not used, but
    /// the server may at any point start supplying a valid token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policies][crate::model::ListPoliciesResponse::policies].
    pub fn set_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Policy>,
    {
        use std::iter::Iterator;
        self.policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPoliciesResponse {
    type PageItem = crate::model::Policy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request sent to the [GetPolicy]
/// [google.cloud.orgpolicy.v2.OrgPolicy.GetPolicy] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPolicyRequest {
    /// Required. Resource name of the policy. See
    /// [Policy][google.cloud.orgpolicy.v2.Policy] for naming requirements.
    ///
    /// [google.cloud.orgpolicy.v2.Policy]: crate::model::Policy
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.GetPolicyRequest"
    }
}

/// The request sent to the [GetEffectivePolicy]
/// [google.cloud.orgpolicy.v2.OrgPolicy.GetEffectivePolicy] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEffectivePolicyRequest {
    /// Required. The effective policy to compute. See
    /// [Policy][google.cloud.orgpolicy.v2.Policy] for naming requirements.
    ///
    /// [google.cloud.orgpolicy.v2.Policy]: crate::model::Policy
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEffectivePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEffectivePolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEffectivePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.GetEffectivePolicyRequest"
    }
}

/// The request sent to the [CreatePolicyRequest]
/// [google.cloud.orgpolicy.v2.OrgPolicy.CreatePolicy] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePolicyRequest {
    /// Required. The Google Cloud resource that will parent the new policy. Must
    /// be in one of the following forms:
    ///
    /// * `projects/{project_number}`
    /// * `projects/{project_id}`
    /// * `folders/{folder_id}`
    /// * `organizations/{organization_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Policy to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy: std::option::Option<crate::model::Policy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePolicyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [policy][crate::model::CreatePolicyRequest::policy].
    pub fn set_policy<T: std::convert::Into<std::option::Option<crate::model::Policy>>>(
        mut self,
        v: T,
    ) -> Self {
        self.policy = v.into();
        self
    }
}

impl wkt::message::Message for CreatePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.CreatePolicyRequest"
    }
}

/// The request sent to the [UpdatePolicyRequest]
/// [google.cloud.orgpolicy.v2.OrgPolicy.UpdatePolicy] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePolicyRequest {
    /// Required. Policy to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy: std::option::Option<crate::model::Policy>,

    /// Field mask used to specify the fields to be overwritten in the policy
    /// by the set. The fields specified in the update_mask are relative to the
    /// policy, not the full request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy][crate::model::UpdatePolicyRequest::policy].
    pub fn set_policy<T: std::convert::Into<std::option::Option<crate::model::Policy>>>(
        mut self,
        v: T,
    ) -> Self {
        self.policy = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePolicyRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.UpdatePolicyRequest"
    }
}

/// The request sent to the [DeletePolicy]
/// [google.cloud.orgpolicy.v2.OrgPolicy.DeletePolicy] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePolicyRequest {
    /// Required. Name of the policy to delete.
    /// See the policy entry for naming rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The current etag of policy. If an etag is provided and does not
    /// match the current etag of the policy, deletion will be blocked and an
    /// ABORTED error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeletePolicyRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeletePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.DeletePolicyRequest"
    }
}

/// The request sent to the [CreateCustomConstraintRequest]
/// [google.cloud.orgpolicy.v2.OrgPolicy.CreateCustomConstraint] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCustomConstraintRequest {
    /// Required. Must be in the following form:
    ///
    /// * `organizations/{organization_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Custom constraint to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_constraint: std::option::Option<crate::model::CustomConstraint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCustomConstraintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCustomConstraintRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [custom_constraint][crate::model::CreateCustomConstraintRequest::custom_constraint].
    pub fn set_custom_constraint<
        T: std::convert::Into<std::option::Option<crate::model::CustomConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.custom_constraint = v.into();
        self
    }
}

impl wkt::message::Message for CreateCustomConstraintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.CreateCustomConstraintRequest"
    }
}

/// The request sent to the [GetCustomConstraint]
/// [google.cloud.orgpolicy.v2.OrgPolicy.GetCustomConstraint] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCustomConstraintRequest {
    /// Required. Resource name of the custom or managed constraint. See the custom
    /// constraint entry for naming requirements.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCustomConstraintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCustomConstraintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCustomConstraintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.GetCustomConstraintRequest"
    }
}

/// The request sent to the [ListCustomConstraints]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListCustomConstraints] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomConstraintsRequest {
    /// Required. The target Google Cloud resource that parents the set of custom
    /// constraints that will be returned from this call. Must be in one of the
    /// following forms:
    ///
    /// * `organizations/{organization_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Size of the pages to be returned. This is currently unsupported and will
    /// be ignored. The server may at any point start using this field to limit
    /// page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Page token used to retrieve the next page. This is currently unsupported
    /// and will be ignored. The server may at any point start using this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomConstraintsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCustomConstraintsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCustomConstraintsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCustomConstraintsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomConstraintsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListCustomConstraintsRequest"
    }
}

/// The response returned from the [ListCustomConstraints]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListCustomConstraints] method. It will
/// be empty if no custom or managed constraints are set on the organization
/// resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomConstraintsResponse {
    /// All custom and managed constraints that exist on the organization resource.
    /// It will be empty if no custom constraints are set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub custom_constraints: std::vec::Vec<crate::model::CustomConstraint>,

    /// Page token used to retrieve the next page. This is currently not used, but
    /// the server may at any point start supplying a valid token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomConstraintsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_constraints][crate::model::ListCustomConstraintsResponse::custom_constraints].
    pub fn set_custom_constraints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomConstraint>,
    {
        use std::iter::Iterator;
        self.custom_constraints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCustomConstraintsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomConstraintsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListCustomConstraintsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCustomConstraintsResponse {
    type PageItem = crate::model::CustomConstraint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.custom_constraints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request sent to the [UpdateCustomConstraintRequest]
/// [google.cloud.orgpolicy.v2.OrgPolicy.UpdateCustomConstraint] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCustomConstraintRequest {
    /// Required. `CustomConstraint` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_constraint: std::option::Option<crate::model::CustomConstraint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCustomConstraintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_constraint][crate::model::UpdateCustomConstraintRequest::custom_constraint].
    pub fn set_custom_constraint<
        T: std::convert::Into<std::option::Option<crate::model::CustomConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.custom_constraint = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCustomConstraintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.UpdateCustomConstraintRequest"
    }
}

/// The request sent to the [DeleteCustomConstraint]
/// [google.cloud.orgpolicy.v2.OrgPolicy.DeleteCustomConstraint] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCustomConstraintRequest {
    /// Required. Name of the custom constraint to delete.
    /// See the custom constraint entry for naming rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCustomConstraintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCustomConstraintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCustomConstraintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.DeleteCustomConstraintRequest"
    }
}
