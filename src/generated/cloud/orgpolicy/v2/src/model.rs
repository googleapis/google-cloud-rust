// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A constraint describes a way to restrict resource's configuration. For
/// example, you could enforce a constraint that controls which Google Cloud
/// services can be activated across an organization, or whether a Compute Engine
/// instance can have serial port connections established. Constraints can be
/// configured by the organization policy administrator to fit the needs of the
/// organization by setting a policy that includes constraints at different
/// locations in the organization's resource hierarchy. Policies are inherited
/// down the resource hierarchy from higher levels, but can also be overridden.
/// For details about the inheritance rules please read about
/// [`policies`][google.cloud.OrgPolicy.v2.Policy].
///
/// Constraints have a default behavior determined by the `constraint_default`
/// field, which is the enforcement behavior that is used in the absence of a
/// policy being defined or inherited for the resource in question.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Constraint {
    /// Immutable. The resource name of the constraint. Must be in one of
    /// the following forms:
    ///
    /// * `projects/{project_number}/constraints/{constraint_name}`
    /// * `folders/{folder_id}/constraints/{constraint_name}`
    /// * `organizations/{organization_id}/constraints/{constraint_name}`
    ///
    /// For example, "/projects/123/constraints/compute.disableSerialPortAccess".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The human readable name.
    ///
    /// Mutable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Detailed description of what this constraint controls as well as how and
    /// where it is enforced.
    ///
    /// Mutable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The evaluation behavior of this constraint in the absence of a policy.
    pub constraint_default: crate::model::constraint::ConstraintDefault,

    /// Shows if dry run is supported for this constraint or not.
    pub supports_dry_run: bool,

    /// The type of restrictions for this `Constraint`.
    ///
    /// Immutable after creation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub constraint_type: std::option::Option<crate::model::constraint::ConstraintType>,
}

impl Constraint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Constraint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Constraint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Constraint::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [constraint_default][crate::model::Constraint::constraint_default].
    pub fn set_constraint_default<
        T: std::convert::Into<crate::model::constraint::ConstraintDefault>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_default = v.into();
        self
    }

    /// Sets the value of [supports_dry_run][crate::model::Constraint::supports_dry_run].
    pub fn set_supports_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.supports_dry_run = v.into();
        self
    }

    /// Sets the value of `constraint_type`.
    pub fn set_constraint_type<
        T: std::convert::Into<std::option::Option<crate::model::constraint::ConstraintType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_type = v.into();
        self
    }

    /// The value of [constraint_type][crate::model::Constraint::constraint_type]
    /// if it holds a `ListConstraint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_list_constraint(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::constraint::ListConstraint>> {
        #[allow(unreachable_patterns)]
        self.constraint_type.as_ref().and_then(|v| match v {
            crate::model::constraint::ConstraintType::ListConstraint(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [constraint_type][crate::model::Constraint::constraint_type]
    /// if it holds a `BooleanConstraint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_boolean_constraint(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::constraint::BooleanConstraint>> {
        #[allow(unreachable_patterns)]
        self.constraint_type.as_ref().and_then(|v| match v {
            crate::model::constraint::ConstraintType::BooleanConstraint(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [constraint_type][crate::model::Constraint::constraint_type]
    /// to hold a `ListConstraint`.
    ///
    /// Note that all the setters affecting `constraint_type` are
    /// mutually exclusive.
    pub fn set_list_constraint<
        T: std::convert::Into<std::boxed::Box<crate::model::constraint::ListConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_type = std::option::Option::Some(
            crate::model::constraint::ConstraintType::ListConstraint(v.into()),
        );
        self
    }

    /// Sets the value of [constraint_type][crate::model::Constraint::constraint_type]
    /// to hold a `BooleanConstraint`.
    ///
    /// Note that all the setters affecting `constraint_type` are
    /// mutually exclusive.
    pub fn set_boolean_constraint<
        T: std::convert::Into<std::boxed::Box<crate::model::constraint::BooleanConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_type = std::option::Option::Some(
            crate::model::constraint::ConstraintType::BooleanConstraint(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Constraint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint"
    }
}

/// Defines additional types related to Constraint
pub mod constraint {
    #[allow(unused_imports)]
    use super::*;

    /// A constraint that allows or disallows a list of string values, which are
    /// configured by an Organization Policy administrator with a policy.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ListConstraint {
        /// Indicates whether values grouped into categories can be used in
        /// `Policy.allowed_values` and `Policy.denied_values`. For example,
        /// `"in:Python"` would match any value in the 'Python' group.
        pub supports_in: bool,

        /// Indicates whether subtrees of the Resource Manager resource hierarchy
        /// can be used in `Policy.allowed_values` and `Policy.denied_values`. For
        /// example, `"under:folders/123"` would match any resource under the
        /// 'folders/123' folder.
        pub supports_under: bool,
    }

    impl ListConstraint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [supports_in][crate::model::constraint::ListConstraint::supports_in].
        pub fn set_supports_in<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.supports_in = v.into();
            self
        }

        /// Sets the value of [supports_under][crate::model::constraint::ListConstraint::supports_under].
        pub fn set_supports_under<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.supports_under = v.into();
            self
        }
    }

    impl wkt::message::Message for ListConstraint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint.ListConstraint"
        }
    }

    /// A constraint that is either enforced or not.
    ///
    /// For example, a constraint `constraints/compute.disableSerialPortAccess`.
    /// If it is enforced on a VM instance, serial port connections will not be
    /// opened to that instance.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BooleanConstraint {}

    impl BooleanConstraint {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for BooleanConstraint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orgpolicy.v2.Constraint.BooleanConstraint"
        }
    }

    /// Specifies the default behavior in the absence of any policy for the
    /// constraint. This must not be `CONSTRAINT_DEFAULT_UNSPECIFIED`.
    ///
    /// Immutable after creation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ConstraintDefault(i32);

    impl ConstraintDefault {
        /// This is only used for distinguishing unset values and should never be
        /// used.
        pub const CONSTRAINT_DEFAULT_UNSPECIFIED: ConstraintDefault = ConstraintDefault::new(0);

        /// Indicate that all values are allowed for list constraints.
        /// Indicate that enforcement is off for boolean constraints.
        pub const ALLOW: ConstraintDefault = ConstraintDefault::new(1);

        /// Indicate that all values are denied for list constraints.
        /// Indicate that enforcement is on for boolean constraints.
        pub const DENY: ConstraintDefault = ConstraintDefault::new(2);

        /// Creates a new ConstraintDefault instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CONSTRAINT_DEFAULT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ALLOW"),
                2 => std::borrow::Cow::Borrowed("DENY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CONSTRAINT_DEFAULT_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CONSTRAINT_DEFAULT_UNSPECIFIED)
                }
                "ALLOW" => std::option::Option::Some(Self::ALLOW),
                "DENY" => std::option::Option::Some(Self::DENY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ConstraintDefault {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ConstraintDefault {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The type of restrictions for this `Constraint`.
    ///
    /// Immutable after creation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ConstraintType {
        /// Defines this constraint as being a ListConstraint.
        ListConstraint(std::boxed::Box<crate::model::constraint::ListConstraint>),
        /// Defines this constraint as being a BooleanConstraint.
        BooleanConstraint(std::boxed::Box<crate::model::constraint::BooleanConstraint>),
    }
}

/// A custom constraint defined by customers which can *only* be applied to the
/// given resource types and organization.
///
/// By creating a custom constraint, customers can apply policies of this
/// custom constraint. *Creating a custom constraint itself does NOT apply any
/// policy enforcement*.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomConstraint {
    /// Immutable. Name of the constraint. This is unique within the organization.
    /// Format of the name should be
    ///
    /// * `organizations/{organization_id}/customConstraints/{custom_constraint_id}`
    ///
    /// Example: `organizations/123/customConstraints/custom.createOnlyE2TypeVms`
    ///
    /// The max length is 70 characters and the minimum length is 1. Note that the
    /// prefix `organizations/{organization_id}/customConstraints/` is not counted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Immutable. The resource instance type on which this policy applies. Format
    /// will be of the form : `<canonical service name>/<type>` Example:
    ///
    /// * `compute.googleapis.com/Instance`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_types: std::vec::Vec<std::string::String>,

    /// All the operations being applied for this constraint.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub method_types: std::vec::Vec<crate::model::custom_constraint::MethodType>,

    /// Org policy condition/expression. For example:
    /// `resource.instanceName.matches("[production|test]_.*_(\d)+")` or,
    /// `resource.management.auto_upgrade == true`
    ///
    /// The max length of the condition is 1000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub condition: std::string::String,

    /// Allow or deny type.
    pub action_type: crate::model::custom_constraint::ActionType,

    /// One line display name for the UI.
    /// The max length of the display_name is 200 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Detailed information about this custom policy constraint.
    /// The max length of the description is 2000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The last time this custom constraint was updated. This
    /// represents the last time that the `CreateCustomConstraint` or
    /// `UpdateCustomConstraint` RPC was called
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl CustomConstraint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CustomConstraint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::CustomConstraint::condition].
    pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [action_type][crate::model::CustomConstraint::action_type].
    pub fn set_action_type<T: std::convert::Into<crate::model::custom_constraint::ActionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.action_type = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CustomConstraint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::CustomConstraint::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CustomConstraint::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [resource_types][crate::model::CustomConstraint::resource_types].
    pub fn set_resource_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [method_types][crate::model::CustomConstraint::method_types].
    pub fn set_method_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::custom_constraint::MethodType>,
    {
        use std::iter::Iterator;
        self.method_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CustomConstraint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.CustomConstraint"
    }
}

/// Defines additional types related to CustomConstraint
pub mod custom_constraint {
    #[allow(unused_imports)]
    use super::*;

    /// The operation for which this constraint will be applied. To apply this
    /// constraint only when creating new VMs, the `method_types` should be
    /// `CREATE` only. To apply this constraint when creating or deleting
    /// VMs, the `method_types` should be `CREATE` and `DELETE`.
    ///
    /// `UPDATE` only custom constraints are not supported. Use `CREATE` or
    /// `CREATE, UPDATE`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MethodType(i32);

    impl MethodType {
        /// Unspecified. Results in an error.
        pub const METHOD_TYPE_UNSPECIFIED: MethodType = MethodType::new(0);

        /// Constraint applied when creating the resource.
        pub const CREATE: MethodType = MethodType::new(1);

        /// Constraint applied when updating the resource.
        pub const UPDATE: MethodType = MethodType::new(2);

        /// Constraint applied when deleting the resource.
        /// Not supported yet.
        pub const DELETE: MethodType = MethodType::new(3);

        /// Constraint applied when removing an IAM grant.
        pub const REMOVE_GRANT: MethodType = MethodType::new(4);

        /// Constraint applied when enforcing forced tagging.
        pub const GOVERN_TAGS: MethodType = MethodType::new(5);

        /// Creates a new MethodType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("METHOD_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATE"),
                2 => std::borrow::Cow::Borrowed("UPDATE"),
                3 => std::borrow::Cow::Borrowed("DELETE"),
                4 => std::borrow::Cow::Borrowed("REMOVE_GRANT"),
                5 => std::borrow::Cow::Borrowed("GOVERN_TAGS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "METHOD_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::METHOD_TYPE_UNSPECIFIED)
                }
                "CREATE" => std::option::Option::Some(Self::CREATE),
                "UPDATE" => std::option::Option::Some(Self::UPDATE),
                "DELETE" => std::option::Option::Some(Self::DELETE),
                "REMOVE_GRANT" => std::option::Option::Some(Self::REMOVE_GRANT),
                "GOVERN_TAGS" => std::option::Option::Some(Self::GOVERN_TAGS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for MethodType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for MethodType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Allow or deny type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ActionType(i32);

    impl ActionType {
        /// Unspecified. Results in an error.
        pub const ACTION_TYPE_UNSPECIFIED: ActionType = ActionType::new(0);

        /// Allowed action type.
        pub const ALLOW: ActionType = ActionType::new(1);

        /// Deny action type.
        pub const DENY: ActionType = ActionType::new(2);

        /// Creates a new ActionType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ACTION_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ALLOW"),
                2 => std::borrow::Cow::Borrowed("DENY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ACTION_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ACTION_TYPE_UNSPECIFIED)
                }
                "ALLOW" => std::option::Option::Some(Self::ALLOW),
                "DENY" => std::option::Option::Some(Self::DENY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ActionType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ActionType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Defines an organization policy which is used to specify constraints
/// for configurations of Google Cloud resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Policy {
    /// Immutable. The resource name of the policy. Must be one of the following
    /// forms, where `constraint_name` is the name of the constraint which this
    /// policy configures:
    ///
    /// * `projects/{project_number}/policies/{constraint_name}`
    /// * `folders/{folder_id}/policies/{constraint_name}`
    /// * `organizations/{organization_id}/policies/{constraint_name}`
    ///
    /// For example, `projects/123/policies/compute.disableSerialPortAccess`.
    ///
    /// Note: `projects/{project_id}/policies/{constraint_name}` is also an
    /// acceptable name for API requests, but responses will return the name using
    /// the equivalent project number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Basic information about the Organization Policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spec: std::option::Option<crate::model::PolicySpec>,

    /// Deprecated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub alternate: std::option::Option<crate::model::AlternatePolicySpec>,

    /// Dry-run policy.
    /// Audit-only policy, can be used to monitor how the policy would have
    /// impacted the existing and future resources if it's enforced.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dry_run_spec: std::option::Option<crate::model::PolicySpec>,

    /// Optional. An opaque tag indicating the current state of the policy, used
    /// for concurrency control. This 'etag' is computed by the server based on the
    /// value of other fields, and may be sent on update and delete requests to
    /// ensure the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl Policy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Policy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::Policy::spec].
    pub fn set_spec<T: std::convert::Into<std::option::Option<crate::model::PolicySpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }

    /// Sets the value of [alternate][crate::model::Policy::alternate].
    pub fn set_alternate<
        T: std::convert::Into<std::option::Option<crate::model::AlternatePolicySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alternate = v.into();
        self
    }

    /// Sets the value of [dry_run_spec][crate::model::Policy::dry_run_spec].
    pub fn set_dry_run_spec<
        T: std::convert::Into<std::option::Option<crate::model::PolicySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dry_run_spec = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Policy::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Policy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.Policy"
    }
}

/// Similar to PolicySpec but with an extra 'launch' field for launch reference.
/// The PolicySpec here is specific for dry-run/darklaunch.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AlternatePolicySpec {
    /// Reference to the launch that will be used while audit logging and to
    /// control the launch.
    /// Should be set only in the alternate policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub launch: std::string::String,

    /// Specify constraint for configurations of Google Cloud resources.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spec: std::option::Option<crate::model::PolicySpec>,
}

impl AlternatePolicySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [launch][crate::model::AlternatePolicySpec::launch].
    pub fn set_launch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.launch = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::AlternatePolicySpec::spec].
    pub fn set_spec<T: std::convert::Into<std::option::Option<crate::model::PolicySpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }
}

impl wkt::message::Message for AlternatePolicySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.AlternatePolicySpec"
    }
}

/// Defines a Google Cloud policy specification which is used to specify
/// constraints for configurations of Google Cloud resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PolicySpec {
    /// An opaque tag indicating the current version of the policySpec, used for
    /// concurrency control.
    ///
    /// This field is ignored if used in a `CreatePolicy` request.
    ///
    /// When the policy is returned from either a `GetPolicy` or a
    /// `ListPolicies` request, this `etag` indicates the version of the
    /// current policySpec to use when executing a read-modify-write loop.
    ///
    /// When the policy is returned from a `GetEffectivePolicy` request, the
    /// `etag` will be unset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. The time stamp this was previously updated. This
    /// represents the last time a call to `CreatePolicy` or `UpdatePolicy` was
    /// made for that policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// In policies for boolean constraints, the following requirements apply:
    ///
    /// - There must be one and only one policy rule where condition is unset.
    /// - Boolean policy rules with conditions must set `enforced` to the
    ///   opposite of the policy rule without a condition.
    /// - During policy evaluation, policy rules with conditions that are
    ///   true for a target resource take precedence.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rules: std::vec::Vec<crate::model::policy_spec::PolicyRule>,

    /// Determines the inheritance behavior for this policy.
    ///
    /// If `inherit_from_parent` is true, policy rules set higher up in the
    /// hierarchy (up to the closest root) are inherited and present in the
    /// effective policy. If it is false, then no rules are inherited, and this
    /// policy becomes the new root for evaluation.
    /// This field can be set only for policies which configure list constraints.
    pub inherit_from_parent: bool,

    /// Ignores policies set above this resource and restores the
    /// `constraint_default` enforcement behavior of the specific constraint at
    /// this resource.
    /// This field can be set in policies for either list or boolean
    /// constraints. If set, `rules` must be empty and `inherit_from_parent`
    /// must be set to false.
    pub reset: bool,
}

impl PolicySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [etag][crate::model::PolicySpec::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PolicySpec::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [inherit_from_parent][crate::model::PolicySpec::inherit_from_parent].
    pub fn set_inherit_from_parent<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.inherit_from_parent = v.into();
        self
    }

    /// Sets the value of [reset][crate::model::PolicySpec::reset].
    pub fn set_reset<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reset = v.into();
        self
    }

    /// Sets the value of [rules][crate::model::PolicySpec::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::policy_spec::PolicyRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PolicySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.PolicySpec"
    }
}

/// Defines additional types related to PolicySpec
pub mod policy_spec {
    #[allow(unused_imports)]
    use super::*;

    /// A rule used to express this policy.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PolicyRule {
        /// A condition which determines whether this rule is used
        /// in the evaluation of the policy. When set, the `expression` field in
        /// the `Expr' must include from 1 to 10 subexpressions, joined by the "||"
        /// or "&&" operators. Each subexpression must be of the form
        /// "resource.matchTag('<ORG_ID>/tag_key_short_name,
        /// 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id',
        /// 'tagValues/value_id')". where key_name and value_name are the resource
        /// names for Label Keys and Values. These names are available from the Tag
        /// Manager Service. An example expression is:
        /// "resource.matchTag('123456789/environment,
        /// 'prod')". or "resource.matchTagId('tagKeys/123',
        /// 'tagValues/456')".
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub condition: std::option::Option<gtype::model::Expr>,

        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub kind: std::option::Option<crate::model::policy_spec::policy_rule::Kind>,
    }

    impl PolicyRule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [condition][crate::model::policy_spec::PolicyRule::condition].
        pub fn set_condition<T: std::convert::Into<std::option::Option<gtype::model::Expr>>>(
            mut self,
            v: T,
        ) -> Self {
            self.condition = v.into();
            self
        }

        /// Sets the value of `kind`.
        pub fn set_kind<
            T: std::convert::Into<std::option::Option<crate::model::policy_spec::policy_rule::Kind>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// if it holds a `Values`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_values(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::policy_spec::policy_rule::StringValues>,
        > {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::policy_spec::policy_rule::Kind::Values(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// if it holds a `AllowAll`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_allow_all(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::policy_spec::policy_rule::Kind::AllowAll(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// if it holds a `DenyAll`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_deny_all(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::policy_spec::policy_rule::Kind::DenyAll(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// if it holds a `Enforce`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_enforce(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::policy_spec::policy_rule::Kind::Enforce(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// to hold a `Values`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_values<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::policy_spec::policy_rule::StringValues>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::policy_spec::policy_rule::Kind::Values(v.into()),
            );
            self
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// to hold a `AllowAll`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_allow_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::policy_spec::policy_rule::Kind::AllowAll(v.into()),
            );
            self
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// to hold a `DenyAll`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_deny_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::policy_spec::policy_rule::Kind::DenyAll(v.into()),
            );
            self
        }

        /// Sets the value of [kind][crate::model::policy_spec::PolicyRule::kind]
        /// to hold a `Enforce`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_enforce<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::policy_spec::policy_rule::Kind::Enforce(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for PolicyRule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.orgpolicy.v2.PolicySpec.PolicyRule"
        }
    }

    /// Defines additional types related to PolicyRule
    pub mod policy_rule {
        #[allow(unused_imports)]
        use super::*;

        /// A message that holds specific allowed and denied values.
        /// This message can define specific values and subtrees of the Resource
        /// Manager resource hierarchy (`Organizations`, `Folders`, `Projects`) that
        /// are allowed or denied. This is achieved by using the `under:` and
        /// optional `is:` prefixes.
        /// The `under:` prefix is used to denote resource subtree values.
        /// The `is:` prefix is used to denote specific values, and is required only
        /// if the value contains a ":". Values prefixed with "is:" are treated the
        /// same as values with no prefix.
        /// Ancestry subtrees must be in one of the following formats:
        ///
        /// - `projects/<project-id>` (for example, `projects/tokyo-rain-123`)
        /// - `folders/<folder-id>` (for example, `folders/1234`)
        /// - `organizations/<organization-id>` (for example, `organizations/1234`)
        ///
        /// The `supports_under` field of the associated `Constraint`  defines
        /// whether ancestry prefixes can be used.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct StringValues {
            /// List of values allowed at this resource.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub allowed_values: std::vec::Vec<std::string::String>,

            /// List of values denied at this resource.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub denied_values: std::vec::Vec<std::string::String>,
        }

        impl StringValues {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [allowed_values][crate::model::policy_spec::policy_rule::StringValues::allowed_values].
            pub fn set_allowed_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.allowed_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [denied_values][crate::model::policy_spec::policy_rule::StringValues::denied_values].
            pub fn set_denied_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.denied_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for StringValues {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.orgpolicy.v2.PolicySpec.PolicyRule.StringValues"
            }
        }

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Kind {
            /// List of values to be used for this policy rule. This field can be set
            /// only in policies for list constraints.
            Values(std::boxed::Box<crate::model::policy_spec::policy_rule::StringValues>),
            /// Setting this to true means that all values are allowed. This field can
            /// be set only in policies for list constraints.
            AllowAll(bool),
            /// Setting this to true means that all values are denied. This field can
            /// be set only in policies for list constraints.
            DenyAll(bool),
            /// If `true`, then the policy is enforced. If `false`, then any
            /// configuration is acceptable.
            /// This field can be set only in policies for boolean constraints.
            Enforce(bool),
        }
    }
}

/// The request sent to the [ListConstraints]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListConstraints] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConstraintsRequest {
    /// Required. The Google Cloud resource that parents the constraint. Must be in
    /// one of the following forms:
    ///
    /// * `projects/{project_number}`
    /// * `projects/{project_id}`
    /// * `folders/{folder_id}`
    /// * `organizations/{organization_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Size of the pages to be returned. This is currently unsupported and will
    /// be ignored. The server may at any point start using this field to limit
    /// page size.
    pub page_size: i32,

    /// Page token used to retrieve the next page. This is currently unsupported
    /// and will be ignored. The server may at any point start using this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListConstraintsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConstraintsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConstraintsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConstraintsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConstraintsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListConstraintsRequest"
    }
}

/// The response returned from the [ListConstraints]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListConstraints] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConstraintsResponse {
    /// The collection of constraints that are available on the targeted resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub constraints: std::vec::Vec<crate::model::Constraint>,

    /// Page token used to retrieve the next page. This is currently not used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListConstraintsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListConstraintsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [constraints][crate::model::ListConstraintsResponse::constraints].
    pub fn set_constraints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Constraint>,
    {
        use std::iter::Iterator;
        self.constraints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConstraintsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListConstraintsResponse"
    }
}

impl gax::paginator::PageableResponse for ListConstraintsResponse {
    type PageItem = crate::model::Constraint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.constraints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request sent to the [ListPolicies]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListPolicies] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPoliciesRequest {
    /// Required. The target Google Cloud resource that parents the set of
    /// constraints and policies that will be returned from this call. Must be in
    /// one of the following forms:
    ///
    /// * `projects/{project_number}`
    /// * `projects/{project_id}`
    /// * `folders/{folder_id}`
    /// * `organizations/{organization_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Size of the pages to be returned. This is currently unsupported and will
    /// be ignored. The server may at any point start using this field to limit
    /// page size.
    pub page_size: i32,

    /// Page token used to retrieve the next page. This is currently unsupported
    /// and will be ignored. The server may at any point start using this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListPoliciesRequest"
    }
}

/// The response returned from the [ListPolicies]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListPolicies] method. It will be empty
/// if no policies are set on the resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPoliciesResponse {
    /// All policies that exist on the resource. It will be empty if no
    /// policies are set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub policies: std::vec::Vec<crate::model::Policy>,

    /// Page token used to retrieve the next page. This is currently not used, but
    /// the server may at any point start supplying a valid token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [policies][crate::model::ListPoliciesResponse::policies].
    pub fn set_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Policy>,
    {
        use std::iter::Iterator;
        self.policies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListPoliciesResponse"
    }
}

impl gax::paginator::PageableResponse for ListPoliciesResponse {
    type PageItem = crate::model::Policy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request sent to the [GetPolicy]
/// [google.cloud.orgpolicy.v2.OrgPolicy.GetPolicy] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPolicyRequest {
    /// Required. Resource name of the policy. See
    /// [Policy][google.cloud.orgpolicy.v2.Policy] for naming requirements.
    ///
    /// [google.cloud.orgpolicy.v2.Policy]: crate::model::Policy
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.GetPolicyRequest"
    }
}

/// The request sent to the [GetEffectivePolicy]
/// [google.cloud.orgpolicy.v2.OrgPolicy.GetEffectivePolicy] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEffectivePolicyRequest {
    /// Required. The effective policy to compute. See
    /// [Policy][google.cloud.orgpolicy.v2.Policy] for naming requirements.
    ///
    /// [google.cloud.orgpolicy.v2.Policy]: crate::model::Policy
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetEffectivePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEffectivePolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEffectivePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.GetEffectivePolicyRequest"
    }
}

/// The request sent to the [CreatePolicyRequest]
/// [google.cloud.orgpolicy.v2.OrgPolicy.CreatePolicy] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePolicyRequest {
    /// Required. The Google Cloud resource that will parent the new policy. Must
    /// be in one of the following forms:
    ///
    /// * `projects/{project_number}`
    /// * `projects/{project_id}`
    /// * `folders/{folder_id}`
    /// * `organizations/{organization_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Policy to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy: std::option::Option<crate::model::Policy>,
}

impl CreatePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePolicyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [policy][crate::model::CreatePolicyRequest::policy].
    pub fn set_policy<T: std::convert::Into<std::option::Option<crate::model::Policy>>>(
        mut self,
        v: T,
    ) -> Self {
        self.policy = v.into();
        self
    }
}

impl wkt::message::Message for CreatePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.CreatePolicyRequest"
    }
}

/// The request sent to the [UpdatePolicyRequest]
/// [google.cloud.orgpolicy.v2.OrgPolicy.UpdatePolicy] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePolicyRequest {
    /// Required. Policy to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy: std::option::Option<crate::model::Policy>,

    /// Field mask used to specify the fields to be overwritten in the policy
    /// by the set. The fields specified in the update_mask are relative to the
    /// policy, not the full request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdatePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy][crate::model::UpdatePolicyRequest::policy].
    pub fn set_policy<T: std::convert::Into<std::option::Option<crate::model::Policy>>>(
        mut self,
        v: T,
    ) -> Self {
        self.policy = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePolicyRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.UpdatePolicyRequest"
    }
}

/// The request sent to the [DeletePolicy]
/// [google.cloud.orgpolicy.v2.OrgPolicy.DeletePolicy] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePolicyRequest {
    /// Required. Name of the policy to delete.
    /// See the policy entry for naming rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The current etag of policy. If an etag is provided and does not
    /// match the current etag of the policy, deletion will be blocked and an
    /// ABORTED error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl DeletePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeletePolicyRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeletePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.DeletePolicyRequest"
    }
}

/// The request sent to the [CreateCustomConstraintRequest]
/// [google.cloud.orgpolicy.v2.OrgPolicy.CreateCustomConstraint] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCustomConstraintRequest {
    /// Required. Must be in the following form:
    ///
    /// * `organizations/{organization_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Custom constraint to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_constraint: std::option::Option<crate::model::CustomConstraint>,
}

impl CreateCustomConstraintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCustomConstraintRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [custom_constraint][crate::model::CreateCustomConstraintRequest::custom_constraint].
    pub fn set_custom_constraint<
        T: std::convert::Into<std::option::Option<crate::model::CustomConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.custom_constraint = v.into();
        self
    }
}

impl wkt::message::Message for CreateCustomConstraintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.CreateCustomConstraintRequest"
    }
}

/// The request sent to the [GetCustomConstraint]
/// [google.cloud.orgpolicy.v2.OrgPolicy.GetCustomConstraint] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCustomConstraintRequest {
    /// Required. Resource name of the custom constraint. See the custom constraint
    /// entry for naming requirements.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetCustomConstraintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCustomConstraintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCustomConstraintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.GetCustomConstraintRequest"
    }
}

/// The request sent to the [ListCustomConstraints]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListCustomConstraints] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomConstraintsRequest {
    /// Required. The target Google Cloud resource that parents the set of custom
    /// constraints that will be returned from this call. Must be in one of the
    /// following forms:
    ///
    /// * `organizations/{organization_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Size of the pages to be returned. This is currently unsupported and will
    /// be ignored. The server may at any point start using this field to limit
    /// page size.
    pub page_size: i32,

    /// Page token used to retrieve the next page. This is currently unsupported
    /// and will be ignored. The server may at any point start using this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListCustomConstraintsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCustomConstraintsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCustomConstraintsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCustomConstraintsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomConstraintsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListCustomConstraintsRequest"
    }
}

/// The response returned from the [ListCustomConstraints]
/// [google.cloud.orgpolicy.v2.OrgPolicy.ListCustomConstraints] method. It will
/// be empty if no custom constraints are set on the organization resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomConstraintsResponse {
    /// All custom constraints that exist on the organization resource. It will be
    /// empty if no custom constraints are set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub custom_constraints: std::vec::Vec<crate::model::CustomConstraint>,

    /// Page token used to retrieve the next page. This is currently not used, but
    /// the server may at any point start supplying a valid token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListCustomConstraintsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCustomConstraintsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [custom_constraints][crate::model::ListCustomConstraintsResponse::custom_constraints].
    pub fn set_custom_constraints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomConstraint>,
    {
        use std::iter::Iterator;
        self.custom_constraints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCustomConstraintsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.ListCustomConstraintsResponse"
    }
}

impl gax::paginator::PageableResponse for ListCustomConstraintsResponse {
    type PageItem = crate::model::CustomConstraint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.custom_constraints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request sent to the [UpdateCustomConstraintRequest]
/// [google.cloud.orgpolicy.v2.OrgPolicy.UpdateCustomConstraint] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCustomConstraintRequest {
    /// Required. `CustomConstraint` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_constraint: std::option::Option<crate::model::CustomConstraint>,
}

impl UpdateCustomConstraintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_constraint][crate::model::UpdateCustomConstraintRequest::custom_constraint].
    pub fn set_custom_constraint<
        T: std::convert::Into<std::option::Option<crate::model::CustomConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.custom_constraint = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCustomConstraintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.UpdateCustomConstraintRequest"
    }
}

/// The request sent to the [DeleteCustomConstraint]
/// [google.cloud.orgpolicy.v2.OrgPolicy.DeleteCustomConstraint] method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCustomConstraintRequest {
    /// Required. Name of the custom constraint to delete.
    /// See the custom constraint entry for naming rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteCustomConstraintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCustomConstraintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCustomConstraintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.orgpolicy.v2.DeleteCustomConstraintRequest"
    }
}
