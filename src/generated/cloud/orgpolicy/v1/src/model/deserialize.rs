// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Policy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __constraint,
            __etag,
            __update_time,
            __list_policy,
            __boolean_policy,
            __restore_default,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Policy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "constraint" => Ok(__FieldTag::__constraint),
                            "etag" => Ok(__FieldTag::__etag),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "listPolicy" => Ok(__FieldTag::__list_policy),
                            "list_policy" => Ok(__FieldTag::__list_policy),
                            "booleanPolicy" => Ok(__FieldTag::__boolean_policy),
                            "boolean_policy" => Ok(__FieldTag::__boolean_policy),
                            "restoreDefault" => Ok(__FieldTag::__restore_default),
                            "restore_default" => Ok(__FieldTag::__restore_default),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Policy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Policy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for version"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__constraint => {
                            if !fields.insert(__FieldTag::__constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for constraint"));
                            }
                            result.constraint = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for etag"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.etag = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_time"));
                            }
                            result.update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__list_policy => {
                            if !fields.insert(__FieldTag::__list_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for list_policy"));
                            }
                            if result.policy_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `policy_type`, a oneof with full ID .google.cloud.orgpolicy.v1.Policy.list_policy, latest field was listPolicy",
                                ));
                            }
                            result.policy_type = std::option::Option::Some(
                                crate::model::policy::PolicyType::ListPolicy(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::policy::ListPolicy>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__boolean_policy => {
                            if !fields.insert(__FieldTag::__boolean_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for boolean_policy"));
                            }
                            if result.policy_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `policy_type`, a oneof with full ID .google.cloud.orgpolicy.v1.Policy.boolean_policy, latest field was booleanPolicy",
                                ));
                            }
                            result.policy_type = std::option::Option::Some(
                                crate::model::policy::PolicyType::BooleanPolicy(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::policy::BooleanPolicy>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__restore_default => {
                            if !fields.insert(__FieldTag::__restore_default) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for restore_default"));
                            }
                            if result.policy_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `policy_type`, a oneof with full ID .google.cloud.orgpolicy.v1.Policy.restore_default, latest field was restoreDefault",
                                ));
                            }
                            result.policy_type = std::option::Option::Some(
                                crate::model::policy::PolicyType::RestoreDefault(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::policy::RestoreDefault>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::policy::ListPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowed_values,
            __denied_values,
            __all_values,
            __suggested_value,
            __inherit_from_parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowedValues" => Ok(__FieldTag::__allowed_values),
                            "allowed_values" => Ok(__FieldTag::__allowed_values),
                            "deniedValues" => Ok(__FieldTag::__denied_values),
                            "denied_values" => Ok(__FieldTag::__denied_values),
                            "allValues" => Ok(__FieldTag::__all_values),
                            "all_values" => Ok(__FieldTag::__all_values),
                            "suggestedValue" => Ok(__FieldTag::__suggested_value),
                            "suggested_value" => Ok(__FieldTag::__suggested_value),
                            "inheritFromParent" => Ok(__FieldTag::__inherit_from_parent),
                            "inherit_from_parent" => Ok(__FieldTag::__inherit_from_parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::policy::ListPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowed_values => {
                            if !fields.insert(__FieldTag::__allowed_values) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for allowed_values"));
                            }
                            result.allowed_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__denied_values => {
                            if !fields.insert(__FieldTag::__denied_values) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for denied_values"));
                            }
                            result.denied_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__all_values => {
                            if !fields.insert(__FieldTag::__all_values) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for all_values"));
                            }
                            result.all_values = map.next_value::<std::option::Option<crate::model::policy::list_policy::AllValues>>()?.unwrap_or_default();
                        },
                        __FieldTag::__suggested_value => {
                            if !fields.insert(__FieldTag::__suggested_value) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggested_value"));
                            }
                            result.suggested_value = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__inherit_from_parent => {
                            if !fields.insert(__FieldTag::__inherit_from_parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for inherit_from_parent"));
                            }
                            result.inherit_from_parent = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::policy::BooleanPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enforced,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BooleanPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enforced" => Ok(__FieldTag::__enforced),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::policy::BooleanPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BooleanPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enforced => {
                            if !fields.insert(__FieldTag::__enforced) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enforced"));
                            }
                            result.enforced = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::policy::RestoreDefault {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreDefault")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::policy::RestoreDefault;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreDefault")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
