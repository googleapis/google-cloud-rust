// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A CrawledUrl resource represents a URL that was crawled during a ScanRun. Web
/// Security Scanner Service crawls the web applications, following all links
/// within the scope of sites, to find the URLs to test against.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CrawledUrl {
    /// Output only. The http method of the request that was used to visit the URL, in
    /// uppercase.
    pub http_method: std::string::String,

    /// Output only. The URL that was crawled.
    pub url: std::string::String,

    /// Output only. The body of the request that was used to visit the URL.
    pub body: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CrawledUrl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http_method][crate::model::CrawledUrl::http_method].
    pub fn set_http_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.http_method = v.into();
        self
    }

    /// Sets the value of [url][crate::model::CrawledUrl::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [body][crate::model::CrawledUrl::body].
    pub fn set_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for CrawledUrl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.CrawledUrl"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CrawledUrl {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __http_method,
            __url,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CrawledUrl")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "httpMethod" => Ok(__FieldTag::__http_method),
                            "http_method" => Ok(__FieldTag::__http_method),
                            "url" => Ok(__FieldTag::__url),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CrawledUrl;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CrawledUrl")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__http_method => {
                            if !fields.insert(__FieldTag::__http_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_method",
                                ));
                            }
                            result.http_method = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CrawledUrl {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.http_method.is_empty() {
            state.serialize_entry("httpMethod", &self.http_method)?;
        }
        if !self.url.is_empty() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self.body.is_empty() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Finding resource represents a vulnerability instance identified during a
/// ScanRun.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Finding {
    /// Output only. The resource name of the Finding. The name follows the format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanruns/{scanRunId}/findings/{findingId}'.
    /// The finding IDs are generated by the system.
    pub name: std::string::String,

    /// Output only. The type of the Finding.
    /// Detailed and up-to-date information on findings can be found here:
    /// <https://cloud.google.com/security-command-center/docs/how-to-remediate-web-security-scanner-findings>
    pub finding_type: std::string::String,

    /// Output only. The severity level of the reported vulnerability.
    pub severity: crate::model::finding::Severity,

    /// Output only. The http method of the request that triggered the vulnerability, in
    /// uppercase.
    pub http_method: std::string::String,

    /// Output only. The URL produced by the server-side fuzzer and used in the request that
    /// triggered the vulnerability.
    pub fuzzed_url: std::string::String,

    /// Output only. The body of the request that triggered the vulnerability.
    pub body: std::string::String,

    /// Output only. The description of the vulnerability.
    pub description: std::string::String,

    /// Output only. The URL containing human-readable payload that user can leverage to
    /// reproduce the vulnerability.
    pub reproduction_url: std::string::String,

    /// Output only. If the vulnerability was originated from nested IFrame, the immediate
    /// parent IFrame is reported.
    pub frame_url: std::string::String,

    /// Output only. The URL where the browser lands when the vulnerability is detected.
    pub final_url: std::string::String,

    /// Output only. The tracking ID uniquely identifies a vulnerability instance across
    /// multiple ScanRuns.
    pub tracking_id: std::string::String,

    /// Output only. An addon containing information reported for a vulnerability with an HTML
    /// form, if any.
    pub form: std::option::Option<crate::model::Form>,

    /// Output only. An addon containing information about outdated libraries.
    pub outdated_library: std::option::Option<crate::model::OutdatedLibrary>,

    /// Output only. An addon containing detailed information regarding any resource causing the
    /// vulnerability such as JavaScript sources, image, audio files, etc.
    pub violating_resource: std::option::Option<crate::model::ViolatingResource>,

    /// Output only. An addon containing information about vulnerable or missing HTTP headers.
    pub vulnerable_headers: std::option::Option<crate::model::VulnerableHeaders>,

    /// Output only. An addon containing information about request parameters which were found
    /// to be vulnerable.
    pub vulnerable_parameters: std::option::Option<crate::model::VulnerableParameters>,

    /// Output only. An addon containing information reported for an XSS, if any.
    pub xss: std::option::Option<crate::model::Xss>,

    /// Output only. An addon containing information reported for an XXE, if any.
    pub xxe: std::option::Option<crate::model::Xxe>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Finding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Finding::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [finding_type][crate::model::Finding::finding_type].
    pub fn set_finding_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.finding_type = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::Finding::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::finding::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [http_method][crate::model::Finding::http_method].
    pub fn set_http_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.http_method = v.into();
        self
    }

    /// Sets the value of [fuzzed_url][crate::model::Finding::fuzzed_url].
    pub fn set_fuzzed_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fuzzed_url = v.into();
        self
    }

    /// Sets the value of [body][crate::model::Finding::body].
    pub fn set_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Finding::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [reproduction_url][crate::model::Finding::reproduction_url].
    pub fn set_reproduction_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reproduction_url = v.into();
        self
    }

    /// Sets the value of [frame_url][crate::model::Finding::frame_url].
    pub fn set_frame_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.frame_url = v.into();
        self
    }

    /// Sets the value of [final_url][crate::model::Finding::final_url].
    pub fn set_final_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.final_url = v.into();
        self
    }

    /// Sets the value of [tracking_id][crate::model::Finding::tracking_id].
    pub fn set_tracking_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tracking_id = v.into();
        self
    }

    /// Sets the value of [form][crate::model::Finding::form].
    pub fn set_form<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Form>,
    {
        self.form = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [form][crate::model::Finding::form].
    pub fn set_or_clear_form<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Form>,
    {
        self.form = v.map(|x| x.into());
        self
    }

    /// Sets the value of [outdated_library][crate::model::Finding::outdated_library].
    pub fn set_outdated_library<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutdatedLibrary>,
    {
        self.outdated_library = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [outdated_library][crate::model::Finding::outdated_library].
    pub fn set_or_clear_outdated_library<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutdatedLibrary>,
    {
        self.outdated_library = v.map(|x| x.into());
        self
    }

    /// Sets the value of [violating_resource][crate::model::Finding::violating_resource].
    pub fn set_violating_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ViolatingResource>,
    {
        self.violating_resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [violating_resource][crate::model::Finding::violating_resource].
    pub fn set_or_clear_violating_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ViolatingResource>,
    {
        self.violating_resource = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vulnerable_headers][crate::model::Finding::vulnerable_headers].
    pub fn set_vulnerable_headers<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VulnerableHeaders>,
    {
        self.vulnerable_headers = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vulnerable_headers][crate::model::Finding::vulnerable_headers].
    pub fn set_or_clear_vulnerable_headers<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VulnerableHeaders>,
    {
        self.vulnerable_headers = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vulnerable_parameters][crate::model::Finding::vulnerable_parameters].
    pub fn set_vulnerable_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VulnerableParameters>,
    {
        self.vulnerable_parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vulnerable_parameters][crate::model::Finding::vulnerable_parameters].
    pub fn set_or_clear_vulnerable_parameters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VulnerableParameters>,
    {
        self.vulnerable_parameters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [xss][crate::model::Finding::xss].
    pub fn set_xss<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Xss>,
    {
        self.xss = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [xss][crate::model::Finding::xss].
    pub fn set_or_clear_xss<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Xss>,
    {
        self.xss = v.map(|x| x.into());
        self
    }

    /// Sets the value of [xxe][crate::model::Finding::xxe].
    pub fn set_xxe<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Xxe>,
    {
        self.xxe = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [xxe][crate::model::Finding::xxe].
    pub fn set_or_clear_xxe<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Xxe>,
    {
        self.xxe = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Finding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.Finding"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Finding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __finding_type,
            __severity,
            __http_method,
            __fuzzed_url,
            __body,
            __description,
            __reproduction_url,
            __frame_url,
            __final_url,
            __tracking_id,
            __form,
            __outdated_library,
            __violating_resource,
            __vulnerable_headers,
            __vulnerable_parameters,
            __xss,
            __xxe,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Finding")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "findingType" => Ok(__FieldTag::__finding_type),
                            "finding_type" => Ok(__FieldTag::__finding_type),
                            "severity" => Ok(__FieldTag::__severity),
                            "httpMethod" => Ok(__FieldTag::__http_method),
                            "http_method" => Ok(__FieldTag::__http_method),
                            "fuzzedUrl" => Ok(__FieldTag::__fuzzed_url),
                            "fuzzed_url" => Ok(__FieldTag::__fuzzed_url),
                            "body" => Ok(__FieldTag::__body),
                            "description" => Ok(__FieldTag::__description),
                            "reproductionUrl" => Ok(__FieldTag::__reproduction_url),
                            "reproduction_url" => Ok(__FieldTag::__reproduction_url),
                            "frameUrl" => Ok(__FieldTag::__frame_url),
                            "frame_url" => Ok(__FieldTag::__frame_url),
                            "finalUrl" => Ok(__FieldTag::__final_url),
                            "final_url" => Ok(__FieldTag::__final_url),
                            "trackingId" => Ok(__FieldTag::__tracking_id),
                            "tracking_id" => Ok(__FieldTag::__tracking_id),
                            "form" => Ok(__FieldTag::__form),
                            "outdatedLibrary" => Ok(__FieldTag::__outdated_library),
                            "outdated_library" => Ok(__FieldTag::__outdated_library),
                            "violatingResource" => Ok(__FieldTag::__violating_resource),
                            "violating_resource" => Ok(__FieldTag::__violating_resource),
                            "vulnerableHeaders" => Ok(__FieldTag::__vulnerable_headers),
                            "vulnerable_headers" => Ok(__FieldTag::__vulnerable_headers),
                            "vulnerableParameters" => Ok(__FieldTag::__vulnerable_parameters),
                            "vulnerable_parameters" => Ok(__FieldTag::__vulnerable_parameters),
                            "xss" => Ok(__FieldTag::__xss),
                            "xxe" => Ok(__FieldTag::__xxe),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Finding;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Finding")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__finding_type => {
                            if !fields.insert(__FieldTag::__finding_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding_type",
                                ));
                            }
                            result.finding_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<crate::model::finding::Severity>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__http_method => {
                            if !fields.insert(__FieldTag::__http_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_method",
                                ));
                            }
                            result.http_method = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fuzzed_url => {
                            if !fields.insert(__FieldTag::__fuzzed_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fuzzed_url",
                                ));
                            }
                            result.fuzzed_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reproduction_url => {
                            if !fields.insert(__FieldTag::__reproduction_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reproduction_url",
                                ));
                            }
                            result.reproduction_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__frame_url => {
                            if !fields.insert(__FieldTag::__frame_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frame_url",
                                ));
                            }
                            result.frame_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__final_url => {
                            if !fields.insert(__FieldTag::__final_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for final_url",
                                ));
                            }
                            result.final_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tracking_id => {
                            if !fields.insert(__FieldTag::__tracking_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tracking_id",
                                ));
                            }
                            result.tracking_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__form => {
                            if !fields.insert(__FieldTag::__form) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for form",
                                ));
                            }
                            result.form =
                                map.next_value::<std::option::Option<crate::model::Form>>()?;
                        }
                        __FieldTag::__outdated_library => {
                            if !fields.insert(__FieldTag::__outdated_library) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for outdated_library",
                                ));
                            }
                            result.outdated_library = map
                                .next_value::<std::option::Option<crate::model::OutdatedLibrary>>(
                                )?;
                        }
                        __FieldTag::__violating_resource => {
                            if !fields.insert(__FieldTag::__violating_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for violating_resource",
                                ));
                            }
                            result.violating_resource = map
                                .next_value::<std::option::Option<crate::model::ViolatingResource>>(
                                )?;
                        }
                        __FieldTag::__vulnerable_headers => {
                            if !fields.insert(__FieldTag::__vulnerable_headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerable_headers",
                                ));
                            }
                            result.vulnerable_headers = map
                                .next_value::<std::option::Option<crate::model::VulnerableHeaders>>(
                                )?;
                        }
                        __FieldTag::__vulnerable_parameters => {
                            if !fields.insert(__FieldTag::__vulnerable_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerable_parameters",
                                ));
                            }
                            result.vulnerable_parameters = map.next_value::<std::option::Option<crate::model::VulnerableParameters>>()?
                                ;
                        }
                        __FieldTag::__xss => {
                            if !fields.insert(__FieldTag::__xss) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for xss",
                                ));
                            }
                            result.xss =
                                map.next_value::<std::option::Option<crate::model::Xss>>()?;
                        }
                        __FieldTag::__xxe => {
                            if !fields.insert(__FieldTag::__xxe) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for xxe",
                                ));
                            }
                            result.xxe =
                                map.next_value::<std::option::Option<crate::model::Xxe>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Finding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.finding_type.is_empty() {
            state.serialize_entry("findingType", &self.finding_type)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.http_method.is_empty() {
            state.serialize_entry("httpMethod", &self.http_method)?;
        }
        if !self.fuzzed_url.is_empty() {
            state.serialize_entry("fuzzedUrl", &self.fuzzed_url)?;
        }
        if !self.body.is_empty() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.reproduction_url.is_empty() {
            state.serialize_entry("reproductionUrl", &self.reproduction_url)?;
        }
        if !self.frame_url.is_empty() {
            state.serialize_entry("frameUrl", &self.frame_url)?;
        }
        if !self.final_url.is_empty() {
            state.serialize_entry("finalUrl", &self.final_url)?;
        }
        if !self.tracking_id.is_empty() {
            state.serialize_entry("trackingId", &self.tracking_id)?;
        }
        if self.form.is_some() {
            state.serialize_entry("form", &self.form)?;
        }
        if self.outdated_library.is_some() {
            state.serialize_entry("outdatedLibrary", &self.outdated_library)?;
        }
        if self.violating_resource.is_some() {
            state.serialize_entry("violatingResource", &self.violating_resource)?;
        }
        if self.vulnerable_headers.is_some() {
            state.serialize_entry("vulnerableHeaders", &self.vulnerable_headers)?;
        }
        if self.vulnerable_parameters.is_some() {
            state.serialize_entry("vulnerableParameters", &self.vulnerable_parameters)?;
        }
        if self.xss.is_some() {
            state.serialize_entry("xss", &self.xss)?;
        }
        if self.xxe.is_some() {
            state.serialize_entry("xxe", &self.xxe)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Finding].
pub mod finding {
    #[allow(unused_imports)]
    use super::*;

    /// The severity level of a vulnerability.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// No severity specified. The default value.
        Unspecified,
        /// Critical severity.
        Critical,
        /// High severity.
        High,
        /// Medium severity.
        Medium,
        /// Low severity.
        Low,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Critical => std::option::Option::Some(1),
                Self::High => std::option::Option::Some(2),
                Self::Medium => std::option::Option::Some(3),
                Self::Low => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Critical => std::option::Option::Some("CRITICAL"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::Medium => std::option::Option::Some("MEDIUM"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Critical,
                2 => Self::High,
                3 => Self::Medium,
                4 => Self::Low,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "CRITICAL" => Self::Critical,
                "HIGH" => Self::High,
                "MEDIUM" => Self::Medium,
                "LOW" => Self::Low,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Critical => serializer.serialize_i32(1),
                Self::High => serializer.serialize_i32(2),
                Self::Medium => serializer.serialize_i32(3),
                Self::Low => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.cloud.websecurityscanner.v1.Finding.Severity",
            ))
        }
    }
}

/// ! Information about a vulnerability with an HTML.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Form {
    /// ! The URI where to send the form when it's submitted.
    pub action_uri: std::string::String,

    /// ! The names of form fields related to the vulnerability.
    pub fields: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Form {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action_uri][crate::model::Form::action_uri].
    pub fn set_action_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action_uri = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::Form::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Form {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.Form"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Form {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __action_uri,
            __fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Form")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "actionUri" => Ok(__FieldTag::__action_uri),
                            "action_uri" => Ok(__FieldTag::__action_uri),
                            "fields" => Ok(__FieldTag::__fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Form;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Form")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__action_uri => {
                            if !fields.insert(__FieldTag::__action_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_uri",
                                ));
                            }
                            result.action_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Form {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.action_uri.is_empty() {
            state.serialize_entry("actionUri", &self.action_uri)?;
        }
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information reported for an outdated library.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OutdatedLibrary {
    /// The name of the outdated library.
    pub library_name: std::string::String,

    /// The version number.
    pub version: std::string::String,

    /// URLs to learn more information about the vulnerabilities in the library.
    pub learn_more_urls: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutdatedLibrary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [library_name][crate::model::OutdatedLibrary::library_name].
    pub fn set_library_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.library_name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::OutdatedLibrary::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [learn_more_urls][crate::model::OutdatedLibrary::learn_more_urls].
    pub fn set_learn_more_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.learn_more_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OutdatedLibrary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.OutdatedLibrary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OutdatedLibrary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __library_name,
            __version,
            __learn_more_urls,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutdatedLibrary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "libraryName" => Ok(__FieldTag::__library_name),
                            "library_name" => Ok(__FieldTag::__library_name),
                            "version" => Ok(__FieldTag::__version),
                            "learnMoreUrls" => Ok(__FieldTag::__learn_more_urls),
                            "learn_more_urls" => Ok(__FieldTag::__learn_more_urls),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OutdatedLibrary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutdatedLibrary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__library_name => {
                            if !fields.insert(__FieldTag::__library_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for library_name",
                                ));
                            }
                            result.library_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__learn_more_urls => {
                            if !fields.insert(__FieldTag::__learn_more_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for learn_more_urls",
                                ));
                            }
                            result.learn_more_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OutdatedLibrary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.library_name.is_empty() {
            state.serialize_entry("libraryName", &self.library_name)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.learn_more_urls.is_empty() {
            state.serialize_entry("learnMoreUrls", &self.learn_more_urls)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information regarding any resource causing the vulnerability such
/// as JavaScript sources, image, audio files, etc.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ViolatingResource {
    /// The MIME type of this resource.
    pub content_type: std::string::String,

    /// URL of this violating resource.
    pub resource_url: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ViolatingResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content_type][crate::model::ViolatingResource::content_type].
    pub fn set_content_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content_type = v.into();
        self
    }

    /// Sets the value of [resource_url][crate::model::ViolatingResource::resource_url].
    pub fn set_resource_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_url = v.into();
        self
    }
}

impl wkt::message::Message for ViolatingResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ViolatingResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ViolatingResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content_type,
            __resource_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ViolatingResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "contentType" => Ok(__FieldTag::__content_type),
                            "content_type" => Ok(__FieldTag::__content_type),
                            "resourceUrl" => Ok(__FieldTag::__resource_url),
                            "resource_url" => Ok(__FieldTag::__resource_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ViolatingResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ViolatingResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content_type => {
                            if !fields.insert(__FieldTag::__content_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_type",
                                ));
                            }
                            result.content_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_url => {
                            if !fields.insert(__FieldTag::__resource_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_url",
                                ));
                            }
                            result.resource_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ViolatingResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content_type.is_empty() {
            state.serialize_entry("contentType", &self.content_type)?;
        }
        if !self.resource_url.is_empty() {
            state.serialize_entry("resourceUrl", &self.resource_url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information about vulnerable request parameters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VulnerableParameters {
    /// The vulnerable parameter names.
    pub parameter_names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerableParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameter_names][crate::model::VulnerableParameters::parameter_names].
    pub fn set_parameter_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameter_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VulnerableParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.VulnerableParameters"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VulnerableParameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parameter_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VulnerableParameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parameterNames" => Ok(__FieldTag::__parameter_names),
                            "parameter_names" => Ok(__FieldTag::__parameter_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VulnerableParameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VulnerableParameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parameter_names => {
                            if !fields.insert(__FieldTag::__parameter_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameter_names",
                                ));
                            }
                            result.parameter_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VulnerableParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parameter_names.is_empty() {
            state.serialize_entry("parameterNames", &self.parameter_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information about vulnerable or missing HTTP Headers.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VulnerableHeaders {
    /// List of vulnerable headers.
    pub headers: std::vec::Vec<crate::model::vulnerable_headers::Header>,

    /// List of missing headers.
    pub missing_headers: std::vec::Vec<crate::model::vulnerable_headers::Header>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerableHeaders {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [headers][crate::model::VulnerableHeaders::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerable_headers::Header>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [missing_headers][crate::model::VulnerableHeaders::missing_headers].
    pub fn set_missing_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerable_headers::Header>,
    {
        use std::iter::Iterator;
        self.missing_headers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VulnerableHeaders {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.VulnerableHeaders"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VulnerableHeaders {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __headers,
            __missing_headers,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VulnerableHeaders")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "headers" => Ok(__FieldTag::__headers),
                            "missingHeaders" => Ok(__FieldTag::__missing_headers),
                            "missing_headers" => Ok(__FieldTag::__missing_headers),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VulnerableHeaders;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VulnerableHeaders")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__headers => {
                            if !fields.insert(__FieldTag::__headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headers",
                                ));
                            }
                            result.headers = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::vulnerable_headers::Header>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__missing_headers => {
                            if !fields.insert(__FieldTag::__missing_headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for missing_headers",
                                ));
                            }
                            result.missing_headers = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::vulnerable_headers::Header>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VulnerableHeaders {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.headers.is_empty() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if !self.missing_headers.is_empty() {
            state.serialize_entry("missingHeaders", &self.missing_headers)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VulnerableHeaders].
pub mod vulnerable_headers {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a HTTP Header.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Header {
        /// Header name.
        pub name: std::string::String,

        /// Header value.
        pub value: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Header {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::vulnerable_headers::Header::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::vulnerable_headers::Header::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Header {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.websecurityscanner.v1.VulnerableHeaders.Header"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Header {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Header")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "value" => Ok(__FieldTag::__value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Header;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Header")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Header {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Information reported for an XSS.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Xss {
    /// Stack traces leading to the point where the XSS occurred.
    pub stack_traces: std::vec::Vec<std::string::String>,

    /// An error message generated by a javascript breakage.
    pub error_message: std::string::String,

    /// The attack vector of the payload triggering this XSS.
    pub attack_vector: crate::model::xss::AttackVector,

    /// The reproduction url for the seeding POST request of a Stored XSS.
    pub stored_xss_seeding_url: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Xss {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stack_traces][crate::model::Xss::stack_traces].
    pub fn set_stack_traces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.stack_traces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_message][crate::model::Xss::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }

    /// Sets the value of [attack_vector][crate::model::Xss::attack_vector].
    pub fn set_attack_vector<T: std::convert::Into<crate::model::xss::AttackVector>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_vector = v.into();
        self
    }

    /// Sets the value of [stored_xss_seeding_url][crate::model::Xss::stored_xss_seeding_url].
    pub fn set_stored_xss_seeding_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.stored_xss_seeding_url = v.into();
        self
    }
}

impl wkt::message::Message for Xss {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.Xss"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Xss {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stack_traces,
            __error_message,
            __attack_vector,
            __stored_xss_seeding_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Xss")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stackTraces" => Ok(__FieldTag::__stack_traces),
                            "stack_traces" => Ok(__FieldTag::__stack_traces),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            "attackVector" => Ok(__FieldTag::__attack_vector),
                            "attack_vector" => Ok(__FieldTag::__attack_vector),
                            "storedXssSeedingUrl" => Ok(__FieldTag::__stored_xss_seeding_url),
                            "stored_xss_seeding_url" => Ok(__FieldTag::__stored_xss_seeding_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Xss;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Xss")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stack_traces => {
                            if !fields.insert(__FieldTag::__stack_traces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stack_traces",
                                ));
                            }
                            result.stack_traces = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attack_vector => {
                            if !fields.insert(__FieldTag::__attack_vector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_vector",
                                ));
                            }
                            result.attack_vector = map
                                .next_value::<std::option::Option<crate::model::xss::AttackVector>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stored_xss_seeding_url => {
                            if !fields.insert(__FieldTag::__stored_xss_seeding_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stored_xss_seeding_url",
                                ));
                            }
                            result.stored_xss_seeding_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Xss {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.stack_traces.is_empty() {
            state.serialize_entry("stackTraces", &self.stack_traces)?;
        }
        if !self.error_message.is_empty() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if !wkt::internal::is_default(&self.attack_vector) {
            state.serialize_entry("attackVector", &self.attack_vector)?;
        }
        if !self.stored_xss_seeding_url.is_empty() {
            state.serialize_entry("storedXssSeedingUrl", &self.stored_xss_seeding_url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Xss].
pub mod xss {
    #[allow(unused_imports)]
    use super::*;

    /// Types of XSS attack vector.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackVector {
        /// Unknown attack vector.
        Unspecified,
        /// The attack comes from fuzzing the browser's localStorage.
        LocalStorage,
        /// The attack comes from fuzzing the browser's sessionStorage.
        SessionStorage,
        /// The attack comes from fuzzing the window's name property.
        WindowName,
        /// The attack comes from fuzzing the referrer property.
        Referrer,
        /// The attack comes from fuzzing an input element.
        FormInput,
        /// The attack comes from fuzzing the browser's cookies.
        Cookie,
        /// The attack comes from hijacking the post messaging mechanism.
        PostMessage,
        /// The attack comes from fuzzing parameters in the url.
        GetParameters,
        /// The attack comes from fuzzing the fragment in the url.
        UrlFragment,
        /// The attack comes from fuzzing the HTML comments.
        HtmlComment,
        /// The attack comes from fuzzing the POST parameters.
        PostParameters,
        /// The attack comes from fuzzing the protocol.
        Protocol,
        /// The attack comes from the server side and is stored.
        StoredXss,
        /// The attack is a Same-Origin Method Execution attack via a GET parameter.
        SameOrigin,
        /// The attack payload is received from a third-party host via a URL that is
        /// user-controllable
        UserControllableUrl,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackVector::value] or
        /// [AttackVector::name].
        UnknownValue(attack_vector::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_vector {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackVector {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LocalStorage => std::option::Option::Some(1),
                Self::SessionStorage => std::option::Option::Some(2),
                Self::WindowName => std::option::Option::Some(3),
                Self::Referrer => std::option::Option::Some(4),
                Self::FormInput => std::option::Option::Some(5),
                Self::Cookie => std::option::Option::Some(6),
                Self::PostMessage => std::option::Option::Some(7),
                Self::GetParameters => std::option::Option::Some(8),
                Self::UrlFragment => std::option::Option::Some(9),
                Self::HtmlComment => std::option::Option::Some(10),
                Self::PostParameters => std::option::Option::Some(11),
                Self::Protocol => std::option::Option::Some(12),
                Self::StoredXss => std::option::Option::Some(13),
                Self::SameOrigin => std::option::Option::Some(14),
                Self::UserControllableUrl => std::option::Option::Some(15),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_VECTOR_UNSPECIFIED"),
                Self::LocalStorage => std::option::Option::Some("LOCAL_STORAGE"),
                Self::SessionStorage => std::option::Option::Some("SESSION_STORAGE"),
                Self::WindowName => std::option::Option::Some("WINDOW_NAME"),
                Self::Referrer => std::option::Option::Some("REFERRER"),
                Self::FormInput => std::option::Option::Some("FORM_INPUT"),
                Self::Cookie => std::option::Option::Some("COOKIE"),
                Self::PostMessage => std::option::Option::Some("POST_MESSAGE"),
                Self::GetParameters => std::option::Option::Some("GET_PARAMETERS"),
                Self::UrlFragment => std::option::Option::Some("URL_FRAGMENT"),
                Self::HtmlComment => std::option::Option::Some("HTML_COMMENT"),
                Self::PostParameters => std::option::Option::Some("POST_PARAMETERS"),
                Self::Protocol => std::option::Option::Some("PROTOCOL"),
                Self::StoredXss => std::option::Option::Some("STORED_XSS"),
                Self::SameOrigin => std::option::Option::Some("SAME_ORIGIN"),
                Self::UserControllableUrl => std::option::Option::Some("USER_CONTROLLABLE_URL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackVector {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackVector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackVector {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LocalStorage,
                2 => Self::SessionStorage,
                3 => Self::WindowName,
                4 => Self::Referrer,
                5 => Self::FormInput,
                6 => Self::Cookie,
                7 => Self::PostMessage,
                8 => Self::GetParameters,
                9 => Self::UrlFragment,
                10 => Self::HtmlComment,
                11 => Self::PostParameters,
                12 => Self::Protocol,
                13 => Self::StoredXss,
                14 => Self::SameOrigin,
                15 => Self::UserControllableUrl,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackVector {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_VECTOR_UNSPECIFIED" => Self::Unspecified,
                "LOCAL_STORAGE" => Self::LocalStorage,
                "SESSION_STORAGE" => Self::SessionStorage,
                "WINDOW_NAME" => Self::WindowName,
                "REFERRER" => Self::Referrer,
                "FORM_INPUT" => Self::FormInput,
                "COOKIE" => Self::Cookie,
                "POST_MESSAGE" => Self::PostMessage,
                "GET_PARAMETERS" => Self::GetParameters,
                "URL_FRAGMENT" => Self::UrlFragment,
                "HTML_COMMENT" => Self::HtmlComment,
                "POST_PARAMETERS" => Self::PostParameters,
                "PROTOCOL" => Self::Protocol,
                "STORED_XSS" => Self::StoredXss,
                "SAME_ORIGIN" => Self::SameOrigin,
                "USER_CONTROLLABLE_URL" => Self::UserControllableUrl,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackVector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LocalStorage => serializer.serialize_i32(1),
                Self::SessionStorage => serializer.serialize_i32(2),
                Self::WindowName => serializer.serialize_i32(3),
                Self::Referrer => serializer.serialize_i32(4),
                Self::FormInput => serializer.serialize_i32(5),
                Self::Cookie => serializer.serialize_i32(6),
                Self::PostMessage => serializer.serialize_i32(7),
                Self::GetParameters => serializer.serialize_i32(8),
                Self::UrlFragment => serializer.serialize_i32(9),
                Self::HtmlComment => serializer.serialize_i32(10),
                Self::PostParameters => serializer.serialize_i32(11),
                Self::Protocol => serializer.serialize_i32(12),
                Self::StoredXss => serializer.serialize_i32(13),
                Self::SameOrigin => serializer.serialize_i32(14),
                Self::UserControllableUrl => serializer.serialize_i32(15),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackVector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackVector>::new(
                ".google.cloud.websecurityscanner.v1.Xss.AttackVector",
            ))
        }
    }
}

/// Information reported for an XXE.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Xxe {
    /// The XML string that triggered the XXE vulnerability. Non-payload values
    /// might be redacted.
    pub payload_value: std::string::String,

    /// Location within the request where the payload was placed.
    pub payload_location: crate::model::xxe::Location,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Xxe {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [payload_value][crate::model::Xxe::payload_value].
    pub fn set_payload_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload_value = v.into();
        self
    }

    /// Sets the value of [payload_location][crate::model::Xxe::payload_location].
    pub fn set_payload_location<T: std::convert::Into<crate::model::xxe::Location>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload_location = v.into();
        self
    }
}

impl wkt::message::Message for Xxe {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.Xxe"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Xxe {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __payload_value,
            __payload_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Xxe")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "payloadValue" => Ok(__FieldTag::__payload_value),
                            "payload_value" => Ok(__FieldTag::__payload_value),
                            "payloadLocation" => Ok(__FieldTag::__payload_location),
                            "payload_location" => Ok(__FieldTag::__payload_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Xxe;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Xxe")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__payload_value => {
                            if !fields.insert(__FieldTag::__payload_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload_value",
                                ));
                            }
                            result.payload_value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__payload_location => {
                            if !fields.insert(__FieldTag::__payload_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload_location",
                                ));
                            }
                            result.payload_location = map
                                .next_value::<std::option::Option<crate::model::xxe::Location>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Xxe {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.payload_value.is_empty() {
            state.serialize_entry("payloadValue", &self.payload_value)?;
        }
        if !wkt::internal::is_default(&self.payload_location) {
            state.serialize_entry("payloadLocation", &self.payload_location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Xxe].
pub mod xxe {
    #[allow(unused_imports)]
    use super::*;

    /// Locations within a request where XML was substituted.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Location {
        /// Unknown Location.
        Unspecified,
        /// The XML payload replaced the complete request body.
        CompleteRequestBody,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Location::value] or
        /// [Location::name].
        UnknownValue(location::UnknownValue),
    }

    #[doc(hidden)]
    pub mod location {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Location {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CompleteRequestBody => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOCATION_UNSPECIFIED"),
                Self::CompleteRequestBody => std::option::Option::Some("COMPLETE_REQUEST_BODY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Location {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Location {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Location {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CompleteRequestBody,
                _ => Self::UnknownValue(location::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Location {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOCATION_UNSPECIFIED" => Self::Unspecified,
                "COMPLETE_REQUEST_BODY" => Self::CompleteRequestBody,
                _ => Self::UnknownValue(location::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Location {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CompleteRequestBody => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Location {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Location>::new(
                ".google.cloud.websecurityscanner.v1.Xxe.Location",
            ))
        }
    }
}

/// A FindingTypeStats resource represents stats regarding a specific FindingType
/// of Findings under a given ScanRun.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FindingTypeStats {
    /// Output only. The finding type associated with the stats.
    pub finding_type: std::string::String,

    /// Output only. The count of findings belonging to this finding type.
    pub finding_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FindingTypeStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [finding_type][crate::model::FindingTypeStats::finding_type].
    pub fn set_finding_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.finding_type = v.into();
        self
    }

    /// Sets the value of [finding_count][crate::model::FindingTypeStats::finding_count].
    pub fn set_finding_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.finding_count = v.into();
        self
    }
}

impl wkt::message::Message for FindingTypeStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.FindingTypeStats"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FindingTypeStats {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __finding_type,
            __finding_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FindingTypeStats")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "findingType" => Ok(__FieldTag::__finding_type),
                            "finding_type" => Ok(__FieldTag::__finding_type),
                            "findingCount" => Ok(__FieldTag::__finding_count),
                            "finding_count" => Ok(__FieldTag::__finding_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FindingTypeStats;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FindingTypeStats")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__finding_type => {
                            if !fields.insert(__FieldTag::__finding_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding_type",
                                ));
                            }
                            result.finding_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__finding_count => {
                            if !fields.insert(__FieldTag::__finding_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.finding_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FindingTypeStats {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.finding_type.is_empty() {
            state.serialize_entry("findingType", &self.finding_type)?;
        }
        if !wkt::internal::is_default(&self.finding_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("findingCount", &__With(&self.finding_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A ScanConfig resource contains the configurations to launch a scan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ScanConfig {
    /// The resource name of the ScanConfig. The name follows the format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}'. The ScanConfig IDs are
    /// generated by the system.
    pub name: std::string::String,

    /// Required. The user provided display name of the ScanConfig.
    pub display_name: std::string::String,

    /// The maximum QPS during scanning. A valid value ranges from 5 to 20
    /// inclusively. If the field is unspecified or its value is set 0, server will
    /// default to 15. Other values outside of [5, 20] range will be rejected with
    /// INVALID_ARGUMENT error.
    pub max_qps: i32,

    /// Required. The starting URLs from which the scanner finds site pages.
    pub starting_urls: std::vec::Vec<std::string::String>,

    /// The authentication configuration. If specified, service will use the
    /// authentication configuration during scanning.
    pub authentication: std::option::Option<crate::model::scan_config::Authentication>,

    /// The user agent used during scanning.
    pub user_agent: crate::model::scan_config::UserAgent,

    /// The excluded URL patterns as described in
    /// <https://cloud.google.com/security-command-center/docs/how-to-use-web-security-scanner#excluding_urls>
    pub blacklist_patterns: std::vec::Vec<std::string::String>,

    /// The schedule of the ScanConfig.
    pub schedule: std::option::Option<crate::model::scan_config::Schedule>,

    /// Controls export of scan configurations and results to Security
    /// Command Center.
    pub export_to_security_command_center: crate::model::scan_config::ExportToSecurityCommandCenter,

    /// The risk level selected for the scan
    pub risk_level: crate::model::scan_config::RiskLevel,

    /// Whether the scan config is managed by Web Security Scanner, output
    /// only.
    pub managed_scan: bool,

    /// Whether the scan configuration has enabled static IP address scan feature.
    /// If enabled, the scanner will access applications from static IP addresses.
    pub static_ip_scan: bool,

    /// Whether to keep scanning even if most requests return HTTP error codes.
    pub ignore_http_status_errors: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ScanConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ScanConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [max_qps][crate::model::ScanConfig::max_qps].
    pub fn set_max_qps<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_qps = v.into();
        self
    }

    /// Sets the value of [starting_urls][crate::model::ScanConfig::starting_urls].
    pub fn set_starting_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.starting_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [authentication][crate::model::ScanConfig::authentication].
    pub fn set_authentication<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::scan_config::Authentication>,
    {
        self.authentication = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authentication][crate::model::ScanConfig::authentication].
    pub fn set_or_clear_authentication<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::scan_config::Authentication>,
    {
        self.authentication = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_agent][crate::model::ScanConfig::user_agent].
    pub fn set_user_agent<T: std::convert::Into<crate::model::scan_config::UserAgent>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_agent = v.into();
        self
    }

    /// Sets the value of [blacklist_patterns][crate::model::ScanConfig::blacklist_patterns].
    pub fn set_blacklist_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.blacklist_patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [schedule][crate::model::ScanConfig::schedule].
    pub fn set_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::scan_config::Schedule>,
    {
        self.schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule][crate::model::ScanConfig::schedule].
    pub fn set_or_clear_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::scan_config::Schedule>,
    {
        self.schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [export_to_security_command_center][crate::model::ScanConfig::export_to_security_command_center].
    pub fn set_export_to_security_command_center<
        T: std::convert::Into<crate::model::scan_config::ExportToSecurityCommandCenter>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.export_to_security_command_center = v.into();
        self
    }

    /// Sets the value of [risk_level][crate::model::ScanConfig::risk_level].
    pub fn set_risk_level<T: std::convert::Into<crate::model::scan_config::RiskLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.risk_level = v.into();
        self
    }

    /// Sets the value of [managed_scan][crate::model::ScanConfig::managed_scan].
    pub fn set_managed_scan<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.managed_scan = v.into();
        self
    }

    /// Sets the value of [static_ip_scan][crate::model::ScanConfig::static_ip_scan].
    pub fn set_static_ip_scan<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.static_ip_scan = v.into();
        self
    }

    /// Sets the value of [ignore_http_status_errors][crate::model::ScanConfig::ignore_http_status_errors].
    pub fn set_ignore_http_status_errors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_http_status_errors = v.into();
        self
    }
}

impl wkt::message::Message for ScanConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScanConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __max_qps,
            __starting_urls,
            __authentication,
            __user_agent,
            __blacklist_patterns,
            __schedule,
            __export_to_security_command_center,
            __risk_level,
            __managed_scan,
            __static_ip_scan,
            __ignore_http_status_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScanConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "maxQps" => Ok(__FieldTag::__max_qps),
                            "max_qps" => Ok(__FieldTag::__max_qps),
                            "startingUrls" => Ok(__FieldTag::__starting_urls),
                            "starting_urls" => Ok(__FieldTag::__starting_urls),
                            "authentication" => Ok(__FieldTag::__authentication),
                            "userAgent" => Ok(__FieldTag::__user_agent),
                            "user_agent" => Ok(__FieldTag::__user_agent),
                            "blacklistPatterns" => Ok(__FieldTag::__blacklist_patterns),
                            "blacklist_patterns" => Ok(__FieldTag::__blacklist_patterns),
                            "schedule" => Ok(__FieldTag::__schedule),
                            "exportToSecurityCommandCenter" => {
                                Ok(__FieldTag::__export_to_security_command_center)
                            }
                            "export_to_security_command_center" => {
                                Ok(__FieldTag::__export_to_security_command_center)
                            }
                            "riskLevel" => Ok(__FieldTag::__risk_level),
                            "risk_level" => Ok(__FieldTag::__risk_level),
                            "managedScan" => Ok(__FieldTag::__managed_scan),
                            "managed_scan" => Ok(__FieldTag::__managed_scan),
                            "staticIpScan" => Ok(__FieldTag::__static_ip_scan),
                            "static_ip_scan" => Ok(__FieldTag::__static_ip_scan),
                            "ignoreHttpStatusErrors" => Ok(__FieldTag::__ignore_http_status_errors),
                            "ignore_http_status_errors" => {
                                Ok(__FieldTag::__ignore_http_status_errors)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScanConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScanConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_qps => {
                            if !fields.insert(__FieldTag::__max_qps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_qps",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_qps = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__starting_urls => {
                            if !fields.insert(__FieldTag::__starting_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for starting_urls",
                                ));
                            }
                            result.starting_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__authentication => {
                            if !fields.insert(__FieldTag::__authentication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authentication",
                                ));
                            }
                            result.authentication = map.next_value::<std::option::Option<crate::model::scan_config::Authentication>>()?
                                ;
                        }
                        __FieldTag::__user_agent => {
                            if !fields.insert(__FieldTag::__user_agent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_agent",
                                ));
                            }
                            result.user_agent = map.next_value::<std::option::Option<crate::model::scan_config::UserAgent>>()?.unwrap_or_default();
                        }
                        __FieldTag::__blacklist_patterns => {
                            if !fields.insert(__FieldTag::__blacklist_patterns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blacklist_patterns",
                                ));
                            }
                            result.blacklist_patterns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__schedule => {
                            if !fields.insert(__FieldTag::__schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule",
                                ));
                            }
                            result.schedule = map.next_value::<std::option::Option<crate::model::scan_config::Schedule>>()?
                                ;
                        }
                        __FieldTag::__export_to_security_command_center => {
                            if !fields.insert(__FieldTag::__export_to_security_command_center) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export_to_security_command_center",
                                ));
                            }
                            result.export_to_security_command_center = map
                                .next_value::<std::option::Option<
                                    crate::model::scan_config::ExportToSecurityCommandCenter,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__risk_level => {
                            if !fields.insert(__FieldTag::__risk_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for risk_level",
                                ));
                            }
                            result.risk_level = map.next_value::<std::option::Option<crate::model::scan_config::RiskLevel>>()?.unwrap_or_default();
                        }
                        __FieldTag::__managed_scan => {
                            if !fields.insert(__FieldTag::__managed_scan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_scan",
                                ));
                            }
                            result.managed_scan = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__static_ip_scan => {
                            if !fields.insert(__FieldTag::__static_ip_scan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for static_ip_scan",
                                ));
                            }
                            result.static_ip_scan = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_http_status_errors => {
                            if !fields.insert(__FieldTag::__ignore_http_status_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_http_status_errors",
                                ));
                            }
                            result.ignore_http_status_errors = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScanConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.max_qps) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxQps", &__With(&self.max_qps))?;
        }
        if !self.starting_urls.is_empty() {
            state.serialize_entry("startingUrls", &self.starting_urls)?;
        }
        if self.authentication.is_some() {
            state.serialize_entry("authentication", &self.authentication)?;
        }
        if !wkt::internal::is_default(&self.user_agent) {
            state.serialize_entry("userAgent", &self.user_agent)?;
        }
        if !self.blacklist_patterns.is_empty() {
            state.serialize_entry("blacklistPatterns", &self.blacklist_patterns)?;
        }
        if self.schedule.is_some() {
            state.serialize_entry("schedule", &self.schedule)?;
        }
        if !wkt::internal::is_default(&self.export_to_security_command_center) {
            state.serialize_entry(
                "exportToSecurityCommandCenter",
                &self.export_to_security_command_center,
            )?;
        }
        if !wkt::internal::is_default(&self.risk_level) {
            state.serialize_entry("riskLevel", &self.risk_level)?;
        }
        if !wkt::internal::is_default(&self.managed_scan) {
            state.serialize_entry("managedScan", &self.managed_scan)?;
        }
        if !wkt::internal::is_default(&self.static_ip_scan) {
            state.serialize_entry("staticIpScan", &self.static_ip_scan)?;
        }
        if !wkt::internal::is_default(&self.ignore_http_status_errors) {
            state.serialize_entry("ignoreHttpStatusErrors", &self.ignore_http_status_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ScanConfig].
pub mod scan_config {
    #[allow(unused_imports)]
    use super::*;

    /// Scan authentication configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Authentication {
        /// Required.
        /// Authentication configuration
        pub authentication:
            std::option::Option<crate::model::scan_config::authentication::Authentication>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Authentication {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [authentication][crate::model::scan_config::Authentication::authentication].
        ///
        /// Note that all the setters affecting `authentication` are mutually
        /// exclusive.
        pub fn set_authentication<
            T: std::convert::Into<
                    std::option::Option<crate::model::scan_config::authentication::Authentication>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication = v.into();
            self
        }

        /// The value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// if it holds a `GoogleAccount`, `None` if the field is not set or
        /// holds a different branch.
        #[deprecated]
        pub fn google_account(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::scan_config::authentication::GoogleAccount>,
        > {
            #[allow(unreachable_patterns)]
            self.authentication.as_ref().and_then(|v| match v {
                crate::model::scan_config::authentication::Authentication::GoogleAccount(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// to hold a `GoogleAccount`.
        ///
        /// Note that all the setters affecting `authentication` are
        /// mutually exclusive.
        #[deprecated]
        pub fn set_google_account<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::scan_config::authentication::GoogleAccount>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication = std::option::Option::Some(
                crate::model::scan_config::authentication::Authentication::GoogleAccount(v.into()),
            );
            self
        }

        /// The value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// if it holds a `CustomAccount`, `None` if the field is not set or
        /// holds a different branch.
        pub fn custom_account(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::scan_config::authentication::CustomAccount>,
        > {
            #[allow(unreachable_patterns)]
            self.authentication.as_ref().and_then(|v| match v {
                crate::model::scan_config::authentication::Authentication::CustomAccount(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// to hold a `CustomAccount`.
        ///
        /// Note that all the setters affecting `authentication` are
        /// mutually exclusive.
        pub fn set_custom_account<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::scan_config::authentication::CustomAccount>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication = std::option::Option::Some(
                crate::model::scan_config::authentication::Authentication::CustomAccount(v.into()),
            );
            self
        }

        /// The value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// if it holds a `IapCredential`, `None` if the field is not set or
        /// holds a different branch.
        pub fn iap_credential(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::scan_config::authentication::IapCredential>,
        > {
            #[allow(unreachable_patterns)]
            self.authentication.as_ref().and_then(|v| match v {
                crate::model::scan_config::authentication::Authentication::IapCredential(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// to hold a `IapCredential`.
        ///
        /// Note that all the setters affecting `authentication` are
        /// mutually exclusive.
        pub fn set_iap_credential<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::scan_config::authentication::IapCredential>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication = std::option::Option::Some(
                crate::model::scan_config::authentication::Authentication::IapCredential(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Authentication {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Authentication {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __google_account,
                __custom_account,
                __iap_credential,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Authentication")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "googleAccount" => Ok(__FieldTag::__google_account),
                                "google_account" => Ok(__FieldTag::__google_account),
                                "customAccount" => Ok(__FieldTag::__custom_account),
                                "custom_account" => Ok(__FieldTag::__custom_account),
                                "iapCredential" => Ok(__FieldTag::__iap_credential),
                                "iap_credential" => Ok(__FieldTag::__iap_credential),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Authentication;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Authentication")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__google_account => {
                                if !fields.insert(__FieldTag::__google_account) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for google_account",
                                    ));
                                }
                                if result.authentication.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `authentication`, a oneof with full ID .google.cloud.websecurityscanner.v1.ScanConfig.Authentication.google_account, latest field was googleAccount",
                                    ));
                                }
                                result.authentication = std::option::Option::Some(
                                    crate::model::scan_config::authentication::Authentication::GoogleAccount(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::scan_config::authentication::GoogleAccount>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__custom_account => {
                                if !fields.insert(__FieldTag::__custom_account) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for custom_account",
                                    ));
                                }
                                if result.authentication.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `authentication`, a oneof with full ID .google.cloud.websecurityscanner.v1.ScanConfig.Authentication.custom_account, latest field was customAccount",
                                    ));
                                }
                                result.authentication = std::option::Option::Some(
                                    crate::model::scan_config::authentication::Authentication::CustomAccount(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::scan_config::authentication::CustomAccount>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__iap_credential => {
                                if !fields.insert(__FieldTag::__iap_credential) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for iap_credential",
                                    ));
                                }
                                if result.authentication.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `authentication`, a oneof with full ID .google.cloud.websecurityscanner.v1.ScanConfig.Authentication.iap_credential, latest field was iapCredential",
                                    ));
                                }
                                result.authentication = std::option::Option::Some(
                                    crate::model::scan_config::authentication::Authentication::IapCredential(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::scan_config::authentication::IapCredential>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Authentication {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.google_account() {
                state.serialize_entry("googleAccount", value)?;
            }
            if let Some(value) = self.custom_account() {
                state.serialize_entry("customAccount", value)?;
            }
            if let Some(value) = self.iap_credential() {
                state.serialize_entry("iapCredential", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Authentication].
    pub mod authentication {
        #[allow(unused_imports)]
        use super::*;

        /// Describes authentication configuration that uses a Google account.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        #[deprecated]
        pub struct GoogleAccount {
            /// Required. The user name of the Google account.
            pub username: std::string::String,

            /// Required. Input only. The password of the Google account. The credential is stored encrypted
            /// and not returned in any response nor included in audit logs.
            pub password: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl GoogleAccount {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [username][crate::model::scan_config::authentication::GoogleAccount::username].
            pub fn set_username<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.username = v.into();
                self
            }

            /// Sets the value of [password][crate::model::scan_config::authentication::GoogleAccount::password].
            pub fn set_password<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.password = v.into();
                self
            }
        }

        impl wkt::message::Message for GoogleAccount {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication.GoogleAccount"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for GoogleAccount {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __username,
                    __password,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for GoogleAccount")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "username" => Ok(__FieldTag::__username),
                                    "password" => Ok(__FieldTag::__password),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = GoogleAccount;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct GoogleAccount")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__username => {
                                    if !fields.insert(__FieldTag::__username) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for username",
                                            ),
                                        );
                                    }
                                    result.username = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__password => {
                                    if !fields.insert(__FieldTag::__password) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for password",
                                            ),
                                        );
                                    }
                                    result.password = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for GoogleAccount {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.username.is_empty() {
                    state.serialize_entry("username", &self.username)?;
                }
                if !self.password.is_empty() {
                    state.serialize_entry("password", &self.password)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Describes authentication configuration that uses a custom account.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CustomAccount {
            /// Required. The user name of the custom account.
            pub username: std::string::String,

            /// Required. Input only. The password of the custom account. The credential is stored encrypted
            /// and not returned in any response nor included in audit logs.
            pub password: std::string::String,

            /// Required. The login form URL of the website.
            pub login_url: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomAccount {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [username][crate::model::scan_config::authentication::CustomAccount::username].
            pub fn set_username<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.username = v.into();
                self
            }

            /// Sets the value of [password][crate::model::scan_config::authentication::CustomAccount::password].
            pub fn set_password<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.password = v.into();
                self
            }

            /// Sets the value of [login_url][crate::model::scan_config::authentication::CustomAccount::login_url].
            pub fn set_login_url<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.login_url = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomAccount {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication.CustomAccount"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CustomAccount {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __username,
                    __password,
                    __login_url,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for CustomAccount")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "username" => Ok(__FieldTag::__username),
                                    "password" => Ok(__FieldTag::__password),
                                    "loginUrl" => Ok(__FieldTag::__login_url),
                                    "login_url" => Ok(__FieldTag::__login_url),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CustomAccount;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CustomAccount")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__username => {
                                    if !fields.insert(__FieldTag::__username) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for username",
                                            ),
                                        );
                                    }
                                    result.username = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__password => {
                                    if !fields.insert(__FieldTag::__password) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for password",
                                            ),
                                        );
                                    }
                                    result.password = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__login_url => {
                                    if !fields.insert(__FieldTag::__login_url) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for login_url",
                                            ),
                                        );
                                    }
                                    result.login_url = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CustomAccount {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.username.is_empty() {
                    state.serialize_entry("username", &self.username)?;
                }
                if !self.password.is_empty() {
                    state.serialize_entry("password", &self.password)?;
                }
                if !self.login_url.is_empty() {
                    state.serialize_entry("loginUrl", &self.login_url)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Describes authentication configuration for Identity-Aware-Proxy (IAP).
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct IapCredential {
            /// Identity-Aware-Proxy (IAP) Authentication Configuration
            pub iap_credentials: std::option::Option<
                crate::model::scan_config::authentication::iap_credential::IapCredentials,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl IapCredential {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [iap_credentials][crate::model::scan_config::authentication::IapCredential::iap_credentials].
            ///
            /// Note that all the setters affecting `iap_credentials` are mutually
            /// exclusive.
            pub fn set_iap_credentials<T: std::convert::Into<std::option::Option<crate::model::scan_config::authentication::iap_credential::IapCredentials>>>(mut self, v: T) -> Self
            {
                self.iap_credentials = v.into();
                self
            }

            /// The value of [iap_credentials][crate::model::scan_config::authentication::IapCredential::iap_credentials]
            /// if it holds a `IapTestServiceAccountInfo`, `None` if the field is not set or
            /// holds a different branch.
            pub fn iap_test_service_account_info(&self) -> std::option::Option<&std::boxed::Box<crate::model::scan_config::authentication::iap_credential::IapTestServiceAccountInfo>>{
                #[allow(unreachable_patterns)]
                self.iap_credentials.as_ref().and_then(|v| match v {
                    crate::model::scan_config::authentication::iap_credential::IapCredentials::IapTestServiceAccountInfo(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [iap_credentials][crate::model::scan_config::authentication::IapCredential::iap_credentials]
            /// to hold a `IapTestServiceAccountInfo`.
            ///
            /// Note that all the setters affecting `iap_credentials` are
            /// mutually exclusive.
            pub fn set_iap_test_service_account_info<T: std::convert::Into<std::boxed::Box<crate::model::scan_config::authentication::iap_credential::IapTestServiceAccountInfo>>>(mut self, v: T) -> Self{
                self.iap_credentials = std::option::Option::Some(
                    crate::model::scan_config::authentication::iap_credential::IapCredentials::IapTestServiceAccountInfo(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for IapCredential {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication.IapCredential"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for IapCredential {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __iap_test_service_account_info,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for IapCredential")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "iapTestServiceAccountInfo" => {
                                        Ok(__FieldTag::__iap_test_service_account_info)
                                    }
                                    "iap_test_service_account_info" => {
                                        Ok(__FieldTag::__iap_test_service_account_info)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = IapCredential;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct IapCredential")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__iap_test_service_account_info => {
                                    if !fields.insert(__FieldTag::__iap_test_service_account_info) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for iap_test_service_account_info",
                                            ),
                                        );
                                    }
                                    if result.iap_credentials.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `iap_credentials`, a oneof with full ID .google.cloud.websecurityscanner.v1.ScanConfig.Authentication.IapCredential.iap_test_service_account_info, latest field was iapTestServiceAccountInfo",
                                            ),
                                        );
                                    }
                                    result.iap_credentials = std::option::Option::Some(
                                        crate::model::scan_config::authentication::iap_credential::IapCredentials::IapTestServiceAccountInfo(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::scan_config::authentication::iap_credential::IapTestServiceAccountInfo>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for IapCredential {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.iap_test_service_account_info() {
                    state.serialize_entry("iapTestServiceAccountInfo", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [IapCredential].
        pub mod iap_credential {
            #[allow(unused_imports)]
            use super::*;

            /// Describes authentication configuration when Web-Security-Scanner
            /// service account is added in Identity-Aware-Proxy (IAP) access policies.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct IapTestServiceAccountInfo {
                /// Required. Describes OAuth2 client id of resources protected by
                /// Identity-Aware-Proxy (IAP).
                pub target_audience_client_id: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl IapTestServiceAccountInfo {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [target_audience_client_id][crate::model::scan_config::authentication::iap_credential::IapTestServiceAccountInfo::target_audience_client_id].
                pub fn set_target_audience_client_id<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.target_audience_client_id = v.into();
                    self
                }
            }

            impl wkt::message::Message for IapTestServiceAccountInfo {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication.IapCredential.IapTestServiceAccountInfo"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for IapTestServiceAccountInfo {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __target_audience_client_id,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter
                                        .write_str("a field name for IapTestServiceAccountInfo")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "targetAudienceClientId" => {
                                            Ok(__FieldTag::__target_audience_client_id)
                                        }
                                        "target_audience_client_id" => {
                                            Ok(__FieldTag::__target_audience_client_id)
                                        }
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = IapTestServiceAccountInfo;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct IapTestServiceAccountInfo")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__target_audience_client_id => {
                                        if !fields.insert(__FieldTag::__target_audience_client_id) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for target_audience_client_id",
                                                ),
                                            );
                                        }
                                        result.target_audience_client_id = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for IapTestServiceAccountInfo {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.target_audience_client_id.is_empty() {
                        state.serialize_entry(
                            "targetAudienceClientId",
                            &self.target_audience_client_id,
                        )?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Identity-Aware-Proxy (IAP) Authentication Configuration
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum IapCredentials {
                /// Authentication configuration when Web-Security-Scanner service
                /// account is added in Identity-Aware-Proxy (IAP) access policies.
                IapTestServiceAccountInfo(std::boxed::Box<crate::model::scan_config::authentication::iap_credential::IapTestServiceAccountInfo>),
            }
        }

        /// Required.
        /// Authentication configuration
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Authentication {
            /// Authentication using a Google account.
            #[deprecated]
            GoogleAccount(
                std::boxed::Box<crate::model::scan_config::authentication::GoogleAccount>,
            ),
            /// Authentication using a custom account.
            CustomAccount(
                std::boxed::Box<crate::model::scan_config::authentication::CustomAccount>,
            ),
            /// Authentication using Identity-Aware-Proxy (IAP).
            IapCredential(
                std::boxed::Box<crate::model::scan_config::authentication::IapCredential>,
            ),
        }
    }

    /// Scan schedule configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Schedule {
        /// A timestamp indicates when the next run will be scheduled. The value is
        /// refreshed by the server after each run. If unspecified, it will default
        /// to current server time, which means the scan will be scheduled to start
        /// immediately.
        pub schedule_time: std::option::Option<wkt::Timestamp>,

        /// Required. The duration of time between executions in days.
        pub interval_duration_days: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Schedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [schedule_time][crate::model::scan_config::Schedule::schedule_time].
        pub fn set_schedule_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.schedule_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [schedule_time][crate::model::scan_config::Schedule::schedule_time].
        pub fn set_or_clear_schedule_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.schedule_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [interval_duration_days][crate::model::scan_config::Schedule::interval_duration_days].
        pub fn set_interval_duration_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.interval_duration_days = v.into();
            self
        }
    }

    impl wkt::message::Message for Schedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Schedule"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Schedule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __schedule_time,
                __interval_duration_days,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Schedule")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "scheduleTime" => Ok(__FieldTag::__schedule_time),
                                "schedule_time" => Ok(__FieldTag::__schedule_time),
                                "intervalDurationDays" => Ok(__FieldTag::__interval_duration_days),
                                "interval_duration_days" => {
                                    Ok(__FieldTag::__interval_duration_days)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Schedule;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Schedule")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__schedule_time => {
                                if !fields.insert(__FieldTag::__schedule_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schedule_time",
                                    ));
                                }
                                result.schedule_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__interval_duration_days => {
                                if !fields.insert(__FieldTag::__interval_duration_days) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for interval_duration_days",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.interval_duration_days =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Schedule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.schedule_time.is_some() {
                state.serialize_entry("scheduleTime", &self.schedule_time)?;
            }
            if !wkt::internal::is_default(&self.interval_duration_days) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "intervalDurationDays",
                    &__With(&self.interval_duration_days),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Type of user agents used for scanning.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserAgent {
        /// The user agent is unknown. Service will default to CHROME_LINUX.
        Unspecified,
        /// Chrome on Linux. This is the service default if unspecified.
        ChromeLinux,
        /// Chrome on Android.
        ChromeAndroid,
        /// Safari on IPhone.
        SafariIphone,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserAgent::value] or
        /// [UserAgent::name].
        UnknownValue(user_agent::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_agent {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserAgent {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ChromeLinux => std::option::Option::Some(1),
                Self::ChromeAndroid => std::option::Option::Some(2),
                Self::SafariIphone => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("USER_AGENT_UNSPECIFIED"),
                Self::ChromeLinux => std::option::Option::Some("CHROME_LINUX"),
                Self::ChromeAndroid => std::option::Option::Some("CHROME_ANDROID"),
                Self::SafariIphone => std::option::Option::Some("SAFARI_IPHONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserAgent {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserAgent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserAgent {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ChromeLinux,
                2 => Self::ChromeAndroid,
                3 => Self::SafariIphone,
                _ => Self::UnknownValue(user_agent::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for UserAgent {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_AGENT_UNSPECIFIED" => Self::Unspecified,
                "CHROME_LINUX" => Self::ChromeLinux,
                "CHROME_ANDROID" => Self::ChromeAndroid,
                "SAFARI_IPHONE" => Self::SafariIphone,
                _ => Self::UnknownValue(user_agent::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for UserAgent {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ChromeLinux => serializer.serialize_i32(1),
                Self::ChromeAndroid => serializer.serialize_i32(2),
                Self::SafariIphone => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserAgent {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserAgent>::new(
                ".google.cloud.websecurityscanner.v1.ScanConfig.UserAgent",
            ))
        }
    }

    /// Scan risk levels supported by Web Security Scanner. LOW impact
    /// scanning will minimize requests with the potential to modify data. To
    /// achieve the maximum scan coverage, NORMAL risk level is recommended.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RiskLevel {
        /// Use default, which is NORMAL.
        Unspecified,
        /// Normal scanning (Recommended)
        Normal,
        /// Lower impact scanning
        Low,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RiskLevel::value] or
        /// [RiskLevel::name].
        UnknownValue(risk_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod risk_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RiskLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Normal => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RISK_LEVEL_UNSPECIFIED"),
                Self::Normal => std::option::Option::Some("NORMAL"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RiskLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RiskLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RiskLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Normal,
                2 => Self::Low,
                _ => Self::UnknownValue(risk_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RiskLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RISK_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "NORMAL" => Self::Normal,
                "LOW" => Self::Low,
                _ => Self::UnknownValue(risk_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RiskLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Normal => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RiskLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RiskLevel>::new(
                ".google.cloud.websecurityscanner.v1.ScanConfig.RiskLevel",
            ))
        }
    }

    /// Controls export of scan configurations and results to Security
    /// Command Center.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExportToSecurityCommandCenter {
        /// Use default, which is ENABLED.
        Unspecified,
        /// Export results of this scan to Security Command Center.
        Enabled,
        /// Do not export results of this scan to Security Command Center.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExportToSecurityCommandCenter::value] or
        /// [ExportToSecurityCommandCenter::name].
        UnknownValue(export_to_security_command_center::UnknownValue),
    }

    #[doc(hidden)]
    pub mod export_to_security_command_center {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExportToSecurityCommandCenter {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("EXPORT_TO_SECURITY_COMMAND_CENTER_UNSPECIFIED")
                }
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExportToSecurityCommandCenter {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExportToSecurityCommandCenter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExportToSecurityCommandCenter {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(export_to_security_command_center::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExportToSecurityCommandCenter {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXPORT_TO_SECURITY_COMMAND_CENTER_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(export_to_security_command_center::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExportToSecurityCommandCenter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExportToSecurityCommandCenter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<ExportToSecurityCommandCenter>::new(
                    ".google.cloud.websecurityscanner.v1.ScanConfig.ExportToSecurityCommandCenter",
                ),
            )
        }
    }
}

/// Defines a custom error message used by CreateScanConfig and UpdateScanConfig
/// APIs when scan configuration validation fails. It is also reported as part of
/// a ScanRunErrorTrace message if scan validation fails due to a scan
/// configuration error.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ScanConfigError {
    /// Output only. Indicates the reason code for a configuration failure.
    pub code: crate::model::scan_config_error::Code,

    /// Output only. Indicates the full name of the ScanConfig field that triggers this error,
    /// for example "scan_config.max_qps". This field is provided for
    /// troubleshooting purposes only and its actual value can change in the
    /// future.
    pub field_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanConfigError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::ScanConfigError::code].
    pub fn set_code<T: std::convert::Into<crate::model::scan_config_error::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [field_name][crate::model::ScanConfigError::field_name].
    pub fn set_field_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field_name = v.into();
        self
    }
}

impl wkt::message::Message for ScanConfigError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfigError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScanConfigError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __field_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScanConfigError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "fieldName" => Ok(__FieldTag::__field_name),
                            "field_name" => Ok(__FieldTag::__field_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScanConfigError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScanConfigError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map.next_value::<std::option::Option<crate::model::scan_config_error::Code>>()?.unwrap_or_default();
                        }
                        __FieldTag::__field_name => {
                            if !fields.insert(__FieldTag::__field_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_name",
                                ));
                            }
                            result.field_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScanConfigError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.field_name.is_empty() {
            state.serialize_entry("fieldName", &self.field_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ScanConfigError].
pub mod scan_config_error {
    #[allow(unused_imports)]
    use super::*;

    /// Output only.
    /// Defines an error reason code.
    /// Next id: 44
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Code {
        /// There is no error.
        Unspecified,
        /// There is no error.
        Ok,
        /// Indicates an internal server error.
        /// Please DO NOT USE THIS ERROR CODE unless the root cause is truly unknown.
        InternalError,
        /// One of the seed URLs is an App Engine URL but we cannot validate the scan
        /// settings due to an App Engine API backend error.
        AppengineApiBackendError,
        /// One of the seed URLs is an App Engine URL but we cannot access the
        /// App Engine API to validate scan settings.
        AppengineApiNotAccessible,
        /// One of the seed URLs is an App Engine URL but the Default Host of the
        /// App Engine is not set.
        AppengineDefaultHostMissing,
        /// Google corporate accounts can not be used for scanning.
        CannotUseGoogleComAccount,
        /// The account of the scan creator can not be used for scanning.
        CannotUseOwnerAccount,
        /// This scan targets Compute Engine, but we cannot validate scan settings
        /// due to a Compute Engine API backend error.
        ComputeApiBackendError,
        /// This scan targets Compute Engine, but we cannot access the Compute Engine
        /// API to validate the scan settings.
        ComputeApiNotAccessible,
        /// The Custom Login URL does not belong to the current project.
        CustomLoginUrlDoesNotBelongToCurrentProject,
        /// The Custom Login URL is malformed (can not be parsed).
        CustomLoginUrlMalformed,
        /// The Custom Login URL is mapped to a non-routable IP address in DNS.
        CustomLoginUrlMappedToNonRoutableAddress,
        /// The Custom Login URL is mapped to an IP address which is not reserved for
        /// the current project.
        CustomLoginUrlMappedToUnreservedAddress,
        /// The Custom Login URL has a non-routable IP address.
        CustomLoginUrlHasNonRoutableIpAddress,
        /// The Custom Login URL has an IP address which is not reserved for the
        /// current project.
        CustomLoginUrlHasUnreservedIpAddress,
        /// Another scan with the same name (case-sensitive) already exists.
        DuplicateScanName,
        /// A field is set to an invalid value.
        InvalidFieldValue,
        /// There was an error trying to authenticate to the scan target.
        FailedToAuthenticateToTarget,
        /// Finding type value is not specified in the list findings request.
        FindingTypeUnspecified,
        /// Scan targets Compute Engine, yet current project was not whitelisted for
        /// Google Compute Engine Scanning Alpha access.
        ForbiddenToScanCompute,
        /// User tries to update managed scan
        ForbiddenUpdateToManagedScan,
        /// The supplied filter is malformed. For example, it can not be parsed, does
        /// not have a filter type in expression, or the same filter type appears
        /// more than once.
        MalformedFilter,
        /// The supplied resource name is malformed (can not be parsed).
        MalformedResourceName,
        /// The current project is not in an active state.
        ProjectInactive,
        /// A required field is not set.
        RequiredField,
        /// Project id, scanconfig id, scanrun id, or finding id are not consistent
        /// with each other in resource name.
        ResourceNameInconsistent,
        /// The scan being requested to start is already running.
        ScanAlreadyRunning,
        /// The scan that was requested to be stopped is not running.
        ScanNotRunning,
        /// One of the seed URLs does not belong to the current project.
        SeedUrlDoesNotBelongToCurrentProject,
        /// One of the seed URLs is malformed (can not be parsed).
        SeedUrlMalformed,
        /// One of the seed URLs is mapped to a non-routable IP address in DNS.
        SeedUrlMappedToNonRoutableAddress,
        /// One of the seed URLs is mapped to an IP address which is not reserved
        /// for the current project.
        SeedUrlMappedToUnreservedAddress,
        /// One of the seed URLs has on-routable IP address.
        SeedUrlHasNonRoutableIpAddress,
        /// One of the seed URLs has an IP address that is not reserved
        /// for the current project.
        SeedUrlHasUnreservedIpAddress,
        /// The Web Security Scanner service account is not configured under the
        /// project.
        ServiceAccountNotConfigured,
        /// A project has reached the maximum number of scans.
        TooManyScans,
        /// Resolving the details of the current project fails.
        UnableToResolveProjectInfo,
        /// One or more blacklist patterns were in the wrong format.
        UnsupportedBlacklistPatternFormat,
        /// The supplied filter is not supported.
        UnsupportedFilter,
        /// The supplied finding type is not supported. For example, we do not
        /// provide findings of the given finding type.
        UnsupportedFindingType,
        /// The URL scheme of one or more of the supplied URLs is not supported.
        UnsupportedUrlScheme,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Code::value] or
        /// [Code::name].
        UnknownValue(code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Code {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ok => std::option::Option::Some(0),
                Self::InternalError => std::option::Option::Some(1),
                Self::AppengineApiBackendError => std::option::Option::Some(2),
                Self::AppengineApiNotAccessible => std::option::Option::Some(3),
                Self::AppengineDefaultHostMissing => std::option::Option::Some(4),
                Self::CannotUseGoogleComAccount => std::option::Option::Some(6),
                Self::CannotUseOwnerAccount => std::option::Option::Some(7),
                Self::ComputeApiBackendError => std::option::Option::Some(8),
                Self::ComputeApiNotAccessible => std::option::Option::Some(9),
                Self::CustomLoginUrlDoesNotBelongToCurrentProject => std::option::Option::Some(10),
                Self::CustomLoginUrlMalformed => std::option::Option::Some(11),
                Self::CustomLoginUrlMappedToNonRoutableAddress => std::option::Option::Some(12),
                Self::CustomLoginUrlMappedToUnreservedAddress => std::option::Option::Some(13),
                Self::CustomLoginUrlHasNonRoutableIpAddress => std::option::Option::Some(14),
                Self::CustomLoginUrlHasUnreservedIpAddress => std::option::Option::Some(15),
                Self::DuplicateScanName => std::option::Option::Some(16),
                Self::InvalidFieldValue => std::option::Option::Some(18),
                Self::FailedToAuthenticateToTarget => std::option::Option::Some(19),
                Self::FindingTypeUnspecified => std::option::Option::Some(20),
                Self::ForbiddenToScanCompute => std::option::Option::Some(21),
                Self::ForbiddenUpdateToManagedScan => std::option::Option::Some(43),
                Self::MalformedFilter => std::option::Option::Some(22),
                Self::MalformedResourceName => std::option::Option::Some(23),
                Self::ProjectInactive => std::option::Option::Some(24),
                Self::RequiredField => std::option::Option::Some(25),
                Self::ResourceNameInconsistent => std::option::Option::Some(26),
                Self::ScanAlreadyRunning => std::option::Option::Some(27),
                Self::ScanNotRunning => std::option::Option::Some(28),
                Self::SeedUrlDoesNotBelongToCurrentProject => std::option::Option::Some(29),
                Self::SeedUrlMalformed => std::option::Option::Some(30),
                Self::SeedUrlMappedToNonRoutableAddress => std::option::Option::Some(31),
                Self::SeedUrlMappedToUnreservedAddress => std::option::Option::Some(32),
                Self::SeedUrlHasNonRoutableIpAddress => std::option::Option::Some(33),
                Self::SeedUrlHasUnreservedIpAddress => std::option::Option::Some(35),
                Self::ServiceAccountNotConfigured => std::option::Option::Some(36),
                Self::TooManyScans => std::option::Option::Some(37),
                Self::UnableToResolveProjectInfo => std::option::Option::Some(38),
                Self::UnsupportedBlacklistPatternFormat => std::option::Option::Some(39),
                Self::UnsupportedFilter => std::option::Option::Some(40),
                Self::UnsupportedFindingType => std::option::Option::Some(41),
                Self::UnsupportedUrlScheme => std::option::Option::Some(42),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CODE_UNSPECIFIED"),
                Self::Ok => std::option::Option::Some("OK"),
                Self::InternalError => std::option::Option::Some("INTERNAL_ERROR"),
                Self::AppengineApiBackendError => {
                    std::option::Option::Some("APPENGINE_API_BACKEND_ERROR")
                }
                Self::AppengineApiNotAccessible => {
                    std::option::Option::Some("APPENGINE_API_NOT_ACCESSIBLE")
                }
                Self::AppengineDefaultHostMissing => {
                    std::option::Option::Some("APPENGINE_DEFAULT_HOST_MISSING")
                }
                Self::CannotUseGoogleComAccount => {
                    std::option::Option::Some("CANNOT_USE_GOOGLE_COM_ACCOUNT")
                }
                Self::CannotUseOwnerAccount => {
                    std::option::Option::Some("CANNOT_USE_OWNER_ACCOUNT")
                }
                Self::ComputeApiBackendError => {
                    std::option::Option::Some("COMPUTE_API_BACKEND_ERROR")
                }
                Self::ComputeApiNotAccessible => {
                    std::option::Option::Some("COMPUTE_API_NOT_ACCESSIBLE")
                }
                Self::CustomLoginUrlDoesNotBelongToCurrentProject => {
                    std::option::Option::Some("CUSTOM_LOGIN_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT")
                }
                Self::CustomLoginUrlMalformed => {
                    std::option::Option::Some("CUSTOM_LOGIN_URL_MALFORMED")
                }
                Self::CustomLoginUrlMappedToNonRoutableAddress => {
                    std::option::Option::Some("CUSTOM_LOGIN_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS")
                }
                Self::CustomLoginUrlMappedToUnreservedAddress => {
                    std::option::Option::Some("CUSTOM_LOGIN_URL_MAPPED_TO_UNRESERVED_ADDRESS")
                }
                Self::CustomLoginUrlHasNonRoutableIpAddress => {
                    std::option::Option::Some("CUSTOM_LOGIN_URL_HAS_NON_ROUTABLE_IP_ADDRESS")
                }
                Self::CustomLoginUrlHasUnreservedIpAddress => {
                    std::option::Option::Some("CUSTOM_LOGIN_URL_HAS_UNRESERVED_IP_ADDRESS")
                }
                Self::DuplicateScanName => std::option::Option::Some("DUPLICATE_SCAN_NAME"),
                Self::InvalidFieldValue => std::option::Option::Some("INVALID_FIELD_VALUE"),
                Self::FailedToAuthenticateToTarget => {
                    std::option::Option::Some("FAILED_TO_AUTHENTICATE_TO_TARGET")
                }
                Self::FindingTypeUnspecified => {
                    std::option::Option::Some("FINDING_TYPE_UNSPECIFIED")
                }
                Self::ForbiddenToScanCompute => {
                    std::option::Option::Some("FORBIDDEN_TO_SCAN_COMPUTE")
                }
                Self::ForbiddenUpdateToManagedScan => {
                    std::option::Option::Some("FORBIDDEN_UPDATE_TO_MANAGED_SCAN")
                }
                Self::MalformedFilter => std::option::Option::Some("MALFORMED_FILTER"),
                Self::MalformedResourceName => std::option::Option::Some("MALFORMED_RESOURCE_NAME"),
                Self::ProjectInactive => std::option::Option::Some("PROJECT_INACTIVE"),
                Self::RequiredField => std::option::Option::Some("REQUIRED_FIELD"),
                Self::ResourceNameInconsistent => {
                    std::option::Option::Some("RESOURCE_NAME_INCONSISTENT")
                }
                Self::ScanAlreadyRunning => std::option::Option::Some("SCAN_ALREADY_RUNNING"),
                Self::ScanNotRunning => std::option::Option::Some("SCAN_NOT_RUNNING"),
                Self::SeedUrlDoesNotBelongToCurrentProject => {
                    std::option::Option::Some("SEED_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT")
                }
                Self::SeedUrlMalformed => std::option::Option::Some("SEED_URL_MALFORMED"),
                Self::SeedUrlMappedToNonRoutableAddress => {
                    std::option::Option::Some("SEED_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS")
                }
                Self::SeedUrlMappedToUnreservedAddress => {
                    std::option::Option::Some("SEED_URL_MAPPED_TO_UNRESERVED_ADDRESS")
                }
                Self::SeedUrlHasNonRoutableIpAddress => {
                    std::option::Option::Some("SEED_URL_HAS_NON_ROUTABLE_IP_ADDRESS")
                }
                Self::SeedUrlHasUnreservedIpAddress => {
                    std::option::Option::Some("SEED_URL_HAS_UNRESERVED_IP_ADDRESS")
                }
                Self::ServiceAccountNotConfigured => {
                    std::option::Option::Some("SERVICE_ACCOUNT_NOT_CONFIGURED")
                }
                Self::TooManyScans => std::option::Option::Some("TOO_MANY_SCANS"),
                Self::UnableToResolveProjectInfo => {
                    std::option::Option::Some("UNABLE_TO_RESOLVE_PROJECT_INFO")
                }
                Self::UnsupportedBlacklistPatternFormat => {
                    std::option::Option::Some("UNSUPPORTED_BLACKLIST_PATTERN_FORMAT")
                }
                Self::UnsupportedFilter => std::option::Option::Some("UNSUPPORTED_FILTER"),
                Self::UnsupportedFindingType => {
                    std::option::Option::Some("UNSUPPORTED_FINDING_TYPE")
                }
                Self::UnsupportedUrlScheme => std::option::Option::Some("UNSUPPORTED_URL_SCHEME"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Code {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Ok,
                1 => Self::InternalError,
                2 => Self::AppengineApiBackendError,
                3 => Self::AppengineApiNotAccessible,
                4 => Self::AppengineDefaultHostMissing,
                6 => Self::CannotUseGoogleComAccount,
                7 => Self::CannotUseOwnerAccount,
                8 => Self::ComputeApiBackendError,
                9 => Self::ComputeApiNotAccessible,
                10 => Self::CustomLoginUrlDoesNotBelongToCurrentProject,
                11 => Self::CustomLoginUrlMalformed,
                12 => Self::CustomLoginUrlMappedToNonRoutableAddress,
                13 => Self::CustomLoginUrlMappedToUnreservedAddress,
                14 => Self::CustomLoginUrlHasNonRoutableIpAddress,
                15 => Self::CustomLoginUrlHasUnreservedIpAddress,
                16 => Self::DuplicateScanName,
                18 => Self::InvalidFieldValue,
                19 => Self::FailedToAuthenticateToTarget,
                20 => Self::FindingTypeUnspecified,
                21 => Self::ForbiddenToScanCompute,
                22 => Self::MalformedFilter,
                23 => Self::MalformedResourceName,
                24 => Self::ProjectInactive,
                25 => Self::RequiredField,
                26 => Self::ResourceNameInconsistent,
                27 => Self::ScanAlreadyRunning,
                28 => Self::ScanNotRunning,
                29 => Self::SeedUrlDoesNotBelongToCurrentProject,
                30 => Self::SeedUrlMalformed,
                31 => Self::SeedUrlMappedToNonRoutableAddress,
                32 => Self::SeedUrlMappedToUnreservedAddress,
                33 => Self::SeedUrlHasNonRoutableIpAddress,
                35 => Self::SeedUrlHasUnreservedIpAddress,
                36 => Self::ServiceAccountNotConfigured,
                37 => Self::TooManyScans,
                38 => Self::UnableToResolveProjectInfo,
                39 => Self::UnsupportedBlacklistPatternFormat,
                40 => Self::UnsupportedFilter,
                41 => Self::UnsupportedFindingType,
                42 => Self::UnsupportedUrlScheme,
                43 => Self::ForbiddenUpdateToManagedScan,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Code {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CODE_UNSPECIFIED" => Self::Unspecified,
                "OK" => Self::Ok,
                "INTERNAL_ERROR" => Self::InternalError,
                "APPENGINE_API_BACKEND_ERROR" => Self::AppengineApiBackendError,
                "APPENGINE_API_NOT_ACCESSIBLE" => Self::AppengineApiNotAccessible,
                "APPENGINE_DEFAULT_HOST_MISSING" => Self::AppengineDefaultHostMissing,
                "CANNOT_USE_GOOGLE_COM_ACCOUNT" => Self::CannotUseGoogleComAccount,
                "CANNOT_USE_OWNER_ACCOUNT" => Self::CannotUseOwnerAccount,
                "COMPUTE_API_BACKEND_ERROR" => Self::ComputeApiBackendError,
                "COMPUTE_API_NOT_ACCESSIBLE" => Self::ComputeApiNotAccessible,
                "CUSTOM_LOGIN_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT" => {
                    Self::CustomLoginUrlDoesNotBelongToCurrentProject
                }
                "CUSTOM_LOGIN_URL_MALFORMED" => Self::CustomLoginUrlMalformed,
                "CUSTOM_LOGIN_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS" => {
                    Self::CustomLoginUrlMappedToNonRoutableAddress
                }
                "CUSTOM_LOGIN_URL_MAPPED_TO_UNRESERVED_ADDRESS" => {
                    Self::CustomLoginUrlMappedToUnreservedAddress
                }
                "CUSTOM_LOGIN_URL_HAS_NON_ROUTABLE_IP_ADDRESS" => {
                    Self::CustomLoginUrlHasNonRoutableIpAddress
                }
                "CUSTOM_LOGIN_URL_HAS_UNRESERVED_IP_ADDRESS" => {
                    Self::CustomLoginUrlHasUnreservedIpAddress
                }
                "DUPLICATE_SCAN_NAME" => Self::DuplicateScanName,
                "INVALID_FIELD_VALUE" => Self::InvalidFieldValue,
                "FAILED_TO_AUTHENTICATE_TO_TARGET" => Self::FailedToAuthenticateToTarget,
                "FINDING_TYPE_UNSPECIFIED" => Self::FindingTypeUnspecified,
                "FORBIDDEN_TO_SCAN_COMPUTE" => Self::ForbiddenToScanCompute,
                "FORBIDDEN_UPDATE_TO_MANAGED_SCAN" => Self::ForbiddenUpdateToManagedScan,
                "MALFORMED_FILTER" => Self::MalformedFilter,
                "MALFORMED_RESOURCE_NAME" => Self::MalformedResourceName,
                "PROJECT_INACTIVE" => Self::ProjectInactive,
                "REQUIRED_FIELD" => Self::RequiredField,
                "RESOURCE_NAME_INCONSISTENT" => Self::ResourceNameInconsistent,
                "SCAN_ALREADY_RUNNING" => Self::ScanAlreadyRunning,
                "SCAN_NOT_RUNNING" => Self::ScanNotRunning,
                "SEED_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT" => {
                    Self::SeedUrlDoesNotBelongToCurrentProject
                }
                "SEED_URL_MALFORMED" => Self::SeedUrlMalformed,
                "SEED_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS" => {
                    Self::SeedUrlMappedToNonRoutableAddress
                }
                "SEED_URL_MAPPED_TO_UNRESERVED_ADDRESS" => Self::SeedUrlMappedToUnreservedAddress,
                "SEED_URL_HAS_NON_ROUTABLE_IP_ADDRESS" => Self::SeedUrlHasNonRoutableIpAddress,
                "SEED_URL_HAS_UNRESERVED_IP_ADDRESS" => Self::SeedUrlHasUnreservedIpAddress,
                "SERVICE_ACCOUNT_NOT_CONFIGURED" => Self::ServiceAccountNotConfigured,
                "TOO_MANY_SCANS" => Self::TooManyScans,
                "UNABLE_TO_RESOLVE_PROJECT_INFO" => Self::UnableToResolveProjectInfo,
                "UNSUPPORTED_BLACKLIST_PATTERN_FORMAT" => Self::UnsupportedBlacklistPatternFormat,
                "UNSUPPORTED_FILTER" => Self::UnsupportedFilter,
                "UNSUPPORTED_FINDING_TYPE" => Self::UnsupportedFindingType,
                "UNSUPPORTED_URL_SCHEME" => Self::UnsupportedUrlScheme,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Code {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ok => serializer.serialize_i32(0),
                Self::InternalError => serializer.serialize_i32(1),
                Self::AppengineApiBackendError => serializer.serialize_i32(2),
                Self::AppengineApiNotAccessible => serializer.serialize_i32(3),
                Self::AppengineDefaultHostMissing => serializer.serialize_i32(4),
                Self::CannotUseGoogleComAccount => serializer.serialize_i32(6),
                Self::CannotUseOwnerAccount => serializer.serialize_i32(7),
                Self::ComputeApiBackendError => serializer.serialize_i32(8),
                Self::ComputeApiNotAccessible => serializer.serialize_i32(9),
                Self::CustomLoginUrlDoesNotBelongToCurrentProject => serializer.serialize_i32(10),
                Self::CustomLoginUrlMalformed => serializer.serialize_i32(11),
                Self::CustomLoginUrlMappedToNonRoutableAddress => serializer.serialize_i32(12),
                Self::CustomLoginUrlMappedToUnreservedAddress => serializer.serialize_i32(13),
                Self::CustomLoginUrlHasNonRoutableIpAddress => serializer.serialize_i32(14),
                Self::CustomLoginUrlHasUnreservedIpAddress => serializer.serialize_i32(15),
                Self::DuplicateScanName => serializer.serialize_i32(16),
                Self::InvalidFieldValue => serializer.serialize_i32(18),
                Self::FailedToAuthenticateToTarget => serializer.serialize_i32(19),
                Self::FindingTypeUnspecified => serializer.serialize_i32(20),
                Self::ForbiddenToScanCompute => serializer.serialize_i32(21),
                Self::ForbiddenUpdateToManagedScan => serializer.serialize_i32(43),
                Self::MalformedFilter => serializer.serialize_i32(22),
                Self::MalformedResourceName => serializer.serialize_i32(23),
                Self::ProjectInactive => serializer.serialize_i32(24),
                Self::RequiredField => serializer.serialize_i32(25),
                Self::ResourceNameInconsistent => serializer.serialize_i32(26),
                Self::ScanAlreadyRunning => serializer.serialize_i32(27),
                Self::ScanNotRunning => serializer.serialize_i32(28),
                Self::SeedUrlDoesNotBelongToCurrentProject => serializer.serialize_i32(29),
                Self::SeedUrlMalformed => serializer.serialize_i32(30),
                Self::SeedUrlMappedToNonRoutableAddress => serializer.serialize_i32(31),
                Self::SeedUrlMappedToUnreservedAddress => serializer.serialize_i32(32),
                Self::SeedUrlHasNonRoutableIpAddress => serializer.serialize_i32(33),
                Self::SeedUrlHasUnreservedIpAddress => serializer.serialize_i32(35),
                Self::ServiceAccountNotConfigured => serializer.serialize_i32(36),
                Self::TooManyScans => serializer.serialize_i32(37),
                Self::UnableToResolveProjectInfo => serializer.serialize_i32(38),
                Self::UnsupportedBlacklistPatternFormat => serializer.serialize_i32(39),
                Self::UnsupportedFilter => serializer.serialize_i32(40),
                Self::UnsupportedFindingType => serializer.serialize_i32(41),
                Self::UnsupportedUrlScheme => serializer.serialize_i32(42),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Code {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                ".google.cloud.websecurityscanner.v1.ScanConfigError.Code",
            ))
        }
    }
}

/// A ScanRun is a output-only resource representing an actual run of the scan.
/// Next id: 12
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ScanRun {
    /// Output only. The resource name of the ScanRun. The name follows the format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    /// The ScanRun IDs are generated by the system.
    pub name: std::string::String,

    /// Output only. The execution state of the ScanRun.
    pub execution_state: crate::model::scan_run::ExecutionState,

    /// Output only. The result state of the ScanRun. This field is only available after the
    /// execution state reaches "FINISHED".
    pub result_state: crate::model::scan_run::ResultState,

    /// Output only. The time at which the ScanRun started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the ScanRun reached termination state - that the ScanRun
    /// is either finished or stopped by user.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The number of URLs crawled during this ScanRun. If the scan is in progress,
    /// the value represents the number of URLs crawled up to now.
    pub urls_crawled_count: i64,

    /// Output only. The number of URLs tested during this ScanRun. If the scan is in progress,
    /// the value represents the number of URLs tested up to now. The number of
    /// URLs tested is usually larger than the number URLS crawled because
    /// typically a crawled URL is tested with multiple test payloads.
    pub urls_tested_count: i64,

    /// Output only. Whether the scan run has found any vulnerabilities.
    pub has_vulnerabilities: bool,

    /// Output only. The percentage of total completion ranging from 0 to 100.
    /// If the scan is in queue, the value is 0.
    /// If the scan is running, the value ranges from 0 to 100.
    /// If the scan is finished, the value is 100.
    pub progress_percent: i32,

    /// Output only. If result_state is an ERROR, this field provides the primary reason for
    /// scan's termination and more details, if such are available.
    pub error_trace: std::option::Option<crate::model::ScanRunErrorTrace>,

    /// Output only. A list of warnings, if such are encountered during this scan run.
    pub warning_traces: std::vec::Vec<crate::model::ScanRunWarningTrace>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ScanRun::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [execution_state][crate::model::ScanRun::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::scan_run::ExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [result_state][crate::model::ScanRun::result_state].
    pub fn set_result_state<T: std::convert::Into<crate::model::scan_run::ResultState>>(
        mut self,
        v: T,
    ) -> Self {
        self.result_state = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ScanRun::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ScanRun::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ScanRun::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ScanRun::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [urls_crawled_count][crate::model::ScanRun::urls_crawled_count].
    pub fn set_urls_crawled_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.urls_crawled_count = v.into();
        self
    }

    /// Sets the value of [urls_tested_count][crate::model::ScanRun::urls_tested_count].
    pub fn set_urls_tested_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.urls_tested_count = v.into();
        self
    }

    /// Sets the value of [has_vulnerabilities][crate::model::ScanRun::has_vulnerabilities].
    pub fn set_has_vulnerabilities<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_vulnerabilities = v.into();
        self
    }

    /// Sets the value of [progress_percent][crate::model::ScanRun::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [error_trace][crate::model::ScanRun::error_trace].
    pub fn set_error_trace<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ScanRunErrorTrace>,
    {
        self.error_trace = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_trace][crate::model::ScanRun::error_trace].
    pub fn set_or_clear_error_trace<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ScanRunErrorTrace>,
    {
        self.error_trace = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning_traces][crate::model::ScanRun::warning_traces].
    pub fn set_warning_traces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScanRunWarningTrace>,
    {
        use std::iter::Iterator;
        self.warning_traces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ScanRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanRun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScanRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __execution_state,
            __result_state,
            __start_time,
            __end_time,
            __urls_crawled_count,
            __urls_tested_count,
            __has_vulnerabilities,
            __progress_percent,
            __error_trace,
            __warning_traces,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScanRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "resultState" => Ok(__FieldTag::__result_state),
                            "result_state" => Ok(__FieldTag::__result_state),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "urlsCrawledCount" => Ok(__FieldTag::__urls_crawled_count),
                            "urls_crawled_count" => Ok(__FieldTag::__urls_crawled_count),
                            "urlsTestedCount" => Ok(__FieldTag::__urls_tested_count),
                            "urls_tested_count" => Ok(__FieldTag::__urls_tested_count),
                            "hasVulnerabilities" => Ok(__FieldTag::__has_vulnerabilities),
                            "has_vulnerabilities" => Ok(__FieldTag::__has_vulnerabilities),
                            "progressPercent" => Ok(__FieldTag::__progress_percent),
                            "progress_percent" => Ok(__FieldTag::__progress_percent),
                            "errorTrace" => Ok(__FieldTag::__error_trace),
                            "error_trace" => Ok(__FieldTag::__error_trace),
                            "warningTraces" => Ok(__FieldTag::__warning_traces),
                            "warning_traces" => Ok(__FieldTag::__warning_traces),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScanRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScanRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_state",
                                ));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::scan_run::ExecutionState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__result_state => {
                            if !fields.insert(__FieldTag::__result_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result_state",
                                ));
                            }
                            result.result_state = map.next_value::<std::option::Option<crate::model::scan_run::ResultState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__urls_crawled_count => {
                            if !fields.insert(__FieldTag::__urls_crawled_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for urls_crawled_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.urls_crawled_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__urls_tested_count => {
                            if !fields.insert(__FieldTag::__urls_tested_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for urls_tested_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.urls_tested_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__has_vulnerabilities => {
                            if !fields.insert(__FieldTag::__has_vulnerabilities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_vulnerabilities",
                                ));
                            }
                            result.has_vulnerabilities = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__progress_percent => {
                            if !fields.insert(__FieldTag::__progress_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__error_trace => {
                            if !fields.insert(__FieldTag::__error_trace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_trace",
                                ));
                            }
                            result.error_trace = map
                                .next_value::<std::option::Option<crate::model::ScanRunErrorTrace>>(
                                )?;
                        }
                        __FieldTag::__warning_traces => {
                            if !fields.insert(__FieldTag::__warning_traces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warning_traces",
                                ));
                            }
                            result.warning_traces = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ScanRunWarningTrace>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScanRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.execution_state) {
            state.serialize_entry("executionState", &self.execution_state)?;
        }
        if !wkt::internal::is_default(&self.result_state) {
            state.serialize_entry("resultState", &self.result_state)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.urls_crawled_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("urlsCrawledCount", &__With(&self.urls_crawled_count))?;
        }
        if !wkt::internal::is_default(&self.urls_tested_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("urlsTestedCount", &__With(&self.urls_tested_count))?;
        }
        if !wkt::internal::is_default(&self.has_vulnerabilities) {
            state.serialize_entry("hasVulnerabilities", &self.has_vulnerabilities)?;
        }
        if !wkt::internal::is_default(&self.progress_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("progressPercent", &__With(&self.progress_percent))?;
        }
        if self.error_trace.is_some() {
            state.serialize_entry("errorTrace", &self.error_trace)?;
        }
        if !self.warning_traces.is_empty() {
            state.serialize_entry("warningTraces", &self.warning_traces)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ScanRun].
pub mod scan_run {
    #[allow(unused_imports)]
    use super::*;

    /// Types of ScanRun execution state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExecutionState {
        /// Represents an invalid state caused by internal server error. This value
        /// should never be returned.
        Unspecified,
        /// The scan is waiting in the queue.
        Queued,
        /// The scan is in progress.
        Scanning,
        /// The scan is either finished or stopped by user.
        Finished,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExecutionState::value] or
        /// [ExecutionState::name].
        UnknownValue(execution_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod execution_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExecutionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Queued => std::option::Option::Some(1),
                Self::Scanning => std::option::Option::Some(2),
                Self::Finished => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EXECUTION_STATE_UNSPECIFIED"),
                Self::Queued => std::option::Option::Some("QUEUED"),
                Self::Scanning => std::option::Option::Some("SCANNING"),
                Self::Finished => std::option::Option::Some("FINISHED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExecutionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExecutionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExecutionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Queued,
                2 => Self::Scanning,
                3 => Self::Finished,
                _ => Self::UnknownValue(execution_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExecutionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXECUTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "QUEUED" => Self::Queued,
                "SCANNING" => Self::Scanning,
                "FINISHED" => Self::Finished,
                _ => Self::UnknownValue(execution_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExecutionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Queued => serializer.serialize_i32(1),
                Self::Scanning => serializer.serialize_i32(2),
                Self::Finished => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExecutionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExecutionState>::new(
                ".google.cloud.websecurityscanner.v1.ScanRun.ExecutionState",
            ))
        }
    }

    /// Types of ScanRun result state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResultState {
        /// Default value. This value is returned when the ScanRun is not yet
        /// finished.
        Unspecified,
        /// The scan finished without errors.
        Success,
        /// The scan finished with errors.
        Error,
        /// The scan was terminated by user.
        Killed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ResultState::value] or
        /// [ResultState::name].
        UnknownValue(result_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod result_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ResultState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Success => std::option::Option::Some(1),
                Self::Error => std::option::Option::Some(2),
                Self::Killed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESULT_STATE_UNSPECIFIED"),
                Self::Success => std::option::Option::Some("SUCCESS"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Killed => std::option::Option::Some("KILLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ResultState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ResultState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ResultState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Success,
                2 => Self::Error,
                3 => Self::Killed,
                _ => Self::UnknownValue(result_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ResultState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESULT_STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCESS" => Self::Success,
                "ERROR" => Self::Error,
                "KILLED" => Self::Killed,
                _ => Self::UnknownValue(result_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ResultState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Success => serializer.serialize_i32(1),
                Self::Error => serializer.serialize_i32(2),
                Self::Killed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ResultState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResultState>::new(
                ".google.cloud.websecurityscanner.v1.ScanRun.ResultState",
            ))
        }
    }
}

/// Output only.
/// Defines an error trace message for a ScanRun.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ScanRunErrorTrace {
    /// Output only. Indicates the error reason code.
    pub code: crate::model::scan_run_error_trace::Code,

    /// Output only. If the scan encounters SCAN_CONFIG_ISSUE error, this field has the error
    /// message encountered during scan configuration validation that is performed
    /// before each scan run.
    pub scan_config_error: std::option::Option<crate::model::ScanConfigError>,

    /// Output only. If the scan encounters TOO_MANY_HTTP_ERRORS, this field indicates the most
    /// common HTTP error code, if such is available. For example, if this code is
    /// 404, the scan has encountered too many NOT_FOUND responses.
    pub most_common_http_error_code: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanRunErrorTrace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::ScanRunErrorTrace::code].
    pub fn set_code<T: std::convert::Into<crate::model::scan_run_error_trace::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [scan_config_error][crate::model::ScanRunErrorTrace::scan_config_error].
    pub fn set_scan_config_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ScanConfigError>,
    {
        self.scan_config_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scan_config_error][crate::model::ScanRunErrorTrace::scan_config_error].
    pub fn set_or_clear_scan_config_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ScanConfigError>,
    {
        self.scan_config_error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [most_common_http_error_code][crate::model::ScanRunErrorTrace::most_common_http_error_code].
    pub fn set_most_common_http_error_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.most_common_http_error_code = v.into();
        self
    }
}

impl wkt::message::Message for ScanRunErrorTrace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanRunErrorTrace"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScanRunErrorTrace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __scan_config_error,
            __most_common_http_error_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScanRunErrorTrace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "scanConfigError" => Ok(__FieldTag::__scan_config_error),
                            "scan_config_error" => Ok(__FieldTag::__scan_config_error),
                            "mostCommonHttpErrorCode" => {
                                Ok(__FieldTag::__most_common_http_error_code)
                            }
                            "most_common_http_error_code" => {
                                Ok(__FieldTag::__most_common_http_error_code)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScanRunErrorTrace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScanRunErrorTrace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map.next_value::<std::option::Option<crate::model::scan_run_error_trace::Code>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scan_config_error => {
                            if !fields.insert(__FieldTag::__scan_config_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_config_error",
                                ));
                            }
                            result.scan_config_error = map
                                .next_value::<std::option::Option<crate::model::ScanConfigError>>(
                                )?;
                        }
                        __FieldTag::__most_common_http_error_code => {
                            if !fields.insert(__FieldTag::__most_common_http_error_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for most_common_http_error_code",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.most_common_http_error_code =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScanRunErrorTrace {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if self.scan_config_error.is_some() {
            state.serialize_entry("scanConfigError", &self.scan_config_error)?;
        }
        if !wkt::internal::is_default(&self.most_common_http_error_code) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "mostCommonHttpErrorCode",
                &__With(&self.most_common_http_error_code),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ScanRunErrorTrace].
pub mod scan_run_error_trace {
    #[allow(unused_imports)]
    use super::*;

    /// Output only.
    /// Defines an error reason code.
    /// Next id: 8
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Code {
        /// Default value is never used.
        Unspecified,
        /// Indicates that the scan run failed due to an internal server error.
        InternalError,
        /// Indicates a scan configuration error, usually due to outdated ScanConfig
        /// settings, such as starting_urls or the DNS configuration.
        ScanConfigIssue,
        /// Indicates an authentication error, usually due to outdated ScanConfig
        /// authentication settings.
        AuthenticationConfigIssue,
        /// Indicates a scan operation timeout, usually caused by a very large site.
        TimedOutWhileScanning,
        /// Indicates that a scan encountered excessive redirects, either to
        /// authentication or some other page outside of the scan scope.
        TooManyRedirects,
        /// Indicates that a scan encountered numerous errors from the web site
        /// pages. When available, most_common_http_error_code field indicates the
        /// most common HTTP error code encountered during the scan.
        TooManyHttpErrors,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Code::value] or
        /// [Code::name].
        UnknownValue(code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Code {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InternalError => std::option::Option::Some(1),
                Self::ScanConfigIssue => std::option::Option::Some(2),
                Self::AuthenticationConfigIssue => std::option::Option::Some(3),
                Self::TimedOutWhileScanning => std::option::Option::Some(4),
                Self::TooManyRedirects => std::option::Option::Some(5),
                Self::TooManyHttpErrors => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CODE_UNSPECIFIED"),
                Self::InternalError => std::option::Option::Some("INTERNAL_ERROR"),
                Self::ScanConfigIssue => std::option::Option::Some("SCAN_CONFIG_ISSUE"),
                Self::AuthenticationConfigIssue => {
                    std::option::Option::Some("AUTHENTICATION_CONFIG_ISSUE")
                }
                Self::TimedOutWhileScanning => {
                    std::option::Option::Some("TIMED_OUT_WHILE_SCANNING")
                }
                Self::TooManyRedirects => std::option::Option::Some("TOO_MANY_REDIRECTS"),
                Self::TooManyHttpErrors => std::option::Option::Some("TOO_MANY_HTTP_ERRORS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Code {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InternalError,
                2 => Self::ScanConfigIssue,
                3 => Self::AuthenticationConfigIssue,
                4 => Self::TimedOutWhileScanning,
                5 => Self::TooManyRedirects,
                6 => Self::TooManyHttpErrors,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Code {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CODE_UNSPECIFIED" => Self::Unspecified,
                "INTERNAL_ERROR" => Self::InternalError,
                "SCAN_CONFIG_ISSUE" => Self::ScanConfigIssue,
                "AUTHENTICATION_CONFIG_ISSUE" => Self::AuthenticationConfigIssue,
                "TIMED_OUT_WHILE_SCANNING" => Self::TimedOutWhileScanning,
                "TOO_MANY_REDIRECTS" => Self::TooManyRedirects,
                "TOO_MANY_HTTP_ERRORS" => Self::TooManyHttpErrors,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Code {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InternalError => serializer.serialize_i32(1),
                Self::ScanConfigIssue => serializer.serialize_i32(2),
                Self::AuthenticationConfigIssue => serializer.serialize_i32(3),
                Self::TimedOutWhileScanning => serializer.serialize_i32(4),
                Self::TooManyRedirects => serializer.serialize_i32(5),
                Self::TooManyHttpErrors => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Code {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                ".google.cloud.websecurityscanner.v1.ScanRunErrorTrace.Code",
            ))
        }
    }
}

/// A ScanRunLog is an output-only proto used for Stackdriver customer logging.
/// It is used for logs covering the start and end of scan pipelines.
/// Other than an added summary, this is a subset of the ScanRun.
/// Representation in logs is either a proto Struct, or converted to JSON.
/// Next id: 9
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ScanRunLog {
    /// Human friendly message about the event.
    pub summary: std::string::String,

    /// The resource name of the ScanRun being logged.
    pub name: std::string::String,

    /// The execution state of the ScanRun.
    pub execution_state: crate::model::scan_run::ExecutionState,

    /// The result state of the ScanRun.
    pub result_state: crate::model::scan_run::ResultState,

    pub urls_crawled_count: i64,

    pub urls_tested_count: i64,

    pub has_findings: bool,

    pub error_trace: std::option::Option<crate::model::ScanRunErrorTrace>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanRunLog {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [summary][crate::model::ScanRunLog::summary].
    pub fn set_summary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.summary = v.into();
        self
    }

    /// Sets the value of [name][crate::model::ScanRunLog::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [execution_state][crate::model::ScanRunLog::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::scan_run::ExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [result_state][crate::model::ScanRunLog::result_state].
    pub fn set_result_state<T: std::convert::Into<crate::model::scan_run::ResultState>>(
        mut self,
        v: T,
    ) -> Self {
        self.result_state = v.into();
        self
    }

    /// Sets the value of [urls_crawled_count][crate::model::ScanRunLog::urls_crawled_count].
    pub fn set_urls_crawled_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.urls_crawled_count = v.into();
        self
    }

    /// Sets the value of [urls_tested_count][crate::model::ScanRunLog::urls_tested_count].
    pub fn set_urls_tested_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.urls_tested_count = v.into();
        self
    }

    /// Sets the value of [has_findings][crate::model::ScanRunLog::has_findings].
    pub fn set_has_findings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_findings = v.into();
        self
    }

    /// Sets the value of [error_trace][crate::model::ScanRunLog::error_trace].
    pub fn set_error_trace<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ScanRunErrorTrace>,
    {
        self.error_trace = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_trace][crate::model::ScanRunLog::error_trace].
    pub fn set_or_clear_error_trace<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ScanRunErrorTrace>,
    {
        self.error_trace = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ScanRunLog {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanRunLog"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScanRunLog {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __summary,
            __name,
            __execution_state,
            __result_state,
            __urls_crawled_count,
            __urls_tested_count,
            __has_findings,
            __error_trace,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScanRunLog")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "summary" => Ok(__FieldTag::__summary),
                            "name" => Ok(__FieldTag::__name),
                            "executionState" => Ok(__FieldTag::__execution_state),
                            "execution_state" => Ok(__FieldTag::__execution_state),
                            "resultState" => Ok(__FieldTag::__result_state),
                            "result_state" => Ok(__FieldTag::__result_state),
                            "urlsCrawledCount" => Ok(__FieldTag::__urls_crawled_count),
                            "urls_crawled_count" => Ok(__FieldTag::__urls_crawled_count),
                            "urlsTestedCount" => Ok(__FieldTag::__urls_tested_count),
                            "urls_tested_count" => Ok(__FieldTag::__urls_tested_count),
                            "hasFindings" => Ok(__FieldTag::__has_findings),
                            "has_findings" => Ok(__FieldTag::__has_findings),
                            "errorTrace" => Ok(__FieldTag::__error_trace),
                            "error_trace" => Ok(__FieldTag::__error_trace),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScanRunLog;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScanRunLog")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__summary => {
                            if !fields.insert(__FieldTag::__summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summary",
                                ));
                            }
                            result.summary = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_state => {
                            if !fields.insert(__FieldTag::__execution_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_state",
                                ));
                            }
                            result.execution_state = map.next_value::<std::option::Option<crate::model::scan_run::ExecutionState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__result_state => {
                            if !fields.insert(__FieldTag::__result_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result_state",
                                ));
                            }
                            result.result_state = map.next_value::<std::option::Option<crate::model::scan_run::ResultState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__urls_crawled_count => {
                            if !fields.insert(__FieldTag::__urls_crawled_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for urls_crawled_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.urls_crawled_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__urls_tested_count => {
                            if !fields.insert(__FieldTag::__urls_tested_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for urls_tested_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.urls_tested_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__has_findings => {
                            if !fields.insert(__FieldTag::__has_findings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_findings",
                                ));
                            }
                            result.has_findings = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_trace => {
                            if !fields.insert(__FieldTag::__error_trace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_trace",
                                ));
                            }
                            result.error_trace = map
                                .next_value::<std::option::Option<crate::model::ScanRunErrorTrace>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScanRunLog {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.summary.is_empty() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.execution_state) {
            state.serialize_entry("executionState", &self.execution_state)?;
        }
        if !wkt::internal::is_default(&self.result_state) {
            state.serialize_entry("resultState", &self.result_state)?;
        }
        if !wkt::internal::is_default(&self.urls_crawled_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("urlsCrawledCount", &__With(&self.urls_crawled_count))?;
        }
        if !wkt::internal::is_default(&self.urls_tested_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("urlsTestedCount", &__With(&self.urls_tested_count))?;
        }
        if !wkt::internal::is_default(&self.has_findings) {
            state.serialize_entry("hasFindings", &self.has_findings)?;
        }
        if self.error_trace.is_some() {
            state.serialize_entry("errorTrace", &self.error_trace)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Output only.
/// Defines a warning trace message for ScanRun. Warning traces provide customers
/// with useful information that helps make the scanning process more effective.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ScanRunWarningTrace {
    /// Output only. Indicates the warning code.
    pub code: crate::model::scan_run_warning_trace::Code,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanRunWarningTrace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::ScanRunWarningTrace::code].
    pub fn set_code<T: std::convert::Into<crate::model::scan_run_warning_trace::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for ScanRunWarningTrace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanRunWarningTrace"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScanRunWarningTrace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScanRunWarningTrace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScanRunWarningTrace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScanRunWarningTrace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map.next_value::<std::option::Option<crate::model::scan_run_warning_trace::Code>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScanRunWarningTrace {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ScanRunWarningTrace].
pub mod scan_run_warning_trace {
    #[allow(unused_imports)]
    use super::*;

    /// Output only.
    /// Defines a warning message code.
    /// Next id: 6
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Code {
        /// Default value is never used.
        Unspecified,
        /// Indicates that a scan discovered an unexpectedly low number of URLs. This
        /// is sometimes caused by complex navigation features or by using a single
        /// URL for numerous pages.
        InsufficientCrawlResults,
        /// Indicates that a scan discovered too many URLs to test, or excessive
        /// redundant URLs.
        TooManyCrawlResults,
        /// Indicates that too many tests have been generated for the scan. Customer
        /// should try reducing the number of starting URLs, increasing the QPS rate,
        /// or narrowing down the scope of the scan using the excluded patterns.
        TooManyFuzzTasks,
        /// Indicates that a scan is blocked by IAP.
        BlockedByIap,
        /// Indicates that no seeds is found for a scan
        NoStartingUrlFoundForManagedScan,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Code::value] or
        /// [Code::name].
        UnknownValue(code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Code {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InsufficientCrawlResults => std::option::Option::Some(1),
                Self::TooManyCrawlResults => std::option::Option::Some(2),
                Self::TooManyFuzzTasks => std::option::Option::Some(3),
                Self::BlockedByIap => std::option::Option::Some(4),
                Self::NoStartingUrlFoundForManagedScan => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CODE_UNSPECIFIED"),
                Self::InsufficientCrawlResults => {
                    std::option::Option::Some("INSUFFICIENT_CRAWL_RESULTS")
                }
                Self::TooManyCrawlResults => std::option::Option::Some("TOO_MANY_CRAWL_RESULTS"),
                Self::TooManyFuzzTasks => std::option::Option::Some("TOO_MANY_FUZZ_TASKS"),
                Self::BlockedByIap => std::option::Option::Some("BLOCKED_BY_IAP"),
                Self::NoStartingUrlFoundForManagedScan => {
                    std::option::Option::Some("NO_STARTING_URL_FOUND_FOR_MANAGED_SCAN")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Code {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InsufficientCrawlResults,
                2 => Self::TooManyCrawlResults,
                3 => Self::TooManyFuzzTasks,
                4 => Self::BlockedByIap,
                5 => Self::NoStartingUrlFoundForManagedScan,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Code {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CODE_UNSPECIFIED" => Self::Unspecified,
                "INSUFFICIENT_CRAWL_RESULTS" => Self::InsufficientCrawlResults,
                "TOO_MANY_CRAWL_RESULTS" => Self::TooManyCrawlResults,
                "TOO_MANY_FUZZ_TASKS" => Self::TooManyFuzzTasks,
                "BLOCKED_BY_IAP" => Self::BlockedByIap,
                "NO_STARTING_URL_FOUND_FOR_MANAGED_SCAN" => Self::NoStartingUrlFoundForManagedScan,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Code {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InsufficientCrawlResults => serializer.serialize_i32(1),
                Self::TooManyCrawlResults => serializer.serialize_i32(2),
                Self::TooManyFuzzTasks => serializer.serialize_i32(3),
                Self::BlockedByIap => serializer.serialize_i32(4),
                Self::NoStartingUrlFoundForManagedScan => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Code {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                ".google.cloud.websecurityscanner.v1.ScanRunWarningTrace.Code",
            ))
        }
    }
}

/// Request for the `CreateScanConfig` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateScanConfigRequest {
    /// Required. The parent resource name where the scan is created, which should be a
    /// project resource name in the format 'projects/{projectId}'.
    pub parent: std::string::String,

    /// Required. The ScanConfig to be created.
    pub scan_config: std::option::Option<crate::model::ScanConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateScanConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateScanConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [scan_config][crate::model::CreateScanConfigRequest::scan_config].
    pub fn set_scan_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ScanConfig>,
    {
        self.scan_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scan_config][crate::model::CreateScanConfigRequest::scan_config].
    pub fn set_or_clear_scan_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ScanConfig>,
    {
        self.scan_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateScanConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.CreateScanConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateScanConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __scan_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateScanConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "scanConfig" => Ok(__FieldTag::__scan_config),
                            "scan_config" => Ok(__FieldTag::__scan_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateScanConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateScanConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scan_config => {
                            if !fields.insert(__FieldTag::__scan_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_config",
                                ));
                            }
                            result.scan_config =
                                map.next_value::<std::option::Option<crate::model::ScanConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateScanConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.scan_config.is_some() {
            state.serialize_entry("scanConfig", &self.scan_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the `DeleteScanConfig` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteScanConfigRequest {
    /// Required. The resource name of the ScanConfig to be deleted. The name follows the
    /// format of 'projects/{projectId}/scanConfigs/{scanConfigId}'.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteScanConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteScanConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteScanConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.DeleteScanConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteScanConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteScanConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteScanConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteScanConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteScanConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the `GetScanConfig` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetScanConfigRequest {
    /// Required. The resource name of the ScanConfig to be returned. The name follows the
    /// format of 'projects/{projectId}/scanConfigs/{scanConfigId}'.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetScanConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetScanConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetScanConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.GetScanConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetScanConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetScanConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetScanConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetScanConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetScanConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the `ListScanConfigs` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListScanConfigsRequest {
    /// Required. The parent resource name, which should be a project resource name in the
    /// format 'projects/{projectId}'.
    pub parent: std::string::String,

    /// A token identifying a page of results to be returned. This should be a
    /// `next_page_token` value returned from a previous List request.
    /// If unspecified, the first page of results is returned.
    pub page_token: std::string::String,

    /// The maximum number of ScanConfigs to return, can be limited by server.
    /// If not specified or not positive, the implementation will select a
    /// reasonable value.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListScanConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListScanConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListScanConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListScanConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListScanConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListScanConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListScanConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListScanConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListScanConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListScanConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListScanConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the `UpdateScanConfigRequest` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateScanConfigRequest {
    /// Required. The ScanConfig to be updated. The name field must be set to identify the
    /// resource to be updated. The values of fields not covered by the mask
    /// will be ignored.
    pub scan_config: std::option::Option<crate::model::ScanConfig>,

    /// Required. The update mask applies to the resource. For the `FieldMask` definition,
    /// see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateScanConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scan_config][crate::model::UpdateScanConfigRequest::scan_config].
    pub fn set_scan_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ScanConfig>,
    {
        self.scan_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scan_config][crate::model::UpdateScanConfigRequest::scan_config].
    pub fn set_or_clear_scan_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ScanConfig>,
    {
        self.scan_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateScanConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateScanConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateScanConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.UpdateScanConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateScanConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scan_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateScanConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scanConfig" => Ok(__FieldTag::__scan_config),
                            "scan_config" => Ok(__FieldTag::__scan_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateScanConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateScanConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scan_config => {
                            if !fields.insert(__FieldTag::__scan_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_config",
                                ));
                            }
                            result.scan_config =
                                map.next_value::<std::option::Option<crate::model::ScanConfig>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateScanConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.scan_config.is_some() {
            state.serialize_entry("scanConfig", &self.scan_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for the `ListScanConfigs` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListScanConfigsResponse {
    /// The list of ScanConfigs returned.
    pub scan_configs: std::vec::Vec<crate::model::ScanConfig>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListScanConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scan_configs][crate::model::ListScanConfigsResponse::scan_configs].
    pub fn set_scan_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScanConfig>,
    {
        use std::iter::Iterator;
        self.scan_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListScanConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListScanConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListScanConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListScanConfigsResponse {
    type PageItem = crate::model::ScanConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.scan_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListScanConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scan_configs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListScanConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scanConfigs" => Ok(__FieldTag::__scan_configs),
                            "scan_configs" => Ok(__FieldTag::__scan_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListScanConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListScanConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scan_configs => {
                            if !fields.insert(__FieldTag::__scan_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_configs",
                                ));
                            }
                            result.scan_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ScanConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListScanConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.scan_configs.is_empty() {
            state.serialize_entry("scanConfigs", &self.scan_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the `StartScanRun` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StartScanRunRequest {
    /// Required. The resource name of the ScanConfig to be used. The name follows the
    /// format of 'projects/{projectId}/scanConfigs/{scanConfigId}'.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartScanRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartScanRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartScanRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.StartScanRunRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartScanRunRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartScanRunRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartScanRunRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartScanRunRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartScanRunRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the `GetScanRun` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetScanRunRequest {
    /// Required. The resource name of the ScanRun to be returned. The name follows the
    /// format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetScanRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetScanRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetScanRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.GetScanRunRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetScanRunRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetScanRunRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetScanRunRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetScanRunRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetScanRunRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the `ListScanRuns` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListScanRunsRequest {
    /// Required. The parent resource name, which should be a scan resource name in the
    /// format 'projects/{projectId}/scanConfigs/{scanConfigId}'.
    pub parent: std::string::String,

    /// A token identifying a page of results to be returned. This should be a
    /// `next_page_token` value returned from a previous List request.
    /// If unspecified, the first page of results is returned.
    pub page_token: std::string::String,

    /// The maximum number of ScanRuns to return, can be limited by server.
    /// If not specified or not positive, the implementation will select a
    /// reasonable value.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListScanRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListScanRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListScanRunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListScanRunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListScanRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListScanRunsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListScanRunsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListScanRunsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListScanRunsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListScanRunsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListScanRunsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for the `ListScanRuns` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListScanRunsResponse {
    /// The list of ScanRuns returned.
    pub scan_runs: std::vec::Vec<crate::model::ScanRun>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListScanRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scan_runs][crate::model::ListScanRunsResponse::scan_runs].
    pub fn set_scan_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScanRun>,
    {
        use std::iter::Iterator;
        self.scan_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListScanRunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListScanRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListScanRunsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListScanRunsResponse {
    type PageItem = crate::model::ScanRun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.scan_runs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListScanRunsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scan_runs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListScanRunsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scanRuns" => Ok(__FieldTag::__scan_runs),
                            "scan_runs" => Ok(__FieldTag::__scan_runs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListScanRunsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListScanRunsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scan_runs => {
                            if !fields.insert(__FieldTag::__scan_runs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_runs",
                                ));
                            }
                            result.scan_runs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ScanRun>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListScanRunsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.scan_runs.is_empty() {
            state.serialize_entry("scanRuns", &self.scan_runs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the `StopScanRun` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StopScanRunRequest {
    /// Required. The resource name of the ScanRun to be stopped. The name follows the
    /// format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopScanRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopScanRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopScanRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.StopScanRunRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopScanRunRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopScanRunRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopScanRunRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopScanRunRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopScanRunRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the `ListCrawledUrls` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCrawledUrlsRequest {
    /// Required. The parent resource name, which should be a scan run resource name in the
    /// format
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    pub parent: std::string::String,

    /// A token identifying a page of results to be returned. This should be a
    /// `next_page_token` value returned from a previous List request.
    /// If unspecified, the first page of results is returned.
    pub page_token: std::string::String,

    /// The maximum number of CrawledUrls to return, can be limited by server.
    /// If not specified or not positive, the implementation will select a
    /// reasonable value.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCrawledUrlsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCrawledUrlsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCrawledUrlsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCrawledUrlsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListCrawledUrlsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListCrawledUrlsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCrawledUrlsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCrawledUrlsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCrawledUrlsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCrawledUrlsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCrawledUrlsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for the `ListCrawledUrls` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCrawledUrlsResponse {
    /// The list of CrawledUrls returned.
    pub crawled_urls: std::vec::Vec<crate::model::CrawledUrl>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCrawledUrlsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crawled_urls][crate::model::ListCrawledUrlsResponse::crawled_urls].
    pub fn set_crawled_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CrawledUrl>,
    {
        use std::iter::Iterator;
        self.crawled_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCrawledUrlsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCrawledUrlsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListCrawledUrlsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCrawledUrlsResponse {
    type PageItem = crate::model::CrawledUrl;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.crawled_urls
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCrawledUrlsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __crawled_urls,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCrawledUrlsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "crawledUrls" => Ok(__FieldTag::__crawled_urls),
                            "crawled_urls" => Ok(__FieldTag::__crawled_urls),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCrawledUrlsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCrawledUrlsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__crawled_urls => {
                            if !fields.insert(__FieldTag::__crawled_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crawled_urls",
                                ));
                            }
                            result.crawled_urls = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CrawledUrl>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCrawledUrlsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.crawled_urls.is_empty() {
            state.serialize_entry("crawledUrls", &self.crawled_urls)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the `GetFinding` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFindingRequest {
    /// Required. The resource name of the Finding to be returned. The name follows the
    /// format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}/findings/{findingId}'.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFindingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.GetFindingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetFindingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFindingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetFindingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFindingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetFindingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the `ListFindings` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFindingsRequest {
    /// Required. The parent resource name, which should be a scan run resource name in the
    /// format
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    pub parent: std::string::String,

    /// The filter expression. The expression must be in the format: \<field\>
    /// \<operator\> \<value\>.
    /// Supported field: 'finding_type'.
    /// Supported operator: '='.
    pub filter: std::string::String,

    /// A token identifying a page of results to be returned. This should be a
    /// `next_page_token` value returned from a previous List request.
    /// If unspecified, the first page of results is returned.
    pub page_token: std::string::String,

    /// The maximum number of Findings to return, can be limited by server.
    /// If not specified or not positive, the implementation will select a
    /// reasonable value.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFindingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFindingsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFindingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFindingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListFindingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListFindingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFindingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFindingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFindingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFindingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFindingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for the `ListFindings` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFindingsResponse {
    /// The list of Findings returned.
    pub findings: std::vec::Vec<crate::model::Finding>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [findings][crate::model::ListFindingsResponse::findings].
    pub fn set_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Finding>,
    {
        use std::iter::Iterator;
        self.findings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFindingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFindingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListFindingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFindingsResponse {
    type PageItem = crate::model::Finding;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.findings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFindingsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __findings,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFindingsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "findings" => Ok(__FieldTag::__findings),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFindingsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFindingsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__findings => {
                            if !fields.insert(__FieldTag::__findings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for findings",
                                ));
                            }
                            result.findings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Finding>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFindingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.findings.is_empty() {
            state.serialize_entry("findings", &self.findings)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the `ListFindingTypeStats` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFindingTypeStatsRequest {
    /// Required. The parent resource name, which should be a scan run resource name in the
    /// format
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingTypeStatsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFindingTypeStatsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListFindingTypeStatsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListFindingTypeStatsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFindingTypeStatsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFindingTypeStatsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFindingTypeStatsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFindingTypeStatsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFindingTypeStatsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for the `ListFindingTypeStats` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFindingTypeStatsResponse {
    /// The list of FindingTypeStats returned.
    pub finding_type_stats: std::vec::Vec<crate::model::FindingTypeStats>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingTypeStatsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [finding_type_stats][crate::model::ListFindingTypeStatsResponse::finding_type_stats].
    pub fn set_finding_type_stats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FindingTypeStats>,
    {
        use std::iter::Iterator;
        self.finding_type_stats = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFindingTypeStatsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListFindingTypeStatsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFindingTypeStatsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __finding_type_stats,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFindingTypeStatsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "findingTypeStats" => Ok(__FieldTag::__finding_type_stats),
                            "finding_type_stats" => Ok(__FieldTag::__finding_type_stats),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFindingTypeStatsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFindingTypeStatsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__finding_type_stats => {
                            if !fields.insert(__FieldTag::__finding_type_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding_type_stats",
                                ));
                            }
                            result.finding_type_stats =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FindingTypeStats>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFindingTypeStatsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.finding_type_stats.is_empty() {
            state.serialize_entry("findingTypeStats", &self.finding_type_stats)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
