// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A CrawledUrl resource represents a URL that was crawled during a ScanRun. Web
/// Security Scanner Service crawls the web applications, following all links
/// within the scope of sites, to find the URLs to test against.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CrawledUrl {
    /// Output only. The http method of the request that was used to visit the URL, in
    /// uppercase.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub http_method: std::string::String,

    /// Output only. The URL that was crawled.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,

    /// Output only. The body of the request that was used to visit the URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub body: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CrawledUrl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http_method][crate::model::CrawledUrl::http_method].
    pub fn set_http_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.http_method = v.into();
        self
    }

    /// Sets the value of [url][crate::model::CrawledUrl::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [body][crate::model::CrawledUrl::body].
    pub fn set_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for CrawledUrl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.CrawledUrl"
    }
}

/// A Finding resource represents a vulnerability instance identified during a
/// ScanRun.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Finding {
    /// Output only. The resource name of the Finding. The name follows the format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanruns/{scanRunId}/findings/{findingId}'.
    /// The finding IDs are generated by the system.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The type of the Finding.
    /// Detailed and up-to-date information on findings can be found here:
    /// <https://cloud.google.com/security-command-center/docs/how-to-remediate-web-security-scanner-findings>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub finding_type: std::string::String,

    /// Output only. The severity level of the reported vulnerability.
    pub severity: crate::model::finding::Severity,

    /// Output only. The http method of the request that triggered the vulnerability, in
    /// uppercase.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub http_method: std::string::String,

    /// Output only. The URL produced by the server-side fuzzer and used in the request that
    /// triggered the vulnerability.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fuzzed_url: std::string::String,

    /// Output only. The body of the request that triggered the vulnerability.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub body: std::string::String,

    /// Output only. The description of the vulnerability.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The URL containing human-readable payload that user can leverage to
    /// reproduce the vulnerability.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reproduction_url: std::string::String,

    /// Output only. If the vulnerability was originated from nested IFrame, the immediate
    /// parent IFrame is reported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub frame_url: std::string::String,

    /// Output only. The URL where the browser lands when the vulnerability is detected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub final_url: std::string::String,

    /// Output only. The tracking ID uniquely identifies a vulnerability instance across
    /// multiple ScanRuns.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tracking_id: std::string::String,

    /// Output only. An addon containing information reported for a vulnerability with an HTML
    /// form, if any.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub form: std::option::Option<crate::model::Form>,

    /// Output only. An addon containing information about outdated libraries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub outdated_library: std::option::Option<crate::model::OutdatedLibrary>,

    /// Output only. An addon containing detailed information regarding any resource causing the
    /// vulnerability such as JavaScript sources, image, audio files, etc.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub violating_resource: std::option::Option<crate::model::ViolatingResource>,

    /// Output only. An addon containing information about vulnerable or missing HTTP headers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vulnerable_headers: std::option::Option<crate::model::VulnerableHeaders>,

    /// Output only. An addon containing information about request parameters which were found
    /// to be vulnerable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vulnerable_parameters: std::option::Option<crate::model::VulnerableParameters>,

    /// Output only. An addon containing information reported for an XSS, if any.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub xss: std::option::Option<crate::model::Xss>,

    /// Output only. An addon containing information reported for an XXE, if any.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub xxe: std::option::Option<crate::model::Xxe>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Finding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Finding::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [finding_type][crate::model::Finding::finding_type].
    pub fn set_finding_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.finding_type = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::Finding::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::finding::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [http_method][crate::model::Finding::http_method].
    pub fn set_http_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.http_method = v.into();
        self
    }

    /// Sets the value of [fuzzed_url][crate::model::Finding::fuzzed_url].
    pub fn set_fuzzed_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fuzzed_url = v.into();
        self
    }

    /// Sets the value of [body][crate::model::Finding::body].
    pub fn set_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Finding::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [reproduction_url][crate::model::Finding::reproduction_url].
    pub fn set_reproduction_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reproduction_url = v.into();
        self
    }

    /// Sets the value of [frame_url][crate::model::Finding::frame_url].
    pub fn set_frame_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.frame_url = v.into();
        self
    }

    /// Sets the value of [final_url][crate::model::Finding::final_url].
    pub fn set_final_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.final_url = v.into();
        self
    }

    /// Sets the value of [tracking_id][crate::model::Finding::tracking_id].
    pub fn set_tracking_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tracking_id = v.into();
        self
    }

    /// Sets the value of [form][crate::model::Finding::form].
    pub fn set_form<T: std::convert::Into<std::option::Option<crate::model::Form>>>(
        mut self,
        v: T,
    ) -> Self {
        self.form = v.into();
        self
    }

    /// Sets the value of [outdated_library][crate::model::Finding::outdated_library].
    pub fn set_outdated_library<
        T: std::convert::Into<std::option::Option<crate::model::OutdatedLibrary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.outdated_library = v.into();
        self
    }

    /// Sets the value of [violating_resource][crate::model::Finding::violating_resource].
    pub fn set_violating_resource<
        T: std::convert::Into<std::option::Option<crate::model::ViolatingResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.violating_resource = v.into();
        self
    }

    /// Sets the value of [vulnerable_headers][crate::model::Finding::vulnerable_headers].
    pub fn set_vulnerable_headers<
        T: std::convert::Into<std::option::Option<crate::model::VulnerableHeaders>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vulnerable_headers = v.into();
        self
    }

    /// Sets the value of [vulnerable_parameters][crate::model::Finding::vulnerable_parameters].
    pub fn set_vulnerable_parameters<
        T: std::convert::Into<std::option::Option<crate::model::VulnerableParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vulnerable_parameters = v.into();
        self
    }

    /// Sets the value of [xss][crate::model::Finding::xss].
    pub fn set_xss<T: std::convert::Into<std::option::Option<crate::model::Xss>>>(
        mut self,
        v: T,
    ) -> Self {
        self.xss = v.into();
        self
    }

    /// Sets the value of [xxe][crate::model::Finding::xxe].
    pub fn set_xxe<T: std::convert::Into<std::option::Option<crate::model::Xxe>>>(
        mut self,
        v: T,
    ) -> Self {
        self.xxe = v.into();
        self
    }
}

impl wkt::message::Message for Finding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.Finding"
    }
}

/// Defines additional types related to [Finding].
pub mod finding {
    #[allow(unused_imports)]
    use super::*;

    /// The severity level of a vulnerability.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// No severity specified. The default value.
        Unspecified,
        /// Critical severity.
        Critical,
        /// High severity.
        High,
        /// Medium severity.
        Medium,
        /// Low severity.
        Low,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Critical => std::option::Option::Some(1),
                Self::High => std::option::Option::Some(2),
                Self::Medium => std::option::Option::Some(3),
                Self::Low => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Critical => std::option::Option::Some("CRITICAL"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::Medium => std::option::Option::Some("MEDIUM"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Critical,
                2 => Self::High,
                3 => Self::Medium,
                4 => Self::Low,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "CRITICAL" => Self::Critical,
                "HIGH" => Self::High,
                "MEDIUM" => Self::Medium,
                "LOW" => Self::Low,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Critical => serializer.serialize_i32(1),
                Self::High => serializer.serialize_i32(2),
                Self::Medium => serializer.serialize_i32(3),
                Self::Low => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.cloud.websecurityscanner.v1.Finding.Severity",
            ))
        }
    }
}

/// ! Information about a vulnerability with an HTML.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Form {
    /// ! The URI where to send the form when it's submitted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub action_uri: std::string::String,

    /// ! The names of form fields related to the vulnerability.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Form {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action_uri][crate::model::Form::action_uri].
    pub fn set_action_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action_uri = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::Form::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Form {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.Form"
    }
}

/// Information reported for an outdated library.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OutdatedLibrary {
    /// The name of the outdated library.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub library_name: std::string::String,

    /// The version number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// URLs to learn more information about the vulnerabilities in the library.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub learn_more_urls: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutdatedLibrary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [library_name][crate::model::OutdatedLibrary::library_name].
    pub fn set_library_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.library_name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::OutdatedLibrary::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [learn_more_urls][crate::model::OutdatedLibrary::learn_more_urls].
    pub fn set_learn_more_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.learn_more_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OutdatedLibrary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.OutdatedLibrary"
    }
}

/// Information regarding any resource causing the vulnerability such
/// as JavaScript sources, image, audio files, etc.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ViolatingResource {
    /// The MIME type of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content_type: std::string::String,

    /// URL of this violating resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ViolatingResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content_type][crate::model::ViolatingResource::content_type].
    pub fn set_content_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content_type = v.into();
        self
    }

    /// Sets the value of [resource_url][crate::model::ViolatingResource::resource_url].
    pub fn set_resource_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_url = v.into();
        self
    }
}

impl wkt::message::Message for ViolatingResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ViolatingResource"
    }
}

/// Information about vulnerable request parameters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VulnerableParameters {
    /// The vulnerable parameter names.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parameter_names: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerableParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameter_names][crate::model::VulnerableParameters::parameter_names].
    pub fn set_parameter_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameter_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VulnerableParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.VulnerableParameters"
    }
}

/// Information about vulnerable or missing HTTP Headers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VulnerableHeaders {
    /// List of vulnerable headers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub headers: std::vec::Vec<crate::model::vulnerable_headers::Header>,

    /// List of missing headers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub missing_headers: std::vec::Vec<crate::model::vulnerable_headers::Header>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerableHeaders {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [headers][crate::model::VulnerableHeaders::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerable_headers::Header>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [missing_headers][crate::model::VulnerableHeaders::missing_headers].
    pub fn set_missing_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerable_headers::Header>,
    {
        use std::iter::Iterator;
        self.missing_headers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VulnerableHeaders {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.VulnerableHeaders"
    }
}

/// Defines additional types related to [VulnerableHeaders].
pub mod vulnerable_headers {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a HTTP Header.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Header {
        /// Header name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Header value.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Header {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::vulnerable_headers::Header::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::vulnerable_headers::Header::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Header {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.websecurityscanner.v1.VulnerableHeaders.Header"
        }
    }
}

/// Information reported for an XSS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Xss {
    /// Stack traces leading to the point where the XSS occurred.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stack_traces: std::vec::Vec<std::string::String>,

    /// An error message generated by a javascript breakage.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_message: std::string::String,

    /// The attack vector of the payload triggering this XSS.
    pub attack_vector: crate::model::xss::AttackVector,

    /// The reproduction url for the seeding POST request of a Stored XSS.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub stored_xss_seeding_url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Xss {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_message][crate::model::Xss::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }

    /// Sets the value of [attack_vector][crate::model::Xss::attack_vector].
    pub fn set_attack_vector<T: std::convert::Into<crate::model::xss::AttackVector>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_vector = v.into();
        self
    }

    /// Sets the value of [stored_xss_seeding_url][crate::model::Xss::stored_xss_seeding_url].
    pub fn set_stored_xss_seeding_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.stored_xss_seeding_url = v.into();
        self
    }

    /// Sets the value of [stack_traces][crate::model::Xss::stack_traces].
    pub fn set_stack_traces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.stack_traces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Xss {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.Xss"
    }
}

/// Defines additional types related to [Xss].
pub mod xss {
    #[allow(unused_imports)]
    use super::*;

    /// Types of XSS attack vector.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackVector {
        /// Unknown attack vector.
        Unspecified,
        /// The attack comes from fuzzing the browser's localStorage.
        LocalStorage,
        /// The attack comes from fuzzing the browser's sessionStorage.
        SessionStorage,
        /// The attack comes from fuzzing the window's name property.
        WindowName,
        /// The attack comes from fuzzing the referrer property.
        Referrer,
        /// The attack comes from fuzzing an input element.
        FormInput,
        /// The attack comes from fuzzing the browser's cookies.
        Cookie,
        /// The attack comes from hijacking the post messaging mechanism.
        PostMessage,
        /// The attack comes from fuzzing parameters in the url.
        GetParameters,
        /// The attack comes from fuzzing the fragment in the url.
        UrlFragment,
        /// The attack comes from fuzzing the HTML comments.
        HtmlComment,
        /// The attack comes from fuzzing the POST parameters.
        PostParameters,
        /// The attack comes from fuzzing the protocol.
        Protocol,
        /// The attack comes from the server side and is stored.
        StoredXss,
        /// The attack is a Same-Origin Method Execution attack via a GET parameter.
        SameOrigin,
        /// The attack payload is received from a third-party host via a URL that is
        /// user-controllable
        UserControllableUrl,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackVector::value] or
        /// [AttackVector::name].
        UnknownValue(attack_vector::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_vector {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackVector {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LocalStorage => std::option::Option::Some(1),
                Self::SessionStorage => std::option::Option::Some(2),
                Self::WindowName => std::option::Option::Some(3),
                Self::Referrer => std::option::Option::Some(4),
                Self::FormInput => std::option::Option::Some(5),
                Self::Cookie => std::option::Option::Some(6),
                Self::PostMessage => std::option::Option::Some(7),
                Self::GetParameters => std::option::Option::Some(8),
                Self::UrlFragment => std::option::Option::Some(9),
                Self::HtmlComment => std::option::Option::Some(10),
                Self::PostParameters => std::option::Option::Some(11),
                Self::Protocol => std::option::Option::Some(12),
                Self::StoredXss => std::option::Option::Some(13),
                Self::SameOrigin => std::option::Option::Some(14),
                Self::UserControllableUrl => std::option::Option::Some(15),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_VECTOR_UNSPECIFIED"),
                Self::LocalStorage => std::option::Option::Some("LOCAL_STORAGE"),
                Self::SessionStorage => std::option::Option::Some("SESSION_STORAGE"),
                Self::WindowName => std::option::Option::Some("WINDOW_NAME"),
                Self::Referrer => std::option::Option::Some("REFERRER"),
                Self::FormInput => std::option::Option::Some("FORM_INPUT"),
                Self::Cookie => std::option::Option::Some("COOKIE"),
                Self::PostMessage => std::option::Option::Some("POST_MESSAGE"),
                Self::GetParameters => std::option::Option::Some("GET_PARAMETERS"),
                Self::UrlFragment => std::option::Option::Some("URL_FRAGMENT"),
                Self::HtmlComment => std::option::Option::Some("HTML_COMMENT"),
                Self::PostParameters => std::option::Option::Some("POST_PARAMETERS"),
                Self::Protocol => std::option::Option::Some("PROTOCOL"),
                Self::StoredXss => std::option::Option::Some("STORED_XSS"),
                Self::SameOrigin => std::option::Option::Some("SAME_ORIGIN"),
                Self::UserControllableUrl => std::option::Option::Some("USER_CONTROLLABLE_URL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackVector {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackVector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackVector {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LocalStorage,
                2 => Self::SessionStorage,
                3 => Self::WindowName,
                4 => Self::Referrer,
                5 => Self::FormInput,
                6 => Self::Cookie,
                7 => Self::PostMessage,
                8 => Self::GetParameters,
                9 => Self::UrlFragment,
                10 => Self::HtmlComment,
                11 => Self::PostParameters,
                12 => Self::Protocol,
                13 => Self::StoredXss,
                14 => Self::SameOrigin,
                15 => Self::UserControllableUrl,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackVector {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_VECTOR_UNSPECIFIED" => Self::Unspecified,
                "LOCAL_STORAGE" => Self::LocalStorage,
                "SESSION_STORAGE" => Self::SessionStorage,
                "WINDOW_NAME" => Self::WindowName,
                "REFERRER" => Self::Referrer,
                "FORM_INPUT" => Self::FormInput,
                "COOKIE" => Self::Cookie,
                "POST_MESSAGE" => Self::PostMessage,
                "GET_PARAMETERS" => Self::GetParameters,
                "URL_FRAGMENT" => Self::UrlFragment,
                "HTML_COMMENT" => Self::HtmlComment,
                "POST_PARAMETERS" => Self::PostParameters,
                "PROTOCOL" => Self::Protocol,
                "STORED_XSS" => Self::StoredXss,
                "SAME_ORIGIN" => Self::SameOrigin,
                "USER_CONTROLLABLE_URL" => Self::UserControllableUrl,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackVector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LocalStorage => serializer.serialize_i32(1),
                Self::SessionStorage => serializer.serialize_i32(2),
                Self::WindowName => serializer.serialize_i32(3),
                Self::Referrer => serializer.serialize_i32(4),
                Self::FormInput => serializer.serialize_i32(5),
                Self::Cookie => serializer.serialize_i32(6),
                Self::PostMessage => serializer.serialize_i32(7),
                Self::GetParameters => serializer.serialize_i32(8),
                Self::UrlFragment => serializer.serialize_i32(9),
                Self::HtmlComment => serializer.serialize_i32(10),
                Self::PostParameters => serializer.serialize_i32(11),
                Self::Protocol => serializer.serialize_i32(12),
                Self::StoredXss => serializer.serialize_i32(13),
                Self::SameOrigin => serializer.serialize_i32(14),
                Self::UserControllableUrl => serializer.serialize_i32(15),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackVector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackVector>::new(
                ".google.cloud.websecurityscanner.v1.Xss.AttackVector",
            ))
        }
    }
}

/// Information reported for an XXE.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Xxe {
    /// The XML string that triggered the XXE vulnerability. Non-payload values
    /// might be redacted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub payload_value: std::string::String,

    /// Location within the request where the payload was placed.
    pub payload_location: crate::model::xxe::Location,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Xxe {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [payload_value][crate::model::Xxe::payload_value].
    pub fn set_payload_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload_value = v.into();
        self
    }

    /// Sets the value of [payload_location][crate::model::Xxe::payload_location].
    pub fn set_payload_location<T: std::convert::Into<crate::model::xxe::Location>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload_location = v.into();
        self
    }
}

impl wkt::message::Message for Xxe {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.Xxe"
    }
}

/// Defines additional types related to [Xxe].
pub mod xxe {
    #[allow(unused_imports)]
    use super::*;

    /// Locations within a request where XML was substituted.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Location {
        /// Unknown Location.
        Unspecified,
        /// The XML payload replaced the complete request body.
        CompleteRequestBody,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Location::value] or
        /// [Location::name].
        UnknownValue(location::UnknownValue),
    }

    #[doc(hidden)]
    pub mod location {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Location {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CompleteRequestBody => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOCATION_UNSPECIFIED"),
                Self::CompleteRequestBody => std::option::Option::Some("COMPLETE_REQUEST_BODY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Location {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Location {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Location {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CompleteRequestBody,
                _ => Self::UnknownValue(location::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Location {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOCATION_UNSPECIFIED" => Self::Unspecified,
                "COMPLETE_REQUEST_BODY" => Self::CompleteRequestBody,
                _ => Self::UnknownValue(location::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Location {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CompleteRequestBody => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Location {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Location>::new(
                ".google.cloud.websecurityscanner.v1.Xxe.Location",
            ))
        }
    }
}

/// A FindingTypeStats resource represents stats regarding a specific FindingType
/// of Findings under a given ScanRun.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FindingTypeStats {
    /// Output only. The finding type associated with the stats.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub finding_type: std::string::String,

    /// Output only. The count of findings belonging to this finding type.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub finding_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FindingTypeStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [finding_type][crate::model::FindingTypeStats::finding_type].
    pub fn set_finding_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.finding_type = v.into();
        self
    }

    /// Sets the value of [finding_count][crate::model::FindingTypeStats::finding_count].
    pub fn set_finding_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.finding_count = v.into();
        self
    }
}

impl wkt::message::Message for FindingTypeStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.FindingTypeStats"
    }
}

/// A ScanConfig resource contains the configurations to launch a scan.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScanConfig {
    /// The resource name of the ScanConfig. The name follows the format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}'. The ScanConfig IDs are
    /// generated by the system.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user provided display name of the ScanConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The maximum QPS during scanning. A valid value ranges from 5 to 20
    /// inclusively. If the field is unspecified or its value is set 0, server will
    /// default to 15. Other values outside of [5, 20] range will be rejected with
    /// INVALID_ARGUMENT error.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_qps: i32,

    /// Required. The starting URLs from which the scanner finds site pages.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub starting_urls: std::vec::Vec<std::string::String>,

    /// The authentication configuration. If specified, service will use the
    /// authentication configuration during scanning.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authentication: std::option::Option<crate::model::scan_config::Authentication>,

    /// The user agent used during scanning.
    pub user_agent: crate::model::scan_config::UserAgent,

    /// The excluded URL patterns as described in
    /// <https://cloud.google.com/security-command-center/docs/how-to-use-web-security-scanner#excluding_urls>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blacklist_patterns: std::vec::Vec<std::string::String>,

    /// The schedule of the ScanConfig.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schedule: std::option::Option<crate::model::scan_config::Schedule>,

    /// Controls export of scan configurations and results to Security
    /// Command Center.
    pub export_to_security_command_center: crate::model::scan_config::ExportToSecurityCommandCenter,

    /// The risk level selected for the scan
    pub risk_level: crate::model::scan_config::RiskLevel,

    /// Whether the scan config is managed by Web Security Scanner, output
    /// only.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub managed_scan: bool,

    /// Whether the scan configuration has enabled static IP address scan feature.
    /// If enabled, the scanner will access applications from static IP addresses.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub static_ip_scan: bool,

    /// Whether to keep scanning even if most requests return HTTP error codes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ignore_http_status_errors: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ScanConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ScanConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [max_qps][crate::model::ScanConfig::max_qps].
    pub fn set_max_qps<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_qps = v.into();
        self
    }

    /// Sets the value of [authentication][crate::model::ScanConfig::authentication].
    pub fn set_authentication<
        T: std::convert::Into<std::option::Option<crate::model::scan_config::Authentication>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication = v.into();
        self
    }

    /// Sets the value of [user_agent][crate::model::ScanConfig::user_agent].
    pub fn set_user_agent<T: std::convert::Into<crate::model::scan_config::UserAgent>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_agent = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::ScanConfig::schedule].
    pub fn set_schedule<
        T: std::convert::Into<std::option::Option<crate::model::scan_config::Schedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// Sets the value of [export_to_security_command_center][crate::model::ScanConfig::export_to_security_command_center].
    pub fn set_export_to_security_command_center<
        T: std::convert::Into<crate::model::scan_config::ExportToSecurityCommandCenter>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.export_to_security_command_center = v.into();
        self
    }

    /// Sets the value of [risk_level][crate::model::ScanConfig::risk_level].
    pub fn set_risk_level<T: std::convert::Into<crate::model::scan_config::RiskLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.risk_level = v.into();
        self
    }

    /// Sets the value of [managed_scan][crate::model::ScanConfig::managed_scan].
    pub fn set_managed_scan<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.managed_scan = v.into();
        self
    }

    /// Sets the value of [static_ip_scan][crate::model::ScanConfig::static_ip_scan].
    pub fn set_static_ip_scan<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.static_ip_scan = v.into();
        self
    }

    /// Sets the value of [ignore_http_status_errors][crate::model::ScanConfig::ignore_http_status_errors].
    pub fn set_ignore_http_status_errors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_http_status_errors = v.into();
        self
    }

    /// Sets the value of [starting_urls][crate::model::ScanConfig::starting_urls].
    pub fn set_starting_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.starting_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [blacklist_patterns][crate::model::ScanConfig::blacklist_patterns].
    pub fn set_blacklist_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.blacklist_patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ScanConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig"
    }
}

/// Defines additional types related to [ScanConfig].
pub mod scan_config {
    #[allow(unused_imports)]
    use super::*;

    /// Scan authentication configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Authentication {
        /// Required.
        /// Authentication configuration
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub authentication:
            std::option::Option<crate::model::scan_config::authentication::Authentication>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Authentication {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [authentication][crate::model::scan_config::Authentication::authentication].
        ///
        /// Note that all the setters affecting `authentication` are mutually
        /// exclusive.
        pub fn set_authentication<
            T: std::convert::Into<
                    std::option::Option<crate::model::scan_config::authentication::Authentication>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication = v.into();
            self
        }

        /// The value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// if it holds a `GoogleAccount`, `None` if the field is not set or
        /// holds a different branch.
        #[deprecated]
        pub fn google_account(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::scan_config::authentication::GoogleAccount>,
        > {
            #[allow(unreachable_patterns)]
            self.authentication.as_ref().and_then(|v| match v {
                crate::model::scan_config::authentication::Authentication::GoogleAccount(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// if it holds a `CustomAccount`, `None` if the field is not set or
        /// holds a different branch.
        pub fn custom_account(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::scan_config::authentication::CustomAccount>,
        > {
            #[allow(unreachable_patterns)]
            self.authentication.as_ref().and_then(|v| match v {
                crate::model::scan_config::authentication::Authentication::CustomAccount(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// if it holds a `IapCredential`, `None` if the field is not set or
        /// holds a different branch.
        pub fn iap_credential(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::scan_config::authentication::IapCredential>,
        > {
            #[allow(unreachable_patterns)]
            self.authentication.as_ref().and_then(|v| match v {
                crate::model::scan_config::authentication::Authentication::IapCredential(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// to hold a `GoogleAccount`.
        ///
        /// Note that all the setters affecting `authentication` are
        /// mutually exclusive.
        #[deprecated]
        pub fn set_google_account<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::scan_config::authentication::GoogleAccount>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication = std::option::Option::Some(
                crate::model::scan_config::authentication::Authentication::GoogleAccount(v.into()),
            );
            self
        }

        /// Sets the value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// to hold a `CustomAccount`.
        ///
        /// Note that all the setters affecting `authentication` are
        /// mutually exclusive.
        pub fn set_custom_account<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::scan_config::authentication::CustomAccount>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication = std::option::Option::Some(
                crate::model::scan_config::authentication::Authentication::CustomAccount(v.into()),
            );
            self
        }

        /// Sets the value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// to hold a `IapCredential`.
        ///
        /// Note that all the setters affecting `authentication` are
        /// mutually exclusive.
        pub fn set_iap_credential<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::scan_config::authentication::IapCredential>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication = std::option::Option::Some(
                crate::model::scan_config::authentication::Authentication::IapCredential(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Authentication {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication"
        }
    }

    /// Defines additional types related to [Authentication].
    pub mod authentication {
        #[allow(unused_imports)]
        use super::*;

        /// Describes authentication configuration that uses a Google account.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        #[deprecated]
        pub struct GoogleAccount {
            /// Required. The user name of the Google account.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub username: std::string::String,

            /// Required. Input only. The password of the Google account. The credential is stored encrypted
            /// and not returned in any response nor included in audit logs.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub password: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl GoogleAccount {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [username][crate::model::scan_config::authentication::GoogleAccount::username].
            pub fn set_username<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.username = v.into();
                self
            }

            /// Sets the value of [password][crate::model::scan_config::authentication::GoogleAccount::password].
            pub fn set_password<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.password = v.into();
                self
            }
        }

        impl wkt::message::Message for GoogleAccount {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication.GoogleAccount"
            }
        }

        /// Describes authentication configuration that uses a custom account.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CustomAccount {
            /// Required. The user name of the custom account.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub username: std::string::String,

            /// Required. Input only. The password of the custom account. The credential is stored encrypted
            /// and not returned in any response nor included in audit logs.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub password: std::string::String,

            /// Required. The login form URL of the website.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub login_url: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomAccount {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [username][crate::model::scan_config::authentication::CustomAccount::username].
            pub fn set_username<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.username = v.into();
                self
            }

            /// Sets the value of [password][crate::model::scan_config::authentication::CustomAccount::password].
            pub fn set_password<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.password = v.into();
                self
            }

            /// Sets the value of [login_url][crate::model::scan_config::authentication::CustomAccount::login_url].
            pub fn set_login_url<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.login_url = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomAccount {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication.CustomAccount"
            }
        }

        /// Describes authentication configuration for Identity-Aware-Proxy (IAP).
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct IapCredential {
            /// Identity-Aware-Proxy (IAP) Authentication Configuration
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub iap_credentials: std::option::Option<
                crate::model::scan_config::authentication::iap_credential::IapCredentials,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl IapCredential {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [iap_credentials][crate::model::scan_config::authentication::IapCredential::iap_credentials].
            ///
            /// Note that all the setters affecting `iap_credentials` are mutually
            /// exclusive.
            pub fn set_iap_credentials<T: std::convert::Into<std::option::Option<crate::model::scan_config::authentication::iap_credential::IapCredentials>>>(mut self, v: T) -> Self
            {
                self.iap_credentials = v.into();
                self
            }

            /// The value of [iap_credentials][crate::model::scan_config::authentication::IapCredential::iap_credentials]
            /// if it holds a `IapTestServiceAccountInfo`, `None` if the field is not set or
            /// holds a different branch.
            pub fn iap_test_service_account_info(&self) -> std::option::Option<&std::boxed::Box<crate::model::scan_config::authentication::iap_credential::IapTestServiceAccountInfo>>{
                #[allow(unreachable_patterns)]
                self.iap_credentials.as_ref().and_then(|v| match v {
                    crate::model::scan_config::authentication::iap_credential::IapCredentials::IapTestServiceAccountInfo(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [iap_credentials][crate::model::scan_config::authentication::IapCredential::iap_credentials]
            /// to hold a `IapTestServiceAccountInfo`.
            ///
            /// Note that all the setters affecting `iap_credentials` are
            /// mutually exclusive.
            pub fn set_iap_test_service_account_info<T: std::convert::Into<std::boxed::Box<crate::model::scan_config::authentication::iap_credential::IapTestServiceAccountInfo>>>(mut self, v: T) -> Self{
                self.iap_credentials = std::option::Option::Some(
                    crate::model::scan_config::authentication::iap_credential::IapCredentials::IapTestServiceAccountInfo(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for IapCredential {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication.IapCredential"
            }
        }

        /// Defines additional types related to [IapCredential].
        pub mod iap_credential {
            #[allow(unused_imports)]
            use super::*;

            /// Describes authentication configuration when Web-Security-Scanner
            /// service account is added in Identity-Aware-Proxy (IAP) access policies.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct IapTestServiceAccountInfo {
                /// Required. Describes OAuth2 client id of resources protected by
                /// Identity-Aware-Proxy (IAP).
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub target_audience_client_id: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl IapTestServiceAccountInfo {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [target_audience_client_id][crate::model::scan_config::authentication::iap_credential::IapTestServiceAccountInfo::target_audience_client_id].
                pub fn set_target_audience_client_id<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.target_audience_client_id = v.into();
                    self
                }
            }

            impl wkt::message::Message for IapTestServiceAccountInfo {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication.IapCredential.IapTestServiceAccountInfo"
                }
            }

            /// Identity-Aware-Proxy (IAP) Authentication Configuration
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum IapCredentials {
                /// Authentication configuration when Web-Security-Scanner service
                /// account is added in Identity-Aware-Proxy (IAP) access policies.
                IapTestServiceAccountInfo(std::boxed::Box<crate::model::scan_config::authentication::iap_credential::IapTestServiceAccountInfo>),
            }
        }

        /// Required.
        /// Authentication configuration
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Authentication {
            /// Authentication using a Google account.
            #[deprecated]
            GoogleAccount(
                std::boxed::Box<crate::model::scan_config::authentication::GoogleAccount>,
            ),
            /// Authentication using a custom account.
            CustomAccount(
                std::boxed::Box<crate::model::scan_config::authentication::CustomAccount>,
            ),
            /// Authentication using Identity-Aware-Proxy (IAP).
            IapCredential(
                std::boxed::Box<crate::model::scan_config::authentication::IapCredential>,
            ),
        }
    }

    /// Scan schedule configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Schedule {
        /// A timestamp indicates when the next run will be scheduled. The value is
        /// refreshed by the server after each run. If unspecified, it will default
        /// to current server time, which means the scan will be scheduled to start
        /// immediately.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub schedule_time: std::option::Option<wkt::Timestamp>,

        /// Required. The duration of time between executions in days.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub interval_duration_days: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Schedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [schedule_time][crate::model::scan_config::Schedule::schedule_time].
        pub fn set_schedule_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.schedule_time = v.into();
            self
        }

        /// Sets the value of [interval_duration_days][crate::model::scan_config::Schedule::interval_duration_days].
        pub fn set_interval_duration_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.interval_duration_days = v.into();
            self
        }
    }

    impl wkt::message::Message for Schedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Schedule"
        }
    }

    /// Type of user agents used for scanning.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserAgent {
        /// The user agent is unknown. Service will default to CHROME_LINUX.
        Unspecified,
        /// Chrome on Linux. This is the service default if unspecified.
        ChromeLinux,
        /// Chrome on Android.
        ChromeAndroid,
        /// Safari on IPhone.
        SafariIphone,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserAgent::value] or
        /// [UserAgent::name].
        UnknownValue(user_agent::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_agent {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserAgent {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ChromeLinux => std::option::Option::Some(1),
                Self::ChromeAndroid => std::option::Option::Some(2),
                Self::SafariIphone => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("USER_AGENT_UNSPECIFIED"),
                Self::ChromeLinux => std::option::Option::Some("CHROME_LINUX"),
                Self::ChromeAndroid => std::option::Option::Some("CHROME_ANDROID"),
                Self::SafariIphone => std::option::Option::Some("SAFARI_IPHONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserAgent {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserAgent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserAgent {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ChromeLinux,
                2 => Self::ChromeAndroid,
                3 => Self::SafariIphone,
                _ => Self::UnknownValue(user_agent::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for UserAgent {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_AGENT_UNSPECIFIED" => Self::Unspecified,
                "CHROME_LINUX" => Self::ChromeLinux,
                "CHROME_ANDROID" => Self::ChromeAndroid,
                "SAFARI_IPHONE" => Self::SafariIphone,
                _ => Self::UnknownValue(user_agent::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for UserAgent {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ChromeLinux => serializer.serialize_i32(1),
                Self::ChromeAndroid => serializer.serialize_i32(2),
                Self::SafariIphone => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserAgent {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserAgent>::new(
                ".google.cloud.websecurityscanner.v1.ScanConfig.UserAgent",
            ))
        }
    }

    /// Scan risk levels supported by Web Security Scanner. LOW impact
    /// scanning will minimize requests with the potential to modify data. To
    /// achieve the maximum scan coverage, NORMAL risk level is recommended.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RiskLevel {
        /// Use default, which is NORMAL.
        Unspecified,
        /// Normal scanning (Recommended)
        Normal,
        /// Lower impact scanning
        Low,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RiskLevel::value] or
        /// [RiskLevel::name].
        UnknownValue(risk_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod risk_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RiskLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Normal => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RISK_LEVEL_UNSPECIFIED"),
                Self::Normal => std::option::Option::Some("NORMAL"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RiskLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RiskLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RiskLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Normal,
                2 => Self::Low,
                _ => Self::UnknownValue(risk_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RiskLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RISK_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "NORMAL" => Self::Normal,
                "LOW" => Self::Low,
                _ => Self::UnknownValue(risk_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RiskLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Normal => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RiskLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RiskLevel>::new(
                ".google.cloud.websecurityscanner.v1.ScanConfig.RiskLevel",
            ))
        }
    }

    /// Controls export of scan configurations and results to Security
    /// Command Center.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExportToSecurityCommandCenter {
        /// Use default, which is ENABLED.
        Unspecified,
        /// Export results of this scan to Security Command Center.
        Enabled,
        /// Do not export results of this scan to Security Command Center.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExportToSecurityCommandCenter::value] or
        /// [ExportToSecurityCommandCenter::name].
        UnknownValue(export_to_security_command_center::UnknownValue),
    }

    #[doc(hidden)]
    pub mod export_to_security_command_center {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExportToSecurityCommandCenter {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("EXPORT_TO_SECURITY_COMMAND_CENTER_UNSPECIFIED")
                }
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExportToSecurityCommandCenter {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExportToSecurityCommandCenter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExportToSecurityCommandCenter {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(export_to_security_command_center::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExportToSecurityCommandCenter {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXPORT_TO_SECURITY_COMMAND_CENTER_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(export_to_security_command_center::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExportToSecurityCommandCenter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExportToSecurityCommandCenter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<ExportToSecurityCommandCenter>::new(
                    ".google.cloud.websecurityscanner.v1.ScanConfig.ExportToSecurityCommandCenter",
                ),
            )
        }
    }
}

/// Defines a custom error message used by CreateScanConfig and UpdateScanConfig
/// APIs when scan configuration validation fails. It is also reported as part of
/// a ScanRunErrorTrace message if scan validation fails due to a scan
/// configuration error.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScanConfigError {
    /// Output only. Indicates the reason code for a configuration failure.
    pub code: crate::model::scan_config_error::Code,

    /// Output only. Indicates the full name of the ScanConfig field that triggers this error,
    /// for example "scan_config.max_qps". This field is provided for
    /// troubleshooting purposes only and its actual value can change in the
    /// future.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub field_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanConfigError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::ScanConfigError::code].
    pub fn set_code<T: std::convert::Into<crate::model::scan_config_error::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [field_name][crate::model::ScanConfigError::field_name].
    pub fn set_field_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field_name = v.into();
        self
    }
}

impl wkt::message::Message for ScanConfigError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfigError"
    }
}

/// Defines additional types related to [ScanConfigError].
pub mod scan_config_error {
    #[allow(unused_imports)]
    use super::*;

    /// Output only.
    /// Defines an error reason code.
    /// Next id: 44
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Code {
        /// There is no error.
        Unspecified,
        /// There is no error.
        Ok,
        /// Indicates an internal server error.
        /// Please DO NOT USE THIS ERROR CODE unless the root cause is truly unknown.
        InternalError,
        /// One of the seed URLs is an App Engine URL but we cannot validate the scan
        /// settings due to an App Engine API backend error.
        AppengineApiBackendError,
        /// One of the seed URLs is an App Engine URL but we cannot access the
        /// App Engine API to validate scan settings.
        AppengineApiNotAccessible,
        /// One of the seed URLs is an App Engine URL but the Default Host of the
        /// App Engine is not set.
        AppengineDefaultHostMissing,
        /// Google corporate accounts can not be used for scanning.
        CannotUseGoogleComAccount,
        /// The account of the scan creator can not be used for scanning.
        CannotUseOwnerAccount,
        /// This scan targets Compute Engine, but we cannot validate scan settings
        /// due to a Compute Engine API backend error.
        ComputeApiBackendError,
        /// This scan targets Compute Engine, but we cannot access the Compute Engine
        /// API to validate the scan settings.
        ComputeApiNotAccessible,
        /// The Custom Login URL does not belong to the current project.
        CustomLoginUrlDoesNotBelongToCurrentProject,
        /// The Custom Login URL is malformed (can not be parsed).
        CustomLoginUrlMalformed,
        /// The Custom Login URL is mapped to a non-routable IP address in DNS.
        CustomLoginUrlMappedToNonRoutableAddress,
        /// The Custom Login URL is mapped to an IP address which is not reserved for
        /// the current project.
        CustomLoginUrlMappedToUnreservedAddress,
        /// The Custom Login URL has a non-routable IP address.
        CustomLoginUrlHasNonRoutableIpAddress,
        /// The Custom Login URL has an IP address which is not reserved for the
        /// current project.
        CustomLoginUrlHasUnreservedIpAddress,
        /// Another scan with the same name (case-sensitive) already exists.
        DuplicateScanName,
        /// A field is set to an invalid value.
        InvalidFieldValue,
        /// There was an error trying to authenticate to the scan target.
        FailedToAuthenticateToTarget,
        /// Finding type value is not specified in the list findings request.
        FindingTypeUnspecified,
        /// Scan targets Compute Engine, yet current project was not whitelisted for
        /// Google Compute Engine Scanning Alpha access.
        ForbiddenToScanCompute,
        /// User tries to update managed scan
        ForbiddenUpdateToManagedScan,
        /// The supplied filter is malformed. For example, it can not be parsed, does
        /// not have a filter type in expression, or the same filter type appears
        /// more than once.
        MalformedFilter,
        /// The supplied resource name is malformed (can not be parsed).
        MalformedResourceName,
        /// The current project is not in an active state.
        ProjectInactive,
        /// A required field is not set.
        RequiredField,
        /// Project id, scanconfig id, scanrun id, or finding id are not consistent
        /// with each other in resource name.
        ResourceNameInconsistent,
        /// The scan being requested to start is already running.
        ScanAlreadyRunning,
        /// The scan that was requested to be stopped is not running.
        ScanNotRunning,
        /// One of the seed URLs does not belong to the current project.
        SeedUrlDoesNotBelongToCurrentProject,
        /// One of the seed URLs is malformed (can not be parsed).
        SeedUrlMalformed,
        /// One of the seed URLs is mapped to a non-routable IP address in DNS.
        SeedUrlMappedToNonRoutableAddress,
        /// One of the seed URLs is mapped to an IP address which is not reserved
        /// for the current project.
        SeedUrlMappedToUnreservedAddress,
        /// One of the seed URLs has on-routable IP address.
        SeedUrlHasNonRoutableIpAddress,
        /// One of the seed URLs has an IP address that is not reserved
        /// for the current project.
        SeedUrlHasUnreservedIpAddress,
        /// The Web Security Scanner service account is not configured under the
        /// project.
        ServiceAccountNotConfigured,
        /// A project has reached the maximum number of scans.
        TooManyScans,
        /// Resolving the details of the current project fails.
        UnableToResolveProjectInfo,
        /// One or more blacklist patterns were in the wrong format.
        UnsupportedBlacklistPatternFormat,
        /// The supplied filter is not supported.
        UnsupportedFilter,
        /// The supplied finding type is not supported. For example, we do not
        /// provide findings of the given finding type.
        UnsupportedFindingType,
        /// The URL scheme of one or more of the supplied URLs is not supported.
        UnsupportedUrlScheme,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Code::value] or
        /// [Code::name].
        UnknownValue(code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Code {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ok => std::option::Option::Some(0),
                Self::InternalError => std::option::Option::Some(1),
                Self::AppengineApiBackendError => std::option::Option::Some(2),
                Self::AppengineApiNotAccessible => std::option::Option::Some(3),
                Self::AppengineDefaultHostMissing => std::option::Option::Some(4),
                Self::CannotUseGoogleComAccount => std::option::Option::Some(6),
                Self::CannotUseOwnerAccount => std::option::Option::Some(7),
                Self::ComputeApiBackendError => std::option::Option::Some(8),
                Self::ComputeApiNotAccessible => std::option::Option::Some(9),
                Self::CustomLoginUrlDoesNotBelongToCurrentProject => std::option::Option::Some(10),
                Self::CustomLoginUrlMalformed => std::option::Option::Some(11),
                Self::CustomLoginUrlMappedToNonRoutableAddress => std::option::Option::Some(12),
                Self::CustomLoginUrlMappedToUnreservedAddress => std::option::Option::Some(13),
                Self::CustomLoginUrlHasNonRoutableIpAddress => std::option::Option::Some(14),
                Self::CustomLoginUrlHasUnreservedIpAddress => std::option::Option::Some(15),
                Self::DuplicateScanName => std::option::Option::Some(16),
                Self::InvalidFieldValue => std::option::Option::Some(18),
                Self::FailedToAuthenticateToTarget => std::option::Option::Some(19),
                Self::FindingTypeUnspecified => std::option::Option::Some(20),
                Self::ForbiddenToScanCompute => std::option::Option::Some(21),
                Self::ForbiddenUpdateToManagedScan => std::option::Option::Some(43),
                Self::MalformedFilter => std::option::Option::Some(22),
                Self::MalformedResourceName => std::option::Option::Some(23),
                Self::ProjectInactive => std::option::Option::Some(24),
                Self::RequiredField => std::option::Option::Some(25),
                Self::ResourceNameInconsistent => std::option::Option::Some(26),
                Self::ScanAlreadyRunning => std::option::Option::Some(27),
                Self::ScanNotRunning => std::option::Option::Some(28),
                Self::SeedUrlDoesNotBelongToCurrentProject => std::option::Option::Some(29),
                Self::SeedUrlMalformed => std::option::Option::Some(30),
                Self::SeedUrlMappedToNonRoutableAddress => std::option::Option::Some(31),
                Self::SeedUrlMappedToUnreservedAddress => std::option::Option::Some(32),
                Self::SeedUrlHasNonRoutableIpAddress => std::option::Option::Some(33),
                Self::SeedUrlHasUnreservedIpAddress => std::option::Option::Some(35),
                Self::ServiceAccountNotConfigured => std::option::Option::Some(36),
                Self::TooManyScans => std::option::Option::Some(37),
                Self::UnableToResolveProjectInfo => std::option::Option::Some(38),
                Self::UnsupportedBlacklistPatternFormat => std::option::Option::Some(39),
                Self::UnsupportedFilter => std::option::Option::Some(40),
                Self::UnsupportedFindingType => std::option::Option::Some(41),
                Self::UnsupportedUrlScheme => std::option::Option::Some(42),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CODE_UNSPECIFIED"),
                Self::Ok => std::option::Option::Some("OK"),
                Self::InternalError => std::option::Option::Some("INTERNAL_ERROR"),
                Self::AppengineApiBackendError => {
                    std::option::Option::Some("APPENGINE_API_BACKEND_ERROR")
                }
                Self::AppengineApiNotAccessible => {
                    std::option::Option::Some("APPENGINE_API_NOT_ACCESSIBLE")
                }
                Self::AppengineDefaultHostMissing => {
                    std::option::Option::Some("APPENGINE_DEFAULT_HOST_MISSING")
                }
                Self::CannotUseGoogleComAccount => {
                    std::option::Option::Some("CANNOT_USE_GOOGLE_COM_ACCOUNT")
                }
                Self::CannotUseOwnerAccount => {
                    std::option::Option::Some("CANNOT_USE_OWNER_ACCOUNT")
                }
                Self::ComputeApiBackendError => {
                    std::option::Option::Some("COMPUTE_API_BACKEND_ERROR")
                }
                Self::ComputeApiNotAccessible => {
                    std::option::Option::Some("COMPUTE_API_NOT_ACCESSIBLE")
                }
                Self::CustomLoginUrlDoesNotBelongToCurrentProject => {
                    std::option::Option::Some("CUSTOM_LOGIN_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT")
                }
                Self::CustomLoginUrlMalformed => {
                    std::option::Option::Some("CUSTOM_LOGIN_URL_MALFORMED")
                }
                Self::CustomLoginUrlMappedToNonRoutableAddress => {
                    std::option::Option::Some("CUSTOM_LOGIN_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS")
                }
                Self::CustomLoginUrlMappedToUnreservedAddress => {
                    std::option::Option::Some("CUSTOM_LOGIN_URL_MAPPED_TO_UNRESERVED_ADDRESS")
                }
                Self::CustomLoginUrlHasNonRoutableIpAddress => {
                    std::option::Option::Some("CUSTOM_LOGIN_URL_HAS_NON_ROUTABLE_IP_ADDRESS")
                }
                Self::CustomLoginUrlHasUnreservedIpAddress => {
                    std::option::Option::Some("CUSTOM_LOGIN_URL_HAS_UNRESERVED_IP_ADDRESS")
                }
                Self::DuplicateScanName => std::option::Option::Some("DUPLICATE_SCAN_NAME"),
                Self::InvalidFieldValue => std::option::Option::Some("INVALID_FIELD_VALUE"),
                Self::FailedToAuthenticateToTarget => {
                    std::option::Option::Some("FAILED_TO_AUTHENTICATE_TO_TARGET")
                }
                Self::FindingTypeUnspecified => {
                    std::option::Option::Some("FINDING_TYPE_UNSPECIFIED")
                }
                Self::ForbiddenToScanCompute => {
                    std::option::Option::Some("FORBIDDEN_TO_SCAN_COMPUTE")
                }
                Self::ForbiddenUpdateToManagedScan => {
                    std::option::Option::Some("FORBIDDEN_UPDATE_TO_MANAGED_SCAN")
                }
                Self::MalformedFilter => std::option::Option::Some("MALFORMED_FILTER"),
                Self::MalformedResourceName => std::option::Option::Some("MALFORMED_RESOURCE_NAME"),
                Self::ProjectInactive => std::option::Option::Some("PROJECT_INACTIVE"),
                Self::RequiredField => std::option::Option::Some("REQUIRED_FIELD"),
                Self::ResourceNameInconsistent => {
                    std::option::Option::Some("RESOURCE_NAME_INCONSISTENT")
                }
                Self::ScanAlreadyRunning => std::option::Option::Some("SCAN_ALREADY_RUNNING"),
                Self::ScanNotRunning => std::option::Option::Some("SCAN_NOT_RUNNING"),
                Self::SeedUrlDoesNotBelongToCurrentProject => {
                    std::option::Option::Some("SEED_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT")
                }
                Self::SeedUrlMalformed => std::option::Option::Some("SEED_URL_MALFORMED"),
                Self::SeedUrlMappedToNonRoutableAddress => {
                    std::option::Option::Some("SEED_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS")
                }
                Self::SeedUrlMappedToUnreservedAddress => {
                    std::option::Option::Some("SEED_URL_MAPPED_TO_UNRESERVED_ADDRESS")
                }
                Self::SeedUrlHasNonRoutableIpAddress => {
                    std::option::Option::Some("SEED_URL_HAS_NON_ROUTABLE_IP_ADDRESS")
                }
                Self::SeedUrlHasUnreservedIpAddress => {
                    std::option::Option::Some("SEED_URL_HAS_UNRESERVED_IP_ADDRESS")
                }
                Self::ServiceAccountNotConfigured => {
                    std::option::Option::Some("SERVICE_ACCOUNT_NOT_CONFIGURED")
                }
                Self::TooManyScans => std::option::Option::Some("TOO_MANY_SCANS"),
                Self::UnableToResolveProjectInfo => {
                    std::option::Option::Some("UNABLE_TO_RESOLVE_PROJECT_INFO")
                }
                Self::UnsupportedBlacklistPatternFormat => {
                    std::option::Option::Some("UNSUPPORTED_BLACKLIST_PATTERN_FORMAT")
                }
                Self::UnsupportedFilter => std::option::Option::Some("UNSUPPORTED_FILTER"),
                Self::UnsupportedFindingType => {
                    std::option::Option::Some("UNSUPPORTED_FINDING_TYPE")
                }
                Self::UnsupportedUrlScheme => std::option::Option::Some("UNSUPPORTED_URL_SCHEME"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Code {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Ok,
                1 => Self::InternalError,
                2 => Self::AppengineApiBackendError,
                3 => Self::AppengineApiNotAccessible,
                4 => Self::AppengineDefaultHostMissing,
                6 => Self::CannotUseGoogleComAccount,
                7 => Self::CannotUseOwnerAccount,
                8 => Self::ComputeApiBackendError,
                9 => Self::ComputeApiNotAccessible,
                10 => Self::CustomLoginUrlDoesNotBelongToCurrentProject,
                11 => Self::CustomLoginUrlMalformed,
                12 => Self::CustomLoginUrlMappedToNonRoutableAddress,
                13 => Self::CustomLoginUrlMappedToUnreservedAddress,
                14 => Self::CustomLoginUrlHasNonRoutableIpAddress,
                15 => Self::CustomLoginUrlHasUnreservedIpAddress,
                16 => Self::DuplicateScanName,
                18 => Self::InvalidFieldValue,
                19 => Self::FailedToAuthenticateToTarget,
                20 => Self::FindingTypeUnspecified,
                21 => Self::ForbiddenToScanCompute,
                22 => Self::MalformedFilter,
                23 => Self::MalformedResourceName,
                24 => Self::ProjectInactive,
                25 => Self::RequiredField,
                26 => Self::ResourceNameInconsistent,
                27 => Self::ScanAlreadyRunning,
                28 => Self::ScanNotRunning,
                29 => Self::SeedUrlDoesNotBelongToCurrentProject,
                30 => Self::SeedUrlMalformed,
                31 => Self::SeedUrlMappedToNonRoutableAddress,
                32 => Self::SeedUrlMappedToUnreservedAddress,
                33 => Self::SeedUrlHasNonRoutableIpAddress,
                35 => Self::SeedUrlHasUnreservedIpAddress,
                36 => Self::ServiceAccountNotConfigured,
                37 => Self::TooManyScans,
                38 => Self::UnableToResolveProjectInfo,
                39 => Self::UnsupportedBlacklistPatternFormat,
                40 => Self::UnsupportedFilter,
                41 => Self::UnsupportedFindingType,
                42 => Self::UnsupportedUrlScheme,
                43 => Self::ForbiddenUpdateToManagedScan,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Code {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CODE_UNSPECIFIED" => Self::Unspecified,
                "OK" => Self::Ok,
                "INTERNAL_ERROR" => Self::InternalError,
                "APPENGINE_API_BACKEND_ERROR" => Self::AppengineApiBackendError,
                "APPENGINE_API_NOT_ACCESSIBLE" => Self::AppengineApiNotAccessible,
                "APPENGINE_DEFAULT_HOST_MISSING" => Self::AppengineDefaultHostMissing,
                "CANNOT_USE_GOOGLE_COM_ACCOUNT" => Self::CannotUseGoogleComAccount,
                "CANNOT_USE_OWNER_ACCOUNT" => Self::CannotUseOwnerAccount,
                "COMPUTE_API_BACKEND_ERROR" => Self::ComputeApiBackendError,
                "COMPUTE_API_NOT_ACCESSIBLE" => Self::ComputeApiNotAccessible,
                "CUSTOM_LOGIN_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT" => {
                    Self::CustomLoginUrlDoesNotBelongToCurrentProject
                }
                "CUSTOM_LOGIN_URL_MALFORMED" => Self::CustomLoginUrlMalformed,
                "CUSTOM_LOGIN_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS" => {
                    Self::CustomLoginUrlMappedToNonRoutableAddress
                }
                "CUSTOM_LOGIN_URL_MAPPED_TO_UNRESERVED_ADDRESS" => {
                    Self::CustomLoginUrlMappedToUnreservedAddress
                }
                "CUSTOM_LOGIN_URL_HAS_NON_ROUTABLE_IP_ADDRESS" => {
                    Self::CustomLoginUrlHasNonRoutableIpAddress
                }
                "CUSTOM_LOGIN_URL_HAS_UNRESERVED_IP_ADDRESS" => {
                    Self::CustomLoginUrlHasUnreservedIpAddress
                }
                "DUPLICATE_SCAN_NAME" => Self::DuplicateScanName,
                "INVALID_FIELD_VALUE" => Self::InvalidFieldValue,
                "FAILED_TO_AUTHENTICATE_TO_TARGET" => Self::FailedToAuthenticateToTarget,
                "FINDING_TYPE_UNSPECIFIED" => Self::FindingTypeUnspecified,
                "FORBIDDEN_TO_SCAN_COMPUTE" => Self::ForbiddenToScanCompute,
                "FORBIDDEN_UPDATE_TO_MANAGED_SCAN" => Self::ForbiddenUpdateToManagedScan,
                "MALFORMED_FILTER" => Self::MalformedFilter,
                "MALFORMED_RESOURCE_NAME" => Self::MalformedResourceName,
                "PROJECT_INACTIVE" => Self::ProjectInactive,
                "REQUIRED_FIELD" => Self::RequiredField,
                "RESOURCE_NAME_INCONSISTENT" => Self::ResourceNameInconsistent,
                "SCAN_ALREADY_RUNNING" => Self::ScanAlreadyRunning,
                "SCAN_NOT_RUNNING" => Self::ScanNotRunning,
                "SEED_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT" => {
                    Self::SeedUrlDoesNotBelongToCurrentProject
                }
                "SEED_URL_MALFORMED" => Self::SeedUrlMalformed,
                "SEED_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS" => {
                    Self::SeedUrlMappedToNonRoutableAddress
                }
                "SEED_URL_MAPPED_TO_UNRESERVED_ADDRESS" => Self::SeedUrlMappedToUnreservedAddress,
                "SEED_URL_HAS_NON_ROUTABLE_IP_ADDRESS" => Self::SeedUrlHasNonRoutableIpAddress,
                "SEED_URL_HAS_UNRESERVED_IP_ADDRESS" => Self::SeedUrlHasUnreservedIpAddress,
                "SERVICE_ACCOUNT_NOT_CONFIGURED" => Self::ServiceAccountNotConfigured,
                "TOO_MANY_SCANS" => Self::TooManyScans,
                "UNABLE_TO_RESOLVE_PROJECT_INFO" => Self::UnableToResolveProjectInfo,
                "UNSUPPORTED_BLACKLIST_PATTERN_FORMAT" => Self::UnsupportedBlacklistPatternFormat,
                "UNSUPPORTED_FILTER" => Self::UnsupportedFilter,
                "UNSUPPORTED_FINDING_TYPE" => Self::UnsupportedFindingType,
                "UNSUPPORTED_URL_SCHEME" => Self::UnsupportedUrlScheme,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Code {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ok => serializer.serialize_i32(0),
                Self::InternalError => serializer.serialize_i32(1),
                Self::AppengineApiBackendError => serializer.serialize_i32(2),
                Self::AppengineApiNotAccessible => serializer.serialize_i32(3),
                Self::AppengineDefaultHostMissing => serializer.serialize_i32(4),
                Self::CannotUseGoogleComAccount => serializer.serialize_i32(6),
                Self::CannotUseOwnerAccount => serializer.serialize_i32(7),
                Self::ComputeApiBackendError => serializer.serialize_i32(8),
                Self::ComputeApiNotAccessible => serializer.serialize_i32(9),
                Self::CustomLoginUrlDoesNotBelongToCurrentProject => serializer.serialize_i32(10),
                Self::CustomLoginUrlMalformed => serializer.serialize_i32(11),
                Self::CustomLoginUrlMappedToNonRoutableAddress => serializer.serialize_i32(12),
                Self::CustomLoginUrlMappedToUnreservedAddress => serializer.serialize_i32(13),
                Self::CustomLoginUrlHasNonRoutableIpAddress => serializer.serialize_i32(14),
                Self::CustomLoginUrlHasUnreservedIpAddress => serializer.serialize_i32(15),
                Self::DuplicateScanName => serializer.serialize_i32(16),
                Self::InvalidFieldValue => serializer.serialize_i32(18),
                Self::FailedToAuthenticateToTarget => serializer.serialize_i32(19),
                Self::FindingTypeUnspecified => serializer.serialize_i32(20),
                Self::ForbiddenToScanCompute => serializer.serialize_i32(21),
                Self::ForbiddenUpdateToManagedScan => serializer.serialize_i32(43),
                Self::MalformedFilter => serializer.serialize_i32(22),
                Self::MalformedResourceName => serializer.serialize_i32(23),
                Self::ProjectInactive => serializer.serialize_i32(24),
                Self::RequiredField => serializer.serialize_i32(25),
                Self::ResourceNameInconsistent => serializer.serialize_i32(26),
                Self::ScanAlreadyRunning => serializer.serialize_i32(27),
                Self::ScanNotRunning => serializer.serialize_i32(28),
                Self::SeedUrlDoesNotBelongToCurrentProject => serializer.serialize_i32(29),
                Self::SeedUrlMalformed => serializer.serialize_i32(30),
                Self::SeedUrlMappedToNonRoutableAddress => serializer.serialize_i32(31),
                Self::SeedUrlMappedToUnreservedAddress => serializer.serialize_i32(32),
                Self::SeedUrlHasNonRoutableIpAddress => serializer.serialize_i32(33),
                Self::SeedUrlHasUnreservedIpAddress => serializer.serialize_i32(35),
                Self::ServiceAccountNotConfigured => serializer.serialize_i32(36),
                Self::TooManyScans => serializer.serialize_i32(37),
                Self::UnableToResolveProjectInfo => serializer.serialize_i32(38),
                Self::UnsupportedBlacklistPatternFormat => serializer.serialize_i32(39),
                Self::UnsupportedFilter => serializer.serialize_i32(40),
                Self::UnsupportedFindingType => serializer.serialize_i32(41),
                Self::UnsupportedUrlScheme => serializer.serialize_i32(42),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Code {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                ".google.cloud.websecurityscanner.v1.ScanConfigError.Code",
            ))
        }
    }
}

/// A ScanRun is a output-only resource representing an actual run of the scan.
/// Next id: 12
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScanRun {
    /// Output only. The resource name of the ScanRun. The name follows the format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    /// The ScanRun IDs are generated by the system.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The execution state of the ScanRun.
    pub execution_state: crate::model::scan_run::ExecutionState,

    /// Output only. The result state of the ScanRun. This field is only available after the
    /// execution state reaches "FINISHED".
    pub result_state: crate::model::scan_run::ResultState,

    /// Output only. The time at which the ScanRun started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the ScanRun reached termination state - that the ScanRun
    /// is either finished or stopped by user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The number of URLs crawled during this ScanRun. If the scan is in progress,
    /// the value represents the number of URLs crawled up to now.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub urls_crawled_count: i64,

    /// Output only. The number of URLs tested during this ScanRun. If the scan is in progress,
    /// the value represents the number of URLs tested up to now. The number of
    /// URLs tested is usually larger than the number URLS crawled because
    /// typically a crawled URL is tested with multiple test payloads.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub urls_tested_count: i64,

    /// Output only. Whether the scan run has found any vulnerabilities.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub has_vulnerabilities: bool,

    /// Output only. The percentage of total completion ranging from 0 to 100.
    /// If the scan is in queue, the value is 0.
    /// If the scan is running, the value ranges from 0 to 100.
    /// If the scan is finished, the value is 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub progress_percent: i32,

    /// Output only. If result_state is an ERROR, this field provides the primary reason for
    /// scan's termination and more details, if such are available.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_trace: std::option::Option<crate::model::ScanRunErrorTrace>,

    /// Output only. A list of warnings, if such are encountered during this scan run.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warning_traces: std::vec::Vec<crate::model::ScanRunWarningTrace>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ScanRun::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [execution_state][crate::model::ScanRun::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::scan_run::ExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [result_state][crate::model::ScanRun::result_state].
    pub fn set_result_state<T: std::convert::Into<crate::model::scan_run::ResultState>>(
        mut self,
        v: T,
    ) -> Self {
        self.result_state = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ScanRun::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::ScanRun::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [urls_crawled_count][crate::model::ScanRun::urls_crawled_count].
    pub fn set_urls_crawled_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.urls_crawled_count = v.into();
        self
    }

    /// Sets the value of [urls_tested_count][crate::model::ScanRun::urls_tested_count].
    pub fn set_urls_tested_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.urls_tested_count = v.into();
        self
    }

    /// Sets the value of [has_vulnerabilities][crate::model::ScanRun::has_vulnerabilities].
    pub fn set_has_vulnerabilities<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_vulnerabilities = v.into();
        self
    }

    /// Sets the value of [progress_percent][crate::model::ScanRun::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [error_trace][crate::model::ScanRun::error_trace].
    pub fn set_error_trace<
        T: std::convert::Into<std::option::Option<crate::model::ScanRunErrorTrace>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.error_trace = v.into();
        self
    }

    /// Sets the value of [warning_traces][crate::model::ScanRun::warning_traces].
    pub fn set_warning_traces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScanRunWarningTrace>,
    {
        use std::iter::Iterator;
        self.warning_traces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ScanRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanRun"
    }
}

/// Defines additional types related to [ScanRun].
pub mod scan_run {
    #[allow(unused_imports)]
    use super::*;

    /// Types of ScanRun execution state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExecutionState {
        /// Represents an invalid state caused by internal server error. This value
        /// should never be returned.
        Unspecified,
        /// The scan is waiting in the queue.
        Queued,
        /// The scan is in progress.
        Scanning,
        /// The scan is either finished or stopped by user.
        Finished,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExecutionState::value] or
        /// [ExecutionState::name].
        UnknownValue(execution_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod execution_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExecutionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Queued => std::option::Option::Some(1),
                Self::Scanning => std::option::Option::Some(2),
                Self::Finished => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EXECUTION_STATE_UNSPECIFIED"),
                Self::Queued => std::option::Option::Some("QUEUED"),
                Self::Scanning => std::option::Option::Some("SCANNING"),
                Self::Finished => std::option::Option::Some("FINISHED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExecutionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExecutionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExecutionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Queued,
                2 => Self::Scanning,
                3 => Self::Finished,
                _ => Self::UnknownValue(execution_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExecutionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXECUTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "QUEUED" => Self::Queued,
                "SCANNING" => Self::Scanning,
                "FINISHED" => Self::Finished,
                _ => Self::UnknownValue(execution_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExecutionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Queued => serializer.serialize_i32(1),
                Self::Scanning => serializer.serialize_i32(2),
                Self::Finished => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExecutionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExecutionState>::new(
                ".google.cloud.websecurityscanner.v1.ScanRun.ExecutionState",
            ))
        }
    }

    /// Types of ScanRun result state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResultState {
        /// Default value. This value is returned when the ScanRun is not yet
        /// finished.
        Unspecified,
        /// The scan finished without errors.
        Success,
        /// The scan finished with errors.
        Error,
        /// The scan was terminated by user.
        Killed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ResultState::value] or
        /// [ResultState::name].
        UnknownValue(result_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod result_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ResultState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Success => std::option::Option::Some(1),
                Self::Error => std::option::Option::Some(2),
                Self::Killed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESULT_STATE_UNSPECIFIED"),
                Self::Success => std::option::Option::Some("SUCCESS"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Killed => std::option::Option::Some("KILLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ResultState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ResultState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ResultState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Success,
                2 => Self::Error,
                3 => Self::Killed,
                _ => Self::UnknownValue(result_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ResultState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESULT_STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCESS" => Self::Success,
                "ERROR" => Self::Error,
                "KILLED" => Self::Killed,
                _ => Self::UnknownValue(result_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ResultState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Success => serializer.serialize_i32(1),
                Self::Error => serializer.serialize_i32(2),
                Self::Killed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ResultState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResultState>::new(
                ".google.cloud.websecurityscanner.v1.ScanRun.ResultState",
            ))
        }
    }
}

/// Output only.
/// Defines an error trace message for a ScanRun.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScanRunErrorTrace {
    /// Output only. Indicates the error reason code.
    pub code: crate::model::scan_run_error_trace::Code,

    /// Output only. If the scan encounters SCAN_CONFIG_ISSUE error, this field has the error
    /// message encountered during scan configuration validation that is performed
    /// before each scan run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scan_config_error: std::option::Option<crate::model::ScanConfigError>,

    /// Output only. If the scan encounters TOO_MANY_HTTP_ERRORS, this field indicates the most
    /// common HTTP error code, if such is available. For example, if this code is
    /// 404, the scan has encountered too many NOT_FOUND responses.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub most_common_http_error_code: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanRunErrorTrace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::ScanRunErrorTrace::code].
    pub fn set_code<T: std::convert::Into<crate::model::scan_run_error_trace::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [scan_config_error][crate::model::ScanRunErrorTrace::scan_config_error].
    pub fn set_scan_config_error<
        T: std::convert::Into<std::option::Option<crate::model::ScanConfigError>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scan_config_error = v.into();
        self
    }

    /// Sets the value of [most_common_http_error_code][crate::model::ScanRunErrorTrace::most_common_http_error_code].
    pub fn set_most_common_http_error_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.most_common_http_error_code = v.into();
        self
    }
}

impl wkt::message::Message for ScanRunErrorTrace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanRunErrorTrace"
    }
}

/// Defines additional types related to [ScanRunErrorTrace].
pub mod scan_run_error_trace {
    #[allow(unused_imports)]
    use super::*;

    /// Output only.
    /// Defines an error reason code.
    /// Next id: 8
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Code {
        /// Default value is never used.
        Unspecified,
        /// Indicates that the scan run failed due to an internal server error.
        InternalError,
        /// Indicates a scan configuration error, usually due to outdated ScanConfig
        /// settings, such as starting_urls or the DNS configuration.
        ScanConfigIssue,
        /// Indicates an authentication error, usually due to outdated ScanConfig
        /// authentication settings.
        AuthenticationConfigIssue,
        /// Indicates a scan operation timeout, usually caused by a very large site.
        TimedOutWhileScanning,
        /// Indicates that a scan encountered excessive redirects, either to
        /// authentication or some other page outside of the scan scope.
        TooManyRedirects,
        /// Indicates that a scan encountered numerous errors from the web site
        /// pages. When available, most_common_http_error_code field indicates the
        /// most common HTTP error code encountered during the scan.
        TooManyHttpErrors,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Code::value] or
        /// [Code::name].
        UnknownValue(code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Code {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InternalError => std::option::Option::Some(1),
                Self::ScanConfigIssue => std::option::Option::Some(2),
                Self::AuthenticationConfigIssue => std::option::Option::Some(3),
                Self::TimedOutWhileScanning => std::option::Option::Some(4),
                Self::TooManyRedirects => std::option::Option::Some(5),
                Self::TooManyHttpErrors => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CODE_UNSPECIFIED"),
                Self::InternalError => std::option::Option::Some("INTERNAL_ERROR"),
                Self::ScanConfigIssue => std::option::Option::Some("SCAN_CONFIG_ISSUE"),
                Self::AuthenticationConfigIssue => {
                    std::option::Option::Some("AUTHENTICATION_CONFIG_ISSUE")
                }
                Self::TimedOutWhileScanning => {
                    std::option::Option::Some("TIMED_OUT_WHILE_SCANNING")
                }
                Self::TooManyRedirects => std::option::Option::Some("TOO_MANY_REDIRECTS"),
                Self::TooManyHttpErrors => std::option::Option::Some("TOO_MANY_HTTP_ERRORS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Code {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InternalError,
                2 => Self::ScanConfigIssue,
                3 => Self::AuthenticationConfigIssue,
                4 => Self::TimedOutWhileScanning,
                5 => Self::TooManyRedirects,
                6 => Self::TooManyHttpErrors,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Code {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CODE_UNSPECIFIED" => Self::Unspecified,
                "INTERNAL_ERROR" => Self::InternalError,
                "SCAN_CONFIG_ISSUE" => Self::ScanConfigIssue,
                "AUTHENTICATION_CONFIG_ISSUE" => Self::AuthenticationConfigIssue,
                "TIMED_OUT_WHILE_SCANNING" => Self::TimedOutWhileScanning,
                "TOO_MANY_REDIRECTS" => Self::TooManyRedirects,
                "TOO_MANY_HTTP_ERRORS" => Self::TooManyHttpErrors,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Code {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InternalError => serializer.serialize_i32(1),
                Self::ScanConfigIssue => serializer.serialize_i32(2),
                Self::AuthenticationConfigIssue => serializer.serialize_i32(3),
                Self::TimedOutWhileScanning => serializer.serialize_i32(4),
                Self::TooManyRedirects => serializer.serialize_i32(5),
                Self::TooManyHttpErrors => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Code {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                ".google.cloud.websecurityscanner.v1.ScanRunErrorTrace.Code",
            ))
        }
    }
}

/// A ScanRunLog is an output-only proto used for Stackdriver customer logging.
/// It is used for logs covering the start and end of scan pipelines.
/// Other than an added summary, this is a subset of the ScanRun.
/// Representation in logs is either a proto Struct, or converted to JSON.
/// Next id: 9
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScanRunLog {
    /// Human friendly message about the event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub summary: std::string::String,

    /// The resource name of the ScanRun being logged.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The execution state of the ScanRun.
    pub execution_state: crate::model::scan_run::ExecutionState,

    /// The result state of the ScanRun.
    pub result_state: crate::model::scan_run::ResultState,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub urls_crawled_count: i64,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub urls_tested_count: i64,

    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub has_findings: bool,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_trace: std::option::Option<crate::model::ScanRunErrorTrace>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanRunLog {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [summary][crate::model::ScanRunLog::summary].
    pub fn set_summary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.summary = v.into();
        self
    }

    /// Sets the value of [name][crate::model::ScanRunLog::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [execution_state][crate::model::ScanRunLog::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::scan_run::ExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [result_state][crate::model::ScanRunLog::result_state].
    pub fn set_result_state<T: std::convert::Into<crate::model::scan_run::ResultState>>(
        mut self,
        v: T,
    ) -> Self {
        self.result_state = v.into();
        self
    }

    /// Sets the value of [urls_crawled_count][crate::model::ScanRunLog::urls_crawled_count].
    pub fn set_urls_crawled_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.urls_crawled_count = v.into();
        self
    }

    /// Sets the value of [urls_tested_count][crate::model::ScanRunLog::urls_tested_count].
    pub fn set_urls_tested_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.urls_tested_count = v.into();
        self
    }

    /// Sets the value of [has_findings][crate::model::ScanRunLog::has_findings].
    pub fn set_has_findings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_findings = v.into();
        self
    }

    /// Sets the value of [error_trace][crate::model::ScanRunLog::error_trace].
    pub fn set_error_trace<
        T: std::convert::Into<std::option::Option<crate::model::ScanRunErrorTrace>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.error_trace = v.into();
        self
    }
}

impl wkt::message::Message for ScanRunLog {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanRunLog"
    }
}

/// Output only.
/// Defines a warning trace message for ScanRun. Warning traces provide customers
/// with useful information that helps make the scanning process more effective.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScanRunWarningTrace {
    /// Output only. Indicates the warning code.
    pub code: crate::model::scan_run_warning_trace::Code,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanRunWarningTrace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::ScanRunWarningTrace::code].
    pub fn set_code<T: std::convert::Into<crate::model::scan_run_warning_trace::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for ScanRunWarningTrace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanRunWarningTrace"
    }
}

/// Defines additional types related to [ScanRunWarningTrace].
pub mod scan_run_warning_trace {
    #[allow(unused_imports)]
    use super::*;

    /// Output only.
    /// Defines a warning message code.
    /// Next id: 6
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Code {
        /// Default value is never used.
        Unspecified,
        /// Indicates that a scan discovered an unexpectedly low number of URLs. This
        /// is sometimes caused by complex navigation features or by using a single
        /// URL for numerous pages.
        InsufficientCrawlResults,
        /// Indicates that a scan discovered too many URLs to test, or excessive
        /// redundant URLs.
        TooManyCrawlResults,
        /// Indicates that too many tests have been generated for the scan. Customer
        /// should try reducing the number of starting URLs, increasing the QPS rate,
        /// or narrowing down the scope of the scan using the excluded patterns.
        TooManyFuzzTasks,
        /// Indicates that a scan is blocked by IAP.
        BlockedByIap,
        /// Indicates that no seeds is found for a scan
        NoStartingUrlFoundForManagedScan,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Code::value] or
        /// [Code::name].
        UnknownValue(code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Code {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InsufficientCrawlResults => std::option::Option::Some(1),
                Self::TooManyCrawlResults => std::option::Option::Some(2),
                Self::TooManyFuzzTasks => std::option::Option::Some(3),
                Self::BlockedByIap => std::option::Option::Some(4),
                Self::NoStartingUrlFoundForManagedScan => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CODE_UNSPECIFIED"),
                Self::InsufficientCrawlResults => {
                    std::option::Option::Some("INSUFFICIENT_CRAWL_RESULTS")
                }
                Self::TooManyCrawlResults => std::option::Option::Some("TOO_MANY_CRAWL_RESULTS"),
                Self::TooManyFuzzTasks => std::option::Option::Some("TOO_MANY_FUZZ_TASKS"),
                Self::BlockedByIap => std::option::Option::Some("BLOCKED_BY_IAP"),
                Self::NoStartingUrlFoundForManagedScan => {
                    std::option::Option::Some("NO_STARTING_URL_FOUND_FOR_MANAGED_SCAN")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Code {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InsufficientCrawlResults,
                2 => Self::TooManyCrawlResults,
                3 => Self::TooManyFuzzTasks,
                4 => Self::BlockedByIap,
                5 => Self::NoStartingUrlFoundForManagedScan,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Code {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CODE_UNSPECIFIED" => Self::Unspecified,
                "INSUFFICIENT_CRAWL_RESULTS" => Self::InsufficientCrawlResults,
                "TOO_MANY_CRAWL_RESULTS" => Self::TooManyCrawlResults,
                "TOO_MANY_FUZZ_TASKS" => Self::TooManyFuzzTasks,
                "BLOCKED_BY_IAP" => Self::BlockedByIap,
                "NO_STARTING_URL_FOUND_FOR_MANAGED_SCAN" => Self::NoStartingUrlFoundForManagedScan,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Code {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InsufficientCrawlResults => serializer.serialize_i32(1),
                Self::TooManyCrawlResults => serializer.serialize_i32(2),
                Self::TooManyFuzzTasks => serializer.serialize_i32(3),
                Self::BlockedByIap => serializer.serialize_i32(4),
                Self::NoStartingUrlFoundForManagedScan => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Code {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                ".google.cloud.websecurityscanner.v1.ScanRunWarningTrace.Code",
            ))
        }
    }
}

/// Request for the `CreateScanConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateScanConfigRequest {
    /// Required. The parent resource name where the scan is created, which should be a
    /// project resource name in the format 'projects/{projectId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ScanConfig to be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scan_config: std::option::Option<crate::model::ScanConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateScanConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateScanConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [scan_config][crate::model::CreateScanConfigRequest::scan_config].
    pub fn set_scan_config<T: std::convert::Into<std::option::Option<crate::model::ScanConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scan_config = v.into();
        self
    }
}

impl wkt::message::Message for CreateScanConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.CreateScanConfigRequest"
    }
}

/// Request for the `DeleteScanConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteScanConfigRequest {
    /// Required. The resource name of the ScanConfig to be deleted. The name follows the
    /// format of 'projects/{projectId}/scanConfigs/{scanConfigId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteScanConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteScanConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteScanConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.DeleteScanConfigRequest"
    }
}

/// Request for the `GetScanConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetScanConfigRequest {
    /// Required. The resource name of the ScanConfig to be returned. The name follows the
    /// format of 'projects/{projectId}/scanConfigs/{scanConfigId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetScanConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetScanConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetScanConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.GetScanConfigRequest"
    }
}

/// Request for the `ListScanConfigs` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListScanConfigsRequest {
    /// Required. The parent resource name, which should be a project resource name in the
    /// format 'projects/{projectId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A token identifying a page of results to be returned. This should be a
    /// `next_page_token` value returned from a previous List request.
    /// If unspecified, the first page of results is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The maximum number of ScanConfigs to return, can be limited by server.
    /// If not specified or not positive, the implementation will select a
    /// reasonable value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListScanConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListScanConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListScanConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListScanConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListScanConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListScanConfigsRequest"
    }
}

/// Request for the `UpdateScanConfigRequest` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateScanConfigRequest {
    /// Required. The ScanConfig to be updated. The name field must be set to identify the
    /// resource to be updated. The values of fields not covered by the mask
    /// will be ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scan_config: std::option::Option<crate::model::ScanConfig>,

    /// Required. The update mask applies to the resource. For the `FieldMask` definition,
    /// see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateScanConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scan_config][crate::model::UpdateScanConfigRequest::scan_config].
    pub fn set_scan_config<T: std::convert::Into<std::option::Option<crate::model::ScanConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scan_config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateScanConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateScanConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.UpdateScanConfigRequest"
    }
}

/// Response for the `ListScanConfigs` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListScanConfigsResponse {
    /// The list of ScanConfigs returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub scan_configs: std::vec::Vec<crate::model::ScanConfig>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListScanConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListScanConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [scan_configs][crate::model::ListScanConfigsResponse::scan_configs].
    pub fn set_scan_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScanConfig>,
    {
        use std::iter::Iterator;
        self.scan_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListScanConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListScanConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListScanConfigsResponse {
    type PageItem = crate::model::ScanConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.scan_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `StartScanRun` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartScanRunRequest {
    /// Required. The resource name of the ScanConfig to be used. The name follows the
    /// format of 'projects/{projectId}/scanConfigs/{scanConfigId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartScanRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartScanRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartScanRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.StartScanRunRequest"
    }
}

/// Request for the `GetScanRun` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetScanRunRequest {
    /// Required. The resource name of the ScanRun to be returned. The name follows the
    /// format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetScanRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetScanRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetScanRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.GetScanRunRequest"
    }
}

/// Request for the `ListScanRuns` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListScanRunsRequest {
    /// Required. The parent resource name, which should be a scan resource name in the
    /// format 'projects/{projectId}/scanConfigs/{scanConfigId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A token identifying a page of results to be returned. This should be a
    /// `next_page_token` value returned from a previous List request.
    /// If unspecified, the first page of results is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The maximum number of ScanRuns to return, can be limited by server.
    /// If not specified or not positive, the implementation will select a
    /// reasonable value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListScanRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListScanRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListScanRunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListScanRunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListScanRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListScanRunsRequest"
    }
}

/// Response for the `ListScanRuns` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListScanRunsResponse {
    /// The list of ScanRuns returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub scan_runs: std::vec::Vec<crate::model::ScanRun>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListScanRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListScanRunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [scan_runs][crate::model::ListScanRunsResponse::scan_runs].
    pub fn set_scan_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScanRun>,
    {
        use std::iter::Iterator;
        self.scan_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListScanRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListScanRunsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListScanRunsResponse {
    type PageItem = crate::model::ScanRun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.scan_runs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `StopScanRun` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopScanRunRequest {
    /// Required. The resource name of the ScanRun to be stopped. The name follows the
    /// format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopScanRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopScanRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopScanRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.StopScanRunRequest"
    }
}

/// Request for the `ListCrawledUrls` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCrawledUrlsRequest {
    /// Required. The parent resource name, which should be a scan run resource name in the
    /// format
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A token identifying a page of results to be returned. This should be a
    /// `next_page_token` value returned from a previous List request.
    /// If unspecified, the first page of results is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The maximum number of CrawledUrls to return, can be limited by server.
    /// If not specified or not positive, the implementation will select a
    /// reasonable value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCrawledUrlsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCrawledUrlsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCrawledUrlsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCrawledUrlsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListCrawledUrlsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListCrawledUrlsRequest"
    }
}

/// Response for the `ListCrawledUrls` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCrawledUrlsResponse {
    /// The list of CrawledUrls returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub crawled_urls: std::vec::Vec<crate::model::CrawledUrl>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCrawledUrlsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCrawledUrlsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [crawled_urls][crate::model::ListCrawledUrlsResponse::crawled_urls].
    pub fn set_crawled_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CrawledUrl>,
    {
        use std::iter::Iterator;
        self.crawled_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCrawledUrlsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListCrawledUrlsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCrawledUrlsResponse {
    type PageItem = crate::model::CrawledUrl;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.crawled_urls
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `GetFinding` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFindingRequest {
    /// Required. The resource name of the Finding to be returned. The name follows the
    /// format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}/findings/{findingId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFindingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.GetFindingRequest"
    }
}

/// Request for the `ListFindings` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFindingsRequest {
    /// Required. The parent resource name, which should be a scan run resource name in the
    /// format
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The filter expression. The expression must be in the format: \<field\>
    /// \<operator\> \<value\>.
    /// Supported field: 'finding_type'.
    /// Supported operator: '='.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A token identifying a page of results to be returned. This should be a
    /// `next_page_token` value returned from a previous List request.
    /// If unspecified, the first page of results is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The maximum number of Findings to return, can be limited by server.
    /// If not specified or not positive, the implementation will select a
    /// reasonable value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFindingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFindingsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFindingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFindingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListFindingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListFindingsRequest"
    }
}

/// Response for the `ListFindings` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFindingsResponse {
    /// The list of Findings returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub findings: std::vec::Vec<crate::model::Finding>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFindingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [findings][crate::model::ListFindingsResponse::findings].
    pub fn set_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Finding>,
    {
        use std::iter::Iterator;
        self.findings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFindingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListFindingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFindingsResponse {
    type PageItem = crate::model::Finding;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.findings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `ListFindingTypeStats` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFindingTypeStatsRequest {
    /// Required. The parent resource name, which should be a scan run resource name in the
    /// format
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingTypeStatsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFindingTypeStatsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListFindingTypeStatsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListFindingTypeStatsRequest"
    }
}

/// Response for the `ListFindingTypeStats` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFindingTypeStatsResponse {
    /// The list of FindingTypeStats returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub finding_type_stats: std::vec::Vec<crate::model::FindingTypeStats>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingTypeStatsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [finding_type_stats][crate::model::ListFindingTypeStatsResponse::finding_type_stats].
    pub fn set_finding_type_stats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FindingTypeStats>,
    {
        use std::iter::Iterator;
        self.finding_type_stats = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFindingTypeStatsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListFindingTypeStatsResponse"
    }
}
