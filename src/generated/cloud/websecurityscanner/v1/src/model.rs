// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A CrawledUrl resource represents a URL that was crawled during a ScanRun. Web
/// Security Scanner Service crawls the web applications, following all links
/// within the scope of sites, to find the URLs to test against.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CrawledUrl {
    /// Output only. The http method of the request that was used to visit the URL, in
    /// uppercase.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub http_method: std::string::String,

    /// Output only. The URL that was crawled.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,

    /// Output only. The body of the request that was used to visit the URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub body: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CrawledUrl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http_method][crate::model::CrawledUrl::http_method].
    pub fn set_http_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.http_method = v.into();
        self
    }

    /// Sets the value of [url][crate::model::CrawledUrl::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [body][crate::model::CrawledUrl::body].
    pub fn set_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for CrawledUrl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.CrawledUrl"
    }
}

/// A Finding resource represents a vulnerability instance identified during a
/// ScanRun.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Finding {
    /// Output only. The resource name of the Finding. The name follows the format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanruns/{scanRunId}/findings/{findingId}'.
    /// The finding IDs are generated by the system.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The type of the Finding.
    /// Detailed and up-to-date information on findings can be found here:
    /// <https://cloud.google.com/security-command-center/docs/how-to-remediate-web-security-scanner-findings>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub finding_type: std::string::String,

    /// Output only. The severity level of the reported vulnerability.
    pub severity: crate::model::finding::Severity,

    /// Output only. The http method of the request that triggered the vulnerability, in
    /// uppercase.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub http_method: std::string::String,

    /// Output only. The URL produced by the server-side fuzzer and used in the request that
    /// triggered the vulnerability.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fuzzed_url: std::string::String,

    /// Output only. The body of the request that triggered the vulnerability.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub body: std::string::String,

    /// Output only. The description of the vulnerability.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The URL containing human-readable payload that user can leverage to
    /// reproduce the vulnerability.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reproduction_url: std::string::String,

    /// Output only. If the vulnerability was originated from nested IFrame, the immediate
    /// parent IFrame is reported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub frame_url: std::string::String,

    /// Output only. The URL where the browser lands when the vulnerability is detected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub final_url: std::string::String,

    /// Output only. The tracking ID uniquely identifies a vulnerability instance across
    /// multiple ScanRuns.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tracking_id: std::string::String,

    /// Output only. An addon containing information reported for a vulnerability with an HTML
    /// form, if any.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub form: std::option::Option<crate::model::Form>,

    /// Output only. An addon containing information about outdated libraries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub outdated_library: std::option::Option<crate::model::OutdatedLibrary>,

    /// Output only. An addon containing detailed information regarding any resource causing the
    /// vulnerability such as JavaScript sources, image, audio files, etc.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub violating_resource: std::option::Option<crate::model::ViolatingResource>,

    /// Output only. An addon containing information about vulnerable or missing HTTP headers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vulnerable_headers: std::option::Option<crate::model::VulnerableHeaders>,

    /// Output only. An addon containing information about request parameters which were found
    /// to be vulnerable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vulnerable_parameters: std::option::Option<crate::model::VulnerableParameters>,

    /// Output only. An addon containing information reported for an XSS, if any.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub xss: std::option::Option<crate::model::Xss>,

    /// Output only. An addon containing information reported for an XXE, if any.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub xxe: std::option::Option<crate::model::Xxe>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Finding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Finding::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [finding_type][crate::model::Finding::finding_type].
    pub fn set_finding_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.finding_type = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::Finding::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::finding::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [http_method][crate::model::Finding::http_method].
    pub fn set_http_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.http_method = v.into();
        self
    }

    /// Sets the value of [fuzzed_url][crate::model::Finding::fuzzed_url].
    pub fn set_fuzzed_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fuzzed_url = v.into();
        self
    }

    /// Sets the value of [body][crate::model::Finding::body].
    pub fn set_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Finding::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [reproduction_url][crate::model::Finding::reproduction_url].
    pub fn set_reproduction_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reproduction_url = v.into();
        self
    }

    /// Sets the value of [frame_url][crate::model::Finding::frame_url].
    pub fn set_frame_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.frame_url = v.into();
        self
    }

    /// Sets the value of [final_url][crate::model::Finding::final_url].
    pub fn set_final_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.final_url = v.into();
        self
    }

    /// Sets the value of [tracking_id][crate::model::Finding::tracking_id].
    pub fn set_tracking_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tracking_id = v.into();
        self
    }

    /// Sets the value of [form][crate::model::Finding::form].
    pub fn set_form<T: std::convert::Into<std::option::Option<crate::model::Form>>>(
        mut self,
        v: T,
    ) -> Self {
        self.form = v.into();
        self
    }

    /// Sets the value of [outdated_library][crate::model::Finding::outdated_library].
    pub fn set_outdated_library<
        T: std::convert::Into<std::option::Option<crate::model::OutdatedLibrary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.outdated_library = v.into();
        self
    }

    /// Sets the value of [violating_resource][crate::model::Finding::violating_resource].
    pub fn set_violating_resource<
        T: std::convert::Into<std::option::Option<crate::model::ViolatingResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.violating_resource = v.into();
        self
    }

    /// Sets the value of [vulnerable_headers][crate::model::Finding::vulnerable_headers].
    pub fn set_vulnerable_headers<
        T: std::convert::Into<std::option::Option<crate::model::VulnerableHeaders>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vulnerable_headers = v.into();
        self
    }

    /// Sets the value of [vulnerable_parameters][crate::model::Finding::vulnerable_parameters].
    pub fn set_vulnerable_parameters<
        T: std::convert::Into<std::option::Option<crate::model::VulnerableParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vulnerable_parameters = v.into();
        self
    }

    /// Sets the value of [xss][crate::model::Finding::xss].
    pub fn set_xss<T: std::convert::Into<std::option::Option<crate::model::Xss>>>(
        mut self,
        v: T,
    ) -> Self {
        self.xss = v.into();
        self
    }

    /// Sets the value of [xxe][crate::model::Finding::xxe].
    pub fn set_xxe<T: std::convert::Into<std::option::Option<crate::model::Xxe>>>(
        mut self,
        v: T,
    ) -> Self {
        self.xxe = v.into();
        self
    }
}

impl wkt::message::Message for Finding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.Finding"
    }
}

/// Defines additional types related to [Finding].
pub mod finding {
    #[allow(unused_imports)]
    use super::*;

    /// The severity level of a vulnerability.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Severity(i32);

    impl Severity {
        /// No severity specified. The default value.
        pub const SEVERITY_UNSPECIFIED: Severity = Severity::new(0);

        /// Critical severity.
        pub const CRITICAL: Severity = Severity::new(1);

        /// High severity.
        pub const HIGH: Severity = Severity::new(2);

        /// Medium severity.
        pub const MEDIUM: Severity = Severity::new(3);

        /// Low severity.
        pub const LOW: Severity = Severity::new(4);

        /// Creates a new Severity instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SEVERITY_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CRITICAL"),
                2 => std::borrow::Cow::Borrowed("HIGH"),
                3 => std::borrow::Cow::Borrowed("MEDIUM"),
                4 => std::borrow::Cow::Borrowed("LOW"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SEVERITY_UNSPECIFIED" => std::option::Option::Some(Self::SEVERITY_UNSPECIFIED),
                "CRITICAL" => std::option::Option::Some(Self::CRITICAL),
                "HIGH" => std::option::Option::Some(Self::HIGH),
                "MEDIUM" => std::option::Option::Some(Self::MEDIUM),
                "LOW" => std::option::Option::Some(Self::LOW),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// ! Information about a vulnerability with an HTML.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Form {
    /// ! The URI where to send the form when it's submitted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub action_uri: std::string::String,

    /// ! The names of form fields related to the vulnerability.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Form {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action_uri][crate::model::Form::action_uri].
    pub fn set_action_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action_uri = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::Form::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Form {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.Form"
    }
}

/// Information reported for an outdated library.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OutdatedLibrary {
    /// The name of the outdated library.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub library_name: std::string::String,

    /// The version number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// URLs to learn more information about the vulnerabilities in the library.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub learn_more_urls: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutdatedLibrary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [library_name][crate::model::OutdatedLibrary::library_name].
    pub fn set_library_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.library_name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::OutdatedLibrary::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [learn_more_urls][crate::model::OutdatedLibrary::learn_more_urls].
    pub fn set_learn_more_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.learn_more_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OutdatedLibrary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.OutdatedLibrary"
    }
}

/// Information regarding any resource causing the vulnerability such
/// as JavaScript sources, image, audio files, etc.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ViolatingResource {
    /// The MIME type of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content_type: std::string::String,

    /// URL of this violating resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ViolatingResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content_type][crate::model::ViolatingResource::content_type].
    pub fn set_content_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content_type = v.into();
        self
    }

    /// Sets the value of [resource_url][crate::model::ViolatingResource::resource_url].
    pub fn set_resource_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_url = v.into();
        self
    }
}

impl wkt::message::Message for ViolatingResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ViolatingResource"
    }
}

/// Information about vulnerable request parameters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VulnerableParameters {
    /// The vulnerable parameter names.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parameter_names: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerableParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameter_names][crate::model::VulnerableParameters::parameter_names].
    pub fn set_parameter_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameter_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VulnerableParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.VulnerableParameters"
    }
}

/// Information about vulnerable or missing HTTP Headers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VulnerableHeaders {
    /// List of vulnerable headers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub headers: std::vec::Vec<crate::model::vulnerable_headers::Header>,

    /// List of missing headers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub missing_headers: std::vec::Vec<crate::model::vulnerable_headers::Header>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerableHeaders {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [headers][crate::model::VulnerableHeaders::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerable_headers::Header>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [missing_headers][crate::model::VulnerableHeaders::missing_headers].
    pub fn set_missing_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerable_headers::Header>,
    {
        use std::iter::Iterator;
        self.missing_headers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VulnerableHeaders {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.VulnerableHeaders"
    }
}

/// Defines additional types related to [VulnerableHeaders].
pub mod vulnerable_headers {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a HTTP Header.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Header {
        /// Header name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Header value.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Header {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::vulnerable_headers::Header::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::vulnerable_headers::Header::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Header {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.websecurityscanner.v1.VulnerableHeaders.Header"
        }
    }
}

/// Information reported for an XSS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Xss {
    /// Stack traces leading to the point where the XSS occurred.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stack_traces: std::vec::Vec<std::string::String>,

    /// An error message generated by a javascript breakage.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_message: std::string::String,

    /// The attack vector of the payload triggering this XSS.
    pub attack_vector: crate::model::xss::AttackVector,

    /// The reproduction url for the seeding POST request of a Stored XSS.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub stored_xss_seeding_url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Xss {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_message][crate::model::Xss::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }

    /// Sets the value of [attack_vector][crate::model::Xss::attack_vector].
    pub fn set_attack_vector<T: std::convert::Into<crate::model::xss::AttackVector>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_vector = v.into();
        self
    }

    /// Sets the value of [stored_xss_seeding_url][crate::model::Xss::stored_xss_seeding_url].
    pub fn set_stored_xss_seeding_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.stored_xss_seeding_url = v.into();
        self
    }

    /// Sets the value of [stack_traces][crate::model::Xss::stack_traces].
    pub fn set_stack_traces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.stack_traces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Xss {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.Xss"
    }
}

/// Defines additional types related to [Xss].
pub mod xss {
    #[allow(unused_imports)]
    use super::*;

    /// Types of XSS attack vector.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AttackVector(i32);

    impl AttackVector {
        /// Unknown attack vector.
        pub const ATTACK_VECTOR_UNSPECIFIED: AttackVector = AttackVector::new(0);

        /// The attack comes from fuzzing the browser's localStorage.
        pub const LOCAL_STORAGE: AttackVector = AttackVector::new(1);

        /// The attack comes from fuzzing the browser's sessionStorage.
        pub const SESSION_STORAGE: AttackVector = AttackVector::new(2);

        /// The attack comes from fuzzing the window's name property.
        pub const WINDOW_NAME: AttackVector = AttackVector::new(3);

        /// The attack comes from fuzzing the referrer property.
        pub const REFERRER: AttackVector = AttackVector::new(4);

        /// The attack comes from fuzzing an input element.
        pub const FORM_INPUT: AttackVector = AttackVector::new(5);

        /// The attack comes from fuzzing the browser's cookies.
        pub const COOKIE: AttackVector = AttackVector::new(6);

        /// The attack comes from hijacking the post messaging mechanism.
        pub const POST_MESSAGE: AttackVector = AttackVector::new(7);

        /// The attack comes from fuzzing parameters in the url.
        pub const GET_PARAMETERS: AttackVector = AttackVector::new(8);

        /// The attack comes from fuzzing the fragment in the url.
        pub const URL_FRAGMENT: AttackVector = AttackVector::new(9);

        /// The attack comes from fuzzing the HTML comments.
        pub const HTML_COMMENT: AttackVector = AttackVector::new(10);

        /// The attack comes from fuzzing the POST parameters.
        pub const POST_PARAMETERS: AttackVector = AttackVector::new(11);

        /// The attack comes from fuzzing the protocol.
        pub const PROTOCOL: AttackVector = AttackVector::new(12);

        /// The attack comes from the server side and is stored.
        pub const STORED_XSS: AttackVector = AttackVector::new(13);

        /// The attack is a Same-Origin Method Execution attack via a GET parameter.
        pub const SAME_ORIGIN: AttackVector = AttackVector::new(14);

        /// The attack payload is received from a third-party host via a URL that is
        /// user-controllable
        pub const USER_CONTROLLABLE_URL: AttackVector = AttackVector::new(15);

        /// Creates a new AttackVector instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ATTACK_VECTOR_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("LOCAL_STORAGE"),
                2 => std::borrow::Cow::Borrowed("SESSION_STORAGE"),
                3 => std::borrow::Cow::Borrowed("WINDOW_NAME"),
                4 => std::borrow::Cow::Borrowed("REFERRER"),
                5 => std::borrow::Cow::Borrowed("FORM_INPUT"),
                6 => std::borrow::Cow::Borrowed("COOKIE"),
                7 => std::borrow::Cow::Borrowed("POST_MESSAGE"),
                8 => std::borrow::Cow::Borrowed("GET_PARAMETERS"),
                9 => std::borrow::Cow::Borrowed("URL_FRAGMENT"),
                10 => std::borrow::Cow::Borrowed("HTML_COMMENT"),
                11 => std::borrow::Cow::Borrowed("POST_PARAMETERS"),
                12 => std::borrow::Cow::Borrowed("PROTOCOL"),
                13 => std::borrow::Cow::Borrowed("STORED_XSS"),
                14 => std::borrow::Cow::Borrowed("SAME_ORIGIN"),
                15 => std::borrow::Cow::Borrowed("USER_CONTROLLABLE_URL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ATTACK_VECTOR_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ATTACK_VECTOR_UNSPECIFIED)
                }
                "LOCAL_STORAGE" => std::option::Option::Some(Self::LOCAL_STORAGE),
                "SESSION_STORAGE" => std::option::Option::Some(Self::SESSION_STORAGE),
                "WINDOW_NAME" => std::option::Option::Some(Self::WINDOW_NAME),
                "REFERRER" => std::option::Option::Some(Self::REFERRER),
                "FORM_INPUT" => std::option::Option::Some(Self::FORM_INPUT),
                "COOKIE" => std::option::Option::Some(Self::COOKIE),
                "POST_MESSAGE" => std::option::Option::Some(Self::POST_MESSAGE),
                "GET_PARAMETERS" => std::option::Option::Some(Self::GET_PARAMETERS),
                "URL_FRAGMENT" => std::option::Option::Some(Self::URL_FRAGMENT),
                "HTML_COMMENT" => std::option::Option::Some(Self::HTML_COMMENT),
                "POST_PARAMETERS" => std::option::Option::Some(Self::POST_PARAMETERS),
                "PROTOCOL" => std::option::Option::Some(Self::PROTOCOL),
                "STORED_XSS" => std::option::Option::Some(Self::STORED_XSS),
                "SAME_ORIGIN" => std::option::Option::Some(Self::SAME_ORIGIN),
                "USER_CONTROLLABLE_URL" => std::option::Option::Some(Self::USER_CONTROLLABLE_URL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for AttackVector {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for AttackVector {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Information reported for an XXE.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Xxe {
    /// The XML string that triggered the XXE vulnerability. Non-payload values
    /// might be redacted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub payload_value: std::string::String,

    /// Location within the request where the payload was placed.
    pub payload_location: crate::model::xxe::Location,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Xxe {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [payload_value][crate::model::Xxe::payload_value].
    pub fn set_payload_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload_value = v.into();
        self
    }

    /// Sets the value of [payload_location][crate::model::Xxe::payload_location].
    pub fn set_payload_location<T: std::convert::Into<crate::model::xxe::Location>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload_location = v.into();
        self
    }
}

impl wkt::message::Message for Xxe {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.Xxe"
    }
}

/// Defines additional types related to [Xxe].
pub mod xxe {
    #[allow(unused_imports)]
    use super::*;

    /// Locations within a request where XML was substituted.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Location(i32);

    impl Location {
        /// Unknown Location.
        pub const LOCATION_UNSPECIFIED: Location = Location::new(0);

        /// The XML payload replaced the complete request body.
        pub const COMPLETE_REQUEST_BODY: Location = Location::new(1);

        /// Creates a new Location instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("LOCATION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("COMPLETE_REQUEST_BODY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "LOCATION_UNSPECIFIED" => std::option::Option::Some(Self::LOCATION_UNSPECIFIED),
                "COMPLETE_REQUEST_BODY" => std::option::Option::Some(Self::COMPLETE_REQUEST_BODY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Location {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Location {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A FindingTypeStats resource represents stats regarding a specific FindingType
/// of Findings under a given ScanRun.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FindingTypeStats {
    /// Output only. The finding type associated with the stats.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub finding_type: std::string::String,

    /// Output only. The count of findings belonging to this finding type.
    pub finding_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FindingTypeStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [finding_type][crate::model::FindingTypeStats::finding_type].
    pub fn set_finding_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.finding_type = v.into();
        self
    }

    /// Sets the value of [finding_count][crate::model::FindingTypeStats::finding_count].
    pub fn set_finding_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.finding_count = v.into();
        self
    }
}

impl wkt::message::Message for FindingTypeStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.FindingTypeStats"
    }
}

/// A ScanConfig resource contains the configurations to launch a scan.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScanConfig {
    /// The resource name of the ScanConfig. The name follows the format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}'. The ScanConfig IDs are
    /// generated by the system.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user provided display name of the ScanConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The maximum QPS during scanning. A valid value ranges from 5 to 20
    /// inclusively. If the field is unspecified or its value is set 0, server will
    /// default to 15. Other values outside of [5, 20] range will be rejected with
    /// INVALID_ARGUMENT error.
    pub max_qps: i32,

    /// Required. The starting URLs from which the scanner finds site pages.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub starting_urls: std::vec::Vec<std::string::String>,

    /// The authentication configuration. If specified, service will use the
    /// authentication configuration during scanning.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authentication: std::option::Option<crate::model::scan_config::Authentication>,

    /// The user agent used during scanning.
    pub user_agent: crate::model::scan_config::UserAgent,

    /// The excluded URL patterns as described in
    /// <https://cloud.google.com/security-command-center/docs/how-to-use-web-security-scanner#excluding_urls>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blacklist_patterns: std::vec::Vec<std::string::String>,

    /// The schedule of the ScanConfig.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schedule: std::option::Option<crate::model::scan_config::Schedule>,

    /// Controls export of scan configurations and results to Security
    /// Command Center.
    pub export_to_security_command_center: crate::model::scan_config::ExportToSecurityCommandCenter,

    /// The risk level selected for the scan
    pub risk_level: crate::model::scan_config::RiskLevel,

    /// Whether the scan config is managed by Web Security Scanner, output
    /// only.
    pub managed_scan: bool,

    /// Whether the scan configuration has enabled static IP address scan feature.
    /// If enabled, the scanner will access applications from static IP addresses.
    pub static_ip_scan: bool,

    /// Whether to keep scanning even if most requests return HTTP error codes.
    pub ignore_http_status_errors: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ScanConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ScanConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [max_qps][crate::model::ScanConfig::max_qps].
    pub fn set_max_qps<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_qps = v.into();
        self
    }

    /// Sets the value of [authentication][crate::model::ScanConfig::authentication].
    pub fn set_authentication<
        T: std::convert::Into<std::option::Option<crate::model::scan_config::Authentication>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication = v.into();
        self
    }

    /// Sets the value of [user_agent][crate::model::ScanConfig::user_agent].
    pub fn set_user_agent<T: std::convert::Into<crate::model::scan_config::UserAgent>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_agent = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::ScanConfig::schedule].
    pub fn set_schedule<
        T: std::convert::Into<std::option::Option<crate::model::scan_config::Schedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// Sets the value of [export_to_security_command_center][crate::model::ScanConfig::export_to_security_command_center].
    pub fn set_export_to_security_command_center<
        T: std::convert::Into<crate::model::scan_config::ExportToSecurityCommandCenter>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.export_to_security_command_center = v.into();
        self
    }

    /// Sets the value of [risk_level][crate::model::ScanConfig::risk_level].
    pub fn set_risk_level<T: std::convert::Into<crate::model::scan_config::RiskLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.risk_level = v.into();
        self
    }

    /// Sets the value of [managed_scan][crate::model::ScanConfig::managed_scan].
    pub fn set_managed_scan<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.managed_scan = v.into();
        self
    }

    /// Sets the value of [static_ip_scan][crate::model::ScanConfig::static_ip_scan].
    pub fn set_static_ip_scan<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.static_ip_scan = v.into();
        self
    }

    /// Sets the value of [ignore_http_status_errors][crate::model::ScanConfig::ignore_http_status_errors].
    pub fn set_ignore_http_status_errors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_http_status_errors = v.into();
        self
    }

    /// Sets the value of [starting_urls][crate::model::ScanConfig::starting_urls].
    pub fn set_starting_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.starting_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [blacklist_patterns][crate::model::ScanConfig::blacklist_patterns].
    pub fn set_blacklist_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.blacklist_patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ScanConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig"
    }
}

/// Defines additional types related to [ScanConfig].
pub mod scan_config {
    #[allow(unused_imports)]
    use super::*;

    /// Scan authentication configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Authentication {
        /// Required.
        /// Authentication configuration
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub authentication:
            std::option::Option<crate::model::scan_config::authentication::Authentication>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Authentication {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [authentication][crate::model::scan_config::Authentication::authentication].
        ///
        /// Note that all the setters affecting `authentication` are mutually
        /// exclusive.
        pub fn set_authentication<
            T: std::convert::Into<
                    std::option::Option<crate::model::scan_config::authentication::Authentication>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication = v.into();
            self
        }

        /// The value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// if it holds a `GoogleAccount`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_google_account(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::scan_config::authentication::GoogleAccount>,
        > {
            #[allow(unreachable_patterns)]
            self.authentication.as_ref().and_then(|v| match v {
                crate::model::scan_config::authentication::Authentication::GoogleAccount(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// if it holds a `CustomAccount`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_custom_account(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::scan_config::authentication::CustomAccount>,
        > {
            #[allow(unreachable_patterns)]
            self.authentication.as_ref().and_then(|v| match v {
                crate::model::scan_config::authentication::Authentication::CustomAccount(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// if it holds a `IapCredential`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_iap_credential(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::scan_config::authentication::IapCredential>,
        > {
            #[allow(unreachable_patterns)]
            self.authentication.as_ref().and_then(|v| match v {
                crate::model::scan_config::authentication::Authentication::IapCredential(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// to hold a `GoogleAccount`.
        ///
        /// Note that all the setters affecting `authentication` are
        /// mutually exclusive.
        pub fn set_google_account<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::scan_config::authentication::GoogleAccount>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication = std::option::Option::Some(
                crate::model::scan_config::authentication::Authentication::GoogleAccount(v.into()),
            );
            self
        }

        /// Sets the value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// to hold a `CustomAccount`.
        ///
        /// Note that all the setters affecting `authentication` are
        /// mutually exclusive.
        pub fn set_custom_account<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::scan_config::authentication::CustomAccount>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication = std::option::Option::Some(
                crate::model::scan_config::authentication::Authentication::CustomAccount(v.into()),
            );
            self
        }

        /// Sets the value of [authentication][crate::model::scan_config::Authentication::authentication]
        /// to hold a `IapCredential`.
        ///
        /// Note that all the setters affecting `authentication` are
        /// mutually exclusive.
        pub fn set_iap_credential<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::scan_config::authentication::IapCredential>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication = std::option::Option::Some(
                crate::model::scan_config::authentication::Authentication::IapCredential(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Authentication {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication"
        }
    }

    /// Defines additional types related to [Authentication].
    pub mod authentication {
        #[allow(unused_imports)]
        use super::*;

        /// Describes authentication configuration that uses a Google account.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct GoogleAccount {
            /// Required. The user name of the Google account.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub username: std::string::String,

            /// Required. Input only. The password of the Google account. The credential is stored encrypted
            /// and not returned in any response nor included in audit logs.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub password: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl GoogleAccount {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [username][crate::model::scan_config::authentication::GoogleAccount::username].
            pub fn set_username<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.username = v.into();
                self
            }

            /// Sets the value of [password][crate::model::scan_config::authentication::GoogleAccount::password].
            pub fn set_password<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.password = v.into();
                self
            }
        }

        impl wkt::message::Message for GoogleAccount {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication.GoogleAccount"
            }
        }

        /// Describes authentication configuration that uses a custom account.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CustomAccount {
            /// Required. The user name of the custom account.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub username: std::string::String,

            /// Required. Input only. The password of the custom account. The credential is stored encrypted
            /// and not returned in any response nor included in audit logs.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub password: std::string::String,

            /// Required. The login form URL of the website.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub login_url: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomAccount {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [username][crate::model::scan_config::authentication::CustomAccount::username].
            pub fn set_username<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.username = v.into();
                self
            }

            /// Sets the value of [password][crate::model::scan_config::authentication::CustomAccount::password].
            pub fn set_password<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.password = v.into();
                self
            }

            /// Sets the value of [login_url][crate::model::scan_config::authentication::CustomAccount::login_url].
            pub fn set_login_url<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.login_url = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomAccount {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication.CustomAccount"
            }
        }

        /// Describes authentication configuration for Identity-Aware-Proxy (IAP).
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct IapCredential {
            /// Identity-Aware-Proxy (IAP) Authentication Configuration
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub iap_credentials: std::option::Option<
                crate::model::scan_config::authentication::iap_credential::IapCredentials,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl IapCredential {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [iap_credentials][crate::model::scan_config::authentication::IapCredential::iap_credentials].
            ///
            /// Note that all the setters affecting `iap_credentials` are mutually
            /// exclusive.
            pub fn set_iap_credentials<T: std::convert::Into<std::option::Option<crate::model::scan_config::authentication::iap_credential::IapCredentials>>>(mut self, v: T) -> Self
            {
                self.iap_credentials = v.into();
                self
            }

            /// The value of [iap_credentials][crate::model::scan_config::authentication::IapCredential::iap_credentials]
            /// if it holds a `IapTestServiceAccountInfo`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_iap_test_service_account_info(&self) -> std::option::Option<&std::boxed::Box<crate::model::scan_config::authentication::iap_credential::IapTestServiceAccountInfo>>{
                #[allow(unreachable_patterns)]
                self.iap_credentials.as_ref().and_then(|v| match v {
                    crate::model::scan_config::authentication::iap_credential::IapCredentials::IapTestServiceAccountInfo(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [iap_credentials][crate::model::scan_config::authentication::IapCredential::iap_credentials]
            /// to hold a `IapTestServiceAccountInfo`.
            ///
            /// Note that all the setters affecting `iap_credentials` are
            /// mutually exclusive.
            pub fn set_iap_test_service_account_info<T: std::convert::Into<std::boxed::Box<crate::model::scan_config::authentication::iap_credential::IapTestServiceAccountInfo>>>(mut self, v: T) -> Self{
                self.iap_credentials = std::option::Option::Some(
                    crate::model::scan_config::authentication::iap_credential::IapCredentials::IapTestServiceAccountInfo(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for IapCredential {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication.IapCredential"
            }
        }

        /// Defines additional types related to [IapCredential].
        pub mod iap_credential {
            #[allow(unused_imports)]
            use super::*;

            /// Describes authentication configuration when Web-Security-Scanner
            /// service account is added in Identity-Aware-Proxy (IAP) access policies.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct IapTestServiceAccountInfo {
                /// Required. Describes OAuth2 client id of resources protected by
                /// Identity-Aware-Proxy (IAP).
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub target_audience_client_id: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl IapTestServiceAccountInfo {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [target_audience_client_id][crate::model::scan_config::authentication::iap_credential::IapTestServiceAccountInfo::target_audience_client_id].
                pub fn set_target_audience_client_id<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.target_audience_client_id = v.into();
                    self
                }
            }

            impl wkt::message::Message for IapTestServiceAccountInfo {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Authentication.IapCredential.IapTestServiceAccountInfo"
                }
            }

            /// Identity-Aware-Proxy (IAP) Authentication Configuration
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum IapCredentials {
                /// Authentication configuration when Web-Security-Scanner service
                /// account is added in Identity-Aware-Proxy (IAP) access policies.
                IapTestServiceAccountInfo(std::boxed::Box<crate::model::scan_config::authentication::iap_credential::IapTestServiceAccountInfo>),
            }
        }

        /// Required.
        /// Authentication configuration
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Authentication {
            /// Authentication using a Google account.
            GoogleAccount(
                std::boxed::Box<crate::model::scan_config::authentication::GoogleAccount>,
            ),
            /// Authentication using a custom account.
            CustomAccount(
                std::boxed::Box<crate::model::scan_config::authentication::CustomAccount>,
            ),
            /// Authentication using Identity-Aware-Proxy (IAP).
            IapCredential(
                std::boxed::Box<crate::model::scan_config::authentication::IapCredential>,
            ),
        }
    }

    /// Scan schedule configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Schedule {
        /// A timestamp indicates when the next run will be scheduled. The value is
        /// refreshed by the server after each run. If unspecified, it will default
        /// to current server time, which means the scan will be scheduled to start
        /// immediately.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub schedule_time: std::option::Option<wkt::Timestamp>,

        /// Required. The duration of time between executions in days.
        pub interval_duration_days: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Schedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [schedule_time][crate::model::scan_config::Schedule::schedule_time].
        pub fn set_schedule_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.schedule_time = v.into();
            self
        }

        /// Sets the value of [interval_duration_days][crate::model::scan_config::Schedule::interval_duration_days].
        pub fn set_interval_duration_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.interval_duration_days = v.into();
            self
        }
    }

    impl wkt::message::Message for Schedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfig.Schedule"
        }
    }

    /// Type of user agents used for scanning.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct UserAgent(i32);

    impl UserAgent {
        /// The user agent is unknown. Service will default to CHROME_LINUX.
        pub const USER_AGENT_UNSPECIFIED: UserAgent = UserAgent::new(0);

        /// Chrome on Linux. This is the service default if unspecified.
        pub const CHROME_LINUX: UserAgent = UserAgent::new(1);

        /// Chrome on Android.
        pub const CHROME_ANDROID: UserAgent = UserAgent::new(2);

        /// Safari on IPhone.
        pub const SAFARI_IPHONE: UserAgent = UserAgent::new(3);

        /// Creates a new UserAgent instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("USER_AGENT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CHROME_LINUX"),
                2 => std::borrow::Cow::Borrowed("CHROME_ANDROID"),
                3 => std::borrow::Cow::Borrowed("SAFARI_IPHONE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "USER_AGENT_UNSPECIFIED" => std::option::Option::Some(Self::USER_AGENT_UNSPECIFIED),
                "CHROME_LINUX" => std::option::Option::Some(Self::CHROME_LINUX),
                "CHROME_ANDROID" => std::option::Option::Some(Self::CHROME_ANDROID),
                "SAFARI_IPHONE" => std::option::Option::Some(Self::SAFARI_IPHONE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for UserAgent {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for UserAgent {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Scan risk levels supported by Web Security Scanner. LOW impact
    /// scanning will minimize requests with the potential to modify data. To
    /// achieve the maximum scan coverage, NORMAL risk level is recommended.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RiskLevel(i32);

    impl RiskLevel {
        /// Use default, which is NORMAL.
        pub const RISK_LEVEL_UNSPECIFIED: RiskLevel = RiskLevel::new(0);

        /// Normal scanning (Recommended)
        pub const NORMAL: RiskLevel = RiskLevel::new(1);

        /// Lower impact scanning
        pub const LOW: RiskLevel = RiskLevel::new(2);

        /// Creates a new RiskLevel instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RISK_LEVEL_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NORMAL"),
                2 => std::borrow::Cow::Borrowed("LOW"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RISK_LEVEL_UNSPECIFIED" => std::option::Option::Some(Self::RISK_LEVEL_UNSPECIFIED),
                "NORMAL" => std::option::Option::Some(Self::NORMAL),
                "LOW" => std::option::Option::Some(Self::LOW),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RiskLevel {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RiskLevel {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Controls export of scan configurations and results to Security
    /// Command Center.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ExportToSecurityCommandCenter(i32);

    impl ExportToSecurityCommandCenter {
        /// Use default, which is ENABLED.
        pub const EXPORT_TO_SECURITY_COMMAND_CENTER_UNSPECIFIED: ExportToSecurityCommandCenter =
            ExportToSecurityCommandCenter::new(0);

        /// Export results of this scan to Security Command Center.
        pub const ENABLED: ExportToSecurityCommandCenter = ExportToSecurityCommandCenter::new(1);

        /// Do not export results of this scan to Security Command Center.
        pub const DISABLED: ExportToSecurityCommandCenter = ExportToSecurityCommandCenter::new(2);

        /// Creates a new ExportToSecurityCommandCenter instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("EXPORT_TO_SECURITY_COMMAND_CENTER_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ENABLED"),
                2 => std::borrow::Cow::Borrowed("DISABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "EXPORT_TO_SECURITY_COMMAND_CENTER_UNSPECIFIED" => {
                    std::option::Option::Some(Self::EXPORT_TO_SECURITY_COMMAND_CENTER_UNSPECIFIED)
                }
                "ENABLED" => std::option::Option::Some(Self::ENABLED),
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ExportToSecurityCommandCenter {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ExportToSecurityCommandCenter {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Defines a custom error message used by CreateScanConfig and UpdateScanConfig
/// APIs when scan configuration validation fails. It is also reported as part of
/// a ScanRunErrorTrace message if scan validation fails due to a scan
/// configuration error.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScanConfigError {
    /// Output only. Indicates the reason code for a configuration failure.
    pub code: crate::model::scan_config_error::Code,

    /// Output only. Indicates the full name of the ScanConfig field that triggers this error,
    /// for example "scan_config.max_qps". This field is provided for
    /// troubleshooting purposes only and its actual value can change in the
    /// future.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub field_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanConfigError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::ScanConfigError::code].
    pub fn set_code<T: std::convert::Into<crate::model::scan_config_error::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [field_name][crate::model::ScanConfigError::field_name].
    pub fn set_field_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field_name = v.into();
        self
    }
}

impl wkt::message::Message for ScanConfigError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanConfigError"
    }
}

/// Defines additional types related to [ScanConfigError].
pub mod scan_config_error {
    #[allow(unused_imports)]
    use super::*;

    /// Output only.
    /// Defines an error reason code.
    /// Next id: 44
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Code(i32);

    impl Code {
        /// There is no error.
        pub const CODE_UNSPECIFIED: Code = Code::new(0);

        /// There is no error.
        pub const OK: Code = Code::new(0);

        /// Indicates an internal server error.
        /// Please DO NOT USE THIS ERROR CODE unless the root cause is truly unknown.
        pub const INTERNAL_ERROR: Code = Code::new(1);

        /// One of the seed URLs is an App Engine URL but we cannot validate the scan
        /// settings due to an App Engine API backend error.
        pub const APPENGINE_API_BACKEND_ERROR: Code = Code::new(2);

        /// One of the seed URLs is an App Engine URL but we cannot access the
        /// App Engine API to validate scan settings.
        pub const APPENGINE_API_NOT_ACCESSIBLE: Code = Code::new(3);

        /// One of the seed URLs is an App Engine URL but the Default Host of the
        /// App Engine is not set.
        pub const APPENGINE_DEFAULT_HOST_MISSING: Code = Code::new(4);

        /// Google corporate accounts can not be used for scanning.
        pub const CANNOT_USE_GOOGLE_COM_ACCOUNT: Code = Code::new(6);

        /// The account of the scan creator can not be used for scanning.
        pub const CANNOT_USE_OWNER_ACCOUNT: Code = Code::new(7);

        /// This scan targets Compute Engine, but we cannot validate scan settings
        /// due to a Compute Engine API backend error.
        pub const COMPUTE_API_BACKEND_ERROR: Code = Code::new(8);

        /// This scan targets Compute Engine, but we cannot access the Compute Engine
        /// API to validate the scan settings.
        pub const COMPUTE_API_NOT_ACCESSIBLE: Code = Code::new(9);

        /// The Custom Login URL does not belong to the current project.
        pub const CUSTOM_LOGIN_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT: Code = Code::new(10);

        /// The Custom Login URL is malformed (can not be parsed).
        pub const CUSTOM_LOGIN_URL_MALFORMED: Code = Code::new(11);

        /// The Custom Login URL is mapped to a non-routable IP address in DNS.
        pub const CUSTOM_LOGIN_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS: Code = Code::new(12);

        /// The Custom Login URL is mapped to an IP address which is not reserved for
        /// the current project.
        pub const CUSTOM_LOGIN_URL_MAPPED_TO_UNRESERVED_ADDRESS: Code = Code::new(13);

        /// The Custom Login URL has a non-routable IP address.
        pub const CUSTOM_LOGIN_URL_HAS_NON_ROUTABLE_IP_ADDRESS: Code = Code::new(14);

        /// The Custom Login URL has an IP address which is not reserved for the
        /// current project.
        pub const CUSTOM_LOGIN_URL_HAS_UNRESERVED_IP_ADDRESS: Code = Code::new(15);

        /// Another scan with the same name (case-sensitive) already exists.
        pub const DUPLICATE_SCAN_NAME: Code = Code::new(16);

        /// A field is set to an invalid value.
        pub const INVALID_FIELD_VALUE: Code = Code::new(18);

        /// There was an error trying to authenticate to the scan target.
        pub const FAILED_TO_AUTHENTICATE_TO_TARGET: Code = Code::new(19);

        /// Finding type value is not specified in the list findings request.
        pub const FINDING_TYPE_UNSPECIFIED: Code = Code::new(20);

        /// Scan targets Compute Engine, yet current project was not whitelisted for
        /// Google Compute Engine Scanning Alpha access.
        pub const FORBIDDEN_TO_SCAN_COMPUTE: Code = Code::new(21);

        /// User tries to update managed scan
        pub const FORBIDDEN_UPDATE_TO_MANAGED_SCAN: Code = Code::new(43);

        /// The supplied filter is malformed. For example, it can not be parsed, does
        /// not have a filter type in expression, or the same filter type appears
        /// more than once.
        pub const MALFORMED_FILTER: Code = Code::new(22);

        /// The supplied resource name is malformed (can not be parsed).
        pub const MALFORMED_RESOURCE_NAME: Code = Code::new(23);

        /// The current project is not in an active state.
        pub const PROJECT_INACTIVE: Code = Code::new(24);

        /// A required field is not set.
        pub const REQUIRED_FIELD: Code = Code::new(25);

        /// Project id, scanconfig id, scanrun id, or finding id are not consistent
        /// with each other in resource name.
        pub const RESOURCE_NAME_INCONSISTENT: Code = Code::new(26);

        /// The scan being requested to start is already running.
        pub const SCAN_ALREADY_RUNNING: Code = Code::new(27);

        /// The scan that was requested to be stopped is not running.
        pub const SCAN_NOT_RUNNING: Code = Code::new(28);

        /// One of the seed URLs does not belong to the current project.
        pub const SEED_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT: Code = Code::new(29);

        /// One of the seed URLs is malformed (can not be parsed).
        pub const SEED_URL_MALFORMED: Code = Code::new(30);

        /// One of the seed URLs is mapped to a non-routable IP address in DNS.
        pub const SEED_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS: Code = Code::new(31);

        /// One of the seed URLs is mapped to an IP address which is not reserved
        /// for the current project.
        pub const SEED_URL_MAPPED_TO_UNRESERVED_ADDRESS: Code = Code::new(32);

        /// One of the seed URLs has on-routable IP address.
        pub const SEED_URL_HAS_NON_ROUTABLE_IP_ADDRESS: Code = Code::new(33);

        /// One of the seed URLs has an IP address that is not reserved
        /// for the current project.
        pub const SEED_URL_HAS_UNRESERVED_IP_ADDRESS: Code = Code::new(35);

        /// The Web Security Scanner service account is not configured under the
        /// project.
        pub const SERVICE_ACCOUNT_NOT_CONFIGURED: Code = Code::new(36);

        /// A project has reached the maximum number of scans.
        pub const TOO_MANY_SCANS: Code = Code::new(37);

        /// Resolving the details of the current project fails.
        pub const UNABLE_TO_RESOLVE_PROJECT_INFO: Code = Code::new(38);

        /// One or more blacklist patterns were in the wrong format.
        pub const UNSUPPORTED_BLACKLIST_PATTERN_FORMAT: Code = Code::new(39);

        /// The supplied filter is not supported.
        pub const UNSUPPORTED_FILTER: Code = Code::new(40);

        /// The supplied finding type is not supported. For example, we do not
        /// provide findings of the given finding type.
        pub const UNSUPPORTED_FINDING_TYPE: Code = Code::new(41);

        /// The URL scheme of one or more of the supplied URLs is not supported.
        pub const UNSUPPORTED_URL_SCHEME: Code = Code::new(42);

        /// Creates a new Code instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("OK"),
                1 => std::borrow::Cow::Borrowed("INTERNAL_ERROR"),
                2 => std::borrow::Cow::Borrowed("APPENGINE_API_BACKEND_ERROR"),
                3 => std::borrow::Cow::Borrowed("APPENGINE_API_NOT_ACCESSIBLE"),
                4 => std::borrow::Cow::Borrowed("APPENGINE_DEFAULT_HOST_MISSING"),
                6 => std::borrow::Cow::Borrowed("CANNOT_USE_GOOGLE_COM_ACCOUNT"),
                7 => std::borrow::Cow::Borrowed("CANNOT_USE_OWNER_ACCOUNT"),
                8 => std::borrow::Cow::Borrowed("COMPUTE_API_BACKEND_ERROR"),
                9 => std::borrow::Cow::Borrowed("COMPUTE_API_NOT_ACCESSIBLE"),
                10 => std::borrow::Cow::Borrowed(
                    "CUSTOM_LOGIN_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT",
                ),
                11 => std::borrow::Cow::Borrowed("CUSTOM_LOGIN_URL_MALFORMED"),
                12 => std::borrow::Cow::Borrowed("CUSTOM_LOGIN_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS"),
                13 => std::borrow::Cow::Borrowed("CUSTOM_LOGIN_URL_MAPPED_TO_UNRESERVED_ADDRESS"),
                14 => std::borrow::Cow::Borrowed("CUSTOM_LOGIN_URL_HAS_NON_ROUTABLE_IP_ADDRESS"),
                15 => std::borrow::Cow::Borrowed("CUSTOM_LOGIN_URL_HAS_UNRESERVED_IP_ADDRESS"),
                16 => std::borrow::Cow::Borrowed("DUPLICATE_SCAN_NAME"),
                18 => std::borrow::Cow::Borrowed("INVALID_FIELD_VALUE"),
                19 => std::borrow::Cow::Borrowed("FAILED_TO_AUTHENTICATE_TO_TARGET"),
                20 => std::borrow::Cow::Borrowed("FINDING_TYPE_UNSPECIFIED"),
                21 => std::borrow::Cow::Borrowed("FORBIDDEN_TO_SCAN_COMPUTE"),
                22 => std::borrow::Cow::Borrowed("MALFORMED_FILTER"),
                23 => std::borrow::Cow::Borrowed("MALFORMED_RESOURCE_NAME"),
                24 => std::borrow::Cow::Borrowed("PROJECT_INACTIVE"),
                25 => std::borrow::Cow::Borrowed("REQUIRED_FIELD"),
                26 => std::borrow::Cow::Borrowed("RESOURCE_NAME_INCONSISTENT"),
                27 => std::borrow::Cow::Borrowed("SCAN_ALREADY_RUNNING"),
                28 => std::borrow::Cow::Borrowed("SCAN_NOT_RUNNING"),
                29 => std::borrow::Cow::Borrowed("SEED_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT"),
                30 => std::borrow::Cow::Borrowed("SEED_URL_MALFORMED"),
                31 => std::borrow::Cow::Borrowed("SEED_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS"),
                32 => std::borrow::Cow::Borrowed("SEED_URL_MAPPED_TO_UNRESERVED_ADDRESS"),
                33 => std::borrow::Cow::Borrowed("SEED_URL_HAS_NON_ROUTABLE_IP_ADDRESS"),
                35 => std::borrow::Cow::Borrowed("SEED_URL_HAS_UNRESERVED_IP_ADDRESS"),
                36 => std::borrow::Cow::Borrowed("SERVICE_ACCOUNT_NOT_CONFIGURED"),
                37 => std::borrow::Cow::Borrowed("TOO_MANY_SCANS"),
                38 => std::borrow::Cow::Borrowed("UNABLE_TO_RESOLVE_PROJECT_INFO"),
                39 => std::borrow::Cow::Borrowed("UNSUPPORTED_BLACKLIST_PATTERN_FORMAT"),
                40 => std::borrow::Cow::Borrowed("UNSUPPORTED_FILTER"),
                41 => std::borrow::Cow::Borrowed("UNSUPPORTED_FINDING_TYPE"),
                42 => std::borrow::Cow::Borrowed("UNSUPPORTED_URL_SCHEME"),
                43 => std::borrow::Cow::Borrowed("FORBIDDEN_UPDATE_TO_MANAGED_SCAN"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CODE_UNSPECIFIED" => std::option::Option::Some(Self::CODE_UNSPECIFIED),
                "OK" => std::option::Option::Some(Self::OK),
                "INTERNAL_ERROR" => std::option::Option::Some(Self::INTERNAL_ERROR),
                "APPENGINE_API_BACKEND_ERROR" => {
                    std::option::Option::Some(Self::APPENGINE_API_BACKEND_ERROR)
                }
                "APPENGINE_API_NOT_ACCESSIBLE" => {
                    std::option::Option::Some(Self::APPENGINE_API_NOT_ACCESSIBLE)
                }
                "APPENGINE_DEFAULT_HOST_MISSING" => {
                    std::option::Option::Some(Self::APPENGINE_DEFAULT_HOST_MISSING)
                }
                "CANNOT_USE_GOOGLE_COM_ACCOUNT" => {
                    std::option::Option::Some(Self::CANNOT_USE_GOOGLE_COM_ACCOUNT)
                }
                "CANNOT_USE_OWNER_ACCOUNT" => {
                    std::option::Option::Some(Self::CANNOT_USE_OWNER_ACCOUNT)
                }
                "COMPUTE_API_BACKEND_ERROR" => {
                    std::option::Option::Some(Self::COMPUTE_API_BACKEND_ERROR)
                }
                "COMPUTE_API_NOT_ACCESSIBLE" => {
                    std::option::Option::Some(Self::COMPUTE_API_NOT_ACCESSIBLE)
                }
                "CUSTOM_LOGIN_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT" => std::option::Option::Some(
                    Self::CUSTOM_LOGIN_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT,
                ),
                "CUSTOM_LOGIN_URL_MALFORMED" => {
                    std::option::Option::Some(Self::CUSTOM_LOGIN_URL_MALFORMED)
                }
                "CUSTOM_LOGIN_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS" => {
                    std::option::Option::Some(Self::CUSTOM_LOGIN_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS)
                }
                "CUSTOM_LOGIN_URL_MAPPED_TO_UNRESERVED_ADDRESS" => {
                    std::option::Option::Some(Self::CUSTOM_LOGIN_URL_MAPPED_TO_UNRESERVED_ADDRESS)
                }
                "CUSTOM_LOGIN_URL_HAS_NON_ROUTABLE_IP_ADDRESS" => {
                    std::option::Option::Some(Self::CUSTOM_LOGIN_URL_HAS_NON_ROUTABLE_IP_ADDRESS)
                }
                "CUSTOM_LOGIN_URL_HAS_UNRESERVED_IP_ADDRESS" => {
                    std::option::Option::Some(Self::CUSTOM_LOGIN_URL_HAS_UNRESERVED_IP_ADDRESS)
                }
                "DUPLICATE_SCAN_NAME" => std::option::Option::Some(Self::DUPLICATE_SCAN_NAME),
                "INVALID_FIELD_VALUE" => std::option::Option::Some(Self::INVALID_FIELD_VALUE),
                "FAILED_TO_AUTHENTICATE_TO_TARGET" => {
                    std::option::Option::Some(Self::FAILED_TO_AUTHENTICATE_TO_TARGET)
                }
                "FINDING_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::FINDING_TYPE_UNSPECIFIED)
                }
                "FORBIDDEN_TO_SCAN_COMPUTE" => {
                    std::option::Option::Some(Self::FORBIDDEN_TO_SCAN_COMPUTE)
                }
                "FORBIDDEN_UPDATE_TO_MANAGED_SCAN" => {
                    std::option::Option::Some(Self::FORBIDDEN_UPDATE_TO_MANAGED_SCAN)
                }
                "MALFORMED_FILTER" => std::option::Option::Some(Self::MALFORMED_FILTER),
                "MALFORMED_RESOURCE_NAME" => {
                    std::option::Option::Some(Self::MALFORMED_RESOURCE_NAME)
                }
                "PROJECT_INACTIVE" => std::option::Option::Some(Self::PROJECT_INACTIVE),
                "REQUIRED_FIELD" => std::option::Option::Some(Self::REQUIRED_FIELD),
                "RESOURCE_NAME_INCONSISTENT" => {
                    std::option::Option::Some(Self::RESOURCE_NAME_INCONSISTENT)
                }
                "SCAN_ALREADY_RUNNING" => std::option::Option::Some(Self::SCAN_ALREADY_RUNNING),
                "SCAN_NOT_RUNNING" => std::option::Option::Some(Self::SCAN_NOT_RUNNING),
                "SEED_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT" => {
                    std::option::Option::Some(Self::SEED_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT)
                }
                "SEED_URL_MALFORMED" => std::option::Option::Some(Self::SEED_URL_MALFORMED),
                "SEED_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS" => {
                    std::option::Option::Some(Self::SEED_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS)
                }
                "SEED_URL_MAPPED_TO_UNRESERVED_ADDRESS" => {
                    std::option::Option::Some(Self::SEED_URL_MAPPED_TO_UNRESERVED_ADDRESS)
                }
                "SEED_URL_HAS_NON_ROUTABLE_IP_ADDRESS" => {
                    std::option::Option::Some(Self::SEED_URL_HAS_NON_ROUTABLE_IP_ADDRESS)
                }
                "SEED_URL_HAS_UNRESERVED_IP_ADDRESS" => {
                    std::option::Option::Some(Self::SEED_URL_HAS_UNRESERVED_IP_ADDRESS)
                }
                "SERVICE_ACCOUNT_NOT_CONFIGURED" => {
                    std::option::Option::Some(Self::SERVICE_ACCOUNT_NOT_CONFIGURED)
                }
                "TOO_MANY_SCANS" => std::option::Option::Some(Self::TOO_MANY_SCANS),
                "UNABLE_TO_RESOLVE_PROJECT_INFO" => {
                    std::option::Option::Some(Self::UNABLE_TO_RESOLVE_PROJECT_INFO)
                }
                "UNSUPPORTED_BLACKLIST_PATTERN_FORMAT" => {
                    std::option::Option::Some(Self::UNSUPPORTED_BLACKLIST_PATTERN_FORMAT)
                }
                "UNSUPPORTED_FILTER" => std::option::Option::Some(Self::UNSUPPORTED_FILTER),
                "UNSUPPORTED_FINDING_TYPE" => {
                    std::option::Option::Some(Self::UNSUPPORTED_FINDING_TYPE)
                }
                "UNSUPPORTED_URL_SCHEME" => std::option::Option::Some(Self::UNSUPPORTED_URL_SCHEME),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A ScanRun is a output-only resource representing an actual run of the scan.
/// Next id: 12
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScanRun {
    /// Output only. The resource name of the ScanRun. The name follows the format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    /// The ScanRun IDs are generated by the system.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The execution state of the ScanRun.
    pub execution_state: crate::model::scan_run::ExecutionState,

    /// Output only. The result state of the ScanRun. This field is only available after the
    /// execution state reaches "FINISHED".
    pub result_state: crate::model::scan_run::ResultState,

    /// Output only. The time at which the ScanRun started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the ScanRun reached termination state - that the ScanRun
    /// is either finished or stopped by user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The number of URLs crawled during this ScanRun. If the scan is in progress,
    /// the value represents the number of URLs crawled up to now.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub urls_crawled_count: i64,

    /// Output only. The number of URLs tested during this ScanRun. If the scan is in progress,
    /// the value represents the number of URLs tested up to now. The number of
    /// URLs tested is usually larger than the number URLS crawled because
    /// typically a crawled URL is tested with multiple test payloads.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub urls_tested_count: i64,

    /// Output only. Whether the scan run has found any vulnerabilities.
    pub has_vulnerabilities: bool,

    /// Output only. The percentage of total completion ranging from 0 to 100.
    /// If the scan is in queue, the value is 0.
    /// If the scan is running, the value ranges from 0 to 100.
    /// If the scan is finished, the value is 100.
    pub progress_percent: i32,

    /// Output only. If result_state is an ERROR, this field provides the primary reason for
    /// scan's termination and more details, if such are available.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_trace: std::option::Option<crate::model::ScanRunErrorTrace>,

    /// Output only. A list of warnings, if such are encountered during this scan run.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warning_traces: std::vec::Vec<crate::model::ScanRunWarningTrace>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ScanRun::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [execution_state][crate::model::ScanRun::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::scan_run::ExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [result_state][crate::model::ScanRun::result_state].
    pub fn set_result_state<T: std::convert::Into<crate::model::scan_run::ResultState>>(
        mut self,
        v: T,
    ) -> Self {
        self.result_state = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ScanRun::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::ScanRun::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [urls_crawled_count][crate::model::ScanRun::urls_crawled_count].
    pub fn set_urls_crawled_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.urls_crawled_count = v.into();
        self
    }

    /// Sets the value of [urls_tested_count][crate::model::ScanRun::urls_tested_count].
    pub fn set_urls_tested_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.urls_tested_count = v.into();
        self
    }

    /// Sets the value of [has_vulnerabilities][crate::model::ScanRun::has_vulnerabilities].
    pub fn set_has_vulnerabilities<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_vulnerabilities = v.into();
        self
    }

    /// Sets the value of [progress_percent][crate::model::ScanRun::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [error_trace][crate::model::ScanRun::error_trace].
    pub fn set_error_trace<
        T: std::convert::Into<std::option::Option<crate::model::ScanRunErrorTrace>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.error_trace = v.into();
        self
    }

    /// Sets the value of [warning_traces][crate::model::ScanRun::warning_traces].
    pub fn set_warning_traces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScanRunWarningTrace>,
    {
        use std::iter::Iterator;
        self.warning_traces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ScanRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanRun"
    }
}

/// Defines additional types related to [ScanRun].
pub mod scan_run {
    #[allow(unused_imports)]
    use super::*;

    /// Types of ScanRun execution state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ExecutionState(i32);

    impl ExecutionState {
        /// Represents an invalid state caused by internal server error. This value
        /// should never be returned.
        pub const EXECUTION_STATE_UNSPECIFIED: ExecutionState = ExecutionState::new(0);

        /// The scan is waiting in the queue.
        pub const QUEUED: ExecutionState = ExecutionState::new(1);

        /// The scan is in progress.
        pub const SCANNING: ExecutionState = ExecutionState::new(2);

        /// The scan is either finished or stopped by user.
        pub const FINISHED: ExecutionState = ExecutionState::new(3);

        /// Creates a new ExecutionState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("EXECUTION_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("QUEUED"),
                2 => std::borrow::Cow::Borrowed("SCANNING"),
                3 => std::borrow::Cow::Borrowed("FINISHED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "EXECUTION_STATE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::EXECUTION_STATE_UNSPECIFIED)
                }
                "QUEUED" => std::option::Option::Some(Self::QUEUED),
                "SCANNING" => std::option::Option::Some(Self::SCANNING),
                "FINISHED" => std::option::Option::Some(Self::FINISHED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ExecutionState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ExecutionState {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Types of ScanRun result state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ResultState(i32);

    impl ResultState {
        /// Default value. This value is returned when the ScanRun is not yet
        /// finished.
        pub const RESULT_STATE_UNSPECIFIED: ResultState = ResultState::new(0);

        /// The scan finished without errors.
        pub const SUCCESS: ResultState = ResultState::new(1);

        /// The scan finished with errors.
        pub const ERROR: ResultState = ResultState::new(2);

        /// The scan was terminated by user.
        pub const KILLED: ResultState = ResultState::new(3);

        /// Creates a new ResultState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RESULT_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SUCCESS"),
                2 => std::borrow::Cow::Borrowed("ERROR"),
                3 => std::borrow::Cow::Borrowed("KILLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RESULT_STATE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::RESULT_STATE_UNSPECIFIED)
                }
                "SUCCESS" => std::option::Option::Some(Self::SUCCESS),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                "KILLED" => std::option::Option::Some(Self::KILLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ResultState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ResultState {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Output only.
/// Defines an error trace message for a ScanRun.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScanRunErrorTrace {
    /// Output only. Indicates the error reason code.
    pub code: crate::model::scan_run_error_trace::Code,

    /// Output only. If the scan encounters SCAN_CONFIG_ISSUE error, this field has the error
    /// message encountered during scan configuration validation that is performed
    /// before each scan run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scan_config_error: std::option::Option<crate::model::ScanConfigError>,

    /// Output only. If the scan encounters TOO_MANY_HTTP_ERRORS, this field indicates the most
    /// common HTTP error code, if such is available. For example, if this code is
    /// 404, the scan has encountered too many NOT_FOUND responses.
    pub most_common_http_error_code: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanRunErrorTrace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::ScanRunErrorTrace::code].
    pub fn set_code<T: std::convert::Into<crate::model::scan_run_error_trace::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [scan_config_error][crate::model::ScanRunErrorTrace::scan_config_error].
    pub fn set_scan_config_error<
        T: std::convert::Into<std::option::Option<crate::model::ScanConfigError>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scan_config_error = v.into();
        self
    }

    /// Sets the value of [most_common_http_error_code][crate::model::ScanRunErrorTrace::most_common_http_error_code].
    pub fn set_most_common_http_error_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.most_common_http_error_code = v.into();
        self
    }
}

impl wkt::message::Message for ScanRunErrorTrace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanRunErrorTrace"
    }
}

/// Defines additional types related to [ScanRunErrorTrace].
pub mod scan_run_error_trace {
    #[allow(unused_imports)]
    use super::*;

    /// Output only.
    /// Defines an error reason code.
    /// Next id: 8
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Code(i32);

    impl Code {
        /// Default value is never used.
        pub const CODE_UNSPECIFIED: Code = Code::new(0);

        /// Indicates that the scan run failed due to an internal server error.
        pub const INTERNAL_ERROR: Code = Code::new(1);

        /// Indicates a scan configuration error, usually due to outdated ScanConfig
        /// settings, such as starting_urls or the DNS configuration.
        pub const SCAN_CONFIG_ISSUE: Code = Code::new(2);

        /// Indicates an authentication error, usually due to outdated ScanConfig
        /// authentication settings.
        pub const AUTHENTICATION_CONFIG_ISSUE: Code = Code::new(3);

        /// Indicates a scan operation timeout, usually caused by a very large site.
        pub const TIMED_OUT_WHILE_SCANNING: Code = Code::new(4);

        /// Indicates that a scan encountered excessive redirects, either to
        /// authentication or some other page outside of the scan scope.
        pub const TOO_MANY_REDIRECTS: Code = Code::new(5);

        /// Indicates that a scan encountered numerous errors from the web site
        /// pages. When available, most_common_http_error_code field indicates the
        /// most common HTTP error code encountered during the scan.
        pub const TOO_MANY_HTTP_ERRORS: Code = Code::new(6);

        /// Creates a new Code instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INTERNAL_ERROR"),
                2 => std::borrow::Cow::Borrowed("SCAN_CONFIG_ISSUE"),
                3 => std::borrow::Cow::Borrowed("AUTHENTICATION_CONFIG_ISSUE"),
                4 => std::borrow::Cow::Borrowed("TIMED_OUT_WHILE_SCANNING"),
                5 => std::borrow::Cow::Borrowed("TOO_MANY_REDIRECTS"),
                6 => std::borrow::Cow::Borrowed("TOO_MANY_HTTP_ERRORS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CODE_UNSPECIFIED" => std::option::Option::Some(Self::CODE_UNSPECIFIED),
                "INTERNAL_ERROR" => std::option::Option::Some(Self::INTERNAL_ERROR),
                "SCAN_CONFIG_ISSUE" => std::option::Option::Some(Self::SCAN_CONFIG_ISSUE),
                "AUTHENTICATION_CONFIG_ISSUE" => {
                    std::option::Option::Some(Self::AUTHENTICATION_CONFIG_ISSUE)
                }
                "TIMED_OUT_WHILE_SCANNING" => {
                    std::option::Option::Some(Self::TIMED_OUT_WHILE_SCANNING)
                }
                "TOO_MANY_REDIRECTS" => std::option::Option::Some(Self::TOO_MANY_REDIRECTS),
                "TOO_MANY_HTTP_ERRORS" => std::option::Option::Some(Self::TOO_MANY_HTTP_ERRORS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A ScanRunLog is an output-only proto used for Stackdriver customer logging.
/// It is used for logs covering the start and end of scan pipelines.
/// Other than an added summary, this is a subset of the ScanRun.
/// Representation in logs is either a proto Struct, or converted to JSON.
/// Next id: 9
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScanRunLog {
    /// Human friendly message about the event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub summary: std::string::String,

    /// The resource name of the ScanRun being logged.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The execution state of the ScanRun.
    pub execution_state: crate::model::scan_run::ExecutionState,

    /// The result state of the ScanRun.
    pub result_state: crate::model::scan_run::ResultState,

    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub urls_crawled_count: i64,

    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub urls_tested_count: i64,

    pub has_findings: bool,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_trace: std::option::Option<crate::model::ScanRunErrorTrace>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanRunLog {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [summary][crate::model::ScanRunLog::summary].
    pub fn set_summary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.summary = v.into();
        self
    }

    /// Sets the value of [name][crate::model::ScanRunLog::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [execution_state][crate::model::ScanRunLog::execution_state].
    pub fn set_execution_state<T: std::convert::Into<crate::model::scan_run::ExecutionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_state = v.into();
        self
    }

    /// Sets the value of [result_state][crate::model::ScanRunLog::result_state].
    pub fn set_result_state<T: std::convert::Into<crate::model::scan_run::ResultState>>(
        mut self,
        v: T,
    ) -> Self {
        self.result_state = v.into();
        self
    }

    /// Sets the value of [urls_crawled_count][crate::model::ScanRunLog::urls_crawled_count].
    pub fn set_urls_crawled_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.urls_crawled_count = v.into();
        self
    }

    /// Sets the value of [urls_tested_count][crate::model::ScanRunLog::urls_tested_count].
    pub fn set_urls_tested_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.urls_tested_count = v.into();
        self
    }

    /// Sets the value of [has_findings][crate::model::ScanRunLog::has_findings].
    pub fn set_has_findings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_findings = v.into();
        self
    }

    /// Sets the value of [error_trace][crate::model::ScanRunLog::error_trace].
    pub fn set_error_trace<
        T: std::convert::Into<std::option::Option<crate::model::ScanRunErrorTrace>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.error_trace = v.into();
        self
    }
}

impl wkt::message::Message for ScanRunLog {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanRunLog"
    }
}

/// Output only.
/// Defines a warning trace message for ScanRun. Warning traces provide customers
/// with useful information that helps make the scanning process more effective.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScanRunWarningTrace {
    /// Output only. Indicates the warning code.
    pub code: crate::model::scan_run_warning_trace::Code,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScanRunWarningTrace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::ScanRunWarningTrace::code].
    pub fn set_code<T: std::convert::Into<crate::model::scan_run_warning_trace::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for ScanRunWarningTrace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ScanRunWarningTrace"
    }
}

/// Defines additional types related to [ScanRunWarningTrace].
pub mod scan_run_warning_trace {
    #[allow(unused_imports)]
    use super::*;

    /// Output only.
    /// Defines a warning message code.
    /// Next id: 6
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Code(i32);

    impl Code {
        /// Default value is never used.
        pub const CODE_UNSPECIFIED: Code = Code::new(0);

        /// Indicates that a scan discovered an unexpectedly low number of URLs. This
        /// is sometimes caused by complex navigation features or by using a single
        /// URL for numerous pages.
        pub const INSUFFICIENT_CRAWL_RESULTS: Code = Code::new(1);

        /// Indicates that a scan discovered too many URLs to test, or excessive
        /// redundant URLs.
        pub const TOO_MANY_CRAWL_RESULTS: Code = Code::new(2);

        /// Indicates that too many tests have been generated for the scan. Customer
        /// should try reducing the number of starting URLs, increasing the QPS rate,
        /// or narrowing down the scope of the scan using the excluded patterns.
        pub const TOO_MANY_FUZZ_TASKS: Code = Code::new(3);

        /// Indicates that a scan is blocked by IAP.
        pub const BLOCKED_BY_IAP: Code = Code::new(4);

        /// Indicates that no seeds is found for a scan
        pub const NO_STARTING_URL_FOUND_FOR_MANAGED_SCAN: Code = Code::new(5);

        /// Creates a new Code instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INSUFFICIENT_CRAWL_RESULTS"),
                2 => std::borrow::Cow::Borrowed("TOO_MANY_CRAWL_RESULTS"),
                3 => std::borrow::Cow::Borrowed("TOO_MANY_FUZZ_TASKS"),
                4 => std::borrow::Cow::Borrowed("BLOCKED_BY_IAP"),
                5 => std::borrow::Cow::Borrowed("NO_STARTING_URL_FOUND_FOR_MANAGED_SCAN"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CODE_UNSPECIFIED" => std::option::Option::Some(Self::CODE_UNSPECIFIED),
                "INSUFFICIENT_CRAWL_RESULTS" => {
                    std::option::Option::Some(Self::INSUFFICIENT_CRAWL_RESULTS)
                }
                "TOO_MANY_CRAWL_RESULTS" => std::option::Option::Some(Self::TOO_MANY_CRAWL_RESULTS),
                "TOO_MANY_FUZZ_TASKS" => std::option::Option::Some(Self::TOO_MANY_FUZZ_TASKS),
                "BLOCKED_BY_IAP" => std::option::Option::Some(Self::BLOCKED_BY_IAP),
                "NO_STARTING_URL_FOUND_FOR_MANAGED_SCAN" => {
                    std::option::Option::Some(Self::NO_STARTING_URL_FOUND_FOR_MANAGED_SCAN)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request for the `CreateScanConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateScanConfigRequest {
    /// Required. The parent resource name where the scan is created, which should be a
    /// project resource name in the format 'projects/{projectId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ScanConfig to be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scan_config: std::option::Option<crate::model::ScanConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateScanConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateScanConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [scan_config][crate::model::CreateScanConfigRequest::scan_config].
    pub fn set_scan_config<T: std::convert::Into<std::option::Option<crate::model::ScanConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scan_config = v.into();
        self
    }
}

impl wkt::message::Message for CreateScanConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.CreateScanConfigRequest"
    }
}

/// Request for the `DeleteScanConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteScanConfigRequest {
    /// Required. The resource name of the ScanConfig to be deleted. The name follows the
    /// format of 'projects/{projectId}/scanConfigs/{scanConfigId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteScanConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteScanConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteScanConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.DeleteScanConfigRequest"
    }
}

/// Request for the `GetScanConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetScanConfigRequest {
    /// Required. The resource name of the ScanConfig to be returned. The name follows the
    /// format of 'projects/{projectId}/scanConfigs/{scanConfigId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetScanConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetScanConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetScanConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.GetScanConfigRequest"
    }
}

/// Request for the `ListScanConfigs` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListScanConfigsRequest {
    /// Required. The parent resource name, which should be a project resource name in the
    /// format 'projects/{projectId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A token identifying a page of results to be returned. This should be a
    /// `next_page_token` value returned from a previous List request.
    /// If unspecified, the first page of results is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The maximum number of ScanConfigs to return, can be limited by server.
    /// If not specified or not positive, the implementation will select a
    /// reasonable value.
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListScanConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListScanConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListScanConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListScanConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListScanConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListScanConfigsRequest"
    }
}

/// Request for the `UpdateScanConfigRequest` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateScanConfigRequest {
    /// Required. The ScanConfig to be updated. The name field must be set to identify the
    /// resource to be updated. The values of fields not covered by the mask
    /// will be ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scan_config: std::option::Option<crate::model::ScanConfig>,

    /// Required. The update mask applies to the resource. For the `FieldMask` definition,
    /// see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateScanConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scan_config][crate::model::UpdateScanConfigRequest::scan_config].
    pub fn set_scan_config<T: std::convert::Into<std::option::Option<crate::model::ScanConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scan_config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateScanConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateScanConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.UpdateScanConfigRequest"
    }
}

/// Response for the `ListScanConfigs` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListScanConfigsResponse {
    /// The list of ScanConfigs returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub scan_configs: std::vec::Vec<crate::model::ScanConfig>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListScanConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListScanConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [scan_configs][crate::model::ListScanConfigsResponse::scan_configs].
    pub fn set_scan_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScanConfig>,
    {
        use std::iter::Iterator;
        self.scan_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListScanConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListScanConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListScanConfigsResponse {
    type PageItem = crate::model::ScanConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.scan_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `StartScanRun` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartScanRunRequest {
    /// Required. The resource name of the ScanConfig to be used. The name follows the
    /// format of 'projects/{projectId}/scanConfigs/{scanConfigId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartScanRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartScanRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartScanRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.StartScanRunRequest"
    }
}

/// Request for the `GetScanRun` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetScanRunRequest {
    /// Required. The resource name of the ScanRun to be returned. The name follows the
    /// format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetScanRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetScanRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetScanRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.GetScanRunRequest"
    }
}

/// Request for the `ListScanRuns` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListScanRunsRequest {
    /// Required. The parent resource name, which should be a scan resource name in the
    /// format 'projects/{projectId}/scanConfigs/{scanConfigId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A token identifying a page of results to be returned. This should be a
    /// `next_page_token` value returned from a previous List request.
    /// If unspecified, the first page of results is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The maximum number of ScanRuns to return, can be limited by server.
    /// If not specified or not positive, the implementation will select a
    /// reasonable value.
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListScanRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListScanRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListScanRunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListScanRunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListScanRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListScanRunsRequest"
    }
}

/// Response for the `ListScanRuns` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListScanRunsResponse {
    /// The list of ScanRuns returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub scan_runs: std::vec::Vec<crate::model::ScanRun>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListScanRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListScanRunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [scan_runs][crate::model::ListScanRunsResponse::scan_runs].
    pub fn set_scan_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScanRun>,
    {
        use std::iter::Iterator;
        self.scan_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListScanRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListScanRunsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListScanRunsResponse {
    type PageItem = crate::model::ScanRun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.scan_runs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `StopScanRun` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopScanRunRequest {
    /// Required. The resource name of the ScanRun to be stopped. The name follows the
    /// format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopScanRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopScanRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopScanRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.StopScanRunRequest"
    }
}

/// Request for the `ListCrawledUrls` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCrawledUrlsRequest {
    /// Required. The parent resource name, which should be a scan run resource name in the
    /// format
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A token identifying a page of results to be returned. This should be a
    /// `next_page_token` value returned from a previous List request.
    /// If unspecified, the first page of results is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The maximum number of CrawledUrls to return, can be limited by server.
    /// If not specified or not positive, the implementation will select a
    /// reasonable value.
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCrawledUrlsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCrawledUrlsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCrawledUrlsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCrawledUrlsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListCrawledUrlsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListCrawledUrlsRequest"
    }
}

/// Response for the `ListCrawledUrls` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCrawledUrlsResponse {
    /// The list of CrawledUrls returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub crawled_urls: std::vec::Vec<crate::model::CrawledUrl>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCrawledUrlsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCrawledUrlsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [crawled_urls][crate::model::ListCrawledUrlsResponse::crawled_urls].
    pub fn set_crawled_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CrawledUrl>,
    {
        use std::iter::Iterator;
        self.crawled_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCrawledUrlsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListCrawledUrlsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCrawledUrlsResponse {
    type PageItem = crate::model::CrawledUrl;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.crawled_urls
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `GetFinding` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFindingRequest {
    /// Required. The resource name of the Finding to be returned. The name follows the
    /// format of
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}/findings/{findingId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFindingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.GetFindingRequest"
    }
}

/// Request for the `ListFindings` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFindingsRequest {
    /// Required. The parent resource name, which should be a scan run resource name in the
    /// format
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The filter expression. The expression must be in the format: \<field\>
    /// \<operator\> \<value\>.
    /// Supported field: 'finding_type'.
    /// Supported operator: '='.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A token identifying a page of results to be returned. This should be a
    /// `next_page_token` value returned from a previous List request.
    /// If unspecified, the first page of results is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The maximum number of Findings to return, can be limited by server.
    /// If not specified or not positive, the implementation will select a
    /// reasonable value.
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFindingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFindingsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFindingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFindingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListFindingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListFindingsRequest"
    }
}

/// Response for the `ListFindings` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFindingsResponse {
    /// The list of Findings returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub findings: std::vec::Vec<crate::model::Finding>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFindingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [findings][crate::model::ListFindingsResponse::findings].
    pub fn set_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Finding>,
    {
        use std::iter::Iterator;
        self.findings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFindingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListFindingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFindingsResponse {
    type PageItem = crate::model::Finding;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.findings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `ListFindingTypeStats` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFindingTypeStatsRequest {
    /// Required. The parent resource name, which should be a scan run resource name in the
    /// format
    /// 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingTypeStatsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFindingTypeStatsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListFindingTypeStatsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListFindingTypeStatsRequest"
    }
}

/// Response for the `ListFindingTypeStats` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFindingTypeStatsResponse {
    /// The list of FindingTypeStats returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub finding_type_stats: std::vec::Vec<crate::model::FindingTypeStats>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingTypeStatsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [finding_type_stats][crate::model::ListFindingTypeStatsResponse::finding_type_stats].
    pub fn set_finding_type_stats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FindingTypeStats>,
    {
        use std::iter::Iterator;
        self.finding_type_stats = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFindingTypeStatsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.websecurityscanner.v1.ListFindingTypeStatsResponse"
    }
}
