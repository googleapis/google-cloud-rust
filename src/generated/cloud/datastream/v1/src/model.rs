// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for 'discover' ConnectionProfile request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoverConnectionProfileRequest {
    /// Required. The parent resource of the connection profile type. Must be in
    /// the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The connection profile on which to run discover.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target: std::option::Option<crate::model::discover_connection_profile_request::Target>,

    /// The depth of the retrieved hierarchy of data objects.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub hierarchy:
        std::option::Option<crate::model::discover_connection_profile_request::Hierarchy>,

    /// The data object to populate with child data objects and metadata.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_object:
        std::option::Option<crate::model::discover_connection_profile_request::DataObject>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoverConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::DiscoverConnectionProfileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [target][crate::model::DiscoverConnectionProfileRequest::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<
                std::option::Option<crate::model::discover_connection_profile_request::Target>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::DiscoverConnectionProfileRequest::target]
    /// if it holds a `ConnectionProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn connection_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::Target::ConnectionProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoverConnectionProfileRequest::target]
    /// to hold a `ConnectionProfile`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_connection_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::ConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discover_connection_profile_request::Target::ConnectionProfile(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::DiscoverConnectionProfileRequest::target]
    /// if it holds a `ConnectionProfileName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn connection_profile_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::Target::ConnectionProfileName(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoverConnectionProfileRequest::target]
    /// to hold a `ConnectionProfileName`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_connection_profile_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discover_connection_profile_request::Target::ConnectionProfileName(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [hierarchy][crate::model::DiscoverConnectionProfileRequest::hierarchy].
    ///
    /// Note that all the setters affecting `hierarchy` are mutually
    /// exclusive.
    pub fn set_hierarchy<
        T: std::convert::Into<
                std::option::Option<crate::model::discover_connection_profile_request::Hierarchy>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hierarchy = v.into();
        self
    }

    /// The value of [hierarchy][crate::model::DiscoverConnectionProfileRequest::hierarchy]
    /// if it holds a `FullHierarchy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn full_hierarchy(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.hierarchy.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::Hierarchy::FullHierarchy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [hierarchy][crate::model::DiscoverConnectionProfileRequest::hierarchy]
    /// to hold a `FullHierarchy`.
    ///
    /// Note that all the setters affecting `hierarchy` are
    /// mutually exclusive.
    pub fn set_full_hierarchy<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.hierarchy = std::option::Option::Some(
            crate::model::discover_connection_profile_request::Hierarchy::FullHierarchy(v.into()),
        );
        self
    }

    /// The value of [hierarchy][crate::model::DiscoverConnectionProfileRequest::hierarchy]
    /// if it holds a `HierarchyDepth`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hierarchy_depth(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.hierarchy.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::Hierarchy::HierarchyDepth(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [hierarchy][crate::model::DiscoverConnectionProfileRequest::hierarchy]
    /// to hold a `HierarchyDepth`.
    ///
    /// Note that all the setters affecting `hierarchy` are
    /// mutually exclusive.
    pub fn set_hierarchy_depth<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.hierarchy = std::option::Option::Some(
            crate::model::discover_connection_profile_request::Hierarchy::HierarchyDepth(v.into()),
        );
        self
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object].
    ///
    /// Note that all the setters affecting `data_object` are mutually
    /// exclusive.
    pub fn set_data_object<
        T: std::convert::Into<
                std::option::Option<crate::model::discover_connection_profile_request::DataObject>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = v.into();
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// if it holds a `OracleRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle_rdbms(&self) -> std::option::Option<&std::boxed::Box<crate::model::OracleRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::DataObject::OracleRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// to hold a `OracleRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_oracle_rdbms<T: std::convert::Into<std::boxed::Box<crate::model::OracleRdbms>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_request::DataObject::OracleRdbms(v.into()),
        );
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// if it holds a `MysqlRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_rdbms(&self) -> std::option::Option<&std::boxed::Box<crate::model::MysqlRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::DataObject::MysqlRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// to hold a `MysqlRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_mysql_rdbms<T: std::convert::Into<std::boxed::Box<crate::model::MysqlRdbms>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_request::DataObject::MysqlRdbms(v.into()),
        );
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// if it holds a `PostgresqlRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql_rdbms(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostgresqlRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::DataObject::PostgresqlRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// to hold a `PostgresqlRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_postgresql_rdbms<
        T: std::convert::Into<std::boxed::Box<crate::model::PostgresqlRdbms>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_request::DataObject::PostgresqlRdbms(
                v.into(),
            ),
        );
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// if it holds a `SqlServerRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_server_rdbms(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::DataObject::SqlServerRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// to hold a `SqlServerRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_sql_server_rdbms<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerRdbms>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_request::DataObject::SqlServerRdbms(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoverConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DiscoverConnectionProfileRequest"
    }
}

/// Defines additional types related to [DiscoverConnectionProfileRequest].
pub mod discover_connection_profile_request {
    #[allow(unused_imports)]
    use super::*;

    /// The connection profile on which to run discover.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Target {
        /// An ad-hoc connection profile configuration.
        ConnectionProfile(std::boxed::Box<crate::model::ConnectionProfile>),
        /// A reference to an existing connection profile.
        ConnectionProfileName(std::string::String),
    }

    /// The depth of the retrieved hierarchy of data objects.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Hierarchy {
        /// Whether to retrieve the full hierarchy of data objects (TRUE) or only the
        /// current level (FALSE).
        FullHierarchy(bool),
        /// The number of hierarchy levels below the current level to be retrieved.
        HierarchyDepth(#[serde_as(as = "wkt::internal::I32")] i32),
    }

    /// The data object to populate with child data objects and metadata.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataObject {
        /// Oracle RDBMS to enrich with child data objects and metadata.
        OracleRdbms(std::boxed::Box<crate::model::OracleRdbms>),
        /// MySQL RDBMS to enrich with child data objects and metadata.
        MysqlRdbms(std::boxed::Box<crate::model::MysqlRdbms>),
        /// PostgreSQL RDBMS to enrich with child data objects and metadata.
        PostgresqlRdbms(std::boxed::Box<crate::model::PostgresqlRdbms>),
        /// SQLServer RDBMS to enrich with child data objects and metadata.
        SqlServerRdbms(std::boxed::Box<crate::model::SqlServerRdbms>),
    }
}

/// Response from a discover request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoverConnectionProfileResponse {
    /// The data object that has been enriched by the discover API call.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_object:
        std::option::Option<crate::model::discover_connection_profile_response::DataObject>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoverConnectionProfileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object].
    ///
    /// Note that all the setters affecting `data_object` are mutually
    /// exclusive.
    pub fn set_data_object<
        T: std::convert::Into<
                std::option::Option<crate::model::discover_connection_profile_response::DataObject>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = v.into();
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// if it holds a `OracleRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle_rdbms(&self) -> std::option::Option<&std::boxed::Box<crate::model::OracleRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_response::DataObject::OracleRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// to hold a `OracleRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_oracle_rdbms<T: std::convert::Into<std::boxed::Box<crate::model::OracleRdbms>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_response::DataObject::OracleRdbms(v.into()),
        );
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// if it holds a `MysqlRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_rdbms(&self) -> std::option::Option<&std::boxed::Box<crate::model::MysqlRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_response::DataObject::MysqlRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// to hold a `MysqlRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_mysql_rdbms<T: std::convert::Into<std::boxed::Box<crate::model::MysqlRdbms>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_response::DataObject::MysqlRdbms(v.into()),
        );
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// if it holds a `PostgresqlRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql_rdbms(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostgresqlRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_response::DataObject::PostgresqlRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// to hold a `PostgresqlRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_postgresql_rdbms<
        T: std::convert::Into<std::boxed::Box<crate::model::PostgresqlRdbms>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_response::DataObject::PostgresqlRdbms(
                v.into(),
            ),
        );
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// if it holds a `SqlServerRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_server_rdbms(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_response::DataObject::SqlServerRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// to hold a `SqlServerRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_sql_server_rdbms<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerRdbms>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_response::DataObject::SqlServerRdbms(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DiscoverConnectionProfileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DiscoverConnectionProfileResponse"
    }
}

/// Defines additional types related to [DiscoverConnectionProfileResponse].
pub mod discover_connection_profile_response {
    #[allow(unused_imports)]
    use super::*;

    /// The data object that has been enriched by the discover API call.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataObject {
        /// Enriched Oracle RDBMS object.
        OracleRdbms(std::boxed::Box<crate::model::OracleRdbms>),
        /// Enriched MySQL RDBMS object.
        MysqlRdbms(std::boxed::Box<crate::model::MysqlRdbms>),
        /// Enriched PostgreSQL RDBMS object.
        PostgresqlRdbms(std::boxed::Box<crate::model::PostgresqlRdbms>),
        /// Enriched SQLServer RDBMS object.
        SqlServerRdbms(std::boxed::Box<crate::model::SqlServerRdbms>),
    }
}

/// Request message for 'FetchStaticIps' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchStaticIpsRequest {
    /// Required. The resource name for the location for which static IPs should be
    /// returned. Must be in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Maximum number of Ips to return, will likely not be specified.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListStaticIps` call.
    /// will likely not be specified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchStaticIpsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FetchStaticIpsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchStaticIpsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchStaticIpsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchStaticIpsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.FetchStaticIpsRequest"
    }
}

/// Response message for a 'FetchStaticIps' response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchStaticIpsResponse {
    /// list of static ips by account
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub static_ips: std::vec::Vec<std::string::String>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchStaticIpsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [static_ips][crate::model::FetchStaticIpsResponse::static_ips].
    pub fn set_static_ips<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.static_ips = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchStaticIpsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchStaticIpsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.FetchStaticIpsResponse"
    }
}

/// Request message for listing connection profiles.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionProfilesRequest {
    /// Required. The parent that owns the collection of connection profiles.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of connection profiles to return.
    /// If unspecified, at most 50 connection profiles will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Page token received from a previous `ListConnectionProfiles` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListConnectionProfiles`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectionProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConnectionProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListConnectionProfilesRequest"
    }
}

/// Response message for listing connection profiles.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionProfilesResponse {
    /// List of connection profiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connection_profiles: std::vec::Vec<crate::model::ConnectionProfile>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_profiles][crate::model::ListConnectionProfilesResponse::connection_profiles].
    pub fn set_connection_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectionProfile>,
    {
        use std::iter::Iterator;
        self.connection_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectionProfilesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListConnectionProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionProfilesResponse {
    type PageItem = crate::model::ConnectionProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connection_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for getting a connection profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectionProfileRequest {
    /// Required. The name of the connection profile resource to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GetConnectionProfileRequest"
    }
}

/// Request message for creating a connection profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConnectionProfileRequest {
    /// Required. The parent that owns the collection of ConnectionProfiles.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The connection profile identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_profile_id: std::string::String,

    /// Required. The connection profile resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_profile: std::option::Option<crate::model::ConnectionProfile>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Only validate the connection profile, but don't create any
    /// resources. The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Optional. Create the connection profile without validating it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionProfileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection_profile_id][crate::model::CreateConnectionProfileRequest::connection_profile_id].
    pub fn set_connection_profile_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile_id = v.into();
        self
    }

    /// Sets the value of [connection_profile][crate::model::CreateConnectionProfileRequest::connection_profile].
    pub fn set_connection_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionProfile>,
    {
        self.connection_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_profile][crate::model::CreateConnectionProfileRequest::connection_profile].
    pub fn set_or_clear_connection_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionProfile>,
    {
        self.connection_profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateConnectionProfileRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::CreateConnectionProfileRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for CreateConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.CreateConnectionProfileRequest"
    }
}

/// Connection profile update message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConnectionProfileRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// ConnectionProfile resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The connection profile to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_profile: std::option::Option<crate::model::ConnectionProfile>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Only validate the connection profile, but don't update any
    /// resources. The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Optional. Update the connection profile without validating it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionProfileRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConnectionProfileRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connection_profile][crate::model::UpdateConnectionProfileRequest::connection_profile].
    pub fn set_connection_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionProfile>,
    {
        self.connection_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_profile][crate::model::UpdateConnectionProfileRequest::connection_profile].
    pub fn set_or_clear_connection_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionProfile>,
    {
        self.connection_profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateConnectionProfileRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::UpdateConnectionProfileRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.UpdateConnectionProfileRequest"
    }
}

/// Request message for deleting a connection profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConnectionProfileRequest {
    /// Required. The name of the connection profile resource to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DeleteConnectionProfileRequest"
    }
}

/// Request message for listing streams.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStreamsRequest {
    /// Required. The parent that owns the collection of streams.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of streams to return.
    /// If unspecified, at most 50 streams will  be returned. The maximum
    /// value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Page token received from a previous `ListStreams` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListStreams`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStreamsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListStreamsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListStreamsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListStreamsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListStreamsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListStreamsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListStreamsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListStreamsRequest"
    }
}

/// Response message for listing streams.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStreamsResponse {
    /// List of streams
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub streams: std::vec::Vec<crate::model::Stream>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStreamsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [streams][crate::model::ListStreamsResponse::streams].
    pub fn set_streams<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Stream>,
    {
        use std::iter::Iterator;
        self.streams = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListStreamsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListStreamsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListStreamsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListStreamsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListStreamsResponse {
    type PageItem = crate::model::Stream;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.streams
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for getting a stream.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetStreamRequest {
    /// Required. The name of the stream resource to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetStreamRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStreamRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStreamRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GetStreamRequest"
    }
}

/// Request message for creating a stream.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateStreamRequest {
    /// Required. The parent that owns the collection of streams.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The stream identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub stream_id: std::string::String,

    /// Required. The stream resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stream: std::option::Option<crate::model::Stream>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Only validate the stream, but don't create any resources.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Optional. Create the stream without validating it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateStreamRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateStreamRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [stream_id][crate::model::CreateStreamRequest::stream_id].
    pub fn set_stream_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.stream_id = v.into();
        self
    }

    /// Sets the value of [stream][crate::model::CreateStreamRequest::stream].
    pub fn set_stream<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Stream>,
    {
        self.stream = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stream][crate::model::CreateStreamRequest::stream].
    pub fn set_or_clear_stream<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Stream>,
    {
        self.stream = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateStreamRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateStreamRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::CreateStreamRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for CreateStreamRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.CreateStreamRequest"
    }
}

/// Request message for updating a stream.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateStreamRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// stream resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The stream resource to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stream: std::option::Option<crate::model::Stream>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Only validate the stream with the changes, without actually
    /// updating it. The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Optional. Update the stream without validating it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateStreamRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateStreamRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateStreamRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stream][crate::model::UpdateStreamRequest::stream].
    pub fn set_stream<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Stream>,
    {
        self.stream = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stream][crate::model::UpdateStreamRequest::stream].
    pub fn set_or_clear_stream<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Stream>,
    {
        self.stream = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateStreamRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateStreamRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::UpdateStreamRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for UpdateStreamRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.UpdateStreamRequest"
    }
}

/// Request message for deleting a stream.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteStreamRequest {
    /// Required. The name of the stream resource to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteStreamRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteStreamRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteStreamRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteStreamRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DeleteStreamRequest"
    }
}

/// Request message for running a stream.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunStreamRequest {
    /// Required. Name of the stream resource to start, in the format:
    /// projects/{project_id}/locations/{location}/streams/{stream_name}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The CDC strategy of the stream. If not set, the system's default
    /// value will be used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cdc_strategy: std::option::Option<crate::model::CdcStrategy>,

    /// Optional. Update the stream without validating it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunStreamRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunStreamRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cdc_strategy][crate::model::RunStreamRequest::cdc_strategy].
    pub fn set_cdc_strategy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CdcStrategy>,
    {
        self.cdc_strategy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cdc_strategy][crate::model::RunStreamRequest::cdc_strategy].
    pub fn set_or_clear_cdc_strategy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CdcStrategy>,
    {
        self.cdc_strategy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [force][crate::model::RunStreamRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for RunStreamRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.RunStreamRequest"
    }
}

/// Request for fetching a specific stream object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetStreamObjectRequest {
    /// Required. The name of the stream object resource to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetStreamObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStreamObjectRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStreamObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GetStreamObjectRequest"
    }
}

/// Request for looking up a specific stream object by its source object
/// identifier.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LookupStreamObjectRequest {
    /// Required. The parent stream that owns the collection of objects.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The source object identifier which maps to the stream object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_object_identifier: std::option::Option<crate::model::SourceObjectIdentifier>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookupStreamObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::LookupStreamObjectRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_object_identifier][crate::model::LookupStreamObjectRequest::source_object_identifier].
    pub fn set_source_object_identifier<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceObjectIdentifier>,
    {
        self.source_object_identifier = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_object_identifier][crate::model::LookupStreamObjectRequest::source_object_identifier].
    pub fn set_or_clear_source_object_identifier<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceObjectIdentifier>,
    {
        self.source_object_identifier = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LookupStreamObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.LookupStreamObjectRequest"
    }
}

/// Request for manually initiating a backfill job for a specific stream object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartBackfillJobRequest {
    /// Required. The name of the stream object resource to start a backfill job
    /// for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartBackfillJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object][crate::model::StartBackfillJobRequest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }
}

impl wkt::message::Message for StartBackfillJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.StartBackfillJobRequest"
    }
}

/// Response for manually initiating a backfill job for a specific stream object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartBackfillJobResponse {
    /// The stream object resource a backfill job was started for.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub object: std::option::Option<crate::model::StreamObject>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartBackfillJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object][crate::model::StartBackfillJobResponse::object].
    pub fn set_object<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StreamObject>,
    {
        self.object = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object][crate::model::StartBackfillJobResponse::object].
    pub fn set_or_clear_object<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StreamObject>,
    {
        self.object = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StartBackfillJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.StartBackfillJobResponse"
    }
}

/// Request for manually stopping a running backfill job for a specific stream
/// object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopBackfillJobRequest {
    /// Required. The name of the stream object resource to stop the backfill job
    /// for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopBackfillJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object][crate::model::StopBackfillJobRequest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }
}

impl wkt::message::Message for StopBackfillJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.StopBackfillJobRequest"
    }
}

/// Response for manually stop a backfill job for a specific stream object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopBackfillJobResponse {
    /// The stream object resource the backfill job was stopped for.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub object: std::option::Option<crate::model::StreamObject>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopBackfillJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object][crate::model::StopBackfillJobResponse::object].
    pub fn set_object<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StreamObject>,
    {
        self.object = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object][crate::model::StopBackfillJobResponse::object].
    pub fn set_or_clear_object<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StreamObject>,
    {
        self.object = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StopBackfillJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.StopBackfillJobResponse"
    }
}

/// Request for listing all objects for a specific stream.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStreamObjectsRequest {
    /// Required. The parent stream that owns the collection of objects.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of objects to return. Default is 50.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Page token received from a previous `ListStreamObjectsRequest` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListStreamObjectsRequest` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStreamObjectsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListStreamObjectsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListStreamObjectsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListStreamObjectsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListStreamObjectsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListStreamObjectsRequest"
    }
}

/// Response containing the objects for a stream.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStreamObjectsResponse {
    /// List of stream objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stream_objects: std::vec::Vec<crate::model::StreamObject>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStreamObjectsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stream_objects][crate::model::ListStreamObjectsResponse::stream_objects].
    pub fn set_stream_objects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StreamObject>,
    {
        use std::iter::Iterator;
        self.stream_objects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListStreamObjectsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListStreamObjectsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListStreamObjectsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListStreamObjectsResponse {
    type PageItem = crate::model::StreamObject;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.stream_objects
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    /// Output only. Results of executed validations if there are any.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub validation_result: std::option::Option<crate::model::ValidationResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [validation_result][crate::model::OperationMetadata::validation_result].
    pub fn set_validation_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ValidationResult>,
    {
        self.validation_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [validation_result][crate::model::OperationMetadata::validation_result].
    pub fn set_or_clear_validation_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ValidationResult>,
    {
        self.validation_result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OperationMetadata"
    }
}

/// Request for creating a private connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePrivateConnectionRequest {
    /// Required. The parent that owns the collection of PrivateConnections.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The private connectivity identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_connection_id: std::string::String,

    /// Required. The Private Connectivity resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_connection: std::option::Option<crate::model::PrivateConnection>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set to true, will skip validations.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePrivateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [private_connection_id][crate::model::CreatePrivateConnectionRequest::private_connection_id].
    pub fn set_private_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_connection_id = v.into();
        self
    }

    /// Sets the value of [private_connection][crate::model::CreatePrivateConnectionRequest::private_connection].
    pub fn set_private_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivateConnection>,
    {
        self.private_connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_connection][crate::model::CreatePrivateConnectionRequest::private_connection].
    pub fn set_or_clear_private_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivateConnection>,
    {
        self.private_connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreatePrivateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::CreatePrivateConnectionRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for CreatePrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.CreatePrivateConnectionRequest"
    }
}

/// Request for listing private connections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPrivateConnectionsRequest {
    /// Required. The parent that owns the collection of private connectivity
    /// configurations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of private connectivity configurations to return.
    /// If unspecified, at most 50 private connectivity configurations that will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Page token received from a previous `ListPrivateConnections` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListPrivateConnections` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPrivateConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPrivateConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPrivateConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPrivateConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPrivateConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListPrivateConnectionsRequest"
    }
}

/// Response containing a list of private connection configurations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPrivateConnectionsResponse {
    /// List of private connectivity configurations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub private_connections: std::vec::Vec<crate::model::PrivateConnection>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_connections][crate::model::ListPrivateConnectionsResponse::private_connections].
    pub fn set_private_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PrivateConnection>,
    {
        use std::iter::Iterator;
        self.private_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPrivateConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListPrivateConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListPrivateConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPrivateConnectionsResponse {
    type PageItem = crate::model::PrivateConnection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.private_connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to delete a private connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePrivateConnectionRequest {
    /// Required. The name of the private connectivity configuration to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set to true, any child routes that belong to this
    /// PrivateConnection will also be deleted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePrivateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeletePrivateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeletePrivateConnectionRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeletePrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DeletePrivateConnectionRequest"
    }
}

/// Request to get a private connection configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPrivateConnectionRequest {
    /// Required. The name of the  private connectivity configuration to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPrivateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GetPrivateConnectionRequest"
    }
}

/// Route creation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRouteRequest {
    /// Required. The parent that owns the collection of Routes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Route identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub route_id: std::string::String,

    /// Required. The Route resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub route: std::option::Option<crate::model::Route>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRouteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRouteRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [route_id][crate::model::CreateRouteRequest::route_id].
    pub fn set_route_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.route_id = v.into();
        self
    }

    /// Sets the value of [route][crate::model::CreateRouteRequest::route].
    pub fn set_route<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Route>,
    {
        self.route = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [route][crate::model::CreateRouteRequest::route].
    pub fn set_or_clear_route<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Route>,
    {
        self.route = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateRouteRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateRouteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.CreateRouteRequest"
    }
}

/// Route list request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRoutesRequest {
    /// Required. The parent that owns the collection of Routess.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of Routes to return. The service may return
    /// fewer than this value. If unspecified, at most 50 Routes
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Page token received from a previous `ListRoutes` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListRoutes` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRoutesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRoutesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRoutesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRoutesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRoutesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListRoutesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListRoutesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListRoutesRequest"
    }
}

/// Route list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRoutesResponse {
    /// List of Routes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub routes: std::vec::Vec<crate::model::Route>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRoutesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [routes][crate::model::ListRoutesResponse::routes].
    pub fn set_routes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Route>,
    {
        use std::iter::Iterator;
        self.routes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRoutesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListRoutesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRoutesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListRoutesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRoutesResponse {
    type PageItem = crate::model::Route;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.routes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Route deletion request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRouteRequest {
    /// Required. The name of the Route resource to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRouteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRouteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteRouteRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRouteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DeleteRouteRequest"
    }
}

/// Route get request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRouteRequest {
    /// Required. The name of the Route resource to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRouteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRouteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRouteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GetRouteRequest"
    }
}

/// Oracle database profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OracleProfile {
    /// Required. Hostname for the Oracle connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Port for the Oracle connection, default value is 1521.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub port: i32,

    /// Required. Username for the Oracle connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Optional. Password for the Oracle connection. Mutually exclusive with the
    /// `secret_manager_stored_password` field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Required. Database for the Oracle connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_service: std::string::String,

    /// Connection string attributes
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub connection_attributes: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. SSL configuration for the Oracle connection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub oracle_ssl_config: std::option::Option<crate::model::OracleSslConfig>,

    /// Optional. Configuration for Oracle ASM connection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub oracle_asm_config: std::option::Option<crate::model::OracleAsmConfig>,

    /// Optional. A reference to a Secret Manager resource name storing the Oracle
    /// connection password. Mutually exclusive with the `password` field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret_manager_stored_password: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::OracleProfile::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [port][crate::model::OracleProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::OracleProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::OracleProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [database_service][crate::model::OracleProfile::database_service].
    pub fn set_database_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_service = v.into();
        self
    }

    /// Sets the value of [connection_attributes][crate::model::OracleProfile::connection_attributes].
    pub fn set_connection_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.connection_attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [oracle_ssl_config][crate::model::OracleProfile::oracle_ssl_config].
    pub fn set_oracle_ssl_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OracleSslConfig>,
    {
        self.oracle_ssl_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [oracle_ssl_config][crate::model::OracleProfile::oracle_ssl_config].
    pub fn set_or_clear_oracle_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OracleSslConfig>,
    {
        self.oracle_ssl_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [oracle_asm_config][crate::model::OracleProfile::oracle_asm_config].
    pub fn set_oracle_asm_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OracleAsmConfig>,
    {
        self.oracle_asm_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [oracle_asm_config][crate::model::OracleProfile::oracle_asm_config].
    pub fn set_or_clear_oracle_asm_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OracleAsmConfig>,
    {
        self.oracle_asm_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secret_manager_stored_password][crate::model::OracleProfile::secret_manager_stored_password].
    pub fn set_secret_manager_stored_password<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secret_manager_stored_password = v.into();
        self
    }
}

impl wkt::message::Message for OracleProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleProfile"
    }
}

/// Configuration for Oracle Automatic Storage Management (ASM) connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OracleAsmConfig {
    /// Required. Hostname for the Oracle ASM connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Required. Port for the Oracle ASM connection.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub port: i32,

    /// Required. Username for the Oracle ASM connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Optional. Password for the Oracle ASM connection. Mutually exclusive with
    /// the `secret_manager_stored_password` field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Required. ASM service name for the Oracle ASM connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub asm_service: std::string::String,

    /// Optional. Connection string attributes
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub connection_attributes: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. SSL configuration for the Oracle connection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub oracle_ssl_config: std::option::Option<crate::model::OracleSslConfig>,

    /// Optional. A reference to a Secret Manager resource name storing the Oracle
    /// ASM connection password. Mutually exclusive with the `password` field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret_manager_stored_password: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleAsmConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::OracleAsmConfig::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [port][crate::model::OracleAsmConfig::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::OracleAsmConfig::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::OracleAsmConfig::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [asm_service][crate::model::OracleAsmConfig::asm_service].
    pub fn set_asm_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asm_service = v.into();
        self
    }

    /// Sets the value of [connection_attributes][crate::model::OracleAsmConfig::connection_attributes].
    pub fn set_connection_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.connection_attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [oracle_ssl_config][crate::model::OracleAsmConfig::oracle_ssl_config].
    pub fn set_oracle_ssl_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OracleSslConfig>,
    {
        self.oracle_ssl_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [oracle_ssl_config][crate::model::OracleAsmConfig::oracle_ssl_config].
    pub fn set_or_clear_oracle_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OracleSslConfig>,
    {
        self.oracle_ssl_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secret_manager_stored_password][crate::model::OracleAsmConfig::secret_manager_stored_password].
    pub fn set_secret_manager_stored_password<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secret_manager_stored_password = v.into();
        self
    }
}

impl wkt::message::Message for OracleAsmConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleAsmConfig"
    }
}

/// MySQL database profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MysqlProfile {
    /// Required. Hostname for the MySQL connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Port for the MySQL connection, default value is 3306.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub port: i32,

    /// Required. Username for the MySQL connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Optional. Input only. Password for the MySQL connection. Mutually exclusive
    /// with the `secret_manager_stored_password` field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// SSL configuration for the MySQL connection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssl_config: std::option::Option<crate::model::MysqlSslConfig>,

    /// Optional. A reference to a Secret Manager resource name storing the MySQL
    /// connection password. Mutually exclusive with the `password` field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret_manager_stored_password: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::MysqlProfile::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [port][crate::model::MysqlProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::MysqlProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::MysqlProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [ssl_config][crate::model::MysqlProfile::ssl_config].
    pub fn set_ssl_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MysqlSslConfig>,
    {
        self.ssl_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl_config][crate::model::MysqlProfile::ssl_config].
    pub fn set_or_clear_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MysqlSslConfig>,
    {
        self.ssl_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secret_manager_stored_password][crate::model::MysqlProfile::secret_manager_stored_password].
    pub fn set_secret_manager_stored_password<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secret_manager_stored_password = v.into();
        self
    }
}

impl wkt::message::Message for MysqlProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlProfile"
    }
}

/// PostgreSQL database profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostgresqlProfile {
    /// Required. Hostname for the PostgreSQL connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Port for the PostgreSQL connection, default value is 5432.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub port: i32,

    /// Required. Username for the PostgreSQL connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Optional. Password for the PostgreSQL connection. Mutually exclusive with
    /// the `secret_manager_stored_password` field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Required. Database for the PostgreSQL connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Optional. A reference to a Secret Manager resource name storing the
    /// PostgreSQL connection password. Mutually exclusive with the `password`
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret_manager_stored_password: std::string::String,

    /// Optional. SSL configuration for the PostgreSQL connection.
    /// In case PostgresqlSslConfig is not set, the connection will use the default
    /// SSL mode, which is `prefer` (i.e. this mode will only use encryption if
    /// enabled from database side, otherwise will use unencrypted communication)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssl_config: std::option::Option<crate::model::PostgresqlSslConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::PostgresqlProfile::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [port][crate::model::PostgresqlProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::PostgresqlProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::PostgresqlProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [database][crate::model::PostgresqlProfile::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [secret_manager_stored_password][crate::model::PostgresqlProfile::secret_manager_stored_password].
    pub fn set_secret_manager_stored_password<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secret_manager_stored_password = v.into();
        self
    }

    /// Sets the value of [ssl_config][crate::model::PostgresqlProfile::ssl_config].
    pub fn set_ssl_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PostgresqlSslConfig>,
    {
        self.ssl_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl_config][crate::model::PostgresqlProfile::ssl_config].
    pub fn set_or_clear_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PostgresqlSslConfig>,
    {
        self.ssl_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PostgresqlProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlProfile"
    }
}

/// SQLServer database profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerProfile {
    /// Required. Hostname for the SQLServer connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Port for the SQLServer connection, default value is 1433.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub port: i32,

    /// Required. Username for the SQLServer connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Optional. Password for the SQLServer connection. Mutually exclusive with
    /// the `secret_manager_stored_password` field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Required. Database for the SQLServer connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Optional. A reference to a Secret Manager resource name storing the
    /// SQLServer connection password. Mutually exclusive with the `password`
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret_manager_stored_password: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::SqlServerProfile::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [port][crate::model::SqlServerProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::SqlServerProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::SqlServerProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [database][crate::model::SqlServerProfile::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [secret_manager_stored_password][crate::model::SqlServerProfile::secret_manager_stored_password].
    pub fn set_secret_manager_stored_password<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secret_manager_stored_password = v.into();
        self
    }
}

impl wkt::message::Message for SqlServerProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerProfile"
    }
}

/// Salesforce profile
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SalesforceProfile {
    /// Required. Domain endpoint for the Salesforce connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain: std::string::String,

    /// Credentials for Salesforce connection.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub credentials: std::option::Option<crate::model::salesforce_profile::Credentials>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SalesforceProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domain][crate::model::SalesforceProfile::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [credentials][crate::model::SalesforceProfile::credentials].
    ///
    /// Note that all the setters affecting `credentials` are mutually
    /// exclusive.
    pub fn set_credentials<
        T: std::convert::Into<std::option::Option<crate::model::salesforce_profile::Credentials>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials = v.into();
        self
    }

    /// The value of [credentials][crate::model::SalesforceProfile::credentials]
    /// if it holds a `UserCredentials`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_credentials(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::salesforce_profile::UserCredentials>>
    {
        #[allow(unreachable_patterns)]
        self.credentials.as_ref().and_then(|v| match v {
            crate::model::salesforce_profile::Credentials::UserCredentials(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [credentials][crate::model::SalesforceProfile::credentials]
    /// to hold a `UserCredentials`.
    ///
    /// Note that all the setters affecting `credentials` are
    /// mutually exclusive.
    pub fn set_user_credentials<
        T: std::convert::Into<std::boxed::Box<crate::model::salesforce_profile::UserCredentials>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials = std::option::Option::Some(
            crate::model::salesforce_profile::Credentials::UserCredentials(v.into()),
        );
        self
    }

    /// The value of [credentials][crate::model::SalesforceProfile::credentials]
    /// if it holds a `Oauth2ClientCredentials`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oauth2_client_credentials(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::salesforce_profile::Oauth2ClientCredentials>,
    > {
        #[allow(unreachable_patterns)]
        self.credentials.as_ref().and_then(|v| match v {
            crate::model::salesforce_profile::Credentials::Oauth2ClientCredentials(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [credentials][crate::model::SalesforceProfile::credentials]
    /// to hold a `Oauth2ClientCredentials`.
    ///
    /// Note that all the setters affecting `credentials` are
    /// mutually exclusive.
    pub fn set_oauth2_client_credentials<
        T: std::convert::Into<
                std::boxed::Box<crate::model::salesforce_profile::Oauth2ClientCredentials>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials = std::option::Option::Some(
            crate::model::salesforce_profile::Credentials::Oauth2ClientCredentials(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SalesforceProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SalesforceProfile"
    }
}

/// Defines additional types related to [SalesforceProfile].
pub mod salesforce_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Username-password credentials.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UserCredentials {
        /// Required. Username for the Salesforce connection.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub username: std::string::String,

        /// Optional. Password for the Salesforce connection.
        /// Mutually exclusive with the `secret_manager_stored_password` field.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub password: std::string::String,

        /// Optional. Security token for the Salesforce connection.
        /// Mutually exclusive with the `secret_manager_stored_security_token` field.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub security_token: std::string::String,

        /// Optional. A reference to a Secret Manager resource name storing the
        /// Salesforce connection's password. Mutually exclusive with the `password`
        /// field.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub secret_manager_stored_password: std::string::String,

        /// Optional. A reference to a Secret Manager resource name storing the
        /// Salesforce connection's security token. Mutually exclusive with the
        /// `security_token` field.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub secret_manager_stored_security_token: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserCredentials {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [username][crate::model::salesforce_profile::UserCredentials::username].
        pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.username = v.into();
            self
        }

        /// Sets the value of [password][crate::model::salesforce_profile::UserCredentials::password].
        pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.password = v.into();
            self
        }

        /// Sets the value of [security_token][crate::model::salesforce_profile::UserCredentials::security_token].
        pub fn set_security_token<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.security_token = v.into();
            self
        }

        /// Sets the value of [secret_manager_stored_password][crate::model::salesforce_profile::UserCredentials::secret_manager_stored_password].
        pub fn set_secret_manager_stored_password<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.secret_manager_stored_password = v.into();
            self
        }

        /// Sets the value of [secret_manager_stored_security_token][crate::model::salesforce_profile::UserCredentials::secret_manager_stored_security_token].
        pub fn set_secret_manager_stored_security_token<
            T: std::convert::Into<std::string::String>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.secret_manager_stored_security_token = v.into();
            self
        }
    }

    impl wkt::message::Message for UserCredentials {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SalesforceProfile.UserCredentials"
        }
    }

    /// OAuth2 Client Credentials.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Oauth2ClientCredentials {
        /// Required. Client ID for Salesforce OAuth2 Client Credentials.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub client_id: std::string::String,

        /// Optional. Client secret for Salesforce OAuth2 Client Credentials.
        /// Mutually exclusive with the `secret_manager_stored_client_secret` field.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub client_secret: std::string::String,

        /// Optional. A reference to a Secret Manager resource name storing the
        /// Salesforce OAuth2 client_secret. Mutually exclusive with the
        /// `client_secret` field.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub secret_manager_stored_client_secret: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Oauth2ClientCredentials {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [client_id][crate::model::salesforce_profile::Oauth2ClientCredentials::client_id].
        pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client_id = v.into();
            self
        }

        /// Sets the value of [client_secret][crate::model::salesforce_profile::Oauth2ClientCredentials::client_secret].
        pub fn set_client_secret<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.client_secret = v.into();
            self
        }

        /// Sets the value of [secret_manager_stored_client_secret][crate::model::salesforce_profile::Oauth2ClientCredentials::secret_manager_stored_client_secret].
        pub fn set_secret_manager_stored_client_secret<
            T: std::convert::Into<std::string::String>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.secret_manager_stored_client_secret = v.into();
            self
        }
    }

    impl wkt::message::Message for Oauth2ClientCredentials {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SalesforceProfile.Oauth2ClientCredentials"
        }
    }

    /// Credentials for Salesforce connection.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Credentials {
        /// User-password authentication.
        UserCredentials(std::boxed::Box<crate::model::salesforce_profile::UserCredentials>),
        /// Connected app authentication.
        Oauth2ClientCredentials(
            std::boxed::Box<crate::model::salesforce_profile::Oauth2ClientCredentials>,
        ),
    }
}

/// Cloud Storage bucket profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsProfile {
    /// Required. The Cloud Storage bucket name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// The root path inside the Cloud Storage bucket.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub root_path: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::GcsProfile::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [root_path][crate::model::GcsProfile::root_path].
    pub fn set_root_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_path = v.into();
        self
    }
}

impl wkt::message::Message for GcsProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GcsProfile"
    }
}

/// BigQuery warehouse profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryProfile {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BigQueryProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.BigQueryProfile"
    }
}

/// Static IP address connectivity. Used when the source database is configured
/// to allow incoming connections from the Datastream public IP addresses
/// for the region specified in the connection profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StaticServiceIpConnectivity {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StaticServiceIpConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StaticServiceIpConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.StaticServiceIpConnectivity"
    }
}

/// Forward SSH Tunnel connectivity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ForwardSshTunnelConnectivity {
    /// Required. Hostname for the SSH tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Required. Username for the SSH tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Port for the SSH tunnel, default value is 22.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub port: i32,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub authentication_method:
        std::option::Option<crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ForwardSshTunnelConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::ForwardSshTunnelConnectivity::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [username][crate::model::ForwardSshTunnelConnectivity::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [port][crate::model::ForwardSshTunnelConnectivity::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method].
    ///
    /// Note that all the setters affecting `authentication_method` are mutually
    /// exclusive.
    pub fn set_authentication_method<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = v.into();
        self
    }

    /// The value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// if it holds a `Password`, `None` if the field is not set or
    /// holds a different branch.
    pub fn password(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::Password(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// to hold a `Password`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::Password(v.into()),
        );
        self
    }

    /// The value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// if it holds a `PrivateKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_key(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::PrivateKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// to hold a `PrivateKey`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::PrivateKey(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ForwardSshTunnelConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ForwardSshTunnelConnectivity"
    }
}

/// Defines additional types related to [ForwardSshTunnelConnectivity].
pub mod forward_ssh_tunnel_connectivity {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AuthenticationMethod {
        /// Input only. SSH password.
        Password(std::string::String),
        /// Input only. SSH private key.
        PrivateKey(std::string::String),
    }
}

/// The VPC Peering configuration is used to create VPC peering between
/// Datastream and the consumer's VPC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VpcPeeringConfig {
    /// Required. Fully qualified name of the VPC that Datastream will peer to.
    /// Format: `projects/{project}/global/{networks}/{name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc: std::string::String,

    /// Required. A free subnet for peering. (CIDR of /29)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpcPeeringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpc][crate::model::VpcPeeringConfig::vpc].
    pub fn set_vpc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::VpcPeeringConfig::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }
}

impl wkt::message::Message for VpcPeeringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.VpcPeeringConfig"
    }
}

/// The PrivateConnection resource is used to establish private connectivity
/// between Datastream and a customer's network.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateConnection {
    /// Output only. Identifier. The resource's name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The create time of the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time of the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The state of the Private Connection.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::private_connection::State,

    /// Output only. In case of error, the details of the error in a user-friendly
    /// format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<crate::model::Error>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<bool>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzi: std::option::Option<bool>,

    /// VPC Peering Config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vpc_peering_config: std::option::Option<crate::model::VpcPeeringConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PrivateConnection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PrivateConnection::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PrivateConnection::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PrivateConnection::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PrivateConnection::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::PrivateConnection::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::PrivateConnection::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PrivateConnection::state].
    pub fn set_state<T: std::convert::Into<crate::model::private_connection::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::PrivateConnection::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Error>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::PrivateConnection::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Error>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::PrivateConnection::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::PrivateConnection::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::PrivateConnection::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::PrivateConnection::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vpc_peering_config][crate::model::PrivateConnection::vpc_peering_config].
    pub fn set_vpc_peering_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VpcPeeringConfig>,
    {
        self.vpc_peering_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpc_peering_config][crate::model::PrivateConnection::vpc_peering_config].
    pub fn set_or_clear_vpc_peering_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VpcPeeringConfig>,
    {
        self.vpc_peering_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PrivateConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PrivateConnection"
    }
}

/// Defines additional types related to [PrivateConnection].
pub mod private_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Private Connection state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// The private connection is in creation state - creating resources.
        Creating,
        /// The private connection has been created with all of its resources.
        Created,
        /// The private connection creation has failed.
        Failed,
        /// The private connection is being deleted.
        Deleting,
        /// Delete request has failed, resource is in invalid state.
        FailedToDelete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Created => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::FailedToDelete => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Created => std::option::Option::Some("CREATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::FailedToDelete => std::option::Option::Some("FAILED_TO_DELETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Created,
                3 => Self::Failed,
                4 => Self::Deleting,
                5 => Self::FailedToDelete,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "CREATED" => Self::Created,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                "FAILED_TO_DELETE" => Self::FailedToDelete,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Created => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::FailedToDelete => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.datastream.v1.PrivateConnection.State",
            ))
        }
    }
}

/// Private Connectivity
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateConnectivity {
    /// Required. A reference to a private connection resource.
    /// Format: `projects/{project}/locations/{location}/privateConnections/{name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_connection: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_connection][crate::model::PrivateConnectivity::private_connection].
    pub fn set_private_connection<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_connection = v.into();
        self
    }
}

impl wkt::message::Message for PrivateConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PrivateConnectivity"
    }
}

/// The route resource is the child of the private connection resource,
/// used for defining a route for a private connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Route {
    /// Output only. Identifier. The resource's name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The create time of the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time of the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Destination address for connection
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_address: std::string::String,

    /// Destination port for connection
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub destination_port: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Route {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Route::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Route::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Route::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Route::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Route::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Route::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::Route::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [destination_address][crate::model::Route::destination_address].
    pub fn set_destination_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_address = v.into();
        self
    }

    /// Sets the value of [destination_port][crate::model::Route::destination_port].
    pub fn set_destination_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.destination_port = v.into();
        self
    }
}

impl wkt::message::Message for Route {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.Route"
    }
}

/// MySQL SSL configuration information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MysqlSslConfig {
    /// Optional. Input only. PEM-encoded private key associated with the Client
    /// Certificate. If this field is used then the 'client_certificate' and the
    /// 'ca_certificate' fields are mandatory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_key: std::string::String,

    /// Output only. Indicates whether the client_key field is set.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub client_key_set: bool,

    /// Optional. Input only. PEM-encoded certificate that will be used by the
    /// replica to authenticate against the source database server. If this field
    /// is used then the 'client_key' and the 'ca_certificate' fields are
    /// mandatory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_certificate: std::string::String,

    /// Output only. Indicates whether the client_certificate field is set.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub client_certificate_set: bool,

    /// Input only. PEM-encoded certificate of the CA that signed the source
    /// database server's certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ca_certificate: std::string::String,

    /// Output only. Indicates whether the ca_certificate field is set.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ca_certificate_set: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlSslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [client_key][crate::model::MysqlSslConfig::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [client_key_set][crate::model::MysqlSslConfig::client_key_set].
    pub fn set_client_key_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.client_key_set = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::MysqlSslConfig::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [client_certificate_set][crate::model::MysqlSslConfig::client_certificate_set].
    pub fn set_client_certificate_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.client_certificate_set = v.into();
        self
    }

    /// Sets the value of [ca_certificate][crate::model::MysqlSslConfig::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }

    /// Sets the value of [ca_certificate_set][crate::model::MysqlSslConfig::ca_certificate_set].
    pub fn set_ca_certificate_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ca_certificate_set = v.into();
        self
    }
}

impl wkt::message::Message for MysqlSslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlSslConfig"
    }
}

/// Oracle SSL configuration information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OracleSslConfig {
    /// Input only. PEM-encoded certificate of the CA that signed the source
    /// database server's certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ca_certificate: std::string::String,

    /// Output only. Indicates whether the ca_certificate field has been set for
    /// this Connection-Profile.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ca_certificate_set: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleSslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ca_certificate][crate::model::OracleSslConfig::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }

    /// Sets the value of [ca_certificate_set][crate::model::OracleSslConfig::ca_certificate_set].
    pub fn set_ca_certificate_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ca_certificate_set = v.into();
        self
    }
}

impl wkt::message::Message for OracleSslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleSslConfig"
    }
}

/// PostgreSQL SSL configuration information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostgresqlSslConfig {
    /// The encryption settings available for PostgreSQL connection profiles.
    /// This captures various SSL mode supported by PostgreSQL, which includes
    /// TLS encryption with server verification, TLS encryption with both server
    /// and client verification and no TLS encryption.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_setting:
        std::option::Option<crate::model::postgresql_ssl_config::EncryptionSetting>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlSslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_setting][crate::model::PostgresqlSslConfig::encryption_setting].
    ///
    /// Note that all the setters affecting `encryption_setting` are mutually
    /// exclusive.
    pub fn set_encryption_setting<
        T: std::convert::Into<
                std::option::Option<crate::model::postgresql_ssl_config::EncryptionSetting>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_setting = v.into();
        self
    }

    /// The value of [encryption_setting][crate::model::PostgresqlSslConfig::encryption_setting]
    /// if it holds a `ServerVerification`, `None` if the field is not set or
    /// holds a different branch.
    pub fn server_verification(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::postgresql_ssl_config::ServerVerification>,
    > {
        #[allow(unreachable_patterns)]
        self.encryption_setting.as_ref().and_then(|v| match v {
            crate::model::postgresql_ssl_config::EncryptionSetting::ServerVerification(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [encryption_setting][crate::model::PostgresqlSslConfig::encryption_setting]
    /// to hold a `ServerVerification`.
    ///
    /// Note that all the setters affecting `encryption_setting` are
    /// mutually exclusive.
    pub fn set_server_verification<
        T: std::convert::Into<
                std::boxed::Box<crate::model::postgresql_ssl_config::ServerVerification>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_setting = std::option::Option::Some(
            crate::model::postgresql_ssl_config::EncryptionSetting::ServerVerification(v.into()),
        );
        self
    }

    /// The value of [encryption_setting][crate::model::PostgresqlSslConfig::encryption_setting]
    /// if it holds a `ServerAndClientVerification`, `None` if the field is not set or
    /// holds a different branch.
    pub fn server_and_client_verification(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::postgresql_ssl_config::ServerAndClientVerification>,
    > {
        #[allow(unreachable_patterns)]
        self.encryption_setting.as_ref().and_then(|v| match v {
            crate::model::postgresql_ssl_config::EncryptionSetting::ServerAndClientVerification(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [encryption_setting][crate::model::PostgresqlSslConfig::encryption_setting]
    /// to hold a `ServerAndClientVerification`.
    ///
    /// Note that all the setters affecting `encryption_setting` are
    /// mutually exclusive.
    pub fn set_server_and_client_verification<
        T: std::convert::Into<
                std::boxed::Box<crate::model::postgresql_ssl_config::ServerAndClientVerification>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_setting = std::option::Option::Some(
            crate::model::postgresql_ssl_config::EncryptionSetting::ServerAndClientVerification(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for PostgresqlSslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlSslConfig"
    }
}

/// Defines additional types related to [PostgresqlSslConfig].
pub mod postgresql_ssl_config {
    #[allow(unused_imports)]
    use super::*;

    /// Message represents the option where Datastream will enforce the encryption
    /// and authenticate the server identity. ca_certificate must be set if user
    /// selects this option.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ServerVerification {
        /// Required. Input only. PEM-encoded server root CA certificate.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub ca_certificate: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ServerVerification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ca_certificate][crate::model::postgresql_ssl_config::ServerVerification::ca_certificate].
        pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.ca_certificate = v.into();
            self
        }
    }

    impl wkt::message::Message for ServerVerification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.PostgresqlSslConfig.ServerVerification"
        }
    }

    /// Message represents the option where Datastream will enforce the encryption
    /// and authenticate the server identity as well as the client identity.
    /// ca_certificate, client_certificate and client_key must be set if user
    /// selects this option.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ServerAndClientVerification {
        /// Required. Input only. PEM-encoded certificate used by the source database
        /// to authenticate the client identity (i.e., the Datastream's identity).
        /// This certificate is signed by either a root certificate trusted by the
        /// server or one or more intermediate certificates (which is stored with the
        /// leaf certificate) to link the this certificate to the trusted root
        /// certificate.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub client_certificate: std::string::String,

        /// Optional. Input only. PEM-encoded private key associated with the client
        /// certificate. This value will be used during the SSL/TLS handshake,
        /// allowing the PostgreSQL server to authenticate the client's identity,
        /// i.e. identity of the Datastream.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub client_key: std::string::String,

        /// Required. Input only. PEM-encoded server root CA certificate.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub ca_certificate: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ServerAndClientVerification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [client_certificate][crate::model::postgresql_ssl_config::ServerAndClientVerification::client_certificate].
        pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.client_certificate = v.into();
            self
        }

        /// Sets the value of [client_key][crate::model::postgresql_ssl_config::ServerAndClientVerification::client_key].
        pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client_key = v.into();
            self
        }

        /// Sets the value of [ca_certificate][crate::model::postgresql_ssl_config::ServerAndClientVerification::ca_certificate].
        pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.ca_certificate = v.into();
            self
        }
    }

    impl wkt::message::Message for ServerAndClientVerification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.PostgresqlSslConfig.ServerAndClientVerification"
        }
    }

    /// The encryption settings available for PostgreSQL connection profiles.
    /// This captures various SSL mode supported by PostgreSQL, which includes
    /// TLS encryption with server verification, TLS encryption with both server
    /// and client verification and no TLS encryption.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EncryptionSetting {
        /// If this field is set, the communication will be encrypted with TLS
        /// encryption and the server identity will be authenticated.
        ServerVerification(
            std::boxed::Box<crate::model::postgresql_ssl_config::ServerVerification>,
        ),
        /// If this field is set, the communication will be encrypted with TLS
        /// encryption and both the server identity and the client identity will be
        /// authenticated.
        ServerAndClientVerification(
            std::boxed::Box<crate::model::postgresql_ssl_config::ServerAndClientVerification>,
        ),
    }
}

/// A set of reusable connection configurations to be used as a source or
/// destination for a stream.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectionProfile {
    /// Output only. Identifier. The resource's name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The create time of the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time of the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<bool>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzi: std::option::Option<bool>,

    /// Connection configuration for the ConnectionProfile.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub profile: std::option::Option<crate::model::connection_profile::Profile>,

    /// Connectivity options used to establish a connection to the profile.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connectivity: std::option::Option<crate::model::connection_profile::Connectivity>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConnectionProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConnectionProfile::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ConnectionProfile::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ConnectionProfile::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ConnectionProfile::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ConnectionProfile::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::ConnectionProfile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::ConnectionProfile::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::ConnectionProfile::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::ConnectionProfile::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::ConnectionProfile::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile].
    ///
    /// Note that all the setters affecting `profile` are mutually
    /// exclusive.
    pub fn set_profile<
        T: std::convert::Into<std::option::Option<crate::model::connection_profile::Profile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = v.into();
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `OracleProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OracleProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::OracleProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `OracleProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_oracle_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::OracleProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::OracleProfile(v.into()),
        );
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `GcsProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_profile(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::GcsProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `GcsProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_gcs_profile<T: std::convert::Into<std::boxed::Box<crate::model::GcsProfile>>>(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::GcsProfile(v.into()),
        );
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `MysqlProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MysqlProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::MysqlProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `MysqlProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_mysql_profile<T: std::convert::Into<std::boxed::Box<crate::model::MysqlProfile>>>(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::MysqlProfile(v.into()),
        );
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `BigqueryProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::BigqueryProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `BigqueryProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_bigquery_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::BigqueryProfile(v.into()),
        );
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `PostgresqlProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostgresqlProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::PostgresqlProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `PostgresqlProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_postgresql_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::PostgresqlProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::PostgresqlProfile(v.into()),
        );
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `SqlServerProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_server_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::SqlServerProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `SqlServerProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_sql_server_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::SqlServerProfile(v.into()),
        );
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `SalesforceProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn salesforce_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SalesforceProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::SalesforceProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `SalesforceProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_salesforce_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::SalesforceProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::SalesforceProfile(v.into()),
        );
        self
    }

    /// Sets the value of [connectivity][crate::model::ConnectionProfile::connectivity].
    ///
    /// Note that all the setters affecting `connectivity` are mutually
    /// exclusive.
    pub fn set_connectivity<
        T: std::convert::Into<std::option::Option<crate::model::connection_profile::Connectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::ConnectionProfile::connectivity]
    /// if it holds a `StaticServiceIpConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn static_service_ip_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticServiceIpConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Connectivity::StaticServiceIpConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::ConnectionProfile::connectivity]
    /// to hold a `StaticServiceIpConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_static_service_ip_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticServiceIpConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::connection_profile::Connectivity::StaticServiceIpConnectivity(v.into()),
        );
        self
    }

    /// The value of [connectivity][crate::model::ConnectionProfile::connectivity]
    /// if it holds a `ForwardSshConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn forward_ssh_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Connectivity::ForwardSshConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::ConnectionProfile::connectivity]
    /// to hold a `ForwardSshConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_forward_ssh_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::connection_profile::Connectivity::ForwardSshConnectivity(v.into()),
        );
        self
    }

    /// The value of [connectivity][crate::model::ConnectionProfile::connectivity]
    /// if it holds a `PrivateConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrivateConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Connectivity::PrivateConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::ConnectionProfile::connectivity]
    /// to hold a `PrivateConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_private_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::PrivateConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::connection_profile::Connectivity::PrivateConnectivity(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ConnectionProfile"
    }
}

/// Defines additional types related to [ConnectionProfile].
pub mod connection_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Connection configuration for the ConnectionProfile.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Profile {
        /// Oracle ConnectionProfile configuration.
        OracleProfile(std::boxed::Box<crate::model::OracleProfile>),
        /// Cloud Storage ConnectionProfile configuration.
        GcsProfile(std::boxed::Box<crate::model::GcsProfile>),
        /// MySQL ConnectionProfile configuration.
        MysqlProfile(std::boxed::Box<crate::model::MysqlProfile>),
        /// BigQuery Connection Profile configuration.
        BigqueryProfile(std::boxed::Box<crate::model::BigQueryProfile>),
        /// PostgreSQL Connection Profile configuration.
        PostgresqlProfile(std::boxed::Box<crate::model::PostgresqlProfile>),
        /// SQLServer Connection Profile configuration.
        SqlServerProfile(std::boxed::Box<crate::model::SqlServerProfile>),
        /// Salesforce Connection Profile configuration.
        SalesforceProfile(std::boxed::Box<crate::model::SalesforceProfile>),
    }

    /// Connectivity options used to establish a connection to the profile.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Connectivity {
        /// Static Service IP connectivity.
        StaticServiceIpConnectivity(std::boxed::Box<crate::model::StaticServiceIpConnectivity>),
        /// Forward SSH tunnel connectivity.
        ForwardSshConnectivity(std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>),
        /// Private connectivity.
        PrivateConnectivity(std::boxed::Box<crate::model::PrivateConnectivity>),
    }
}

/// Oracle Column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OracleColumn {
    /// Column name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub column: std::string::String,

    /// The Oracle data type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_type: std::string::String,

    /// Column length.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub length: i32,

    /// Column precision.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub precision: i32,

    /// Column scale.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub scale: i32,

    /// Column encoding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encoding: std::string::String,

    /// Whether or not the column represents a primary key.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub primary_key: bool,

    /// Whether or not the column can accept a null value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub nullable: bool,

    /// The ordinal position of the column in the table.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub ordinal_position: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::OracleColumn::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::OracleColumn::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [length][crate::model::OracleColumn::length].
    pub fn set_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::OracleColumn::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::OracleColumn::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [encoding][crate::model::OracleColumn::encoding].
    pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [primary_key][crate::model::OracleColumn::primary_key].
    pub fn set_primary_key<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.primary_key = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::OracleColumn::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::OracleColumn::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }
}

impl wkt::message::Message for OracleColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleColumn"
    }
}

/// Oracle table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OracleTable {
    /// Table name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table: std::string::String,

    /// Oracle columns in the schema.
    /// When unspecified as part of include/exclude objects, includes/excludes
    /// everything.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub oracle_columns: std::vec::Vec<crate::model::OracleColumn>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::OracleTable::table].
    pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [oracle_columns][crate::model::OracleTable::oracle_columns].
    pub fn set_oracle_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OracleColumn>,
    {
        use std::iter::Iterator;
        self.oracle_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OracleTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleTable"
    }
}

/// Oracle schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OracleSchema {
    /// Schema name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema: std::string::String,

    /// Tables in the schema.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub oracle_tables: std::vec::Vec<crate::model::OracleTable>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema][crate::model::OracleSchema::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [oracle_tables][crate::model::OracleSchema::oracle_tables].
    pub fn set_oracle_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OracleTable>,
    {
        use std::iter::Iterator;
        self.oracle_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OracleSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleSchema"
    }
}

/// Oracle database structure.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OracleRdbms {
    /// Oracle schemas/databases in the database server.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub oracle_schemas: std::vec::Vec<crate::model::OracleSchema>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleRdbms {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [oracle_schemas][crate::model::OracleRdbms::oracle_schemas].
    pub fn set_oracle_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OracleSchema>,
    {
        use std::iter::Iterator;
        self.oracle_schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OracleRdbms {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleRdbms"
    }
}

/// Oracle data source configuration
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OracleSourceConfig {
    /// Oracle objects to include in the stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub include_objects: std::option::Option<crate::model::OracleRdbms>,

    /// Oracle objects to exclude from the stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub exclude_objects: std::option::Option<crate::model::OracleRdbms>,

    /// Maximum number of concurrent CDC tasks. The number should be non-negative.
    /// If not set (or set to 0), the system's default value is used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub max_concurrent_cdc_tasks: i32,

    /// Maximum number of concurrent backfill tasks. The number should be
    /// non-negative. If not set (or set to 0), the system's default value is used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub max_concurrent_backfill_tasks: i32,

    /// The configuration for handle Oracle large objects.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub large_objects_handling:
        std::option::Option<crate::model::oracle_source_config::LargeObjectsHandling>,

    /// Configuration to select the CDC method.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub cdc_method: std::option::Option<crate::model::oracle_source_config::CdcMethod>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleSourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_objects][crate::model::OracleSourceConfig::include_objects].
    pub fn set_include_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OracleRdbms>,
    {
        self.include_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [include_objects][crate::model::OracleSourceConfig::include_objects].
    pub fn set_or_clear_include_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OracleRdbms>,
    {
        self.include_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exclude_objects][crate::model::OracleSourceConfig::exclude_objects].
    pub fn set_exclude_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OracleRdbms>,
    {
        self.exclude_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclude_objects][crate::model::OracleSourceConfig::exclude_objects].
    pub fn set_or_clear_exclude_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OracleRdbms>,
    {
        self.exclude_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_concurrent_cdc_tasks][crate::model::OracleSourceConfig::max_concurrent_cdc_tasks].
    pub fn set_max_concurrent_cdc_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_cdc_tasks = v.into();
        self
    }

    /// Sets the value of [max_concurrent_backfill_tasks][crate::model::OracleSourceConfig::max_concurrent_backfill_tasks].
    pub fn set_max_concurrent_backfill_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_backfill_tasks = v.into();
        self
    }

    /// Sets the value of [large_objects_handling][crate::model::OracleSourceConfig::large_objects_handling].
    ///
    /// Note that all the setters affecting `large_objects_handling` are mutually
    /// exclusive.
    pub fn set_large_objects_handling<
        T: std::convert::Into<
                std::option::Option<crate::model::oracle_source_config::LargeObjectsHandling>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.large_objects_handling = v.into();
        self
    }

    /// The value of [large_objects_handling][crate::model::OracleSourceConfig::large_objects_handling]
    /// if it holds a `DropLargeObjects`, `None` if the field is not set or
    /// holds a different branch.
    pub fn drop_large_objects(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::oracle_source_config::DropLargeObjects>>
    {
        #[allow(unreachable_patterns)]
        self.large_objects_handling.as_ref().and_then(|v| match v {
            crate::model::oracle_source_config::LargeObjectsHandling::DropLargeObjects(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [large_objects_handling][crate::model::OracleSourceConfig::large_objects_handling]
    /// to hold a `DropLargeObjects`.
    ///
    /// Note that all the setters affecting `large_objects_handling` are
    /// mutually exclusive.
    pub fn set_drop_large_objects<
        T: std::convert::Into<std::boxed::Box<crate::model::oracle_source_config::DropLargeObjects>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.large_objects_handling = std::option::Option::Some(
            crate::model::oracle_source_config::LargeObjectsHandling::DropLargeObjects(v.into()),
        );
        self
    }

    /// The value of [large_objects_handling][crate::model::OracleSourceConfig::large_objects_handling]
    /// if it holds a `StreamLargeObjects`, `None` if the field is not set or
    /// holds a different branch.
    pub fn stream_large_objects(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::oracle_source_config::StreamLargeObjects>>
    {
        #[allow(unreachable_patterns)]
        self.large_objects_handling.as_ref().and_then(|v| match v {
            crate::model::oracle_source_config::LargeObjectsHandling::StreamLargeObjects(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [large_objects_handling][crate::model::OracleSourceConfig::large_objects_handling]
    /// to hold a `StreamLargeObjects`.
    ///
    /// Note that all the setters affecting `large_objects_handling` are
    /// mutually exclusive.
    pub fn set_stream_large_objects<
        T: std::convert::Into<std::boxed::Box<crate::model::oracle_source_config::StreamLargeObjects>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.large_objects_handling = std::option::Option::Some(
            crate::model::oracle_source_config::LargeObjectsHandling::StreamLargeObjects(v.into()),
        );
        self
    }

    /// Sets the value of [cdc_method][crate::model::OracleSourceConfig::cdc_method].
    ///
    /// Note that all the setters affecting `cdc_method` are mutually
    /// exclusive.
    pub fn set_cdc_method<
        T: std::convert::Into<std::option::Option<crate::model::oracle_source_config::CdcMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = v.into();
        self
    }

    /// The value of [cdc_method][crate::model::OracleSourceConfig::cdc_method]
    /// if it holds a `LogMiner`, `None` if the field is not set or
    /// holds a different branch.
    pub fn log_miner(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::oracle_source_config::LogMiner>> {
        #[allow(unreachable_patterns)]
        self.cdc_method.as_ref().and_then(|v| match v {
            crate::model::oracle_source_config::CdcMethod::LogMiner(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdc_method][crate::model::OracleSourceConfig::cdc_method]
    /// to hold a `LogMiner`.
    ///
    /// Note that all the setters affecting `cdc_method` are
    /// mutually exclusive.
    pub fn set_log_miner<
        T: std::convert::Into<std::boxed::Box<crate::model::oracle_source_config::LogMiner>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = std::option::Option::Some(
            crate::model::oracle_source_config::CdcMethod::LogMiner(v.into()),
        );
        self
    }

    /// The value of [cdc_method][crate::model::OracleSourceConfig::cdc_method]
    /// if it holds a `BinaryLogParser`, `None` if the field is not set or
    /// holds a different branch.
    pub fn binary_log_parser(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::oracle_source_config::BinaryLogParser>>
    {
        #[allow(unreachable_patterns)]
        self.cdc_method.as_ref().and_then(|v| match v {
            crate::model::oracle_source_config::CdcMethod::BinaryLogParser(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdc_method][crate::model::OracleSourceConfig::cdc_method]
    /// to hold a `BinaryLogParser`.
    ///
    /// Note that all the setters affecting `cdc_method` are
    /// mutually exclusive.
    pub fn set_binary_log_parser<
        T: std::convert::Into<std::boxed::Box<crate::model::oracle_source_config::BinaryLogParser>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = std::option::Option::Some(
            crate::model::oracle_source_config::CdcMethod::BinaryLogParser(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OracleSourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig"
    }
}

/// Defines additional types related to [OracleSourceConfig].
pub mod oracle_source_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration to drop large object values.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DropLargeObjects {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DropLargeObjects {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for DropLargeObjects {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig.DropLargeObjects"
        }
    }

    /// Configuration to stream large object values.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StreamLargeObjects {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StreamLargeObjects {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for StreamLargeObjects {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig.StreamLargeObjects"
        }
    }

    /// Configuration to use LogMiner CDC method.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LogMiner {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LogMiner {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for LogMiner {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig.LogMiner"
        }
    }

    /// Configuration to use Binary Log Parser CDC technique.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BinaryLogParser {
        /// Configuration to specify how the log file should be accessed.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub log_file_access: std::option::Option<
            crate::model::oracle_source_config::binary_log_parser::LogFileAccess,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BinaryLogParser {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [log_file_access][crate::model::oracle_source_config::BinaryLogParser::log_file_access].
        ///
        /// Note that all the setters affecting `log_file_access` are mutually
        /// exclusive.
        pub fn set_log_file_access<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::oracle_source_config::binary_log_parser::LogFileAccess,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.log_file_access = v.into();
            self
        }

        /// The value of [log_file_access][crate::model::oracle_source_config::BinaryLogParser::log_file_access]
        /// if it holds a `OracleAsmLogFileAccess`, `None` if the field is not set or
        /// holds a different branch.
        pub fn oracle_asm_log_file_access(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::oracle_source_config::binary_log_parser::OracleAsmLogFileAccess,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.log_file_access.as_ref().and_then(|v| match v {
                crate::model::oracle_source_config::binary_log_parser::LogFileAccess::OracleAsmLogFileAccess(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [log_file_access][crate::model::oracle_source_config::BinaryLogParser::log_file_access]
        /// to hold a `OracleAsmLogFileAccess`.
        ///
        /// Note that all the setters affecting `log_file_access` are
        /// mutually exclusive.
        pub fn set_oracle_asm_log_file_access<T: std::convert::Into<std::boxed::Box<crate::model::oracle_source_config::binary_log_parser::OracleAsmLogFileAccess>>>(mut self, v: T) -> Self{
            self.log_file_access = std::option::Option::Some(
                crate::model::oracle_source_config::binary_log_parser::LogFileAccess::OracleAsmLogFileAccess(
                    v.into()
                )
            );
            self
        }

        /// The value of [log_file_access][crate::model::oracle_source_config::BinaryLogParser::log_file_access]
        /// if it holds a `LogFileDirectories`, `None` if the field is not set or
        /// holds a different branch.
        pub fn log_file_directories(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::oracle_source_config::binary_log_parser::LogFileDirectories,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.log_file_access.as_ref().and_then(|v| match v {
                crate::model::oracle_source_config::binary_log_parser::LogFileAccess::LogFileDirectories(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [log_file_access][crate::model::oracle_source_config::BinaryLogParser::log_file_access]
        /// to hold a `LogFileDirectories`.
        ///
        /// Note that all the setters affecting `log_file_access` are
        /// mutually exclusive.
        pub fn set_log_file_directories<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::oracle_source_config::binary_log_parser::LogFileDirectories,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.log_file_access = std::option::Option::Some(
                crate::model::oracle_source_config::binary_log_parser::LogFileAccess::LogFileDirectories(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for BinaryLogParser {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig.BinaryLogParser"
        }
    }

    /// Defines additional types related to [BinaryLogParser].
    pub mod binary_log_parser {
        #[allow(unused_imports)]
        use super::*;

        /// Configuration to use Oracle ASM to access the log files.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct OracleAsmLogFileAccess {
            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl OracleAsmLogFileAccess {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for OracleAsmLogFileAccess {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig.BinaryLogParser.OracleAsmLogFileAccess"
            }
        }

        /// Configuration to specify the Oracle directories to access the log files.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct LogFileDirectories {
            /// Required. Oracle directory for online logs.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub online_log_directory: std::string::String,

            /// Required. Oracle directory for archived logs.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub archived_log_directory: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl LogFileDirectories {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [online_log_directory][crate::model::oracle_source_config::binary_log_parser::LogFileDirectories::online_log_directory].
            pub fn set_online_log_directory<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.online_log_directory = v.into();
                self
            }

            /// Sets the value of [archived_log_directory][crate::model::oracle_source_config::binary_log_parser::LogFileDirectories::archived_log_directory].
            pub fn set_archived_log_directory<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.archived_log_directory = v.into();
                self
            }
        }

        impl wkt::message::Message for LogFileDirectories {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig.BinaryLogParser.LogFileDirectories"
            }
        }

        /// Configuration to specify how the log file should be accessed.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum LogFileAccess {
            /// Use Oracle ASM.
            OracleAsmLogFileAccess(
                std::boxed::Box<
                    crate::model::oracle_source_config::binary_log_parser::OracleAsmLogFileAccess,
                >,
            ),
            /// Use Oracle directories.
            LogFileDirectories(
                std::boxed::Box<
                    crate::model::oracle_source_config::binary_log_parser::LogFileDirectories,
                >,
            ),
        }
    }

    /// The configuration for handle Oracle large objects.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum LargeObjectsHandling {
        /// Drop large object values.
        DropLargeObjects(std::boxed::Box<crate::model::oracle_source_config::DropLargeObjects>),
        /// Stream large object values.
        StreamLargeObjects(std::boxed::Box<crate::model::oracle_source_config::StreamLargeObjects>),
    }

    /// Configuration to select the CDC method.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum CdcMethod {
        /// Use LogMiner.
        LogMiner(std::boxed::Box<crate::model::oracle_source_config::LogMiner>),
        /// Use Binary Log Parser.
        BinaryLogParser(std::boxed::Box<crate::model::oracle_source_config::BinaryLogParser>),
    }
}

/// PostgreSQL Column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostgresqlColumn {
    /// Column name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub column: std::string::String,

    /// The PostgreSQL data type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_type: std::string::String,

    /// Column length.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub length: i32,

    /// Column precision.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub precision: i32,

    /// Column scale.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub scale: i32,

    /// Whether or not the column represents a primary key.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub primary_key: bool,

    /// Whether or not the column can accept a null value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub nullable: bool,

    /// The ordinal position of the column in the table.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub ordinal_position: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::PostgresqlColumn::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::PostgresqlColumn::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [length][crate::model::PostgresqlColumn::length].
    pub fn set_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::PostgresqlColumn::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::PostgresqlColumn::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [primary_key][crate::model::PostgresqlColumn::primary_key].
    pub fn set_primary_key<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.primary_key = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::PostgresqlColumn::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::PostgresqlColumn::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }
}

impl wkt::message::Message for PostgresqlColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlColumn"
    }
}

/// PostgreSQL table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostgresqlTable {
    /// Table name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table: std::string::String,

    /// PostgreSQL columns in the schema.
    /// When unspecified as part of include/exclude objects,
    /// includes/excludes everything.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub postgresql_columns: std::vec::Vec<crate::model::PostgresqlColumn>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::PostgresqlTable::table].
    pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [postgresql_columns][crate::model::PostgresqlTable::postgresql_columns].
    pub fn set_postgresql_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PostgresqlColumn>,
    {
        use std::iter::Iterator;
        self.postgresql_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PostgresqlTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlTable"
    }
}

/// PostgreSQL schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostgresqlSchema {
    /// Schema name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema: std::string::String,

    /// Tables in the schema.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub postgresql_tables: std::vec::Vec<crate::model::PostgresqlTable>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema][crate::model::PostgresqlSchema::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [postgresql_tables][crate::model::PostgresqlSchema::postgresql_tables].
    pub fn set_postgresql_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PostgresqlTable>,
    {
        use std::iter::Iterator;
        self.postgresql_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PostgresqlSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlSchema"
    }
}

/// PostgreSQL database structure.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostgresqlRdbms {
    /// PostgreSQL schemas in the database server.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub postgresql_schemas: std::vec::Vec<crate::model::PostgresqlSchema>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlRdbms {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [postgresql_schemas][crate::model::PostgresqlRdbms::postgresql_schemas].
    pub fn set_postgresql_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PostgresqlSchema>,
    {
        use std::iter::Iterator;
        self.postgresql_schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PostgresqlRdbms {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlRdbms"
    }
}

/// PostgreSQL data source configuration
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostgresqlSourceConfig {
    /// PostgreSQL objects to include in the stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub include_objects: std::option::Option<crate::model::PostgresqlRdbms>,

    /// PostgreSQL objects to exclude from the stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub exclude_objects: std::option::Option<crate::model::PostgresqlRdbms>,

    /// Required. Immutable. The name of the logical replication slot that's
    /// configured with the pgoutput plugin.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub replication_slot: std::string::String,

    /// Required. The name of the publication that includes the set of all tables
    /// that are defined in the stream's include_objects.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub publication: std::string::String,

    /// Maximum number of concurrent backfill tasks. The number should be non
    /// negative. If not set (or set to 0), the system's default value will be
    /// used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub max_concurrent_backfill_tasks: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlSourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_objects][crate::model::PostgresqlSourceConfig::include_objects].
    pub fn set_include_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PostgresqlRdbms>,
    {
        self.include_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [include_objects][crate::model::PostgresqlSourceConfig::include_objects].
    pub fn set_or_clear_include_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PostgresqlRdbms>,
    {
        self.include_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exclude_objects][crate::model::PostgresqlSourceConfig::exclude_objects].
    pub fn set_exclude_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PostgresqlRdbms>,
    {
        self.exclude_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclude_objects][crate::model::PostgresqlSourceConfig::exclude_objects].
    pub fn set_or_clear_exclude_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PostgresqlRdbms>,
    {
        self.exclude_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replication_slot][crate::model::PostgresqlSourceConfig::replication_slot].
    pub fn set_replication_slot<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.replication_slot = v.into();
        self
    }

    /// Sets the value of [publication][crate::model::PostgresqlSourceConfig::publication].
    pub fn set_publication<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.publication = v.into();
        self
    }

    /// Sets the value of [max_concurrent_backfill_tasks][crate::model::PostgresqlSourceConfig::max_concurrent_backfill_tasks].
    pub fn set_max_concurrent_backfill_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_backfill_tasks = v.into();
        self
    }
}

impl wkt::message::Message for PostgresqlSourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlSourceConfig"
    }
}

/// SQLServer Column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerColumn {
    /// Column name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub column: std::string::String,

    /// The SQLServer data type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_type: std::string::String,

    /// Column length.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub length: i32,

    /// Column precision.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub precision: i32,

    /// Column scale.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub scale: i32,

    /// Whether or not the column represents a primary key.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub primary_key: bool,

    /// Whether or not the column can accept a null value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub nullable: bool,

    /// The ordinal position of the column in the table.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub ordinal_position: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::SqlServerColumn::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::SqlServerColumn::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [length][crate::model::SqlServerColumn::length].
    pub fn set_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::SqlServerColumn::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::SqlServerColumn::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [primary_key][crate::model::SqlServerColumn::primary_key].
    pub fn set_primary_key<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.primary_key = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::SqlServerColumn::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::SqlServerColumn::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }
}

impl wkt::message::Message for SqlServerColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerColumn"
    }
}

/// SQLServer table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerTable {
    /// Table name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table: std::string::String,

    /// SQLServer columns in the schema.
    /// When unspecified as part of include/exclude objects,
    /// includes/excludes everything.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub columns: std::vec::Vec<crate::model::SqlServerColumn>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::SqlServerTable::table].
    pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [columns][crate::model::SqlServerTable::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlServerColumn>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlServerTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerTable"
    }
}

/// SQLServer schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerSchema {
    /// Schema name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema: std::string::String,

    /// Tables in the schema.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tables: std::vec::Vec<crate::model::SqlServerTable>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema][crate::model::SqlServerSchema::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [tables][crate::model::SqlServerSchema::tables].
    pub fn set_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlServerTable>,
    {
        use std::iter::Iterator;
        self.tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlServerSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerSchema"
    }
}

/// SQLServer database structure.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerRdbms {
    /// SQLServer schemas in the database server.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub schemas: std::vec::Vec<crate::model::SqlServerSchema>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerRdbms {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schemas][crate::model::SqlServerRdbms::schemas].
    pub fn set_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlServerSchema>,
    {
        use std::iter::Iterator;
        self.schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlServerRdbms {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerRdbms"
    }
}

/// SQLServer data source configuration
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerSourceConfig {
    /// SQLServer objects to include in the stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub include_objects: std::option::Option<crate::model::SqlServerRdbms>,

    /// SQLServer objects to exclude from the stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub exclude_objects: std::option::Option<crate::model::SqlServerRdbms>,

    /// Max concurrent CDC tasks.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub max_concurrent_cdc_tasks: i32,

    /// Max concurrent backfill tasks.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub max_concurrent_backfill_tasks: i32,

    /// Configuration to select the CDC read method for the stream.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub cdc_method: std::option::Option<crate::model::sql_server_source_config::CdcMethod>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerSourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_objects][crate::model::SqlServerSourceConfig::include_objects].
    pub fn set_include_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SqlServerRdbms>,
    {
        self.include_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [include_objects][crate::model::SqlServerSourceConfig::include_objects].
    pub fn set_or_clear_include_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SqlServerRdbms>,
    {
        self.include_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exclude_objects][crate::model::SqlServerSourceConfig::exclude_objects].
    pub fn set_exclude_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SqlServerRdbms>,
    {
        self.exclude_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclude_objects][crate::model::SqlServerSourceConfig::exclude_objects].
    pub fn set_or_clear_exclude_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SqlServerRdbms>,
    {
        self.exclude_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_concurrent_cdc_tasks][crate::model::SqlServerSourceConfig::max_concurrent_cdc_tasks].
    pub fn set_max_concurrent_cdc_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_cdc_tasks = v.into();
        self
    }

    /// Sets the value of [max_concurrent_backfill_tasks][crate::model::SqlServerSourceConfig::max_concurrent_backfill_tasks].
    pub fn set_max_concurrent_backfill_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_backfill_tasks = v.into();
        self
    }

    /// Sets the value of [cdc_method][crate::model::SqlServerSourceConfig::cdc_method].
    ///
    /// Note that all the setters affecting `cdc_method` are mutually
    /// exclusive.
    pub fn set_cdc_method<
        T: std::convert::Into<std::option::Option<crate::model::sql_server_source_config::CdcMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = v.into();
        self
    }

    /// The value of [cdc_method][crate::model::SqlServerSourceConfig::cdc_method]
    /// if it holds a `TransactionLogs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn transaction_logs(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerTransactionLogs>> {
        #[allow(unreachable_patterns)]
        self.cdc_method.as_ref().and_then(|v| match v {
            crate::model::sql_server_source_config::CdcMethod::TransactionLogs(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdc_method][crate::model::SqlServerSourceConfig::cdc_method]
    /// to hold a `TransactionLogs`.
    ///
    /// Note that all the setters affecting `cdc_method` are
    /// mutually exclusive.
    pub fn set_transaction_logs<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerTransactionLogs>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = std::option::Option::Some(
            crate::model::sql_server_source_config::CdcMethod::TransactionLogs(v.into()),
        );
        self
    }

    /// The value of [cdc_method][crate::model::SqlServerSourceConfig::cdc_method]
    /// if it holds a `ChangeTables`, `None` if the field is not set or
    /// holds a different branch.
    pub fn change_tables(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerChangeTables>> {
        #[allow(unreachable_patterns)]
        self.cdc_method.as_ref().and_then(|v| match v {
            crate::model::sql_server_source_config::CdcMethod::ChangeTables(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdc_method][crate::model::SqlServerSourceConfig::cdc_method]
    /// to hold a `ChangeTables`.
    ///
    /// Note that all the setters affecting `cdc_method` are
    /// mutually exclusive.
    pub fn set_change_tables<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerChangeTables>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = std::option::Option::Some(
            crate::model::sql_server_source_config::CdcMethod::ChangeTables(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SqlServerSourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerSourceConfig"
    }
}

/// Defines additional types related to [SqlServerSourceConfig].
pub mod sql_server_source_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration to select the CDC read method for the stream.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum CdcMethod {
        /// CDC reader reads from transaction logs.
        TransactionLogs(std::boxed::Box<crate::model::SqlServerTransactionLogs>),
        /// CDC reader reads from change tables.
        ChangeTables(std::boxed::Box<crate::model::SqlServerChangeTables>),
    }
}

/// Configuration to use Transaction Logs CDC read method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerTransactionLogs {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerTransactionLogs {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SqlServerTransactionLogs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerTransactionLogs"
    }
}

/// Configuration to use Change Tables CDC read method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerChangeTables {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerChangeTables {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SqlServerChangeTables {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerChangeTables"
    }
}

/// MySQL Column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MysqlColumn {
    /// Column name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub column: std::string::String,

    /// The MySQL data type. Full data types list can be found here:
    /// <https://dev.mysql.com/doc/refman/8.0/en/data-types.html>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_type: std::string::String,

    /// Column length.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub length: i32,

    /// Column collation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub collation: std::string::String,

    /// Whether or not the column represents a primary key.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub primary_key: bool,

    /// Whether or not the column can accept a null value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub nullable: bool,

    /// The ordinal position of the column in the table.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub ordinal_position: i32,

    /// Column precision.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub precision: i32,

    /// Column scale.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub scale: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::MysqlColumn::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::MysqlColumn::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [length][crate::model::MysqlColumn::length].
    pub fn set_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::MysqlColumn::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [primary_key][crate::model::MysqlColumn::primary_key].
    pub fn set_primary_key<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.primary_key = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::MysqlColumn::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::MysqlColumn::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::MysqlColumn::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::MysqlColumn::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }
}

impl wkt::message::Message for MysqlColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlColumn"
    }
}

/// MySQL table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MysqlTable {
    /// Table name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table: std::string::String,

    /// MySQL columns in the database.
    /// When unspecified as part of include/exclude objects, includes/excludes
    /// everything.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mysql_columns: std::vec::Vec<crate::model::MysqlColumn>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::MysqlTable::table].
    pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [mysql_columns][crate::model::MysqlTable::mysql_columns].
    pub fn set_mysql_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MysqlColumn>,
    {
        use std::iter::Iterator;
        self.mysql_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MysqlTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlTable"
    }
}

/// MySQL database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MysqlDatabase {
    /// Database name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Tables in the database.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mysql_tables: std::vec::Vec<crate::model::MysqlTable>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlDatabase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::MysqlDatabase::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [mysql_tables][crate::model::MysqlDatabase::mysql_tables].
    pub fn set_mysql_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MysqlTable>,
    {
        use std::iter::Iterator;
        self.mysql_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MysqlDatabase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlDatabase"
    }
}

/// MySQL database structure
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MysqlRdbms {
    /// Mysql databases on the server
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mysql_databases: std::vec::Vec<crate::model::MysqlDatabase>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlRdbms {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mysql_databases][crate::model::MysqlRdbms::mysql_databases].
    pub fn set_mysql_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MysqlDatabase>,
    {
        use std::iter::Iterator;
        self.mysql_databases = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MysqlRdbms {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlRdbms"
    }
}

/// MySQL source configuration
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MysqlSourceConfig {
    /// MySQL objects to retrieve from the source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub include_objects: std::option::Option<crate::model::MysqlRdbms>,

    /// MySQL objects to exclude from the stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub exclude_objects: std::option::Option<crate::model::MysqlRdbms>,

    /// Maximum number of concurrent CDC tasks. The number should be non negative.
    /// If not set (or set to 0), the system's default value will be used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub max_concurrent_cdc_tasks: i32,

    /// Maximum number of concurrent backfill tasks. The number should be non
    /// negative. If not set (or set to 0), the system's default value will be
    /// used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub max_concurrent_backfill_tasks: i32,

    /// The CDC method to use for the stream.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub cdc_method: std::option::Option<crate::model::mysql_source_config::CdcMethod>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlSourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_objects][crate::model::MysqlSourceConfig::include_objects].
    pub fn set_include_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MysqlRdbms>,
    {
        self.include_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [include_objects][crate::model::MysqlSourceConfig::include_objects].
    pub fn set_or_clear_include_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MysqlRdbms>,
    {
        self.include_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exclude_objects][crate::model::MysqlSourceConfig::exclude_objects].
    pub fn set_exclude_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MysqlRdbms>,
    {
        self.exclude_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclude_objects][crate::model::MysqlSourceConfig::exclude_objects].
    pub fn set_or_clear_exclude_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MysqlRdbms>,
    {
        self.exclude_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_concurrent_cdc_tasks][crate::model::MysqlSourceConfig::max_concurrent_cdc_tasks].
    pub fn set_max_concurrent_cdc_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_cdc_tasks = v.into();
        self
    }

    /// Sets the value of [max_concurrent_backfill_tasks][crate::model::MysqlSourceConfig::max_concurrent_backfill_tasks].
    pub fn set_max_concurrent_backfill_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_backfill_tasks = v.into();
        self
    }

    /// Sets the value of [cdc_method][crate::model::MysqlSourceConfig::cdc_method].
    ///
    /// Note that all the setters affecting `cdc_method` are mutually
    /// exclusive.
    pub fn set_cdc_method<
        T: std::convert::Into<std::option::Option<crate::model::mysql_source_config::CdcMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = v.into();
        self
    }

    /// The value of [cdc_method][crate::model::MysqlSourceConfig::cdc_method]
    /// if it holds a `BinaryLogPosition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn binary_log_position(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::mysql_source_config::BinaryLogPosition>>
    {
        #[allow(unreachable_patterns)]
        self.cdc_method.as_ref().and_then(|v| match v {
            crate::model::mysql_source_config::CdcMethod::BinaryLogPosition(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdc_method][crate::model::MysqlSourceConfig::cdc_method]
    /// to hold a `BinaryLogPosition`.
    ///
    /// Note that all the setters affecting `cdc_method` are
    /// mutually exclusive.
    pub fn set_binary_log_position<
        T: std::convert::Into<std::boxed::Box<crate::model::mysql_source_config::BinaryLogPosition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = std::option::Option::Some(
            crate::model::mysql_source_config::CdcMethod::BinaryLogPosition(v.into()),
        );
        self
    }

    /// The value of [cdc_method][crate::model::MysqlSourceConfig::cdc_method]
    /// if it holds a `Gtid`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gtid(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::mysql_source_config::Gtid>> {
        #[allow(unreachable_patterns)]
        self.cdc_method.as_ref().and_then(|v| match v {
            crate::model::mysql_source_config::CdcMethod::Gtid(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdc_method][crate::model::MysqlSourceConfig::cdc_method]
    /// to hold a `Gtid`.
    ///
    /// Note that all the setters affecting `cdc_method` are
    /// mutually exclusive.
    pub fn set_gtid<
        T: std::convert::Into<std::boxed::Box<crate::model::mysql_source_config::Gtid>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method =
            std::option::Option::Some(crate::model::mysql_source_config::CdcMethod::Gtid(v.into()));
        self
    }
}

impl wkt::message::Message for MysqlSourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlSourceConfig"
    }
}

/// Defines additional types related to [MysqlSourceConfig].
pub mod mysql_source_config {
    #[allow(unused_imports)]
    use super::*;

    /// Use Binary log position based replication.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BinaryLogPosition {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BinaryLogPosition {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for BinaryLogPosition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.MysqlSourceConfig.BinaryLogPosition"
        }
    }

    /// Use GTID based replication.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Gtid {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Gtid {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Gtid {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.MysqlSourceConfig.Gtid"
        }
    }

    /// The CDC method to use for the stream.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum CdcMethod {
        /// Use Binary log position based replication.
        BinaryLogPosition(std::boxed::Box<crate::model::mysql_source_config::BinaryLogPosition>),
        /// Use GTID based replication.
        Gtid(std::boxed::Box<crate::model::mysql_source_config::Gtid>),
    }
}

/// Salesforce source configuration
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SalesforceSourceConfig {
    /// Salesforce objects to retrieve from the source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub include_objects: std::option::Option<crate::model::SalesforceOrg>,

    /// Salesforce objects to exclude from the stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub exclude_objects: std::option::Option<crate::model::SalesforceOrg>,

    /// Required. Salesforce objects polling interval. The interval at which new
    /// changes will be polled for each object. The duration must be between 5
    /// minutes and 24 hours.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub polling_interval: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SalesforceSourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_objects][crate::model::SalesforceSourceConfig::include_objects].
    pub fn set_include_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SalesforceOrg>,
    {
        self.include_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [include_objects][crate::model::SalesforceSourceConfig::include_objects].
    pub fn set_or_clear_include_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SalesforceOrg>,
    {
        self.include_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exclude_objects][crate::model::SalesforceSourceConfig::exclude_objects].
    pub fn set_exclude_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SalesforceOrg>,
    {
        self.exclude_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclude_objects][crate::model::SalesforceSourceConfig::exclude_objects].
    pub fn set_or_clear_exclude_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SalesforceOrg>,
    {
        self.exclude_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [polling_interval][crate::model::SalesforceSourceConfig::polling_interval].
    pub fn set_polling_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.polling_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [polling_interval][crate::model::SalesforceSourceConfig::polling_interval].
    pub fn set_or_clear_polling_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.polling_interval = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SalesforceSourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SalesforceSourceConfig"
    }
}

/// Salesforce organization structure.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SalesforceOrg {
    /// Salesforce objects in the database server.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub objects: std::vec::Vec<crate::model::SalesforceObject>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SalesforceOrg {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [objects][crate::model::SalesforceOrg::objects].
    pub fn set_objects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SalesforceObject>,
    {
        use std::iter::Iterator;
        self.objects = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SalesforceOrg {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SalesforceOrg"
    }
}

/// Salesforce object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SalesforceObject {
    /// Object name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object_name: std::string::String,

    /// Salesforce fields.
    /// When unspecified as part of include objects,
    /// includes everything, when unspecified as part of exclude objects,
    /// excludes nothing.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<crate::model::SalesforceField>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SalesforceObject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object_name][crate::model::SalesforceObject::object_name].
    pub fn set_object_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object_name = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::SalesforceObject::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SalesforceField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SalesforceObject {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SalesforceObject"
    }
}

/// Salesforce field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SalesforceField {
    /// Field name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The data type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_type: std::string::String,

    /// Indicates whether the field can accept nil values.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub nillable: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SalesforceField {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SalesforceField::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::SalesforceField::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [nillable][crate::model::SalesforceField::nillable].
    pub fn set_nillable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nillable = v.into();
        self
    }
}

impl wkt::message::Message for SalesforceField {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SalesforceField"
    }
}

/// The configuration of the stream source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceConfig {
    /// Required. Source connection profile resource.
    /// Format: `projects/{project}/locations/{location}/connectionProfiles/{name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_connection_profile: std::string::String,

    /// Stream configuration that is specific to the data source type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_stream_config: std::option::Option<crate::model::source_config::SourceStreamConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_connection_profile][crate::model::SourceConfig::source_connection_profile].
    pub fn set_source_connection_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_connection_profile = v.into();
        self
    }

    /// Sets the value of [source_stream_config][crate::model::SourceConfig::source_stream_config].
    ///
    /// Note that all the setters affecting `source_stream_config` are mutually
    /// exclusive.
    pub fn set_source_stream_config<
        T: std::convert::Into<std::option::Option<crate::model::source_config::SourceStreamConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_stream_config = v.into();
        self
    }

    /// The value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// if it holds a `OracleSourceConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle_source_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OracleSourceConfig>> {
        #[allow(unreachable_patterns)]
        self.source_stream_config.as_ref().and_then(|v| match v {
            crate::model::source_config::SourceStreamConfig::OracleSourceConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// to hold a `OracleSourceConfig`.
    ///
    /// Note that all the setters affecting `source_stream_config` are
    /// mutually exclusive.
    pub fn set_oracle_source_config<
        T: std::convert::Into<std::boxed::Box<crate::model::OracleSourceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_stream_config = std::option::Option::Some(
            crate::model::source_config::SourceStreamConfig::OracleSourceConfig(v.into()),
        );
        self
    }

    /// The value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// if it holds a `MysqlSourceConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_source_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MysqlSourceConfig>> {
        #[allow(unreachable_patterns)]
        self.source_stream_config.as_ref().and_then(|v| match v {
            crate::model::source_config::SourceStreamConfig::MysqlSourceConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// to hold a `MysqlSourceConfig`.
    ///
    /// Note that all the setters affecting `source_stream_config` are
    /// mutually exclusive.
    pub fn set_mysql_source_config<
        T: std::convert::Into<std::boxed::Box<crate::model::MysqlSourceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_stream_config = std::option::Option::Some(
            crate::model::source_config::SourceStreamConfig::MysqlSourceConfig(v.into()),
        );
        self
    }

    /// The value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// if it holds a `PostgresqlSourceConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql_source_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostgresqlSourceConfig>> {
        #[allow(unreachable_patterns)]
        self.source_stream_config.as_ref().and_then(|v| match v {
            crate::model::source_config::SourceStreamConfig::PostgresqlSourceConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// to hold a `PostgresqlSourceConfig`.
    ///
    /// Note that all the setters affecting `source_stream_config` are
    /// mutually exclusive.
    pub fn set_postgresql_source_config<
        T: std::convert::Into<std::boxed::Box<crate::model::PostgresqlSourceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_stream_config = std::option::Option::Some(
            crate::model::source_config::SourceStreamConfig::PostgresqlSourceConfig(v.into()),
        );
        self
    }

    /// The value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// if it holds a `SqlServerSourceConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_server_source_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerSourceConfig>> {
        #[allow(unreachable_patterns)]
        self.source_stream_config.as_ref().and_then(|v| match v {
            crate::model::source_config::SourceStreamConfig::SqlServerSourceConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// to hold a `SqlServerSourceConfig`.
    ///
    /// Note that all the setters affecting `source_stream_config` are
    /// mutually exclusive.
    pub fn set_sql_server_source_config<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerSourceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_stream_config = std::option::Option::Some(
            crate::model::source_config::SourceStreamConfig::SqlServerSourceConfig(v.into()),
        );
        self
    }

    /// The value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// if it holds a `SalesforceSourceConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn salesforce_source_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SalesforceSourceConfig>> {
        #[allow(unreachable_patterns)]
        self.source_stream_config.as_ref().and_then(|v| match v {
            crate::model::source_config::SourceStreamConfig::SalesforceSourceConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// to hold a `SalesforceSourceConfig`.
    ///
    /// Note that all the setters affecting `source_stream_config` are
    /// mutually exclusive.
    pub fn set_salesforce_source_config<
        T: std::convert::Into<std::boxed::Box<crate::model::SalesforceSourceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_stream_config = std::option::Option::Some(
            crate::model::source_config::SourceStreamConfig::SalesforceSourceConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SourceConfig"
    }
}

/// Defines additional types related to [SourceConfig].
pub mod source_config {
    #[allow(unused_imports)]
    use super::*;

    /// Stream configuration that is specific to the data source type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceStreamConfig {
        /// Oracle data source configuration.
        OracleSourceConfig(std::boxed::Box<crate::model::OracleSourceConfig>),
        /// MySQL data source configuration.
        MysqlSourceConfig(std::boxed::Box<crate::model::MysqlSourceConfig>),
        /// PostgreSQL data source configuration.
        PostgresqlSourceConfig(std::boxed::Box<crate::model::PostgresqlSourceConfig>),
        /// SQLServer data source configuration.
        SqlServerSourceConfig(std::boxed::Box<crate::model::SqlServerSourceConfig>),
        /// Salesforce data source configuration.
        SalesforceSourceConfig(std::boxed::Box<crate::model::SalesforceSourceConfig>),
    }
}

/// AVRO file format configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AvroFileFormat {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AvroFileFormat {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AvroFileFormat {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.AvroFileFormat"
    }
}

/// JSON file format configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JsonFileFormat {
    /// The schema file format along JSON data files.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub schema_file_format: crate::model::json_file_format::SchemaFileFormat,

    /// Compression of the loaded JSON file.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub compression: crate::model::json_file_format::JsonCompression,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JsonFileFormat {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema_file_format][crate::model::JsonFileFormat::schema_file_format].
    pub fn set_schema_file_format<
        T: std::convert::Into<crate::model::json_file_format::SchemaFileFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema_file_format = v.into();
        self
    }

    /// Sets the value of [compression][crate::model::JsonFileFormat::compression].
    pub fn set_compression<
        T: std::convert::Into<crate::model::json_file_format::JsonCompression>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compression = v.into();
        self
    }
}

impl wkt::message::Message for JsonFileFormat {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.JsonFileFormat"
    }
}

/// Defines additional types related to [JsonFileFormat].
pub mod json_file_format {
    #[allow(unused_imports)]
    use super::*;

    /// Schema file format.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SchemaFileFormat {
        /// Unspecified schema file format.
        Unspecified,
        /// Do not attach schema file.
        NoSchemaFile,
        /// Avro schema format.
        AvroSchemaFile,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SchemaFileFormat::value] or
        /// [SchemaFileFormat::name].
        UnknownValue(schema_file_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod schema_file_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SchemaFileFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoSchemaFile => std::option::Option::Some(1),
                Self::AvroSchemaFile => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCHEMA_FILE_FORMAT_UNSPECIFIED"),
                Self::NoSchemaFile => std::option::Option::Some("NO_SCHEMA_FILE"),
                Self::AvroSchemaFile => std::option::Option::Some("AVRO_SCHEMA_FILE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SchemaFileFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SchemaFileFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SchemaFileFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoSchemaFile,
                2 => Self::AvroSchemaFile,
                _ => Self::UnknownValue(schema_file_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SchemaFileFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCHEMA_FILE_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "NO_SCHEMA_FILE" => Self::NoSchemaFile,
                "AVRO_SCHEMA_FILE" => Self::AvroSchemaFile,
                _ => Self::UnknownValue(schema_file_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SchemaFileFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoSchemaFile => serializer.serialize_i32(1),
                Self::AvroSchemaFile => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SchemaFileFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SchemaFileFormat>::new(
                ".google.cloud.datastream.v1.JsonFileFormat.SchemaFileFormat",
            ))
        }
    }

    /// Json file compression.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JsonCompression {
        /// Unspecified json file compression.
        Unspecified,
        /// Do not compress JSON file.
        NoCompression,
        /// Gzip compression.
        Gzip,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [JsonCompression::value] or
        /// [JsonCompression::name].
        UnknownValue(json_compression::UnknownValue),
    }

    #[doc(hidden)]
    pub mod json_compression {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl JsonCompression {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoCompression => std::option::Option::Some(1),
                Self::Gzip => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("JSON_COMPRESSION_UNSPECIFIED"),
                Self::NoCompression => std::option::Option::Some("NO_COMPRESSION"),
                Self::Gzip => std::option::Option::Some("GZIP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for JsonCompression {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for JsonCompression {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for JsonCompression {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoCompression,
                2 => Self::Gzip,
                _ => Self::UnknownValue(json_compression::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for JsonCompression {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "JSON_COMPRESSION_UNSPECIFIED" => Self::Unspecified,
                "NO_COMPRESSION" => Self::NoCompression,
                "GZIP" => Self::Gzip,
                _ => Self::UnknownValue(json_compression::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for JsonCompression {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoCompression => serializer.serialize_i32(1),
                Self::Gzip => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for JsonCompression {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<JsonCompression>::new(
                ".google.cloud.datastream.v1.JsonFileFormat.JsonCompression",
            ))
        }
    }
}

/// Google Cloud Storage destination configuration
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsDestinationConfig {
    /// Path inside the Cloud Storage bucket to write data to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// The maximum file size to be saved in the bucket.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub file_rotation_mb: i32,

    /// The maximum duration for which new events are added before a file is
    /// closed and a new file is created. Values within the range of 15-60 seconds
    /// are allowed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_rotation_interval: std::option::Option<wkt::Duration>,

    /// File Format that the data should be written in.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub file_format: std::option::Option<crate::model::gcs_destination_config::FileFormat>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsDestinationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::GcsDestinationConfig::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [file_rotation_mb][crate::model::GcsDestinationConfig::file_rotation_mb].
    pub fn set_file_rotation_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.file_rotation_mb = v.into();
        self
    }

    /// Sets the value of [file_rotation_interval][crate::model::GcsDestinationConfig::file_rotation_interval].
    pub fn set_file_rotation_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.file_rotation_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_rotation_interval][crate::model::GcsDestinationConfig::file_rotation_interval].
    pub fn set_or_clear_file_rotation_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.file_rotation_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [file_format][crate::model::GcsDestinationConfig::file_format].
    ///
    /// Note that all the setters affecting `file_format` are mutually
    /// exclusive.
    pub fn set_file_format<
        T: std::convert::Into<std::option::Option<crate::model::gcs_destination_config::FileFormat>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_format = v.into();
        self
    }

    /// The value of [file_format][crate::model::GcsDestinationConfig::file_format]
    /// if it holds a `AvroFileFormat`, `None` if the field is not set or
    /// holds a different branch.
    pub fn avro_file_format(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AvroFileFormat>> {
        #[allow(unreachable_patterns)]
        self.file_format.as_ref().and_then(|v| match v {
            crate::model::gcs_destination_config::FileFormat::AvroFileFormat(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [file_format][crate::model::GcsDestinationConfig::file_format]
    /// to hold a `AvroFileFormat`.
    ///
    /// Note that all the setters affecting `file_format` are
    /// mutually exclusive.
    pub fn set_avro_file_format<
        T: std::convert::Into<std::boxed::Box<crate::model::AvroFileFormat>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_format = std::option::Option::Some(
            crate::model::gcs_destination_config::FileFormat::AvroFileFormat(v.into()),
        );
        self
    }

    /// The value of [file_format][crate::model::GcsDestinationConfig::file_format]
    /// if it holds a `JsonFileFormat`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json_file_format(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::JsonFileFormat>> {
        #[allow(unreachable_patterns)]
        self.file_format.as_ref().and_then(|v| match v {
            crate::model::gcs_destination_config::FileFormat::JsonFileFormat(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [file_format][crate::model::GcsDestinationConfig::file_format]
    /// to hold a `JsonFileFormat`.
    ///
    /// Note that all the setters affecting `file_format` are
    /// mutually exclusive.
    pub fn set_json_file_format<
        T: std::convert::Into<std::boxed::Box<crate::model::JsonFileFormat>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_format = std::option::Option::Some(
            crate::model::gcs_destination_config::FileFormat::JsonFileFormat(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GcsDestinationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GcsDestinationConfig"
    }
}

/// Defines additional types related to [GcsDestinationConfig].
pub mod gcs_destination_config {
    #[allow(unused_imports)]
    use super::*;

    /// File Format that the data should be written in.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FileFormat {
        /// AVRO file format configuration.
        AvroFileFormat(std::boxed::Box<crate::model::AvroFileFormat>),
        /// JSON file format configuration.
        JsonFileFormat(std::boxed::Box<crate::model::JsonFileFormat>),
    }
}

/// BigQuery destination configuration
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryDestinationConfig {
    /// The guaranteed data freshness (in seconds) when querying tables created by
    /// the stream. Editing this field will only affect new tables created in the
    /// future, but existing tables will not be impacted. Lower values mean that
    /// queries will return fresher data, but may result in higher cost.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_freshness: std::option::Option<wkt::Duration>,

    /// Optional. Big Lake Managed Tables (BLMT) configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub blmt_config: std::option::Option<crate::model::big_query_destination_config::BlmtConfig>,

    /// Target dataset(s) configuration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub dataset_config:
        std::option::Option<crate::model::big_query_destination_config::DatasetConfig>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub write_mode: std::option::Option<crate::model::big_query_destination_config::WriteMode>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryDestinationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_freshness][crate::model::BigQueryDestinationConfig::data_freshness].
    pub fn set_data_freshness<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.data_freshness = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_freshness][crate::model::BigQueryDestinationConfig::data_freshness].
    pub fn set_or_clear_data_freshness<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.data_freshness = v.map(|x| x.into());
        self
    }

    /// Sets the value of [blmt_config][crate::model::BigQueryDestinationConfig::blmt_config].
    pub fn set_blmt_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::big_query_destination_config::BlmtConfig>,
    {
        self.blmt_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [blmt_config][crate::model::BigQueryDestinationConfig::blmt_config].
    pub fn set_or_clear_blmt_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::big_query_destination_config::BlmtConfig>,
    {
        self.blmt_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dataset_config][crate::model::BigQueryDestinationConfig::dataset_config].
    ///
    /// Note that all the setters affecting `dataset_config` are mutually
    /// exclusive.
    pub fn set_dataset_config<
        T: std::convert::Into<
                std::option::Option<crate::model::big_query_destination_config::DatasetConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_config = v.into();
        self
    }

    /// The value of [dataset_config][crate::model::BigQueryDestinationConfig::dataset_config]
    /// if it holds a `SingleTargetDataset`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_target_dataset(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::big_query_destination_config::SingleTargetDataset>,
    > {
        #[allow(unreachable_patterns)]
        self.dataset_config.as_ref().and_then(|v| match v {
            crate::model::big_query_destination_config::DatasetConfig::SingleTargetDataset(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dataset_config][crate::model::BigQueryDestinationConfig::dataset_config]
    /// to hold a `SingleTargetDataset`.
    ///
    /// Note that all the setters affecting `dataset_config` are
    /// mutually exclusive.
    pub fn set_single_target_dataset<
        T: std::convert::Into<
                std::boxed::Box<crate::model::big_query_destination_config::SingleTargetDataset>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_config = std::option::Option::Some(
            crate::model::big_query_destination_config::DatasetConfig::SingleTargetDataset(
                v.into(),
            ),
        );
        self
    }

    /// The value of [dataset_config][crate::model::BigQueryDestinationConfig::dataset_config]
    /// if it holds a `SourceHierarchyDatasets`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_hierarchy_datasets(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::big_query_destination_config::SourceHierarchyDatasets>,
    > {
        #[allow(unreachable_patterns)]
        self.dataset_config.as_ref().and_then(|v| match v {
            crate::model::big_query_destination_config::DatasetConfig::SourceHierarchyDatasets(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dataset_config][crate::model::BigQueryDestinationConfig::dataset_config]
    /// to hold a `SourceHierarchyDatasets`.
    ///
    /// Note that all the setters affecting `dataset_config` are
    /// mutually exclusive.
    pub fn set_source_hierarchy_datasets<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::big_query_destination_config::SourceHierarchyDatasets,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_config = std::option::Option::Some(
            crate::model::big_query_destination_config::DatasetConfig::SourceHierarchyDatasets(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [write_mode][crate::model::BigQueryDestinationConfig::write_mode].
    ///
    /// Note that all the setters affecting `write_mode` are mutually
    /// exclusive.
    pub fn set_write_mode<
        T: std::convert::Into<
                std::option::Option<crate::model::big_query_destination_config::WriteMode>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_mode = v.into();
        self
    }

    /// The value of [write_mode][crate::model::BigQueryDestinationConfig::write_mode]
    /// if it holds a `Merge`, `None` if the field is not set or
    /// holds a different branch.
    pub fn merge(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::big_query_destination_config::Merge>>
    {
        #[allow(unreachable_patterns)]
        self.write_mode.as_ref().and_then(|v| match v {
            crate::model::big_query_destination_config::WriteMode::Merge(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [write_mode][crate::model::BigQueryDestinationConfig::write_mode]
    /// to hold a `Merge`.
    ///
    /// Note that all the setters affecting `write_mode` are
    /// mutually exclusive.
    pub fn set_merge<
        T: std::convert::Into<std::boxed::Box<crate::model::big_query_destination_config::Merge>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_mode = std::option::Option::Some(
            crate::model::big_query_destination_config::WriteMode::Merge(v.into()),
        );
        self
    }

    /// The value of [write_mode][crate::model::BigQueryDestinationConfig::write_mode]
    /// if it holds a `AppendOnly`, `None` if the field is not set or
    /// holds a different branch.
    pub fn append_only(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::big_query_destination_config::AppendOnly>>
    {
        #[allow(unreachable_patterns)]
        self.write_mode.as_ref().and_then(|v| match v {
            crate::model::big_query_destination_config::WriteMode::AppendOnly(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [write_mode][crate::model::BigQueryDestinationConfig::write_mode]
    /// to hold a `AppendOnly`.
    ///
    /// Note that all the setters affecting `write_mode` are
    /// mutually exclusive.
    pub fn set_append_only<
        T: std::convert::Into<std::boxed::Box<crate::model::big_query_destination_config::AppendOnly>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_mode = std::option::Option::Some(
            crate::model::big_query_destination_config::WriteMode::AppendOnly(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQueryDestinationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig"
    }
}

/// Defines additional types related to [BigQueryDestinationConfig].
pub mod big_query_destination_config {
    #[allow(unused_imports)]
    use super::*;

    /// A single target dataset to which all data will be streamed.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SingleTargetDataset {
        /// The dataset ID of the target dataset.
        /// DatasetIds allowed characters:
        /// <https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets#datasetreference>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset_id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SingleTargetDataset {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset_id][crate::model::big_query_destination_config::SingleTargetDataset::dataset_id].
        pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset_id = v.into();
            self
        }
    }

    impl wkt::message::Message for SingleTargetDataset {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig.SingleTargetDataset"
        }
    }

    /// Destination datasets are created so that hierarchy of the destination data
    /// objects matches the source hierarchy.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SourceHierarchyDatasets {
        /// The dataset template to use for dynamic dataset creation.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub dataset_template: std::option::Option<
            crate::model::big_query_destination_config::source_hierarchy_datasets::DatasetTemplate,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SourceHierarchyDatasets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset_template][crate::model::big_query_destination_config::SourceHierarchyDatasets::dataset_template].
        pub fn set_dataset_template<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::big_query_destination_config::source_hierarchy_datasets::DatasetTemplate>
        {
            self.dataset_template = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [dataset_template][crate::model::big_query_destination_config::SourceHierarchyDatasets::dataset_template].
        pub fn set_or_clear_dataset_template<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::big_query_destination_config::source_hierarchy_datasets::DatasetTemplate>
        {
            self.dataset_template = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SourceHierarchyDatasets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig.SourceHierarchyDatasets"
        }
    }

    /// Defines additional types related to [SourceHierarchyDatasets].
    pub mod source_hierarchy_datasets {
        #[allow(unused_imports)]
        use super::*;

        /// Dataset template used for dynamic dataset creation.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DatasetTemplate {
            /// Required. The geographic location where the dataset should reside. See
            /// <https://cloud.google.com/bigquery/docs/locations> for supported
            /// locations.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub location: std::string::String,

            /// If supplied, every created dataset will have its name prefixed by the
            /// provided value. The prefix and name will be separated by an underscore.
            /// i.e. \<prefix\>_<dataset_name>.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub dataset_id_prefix: std::string::String,

            /// Describes the Cloud KMS encryption key that will be used to
            /// protect destination BigQuery table. The BigQuery Service Account
            /// associated with your project requires access to this encryption key.
            /// i.e.
            /// projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{cryptoKey}.
            /// See <https://cloud.google.com/bigquery/docs/customer-managed-encryption>
            /// for more information.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub kms_key_name: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DatasetTemplate {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [location][crate::model::big_query_destination_config::source_hierarchy_datasets::DatasetTemplate::location].
            pub fn set_location<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.location = v.into();
                self
            }

            /// Sets the value of [dataset_id_prefix][crate::model::big_query_destination_config::source_hierarchy_datasets::DatasetTemplate::dataset_id_prefix].
            pub fn set_dataset_id_prefix<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.dataset_id_prefix = v.into();
                self
            }

            /// Sets the value of [kms_key_name][crate::model::big_query_destination_config::source_hierarchy_datasets::DatasetTemplate::kms_key_name].
            pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.kms_key_name = v.into();
                self
            }
        }

        impl wkt::message::Message for DatasetTemplate {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig.SourceHierarchyDatasets.DatasetTemplate"
            }
        }
    }

    /// The configuration for BLMT.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BlmtConfig {
        /// Required. The Cloud Storage bucket name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub bucket: std::string::String,

        /// The root path inside the Cloud Storage bucket.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub root_path: std::string::String,

        /// Required. The bigquery connection.
        /// Format: `{project}.{location}.{name}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub connection_name: std::string::String,

        /// Required. The file format.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub file_format: crate::model::big_query_destination_config::blmt_config::FileFormat,

        /// Required. The table format.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub table_format: crate::model::big_query_destination_config::blmt_config::TableFormat,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BlmtConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bucket][crate::model::big_query_destination_config::BlmtConfig::bucket].
        pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.bucket = v.into();
            self
        }

        /// Sets the value of [root_path][crate::model::big_query_destination_config::BlmtConfig::root_path].
        pub fn set_root_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.root_path = v.into();
            self
        }

        /// Sets the value of [connection_name][crate::model::big_query_destination_config::BlmtConfig::connection_name].
        pub fn set_connection_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.connection_name = v.into();
            self
        }

        /// Sets the value of [file_format][crate::model::big_query_destination_config::BlmtConfig::file_format].
        pub fn set_file_format<
            T: std::convert::Into<crate::model::big_query_destination_config::blmt_config::FileFormat>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.file_format = v.into();
            self
        }

        /// Sets the value of [table_format][crate::model::big_query_destination_config::BlmtConfig::table_format].
        pub fn set_table_format<
            T: std::convert::Into<
                    crate::model::big_query_destination_config::blmt_config::TableFormat,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.table_format = v.into();
            self
        }
    }

    impl wkt::message::Message for BlmtConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig.BlmtConfig"
        }
    }

    /// Defines additional types related to [BlmtConfig].
    pub mod blmt_config {
        #[allow(unused_imports)]
        use super::*;

        /// Supported file formats for BigLake managed tables.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum FileFormat {
            /// Default value.
            Unspecified,
            /// Parquet file format.
            Parquet,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [FileFormat::value] or
            /// [FileFormat::name].
            UnknownValue(file_format::UnknownValue),
        }

        #[doc(hidden)]
        pub mod file_format {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl FileFormat {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Parquet => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("FILE_FORMAT_UNSPECIFIED"),
                    Self::Parquet => std::option::Option::Some("PARQUET"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for FileFormat {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for FileFormat {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for FileFormat {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Parquet,
                    _ => Self::UnknownValue(file_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for FileFormat {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "FILE_FORMAT_UNSPECIFIED" => Self::Unspecified,
                    "PARQUET" => Self::Parquet,
                    _ => Self::UnknownValue(file_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for FileFormat {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Parquet => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for FileFormat {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<FileFormat>::new(
                    ".google.cloud.datastream.v1.BigQueryDestinationConfig.BlmtConfig.FileFormat",
                ))
            }
        }

        /// Supported table formats for BigLake managed tables.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TableFormat {
            /// Default value.
            Unspecified,
            /// Iceberg table format.
            Iceberg,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [TableFormat::value] or
            /// [TableFormat::name].
            UnknownValue(table_format::UnknownValue),
        }

        #[doc(hidden)]
        pub mod table_format {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl TableFormat {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Iceberg => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TABLE_FORMAT_UNSPECIFIED"),
                    Self::Iceberg => std::option::Option::Some("ICEBERG"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for TableFormat {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for TableFormat {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for TableFormat {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Iceberg,
                    _ => Self::UnknownValue(table_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for TableFormat {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TABLE_FORMAT_UNSPECIFIED" => Self::Unspecified,
                    "ICEBERG" => Self::Iceberg,
                    _ => Self::UnknownValue(table_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for TableFormat {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Iceberg => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for TableFormat {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<TableFormat>::new(
                    ".google.cloud.datastream.v1.BigQueryDestinationConfig.BlmtConfig.TableFormat",
                ))
            }
        }
    }

    /// AppendOnly mode defines that all changes to a table will be written to the
    /// destination table.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AppendOnly {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AppendOnly {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for AppendOnly {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig.AppendOnly"
        }
    }

    /// Merge mode defines that all changes to a table will be merged at the
    /// destination table.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Merge {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Merge {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Merge {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig.Merge"
        }
    }

    /// Target dataset(s) configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DatasetConfig {
        /// Single destination dataset.
        SingleTargetDataset(
            std::boxed::Box<crate::model::big_query_destination_config::SingleTargetDataset>,
        ),
        /// Source hierarchy datasets.
        SourceHierarchyDatasets(
            std::boxed::Box<crate::model::big_query_destination_config::SourceHierarchyDatasets>,
        ),
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum WriteMode {
        /// The standard mode
        Merge(std::boxed::Box<crate::model::big_query_destination_config::Merge>),
        /// Append only mode
        AppendOnly(std::boxed::Box<crate::model::big_query_destination_config::AppendOnly>),
    }
}

/// The configuration of the stream destination.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DestinationConfig {
    /// Required. Destination connection profile resource.
    /// Format: `projects/{project}/locations/{location}/connectionProfiles/{name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_connection_profile: std::string::String,

    /// Stream configuration that is specific to the data destination type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination_stream_config:
        std::option::Option<crate::model::destination_config::DestinationStreamConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DestinationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination_connection_profile][crate::model::DestinationConfig::destination_connection_profile].
    pub fn set_destination_connection_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_connection_profile = v.into();
        self
    }

    /// Sets the value of [destination_stream_config][crate::model::DestinationConfig::destination_stream_config].
    ///
    /// Note that all the setters affecting `destination_stream_config` are mutually
    /// exclusive.
    pub fn set_destination_stream_config<
        T: std::convert::Into<
                std::option::Option<crate::model::destination_config::DestinationStreamConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_stream_config = v.into();
        self
    }

    /// The value of [destination_stream_config][crate::model::DestinationConfig::destination_stream_config]
    /// if it holds a `GcsDestinationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestinationConfig>> {
        #[allow(unreachable_patterns)]
        self.destination_stream_config
            .as_ref()
            .and_then(|v| match v {
                crate::model::destination_config::DestinationStreamConfig::GcsDestinationConfig(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
    }

    /// Sets the value of [destination_stream_config][crate::model::DestinationConfig::destination_stream_config]
    /// to hold a `GcsDestinationConfig`.
    ///
    /// Note that all the setters affecting `destination_stream_config` are
    /// mutually exclusive.
    pub fn set_gcs_destination_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestinationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_stream_config = std::option::Option::Some(
            crate::model::destination_config::DestinationStreamConfig::GcsDestinationConfig(
                v.into(),
            ),
        );
        self
    }

    /// The value of [destination_stream_config][crate::model::DestinationConfig::destination_stream_config]
    /// if it holds a `BigqueryDestinationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_destination_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestinationConfig>> {
        #[allow(unreachable_patterns)]
        self.destination_stream_config.as_ref().and_then(|v| match v {
            crate::model::destination_config::DestinationStreamConfig::BigqueryDestinationConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination_stream_config][crate::model::DestinationConfig::destination_stream_config]
    /// to hold a `BigqueryDestinationConfig`.
    ///
    /// Note that all the setters affecting `destination_stream_config` are
    /// mutually exclusive.
    pub fn set_bigquery_destination_config<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestinationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_stream_config = std::option::Option::Some(
            crate::model::destination_config::DestinationStreamConfig::BigqueryDestinationConfig(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DestinationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DestinationConfig"
    }
}

/// Defines additional types related to [DestinationConfig].
pub mod destination_config {
    #[allow(unused_imports)]
    use super::*;

    /// Stream configuration that is specific to the data destination type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DestinationStreamConfig {
        /// A configuration for how data should be loaded to Cloud Storage.
        GcsDestinationConfig(std::boxed::Box<crate::model::GcsDestinationConfig>),
        /// BigQuery destination configuration.
        BigqueryDestinationConfig(std::boxed::Box<crate::model::BigQueryDestinationConfig>),
    }
}

/// A resource representing streaming data from a source to a destination.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Stream {
    /// Output only. Identifier. The stream's name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The creation time of the stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update time of the stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Source connection profile configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_config: std::option::Option<crate::model::SourceConfig>,

    /// Required. Destination connection profile configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination_config: std::option::Option<crate::model::DestinationConfig>,

    /// The state of the stream.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::stream::State,

    /// Output only. Errors on the Stream.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Immutable. A reference to a KMS encryption key.
    /// If provided, it will be used to encrypt the data.
    /// If left blank, data will be encrypted using an internal Stream-specific
    /// encryption key provisioned through KMS.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub customer_managed_encryption_key: std::option::Option<std::string::String>,

    /// Output only. If the stream was recovered, the time of the last recovery.
    /// Note: This field is currently experimental.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_recovery_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<bool>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzi: std::option::Option<bool>,

    /// Stream backfill strategy.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub backfill_strategy: std::option::Option<crate::model::stream::BackfillStrategy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Stream {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Stream::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Stream::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Stream::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Stream::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Stream::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Stream::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::Stream::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [source_config][crate::model::Stream::source_config].
    pub fn set_source_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceConfig>,
    {
        self.source_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_config][crate::model::Stream::source_config].
    pub fn set_or_clear_source_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceConfig>,
    {
        self.source_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_config][crate::model::Stream::destination_config].
    pub fn set_destination_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DestinationConfig>,
    {
        self.destination_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destination_config][crate::model::Stream::destination_config].
    pub fn set_or_clear_destination_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DestinationConfig>,
    {
        self.destination_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Stream::state].
    pub fn set_state<T: std::convert::Into<crate::model::stream::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::Stream::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [customer_managed_encryption_key][crate::model::Stream::customer_managed_encryption_key].
    pub fn set_customer_managed_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.customer_managed_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [customer_managed_encryption_key][crate::model::Stream::customer_managed_encryption_key].
    pub fn set_or_clear_customer_managed_encryption_key<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.customer_managed_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_recovery_time][crate::model::Stream::last_recovery_time].
    pub fn set_last_recovery_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_recovery_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_recovery_time][crate::model::Stream::last_recovery_time].
    pub fn set_or_clear_last_recovery_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_recovery_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Stream::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::Stream::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Stream::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::Stream::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backfill_strategy][crate::model::Stream::backfill_strategy].
    ///
    /// Note that all the setters affecting `backfill_strategy` are mutually
    /// exclusive.
    pub fn set_backfill_strategy<
        T: std::convert::Into<std::option::Option<crate::model::stream::BackfillStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backfill_strategy = v.into();
        self
    }

    /// The value of [backfill_strategy][crate::model::Stream::backfill_strategy]
    /// if it holds a `BackfillAll`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backfill_all(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::stream::BackfillAllStrategy>> {
        #[allow(unreachable_patterns)]
        self.backfill_strategy.as_ref().and_then(|v| match v {
            crate::model::stream::BackfillStrategy::BackfillAll(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backfill_strategy][crate::model::Stream::backfill_strategy]
    /// to hold a `BackfillAll`.
    ///
    /// Note that all the setters affecting `backfill_strategy` are
    /// mutually exclusive.
    pub fn set_backfill_all<
        T: std::convert::Into<std::boxed::Box<crate::model::stream::BackfillAllStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backfill_strategy = std::option::Option::Some(
            crate::model::stream::BackfillStrategy::BackfillAll(v.into()),
        );
        self
    }

    /// The value of [backfill_strategy][crate::model::Stream::backfill_strategy]
    /// if it holds a `BackfillNone`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backfill_none(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::stream::BackfillNoneStrategy>> {
        #[allow(unreachable_patterns)]
        self.backfill_strategy.as_ref().and_then(|v| match v {
            crate::model::stream::BackfillStrategy::BackfillNone(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backfill_strategy][crate::model::Stream::backfill_strategy]
    /// to hold a `BackfillNone`.
    ///
    /// Note that all the setters affecting `backfill_strategy` are
    /// mutually exclusive.
    pub fn set_backfill_none<
        T: std::convert::Into<std::boxed::Box<crate::model::stream::BackfillNoneStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backfill_strategy = std::option::Option::Some(
            crate::model::stream::BackfillStrategy::BackfillNone(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Stream {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.Stream"
    }
}

/// Defines additional types related to [Stream].
pub mod stream {
    #[allow(unused_imports)]
    use super::*;

    /// Backfill strategy to automatically backfill the Stream's objects.
    /// Specific objects can be excluded.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BackfillAllStrategy {
        /// List of objects to exclude.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub excluded_objects:
            std::option::Option<crate::model::stream::backfill_all_strategy::ExcludedObjects>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BackfillAllStrategy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects].
        ///
        /// Note that all the setters affecting `excluded_objects` are mutually
        /// exclusive.
        pub fn set_excluded_objects<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::stream::backfill_all_strategy::ExcludedObjects,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.excluded_objects = v.into();
            self
        }

        /// The value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// if it holds a `OracleExcludedObjects`, `None` if the field is not set or
        /// holds a different branch.
        pub fn oracle_excluded_objects(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::OracleRdbms>> {
            #[allow(unreachable_patterns)]
            self.excluded_objects.as_ref().and_then(|v| match v {
                crate::model::stream::backfill_all_strategy::ExcludedObjects::OracleExcludedObjects(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// to hold a `OracleExcludedObjects`.
        ///
        /// Note that all the setters affecting `excluded_objects` are
        /// mutually exclusive.
        pub fn set_oracle_excluded_objects<
            T: std::convert::Into<std::boxed::Box<crate::model::OracleRdbms>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.excluded_objects = std::option::Option::Some(
                crate::model::stream::backfill_all_strategy::ExcludedObjects::OracleExcludedObjects(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// if it holds a `MysqlExcludedObjects`, `None` if the field is not set or
        /// holds a different branch.
        pub fn mysql_excluded_objects(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::MysqlRdbms>> {
            #[allow(unreachable_patterns)]
            self.excluded_objects.as_ref().and_then(|v| match v {
                crate::model::stream::backfill_all_strategy::ExcludedObjects::MysqlExcludedObjects(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// to hold a `MysqlExcludedObjects`.
        ///
        /// Note that all the setters affecting `excluded_objects` are
        /// mutually exclusive.
        pub fn set_mysql_excluded_objects<
            T: std::convert::Into<std::boxed::Box<crate::model::MysqlRdbms>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.excluded_objects = std::option::Option::Some(
                crate::model::stream::backfill_all_strategy::ExcludedObjects::MysqlExcludedObjects(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// if it holds a `PostgresqlExcludedObjects`, `None` if the field is not set or
        /// holds a different branch.
        pub fn postgresql_excluded_objects(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::PostgresqlRdbms>> {
            #[allow(unreachable_patterns)]
            self.excluded_objects.as_ref().and_then(|v| match v {
                crate::model::stream::backfill_all_strategy::ExcludedObjects::PostgresqlExcludedObjects(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// to hold a `PostgresqlExcludedObjects`.
        ///
        /// Note that all the setters affecting `excluded_objects` are
        /// mutually exclusive.
        pub fn set_postgresql_excluded_objects<
            T: std::convert::Into<std::boxed::Box<crate::model::PostgresqlRdbms>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.excluded_objects = std::option::Option::Some(
                crate::model::stream::backfill_all_strategy::ExcludedObjects::PostgresqlExcludedObjects(
                    v.into()
                )
            );
            self
        }

        /// The value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// if it holds a `SqlServerExcludedObjects`, `None` if the field is not set or
        /// holds a different branch.
        pub fn sql_server_excluded_objects(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerRdbms>> {
            #[allow(unreachable_patterns)]
            self.excluded_objects.as_ref().and_then(|v| match v {
                crate::model::stream::backfill_all_strategy::ExcludedObjects::SqlServerExcludedObjects(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// to hold a `SqlServerExcludedObjects`.
        ///
        /// Note that all the setters affecting `excluded_objects` are
        /// mutually exclusive.
        pub fn set_sql_server_excluded_objects<
            T: std::convert::Into<std::boxed::Box<crate::model::SqlServerRdbms>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.excluded_objects = std::option::Option::Some(
                crate::model::stream::backfill_all_strategy::ExcludedObjects::SqlServerExcludedObjects(
                    v.into()
                )
            );
            self
        }

        /// The value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// if it holds a `SalesforceExcludedObjects`, `None` if the field is not set or
        /// holds a different branch.
        pub fn salesforce_excluded_objects(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::SalesforceOrg>> {
            #[allow(unreachable_patterns)]
            self.excluded_objects.as_ref().and_then(|v| match v {
                crate::model::stream::backfill_all_strategy::ExcludedObjects::SalesforceExcludedObjects(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// to hold a `SalesforceExcludedObjects`.
        ///
        /// Note that all the setters affecting `excluded_objects` are
        /// mutually exclusive.
        pub fn set_salesforce_excluded_objects<
            T: std::convert::Into<std::boxed::Box<crate::model::SalesforceOrg>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.excluded_objects = std::option::Option::Some(
                crate::model::stream::backfill_all_strategy::ExcludedObjects::SalesforceExcludedObjects(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for BackfillAllStrategy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.Stream.BackfillAllStrategy"
        }
    }

    /// Defines additional types related to [BackfillAllStrategy].
    pub mod backfill_all_strategy {
        #[allow(unused_imports)]
        use super::*;

        /// List of objects to exclude.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum ExcludedObjects {
            /// Oracle data source objects to avoid backfilling.
            OracleExcludedObjects(std::boxed::Box<crate::model::OracleRdbms>),
            /// MySQL data source objects to avoid backfilling.
            MysqlExcludedObjects(std::boxed::Box<crate::model::MysqlRdbms>),
            /// PostgreSQL data source objects to avoid backfilling.
            PostgresqlExcludedObjects(std::boxed::Box<crate::model::PostgresqlRdbms>),
            /// SQLServer data source objects to avoid backfilling
            SqlServerExcludedObjects(std::boxed::Box<crate::model::SqlServerRdbms>),
            /// Salesforce data source objects to avoid backfilling
            SalesforceExcludedObjects(std::boxed::Box<crate::model::SalesforceOrg>),
        }
    }

    /// Backfill strategy to disable automatic backfill for the Stream's objects.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BackfillNoneStrategy {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BackfillNoneStrategy {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for BackfillNoneStrategy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.Stream.BackfillNoneStrategy"
        }
    }

    /// Stream state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified stream state.
        Unspecified,
        /// The stream has been created but has not yet started streaming data.
        NotStarted,
        /// The stream is running.
        Running,
        /// The stream is paused.
        Paused,
        /// The stream is in maintenance mode.
        ///
        /// Updates are rejected on the resource in this state.
        Maintenance,
        /// The stream is experiencing an error that is preventing data from being
        /// streamed.
        Failed,
        /// The stream has experienced a terminal failure.
        FailedPermanently,
        /// The stream is starting, but not yet running.
        Starting,
        /// The Stream is no longer reading new events, but still writing events in
        /// the buffer.
        Draining,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotStarted => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Paused => std::option::Option::Some(3),
                Self::Maintenance => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::FailedPermanently => std::option::Option::Some(6),
                Self::Starting => std::option::Option::Some(7),
                Self::Draining => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::NotStarted => std::option::Option::Some("NOT_STARTED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::FailedPermanently => std::option::Option::Some("FAILED_PERMANENTLY"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Draining => std::option::Option::Some("DRAINING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotStarted,
                2 => Self::Running,
                3 => Self::Paused,
                4 => Self::Maintenance,
                5 => Self::Failed,
                6 => Self::FailedPermanently,
                7 => Self::Starting,
                8 => Self::Draining,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "NOT_STARTED" => Self::NotStarted,
                "RUNNING" => Self::Running,
                "PAUSED" => Self::Paused,
                "MAINTENANCE" => Self::Maintenance,
                "FAILED" => Self::Failed,
                "FAILED_PERMANENTLY" => Self::FailedPermanently,
                "STARTING" => Self::Starting,
                "DRAINING" => Self::Draining,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotStarted => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Paused => serializer.serialize_i32(3),
                Self::Maintenance => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::FailedPermanently => serializer.serialize_i32(6),
                Self::Starting => serializer.serialize_i32(7),
                Self::Draining => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.datastream.v1.Stream.State",
            ))
        }
    }

    /// Stream backfill strategy.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum BackfillStrategy {
        /// Automatically backfill objects included in the stream source
        /// configuration. Specific objects can be excluded.
        BackfillAll(std::boxed::Box<crate::model::stream::BackfillAllStrategy>),
        /// Do not automatically backfill any objects.
        BackfillNone(std::boxed::Box<crate::model::stream::BackfillNoneStrategy>),
    }
}

/// A specific stream object (e.g a specific DB table).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamObject {
    /// Output only. Identifier. The object resource's name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The creation time of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update time of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. Display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Active errors on the object.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// The latest backfill job that was initiated for the stream object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backfill_job: std::option::Option<crate::model::BackfillJob>,

    /// The object identifier in the data source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_object: std::option::Option<crate::model::SourceObjectIdentifier>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamObject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StreamObject::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::StreamObject::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::StreamObject::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::StreamObject::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::StreamObject::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::StreamObject::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::StreamObject::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [backfill_job][crate::model::StreamObject::backfill_job].
    pub fn set_backfill_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackfillJob>,
    {
        self.backfill_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backfill_job][crate::model::StreamObject::backfill_job].
    pub fn set_or_clear_backfill_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackfillJob>,
    {
        self.backfill_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_object][crate::model::StreamObject::source_object].
    pub fn set_source_object<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceObjectIdentifier>,
    {
        self.source_object = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_object][crate::model::StreamObject::source_object].
    pub fn set_or_clear_source_object<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceObjectIdentifier>,
    {
        self.source_object = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StreamObject {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.StreamObject"
    }
}

/// Represents an identifier of an object in the data source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceObjectIdentifier {
    /// The identifier for an object in the data source.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_identifier:
        std::option::Option<crate::model::source_object_identifier::SourceIdentifier>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceObjectIdentifier {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier].
    ///
    /// Note that all the setters affecting `source_identifier` are mutually
    /// exclusive.
    pub fn set_source_identifier<
        T: std::convert::Into<
                std::option::Option<crate::model::source_object_identifier::SourceIdentifier>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_identifier = v.into();
        self
    }

    /// The value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// if it holds a `OracleIdentifier`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle_identifier(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::source_object_identifier::OracleObjectIdentifier>,
    > {
        #[allow(unreachable_patterns)]
        self.source_identifier.as_ref().and_then(|v| match v {
            crate::model::source_object_identifier::SourceIdentifier::OracleIdentifier(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// to hold a `OracleIdentifier`.
    ///
    /// Note that all the setters affecting `source_identifier` are
    /// mutually exclusive.
    pub fn set_oracle_identifier<
        T: std::convert::Into<
                std::boxed::Box<crate::model::source_object_identifier::OracleObjectIdentifier>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_identifier = std::option::Option::Some(
            crate::model::source_object_identifier::SourceIdentifier::OracleIdentifier(v.into()),
        );
        self
    }

    /// The value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// if it holds a `MysqlIdentifier`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_identifier(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::source_object_identifier::MysqlObjectIdentifier>,
    > {
        #[allow(unreachable_patterns)]
        self.source_identifier.as_ref().and_then(|v| match v {
            crate::model::source_object_identifier::SourceIdentifier::MysqlIdentifier(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// to hold a `MysqlIdentifier`.
    ///
    /// Note that all the setters affecting `source_identifier` are
    /// mutually exclusive.
    pub fn set_mysql_identifier<
        T: std::convert::Into<
                std::boxed::Box<crate::model::source_object_identifier::MysqlObjectIdentifier>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_identifier = std::option::Option::Some(
            crate::model::source_object_identifier::SourceIdentifier::MysqlIdentifier(v.into()),
        );
        self
    }

    /// The value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// if it holds a `PostgresqlIdentifier`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql_identifier(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::source_object_identifier::PostgresqlObjectIdentifier>,
    > {
        #[allow(unreachable_patterns)]
        self.source_identifier.as_ref().and_then(|v| match v {
            crate::model::source_object_identifier::SourceIdentifier::PostgresqlIdentifier(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// to hold a `PostgresqlIdentifier`.
    ///
    /// Note that all the setters affecting `source_identifier` are
    /// mutually exclusive.
    pub fn set_postgresql_identifier<
        T: std::convert::Into<
                std::boxed::Box<crate::model::source_object_identifier::PostgresqlObjectIdentifier>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_identifier = std::option::Option::Some(
            crate::model::source_object_identifier::SourceIdentifier::PostgresqlIdentifier(
                v.into(),
            ),
        );
        self
    }

    /// The value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// if it holds a `SqlServerIdentifier`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_server_identifier(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::source_object_identifier::SqlServerObjectIdentifier>,
    > {
        #[allow(unreachable_patterns)]
        self.source_identifier.as_ref().and_then(|v| match v {
            crate::model::source_object_identifier::SourceIdentifier::SqlServerIdentifier(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// to hold a `SqlServerIdentifier`.
    ///
    /// Note that all the setters affecting `source_identifier` are
    /// mutually exclusive.
    pub fn set_sql_server_identifier<
        T: std::convert::Into<
                std::boxed::Box<crate::model::source_object_identifier::SqlServerObjectIdentifier>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_identifier = std::option::Option::Some(
            crate::model::source_object_identifier::SourceIdentifier::SqlServerIdentifier(v.into()),
        );
        self
    }

    /// The value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// if it holds a `SalesforceIdentifier`, `None` if the field is not set or
    /// holds a different branch.
    pub fn salesforce_identifier(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::source_object_identifier::SalesforceObjectIdentifier>,
    > {
        #[allow(unreachable_patterns)]
        self.source_identifier.as_ref().and_then(|v| match v {
            crate::model::source_object_identifier::SourceIdentifier::SalesforceIdentifier(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// to hold a `SalesforceIdentifier`.
    ///
    /// Note that all the setters affecting `source_identifier` are
    /// mutually exclusive.
    pub fn set_salesforce_identifier<
        T: std::convert::Into<
                std::boxed::Box<crate::model::source_object_identifier::SalesforceObjectIdentifier>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_identifier = std::option::Option::Some(
            crate::model::source_object_identifier::SourceIdentifier::SalesforceIdentifier(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for SourceObjectIdentifier {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SourceObjectIdentifier"
    }
}

/// Defines additional types related to [SourceObjectIdentifier].
pub mod source_object_identifier {
    #[allow(unused_imports)]
    use super::*;

    /// Oracle data source object identifier.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OracleObjectIdentifier {
        /// Required. The schema name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub schema: std::string::String,

        /// Required. The table name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub table: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OracleObjectIdentifier {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [schema][crate::model::source_object_identifier::OracleObjectIdentifier::schema].
        pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.schema = v.into();
            self
        }

        /// Sets the value of [table][crate::model::source_object_identifier::OracleObjectIdentifier::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }
    }

    impl wkt::message::Message for OracleObjectIdentifier {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SourceObjectIdentifier.OracleObjectIdentifier"
        }
    }

    /// PostgreSQL data source object identifier.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PostgresqlObjectIdentifier {
        /// Required. The schema name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub schema: std::string::String,

        /// Required. The table name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub table: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PostgresqlObjectIdentifier {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [schema][crate::model::source_object_identifier::PostgresqlObjectIdentifier::schema].
        pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.schema = v.into();
            self
        }

        /// Sets the value of [table][crate::model::source_object_identifier::PostgresqlObjectIdentifier::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }
    }

    impl wkt::message::Message for PostgresqlObjectIdentifier {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SourceObjectIdentifier.PostgresqlObjectIdentifier"
        }
    }

    /// Mysql data source object identifier.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MysqlObjectIdentifier {
        /// Required. The database name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub database: std::string::String,

        /// Required. The table name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub table: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MysqlObjectIdentifier {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [database][crate::model::source_object_identifier::MysqlObjectIdentifier::database].
        pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.database = v.into();
            self
        }

        /// Sets the value of [table][crate::model::source_object_identifier::MysqlObjectIdentifier::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }
    }

    impl wkt::message::Message for MysqlObjectIdentifier {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SourceObjectIdentifier.MysqlObjectIdentifier"
        }
    }

    /// SQLServer data source object identifier.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlServerObjectIdentifier {
        /// Required. The schema name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub schema: std::string::String,

        /// Required. The table name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub table: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlServerObjectIdentifier {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [schema][crate::model::source_object_identifier::SqlServerObjectIdentifier::schema].
        pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.schema = v.into();
            self
        }

        /// Sets the value of [table][crate::model::source_object_identifier::SqlServerObjectIdentifier::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlServerObjectIdentifier {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SourceObjectIdentifier.SqlServerObjectIdentifier"
        }
    }

    /// Salesforce data source object identifier.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SalesforceObjectIdentifier {
        /// Required. The object name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub object_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SalesforceObjectIdentifier {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [object_name][crate::model::source_object_identifier::SalesforceObjectIdentifier::object_name].
        pub fn set_object_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.object_name = v.into();
            self
        }
    }

    impl wkt::message::Message for SalesforceObjectIdentifier {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SourceObjectIdentifier.SalesforceObjectIdentifier"
        }
    }

    /// The identifier for an object in the data source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceIdentifier {
        /// Oracle data source object identifier.
        OracleIdentifier(
            std::boxed::Box<crate::model::source_object_identifier::OracleObjectIdentifier>,
        ),
        /// Mysql data source object identifier.
        MysqlIdentifier(
            std::boxed::Box<crate::model::source_object_identifier::MysqlObjectIdentifier>,
        ),
        /// PostgreSQL data source object identifier.
        PostgresqlIdentifier(
            std::boxed::Box<crate::model::source_object_identifier::PostgresqlObjectIdentifier>,
        ),
        /// SQLServer data source object identifier.
        SqlServerIdentifier(
            std::boxed::Box<crate::model::source_object_identifier::SqlServerObjectIdentifier>,
        ),
        /// Salesforce data source object identifier.
        SalesforceIdentifier(
            std::boxed::Box<crate::model::source_object_identifier::SalesforceObjectIdentifier>,
        ),
    }
}

/// Represents a backfill job on a specific stream object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackfillJob {
    /// Output only. Backfill job state.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::backfill_job::State,

    /// Backfill job's triggering reason.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub trigger: crate::model::backfill_job::Trigger,

    /// Output only. Backfill job's start time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Backfill job's end time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Errors which caused the backfill job to fail.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackfillJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BackfillJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::backfill_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::BackfillJob::trigger].
    pub fn set_trigger<T: std::convert::Into<crate::model::backfill_job::Trigger>>(
        mut self,
        v: T,
    ) -> Self {
        self.trigger = v.into();
        self
    }

    /// Sets the value of [last_start_time][crate::model::BackfillJob::last_start_time].
    pub fn set_last_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_start_time][crate::model::BackfillJob::last_start_time].
    pub fn set_or_clear_last_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_end_time][crate::model::BackfillJob::last_end_time].
    pub fn set_last_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_end_time][crate::model::BackfillJob::last_end_time].
    pub fn set_or_clear_last_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [errors][crate::model::BackfillJob::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BackfillJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.BackfillJob"
    }
}

/// Defines additional types related to [BackfillJob].
pub mod backfill_job {
    #[allow(unused_imports)]
    use super::*;

    /// State of the stream object's backfill job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value.
        Unspecified,
        /// Backfill job was never started for the stream object (stream has backfill
        /// strategy defined as manual or object was explicitly excluded from
        /// automatic backfill).
        NotStarted,
        /// Backfill job will start pending available resources.
        Pending,
        /// Backfill job is running.
        Active,
        /// Backfill job stopped (next job run will start from beginning).
        Stopped,
        /// Backfill job failed (due to an error).
        Failed,
        /// Backfill completed successfully.
        Completed,
        /// Backfill job failed since the table structure is currently unsupported
        /// for backfill.
        Unsupported,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotStarted => std::option::Option::Some(1),
                Self::Pending => std::option::Option::Some(2),
                Self::Active => std::option::Option::Some(3),
                Self::Stopped => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Completed => std::option::Option::Some(6),
                Self::Unsupported => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::NotStarted => std::option::Option::Some("NOT_STARTED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::Unsupported => std::option::Option::Some("UNSUPPORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotStarted,
                2 => Self::Pending,
                3 => Self::Active,
                4 => Self::Stopped,
                5 => Self::Failed,
                6 => Self::Completed,
                7 => Self::Unsupported,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "NOT_STARTED" => Self::NotStarted,
                "PENDING" => Self::Pending,
                "ACTIVE" => Self::Active,
                "STOPPED" => Self::Stopped,
                "FAILED" => Self::Failed,
                "COMPLETED" => Self::Completed,
                "UNSUPPORTED" => Self::Unsupported,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotStarted => serializer.serialize_i32(1),
                Self::Pending => serializer.serialize_i32(2),
                Self::Active => serializer.serialize_i32(3),
                Self::Stopped => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Completed => serializer.serialize_i32(6),
                Self::Unsupported => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.datastream.v1.BackfillJob.State",
            ))
        }
    }

    /// Triggering reason for a backfill job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Trigger {
        /// Default value.
        Unspecified,
        /// Object backfill job was triggered automatically according to the stream's
        /// backfill strategy.
        Automatic,
        /// Object backfill job was triggered manually using the dedicated API.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Trigger::value] or
        /// [Trigger::name].
        UnknownValue(trigger::UnknownValue),
    }

    #[doc(hidden)]
    pub mod trigger {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Trigger {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automatic => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TRIGGER_UNSPECIFIED"),
                Self::Automatic => std::option::Option::Some("AUTOMATIC"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Trigger {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Trigger {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Trigger {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automatic,
                2 => Self::Manual,
                _ => Self::UnknownValue(trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Trigger {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRIGGER_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC" => Self::Automatic,
                "MANUAL" => Self::Manual,
                _ => Self::UnknownValue(trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Trigger {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automatic => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Trigger {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Trigger>::new(
                ".google.cloud.datastream.v1.BackfillJob.Trigger",
            ))
        }
    }
}

/// Represent a user-facing Error.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Error {
    /// A title that explains the reason for the error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reason: std::string::String,

    /// A unique identifier for this specific error,
    /// allowing it to be traced throughout the system in logs and API responses.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_uuid: std::string::String,

    /// A message containing more information about the error that occurred.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// The time when the error occurred.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_time: std::option::Option<wkt::Timestamp>,

    /// Additional information about the error.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub details: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Error {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reason][crate::model::Error::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }

    /// Sets the value of [error_uuid][crate::model::Error::error_uuid].
    pub fn set_error_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_uuid = v.into();
        self
    }

    /// Sets the value of [message][crate::model::Error::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [error_time][crate::model::Error::error_time].
    pub fn set_error_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.error_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_time][crate::model::Error::error_time].
    pub fn set_or_clear_error_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.error_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [details][crate::model::Error::details].
    pub fn set_details<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Error {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.Error"
    }
}

/// Contains the current validation results.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValidationResult {
    /// A list of validations (includes both executed as well as not executed
    /// validations).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub validations: std::vec::Vec<crate::model::Validation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidationResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [validations][crate::model::ValidationResult::validations].
    pub fn set_validations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Validation>,
    {
        use std::iter::Iterator;
        self.validations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ValidationResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ValidationResult"
    }
}

/// A validation to perform on a stream.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Validation {
    /// A short description of the validation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Validation execution status.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::validation::State,

    /// Messages reflecting the validation results.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub message: std::vec::Vec<crate::model::ValidationMessage>,

    /// A custom code identifying this validation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Validation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::Validation::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Validation::state].
    pub fn set_state<T: std::convert::Into<crate::model::validation::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [message][crate::model::Validation::message].
    pub fn set_message<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ValidationMessage>,
    {
        use std::iter::Iterator;
        self.message = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [code][crate::model::Validation::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for Validation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.Validation"
    }
}

/// Defines additional types related to [Validation].
pub mod validation {
    #[allow(unused_imports)]
    use super::*;

    /// Validation execution state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// Validation did not execute.
        NotExecuted,
        /// Validation failed.
        Failed,
        /// Validation passed.
        Passed,
        /// Validation executed with warnings.
        Warning,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotExecuted => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Passed => std::option::Option::Some(3),
                Self::Warning => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::NotExecuted => std::option::Option::Some("NOT_EXECUTED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Passed => std::option::Option::Some("PASSED"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotExecuted,
                2 => Self::Failed,
                3 => Self::Passed,
                4 => Self::Warning,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "NOT_EXECUTED" => Self::NotExecuted,
                "FAILED" => Self::Failed,
                "PASSED" => Self::Passed,
                "WARNING" => Self::Warning,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotExecuted => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Passed => serializer.serialize_i32(3),
                Self::Warning => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.datastream.v1.Validation.State",
            ))
        }
    }
}

/// Represent user-facing validation result message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValidationMessage {
    /// The result of the validation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// Message severity level (warning or error).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub level: crate::model::validation_message::Level,

    /// Additional metadata related to the result.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// A custom code identifying this specific message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidationMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::ValidationMessage::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [level][crate::model::ValidationMessage::level].
    pub fn set_level<T: std::convert::Into<crate::model::validation_message::Level>>(
        mut self,
        v: T,
    ) -> Self {
        self.level = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ValidationMessage::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [code][crate::model::ValidationMessage::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for ValidationMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ValidationMessage"
    }
}

/// Defines additional types related to [ValidationMessage].
pub mod validation_message {
    #[allow(unused_imports)]
    use super::*;

    /// Validation message level.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Level {
        /// Unspecified level.
        Unspecified,
        /// Potentially cause issues with the Stream.
        Warning,
        /// Definitely cause issues with the Stream.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Level::value] or
        /// [Level::name].
        UnknownValue(level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Level {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Warning => std::option::Option::Some(1),
                Self::Error => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LEVEL_UNSPECIFIED"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Level {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Level {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Level {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Warning,
                2 => Self::Error,
                _ => Self::UnknownValue(level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Level {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LEVEL_UNSPECIFIED" => Self::Unspecified,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Level {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Warning => serializer.serialize_i32(1),
                Self::Error => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Level {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Level>::new(
                ".google.cloud.datastream.v1.ValidationMessage.Level",
            ))
        }
    }
}

/// The strategy that the stream uses for CDC replication.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CdcStrategy {
    /// The position to start reading from when starting, resuming, or recovering
    /// the stream.
    /// If not set, the system's default value will be used.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub start_position: std::option::Option<crate::model::cdc_strategy::StartPosition>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CdcStrategy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_position][crate::model::CdcStrategy::start_position].
    ///
    /// Note that all the setters affecting `start_position` are mutually
    /// exclusive.
    pub fn set_start_position<
        T: std::convert::Into<std::option::Option<crate::model::cdc_strategy::StartPosition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.start_position = v.into();
        self
    }

    /// The value of [start_position][crate::model::CdcStrategy::start_position]
    /// if it holds a `MostRecentStartPosition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn most_recent_start_position(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cdc_strategy::MostRecentStartPosition>>
    {
        #[allow(unreachable_patterns)]
        self.start_position.as_ref().and_then(|v| match v {
            crate::model::cdc_strategy::StartPosition::MostRecentStartPosition(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [start_position][crate::model::CdcStrategy::start_position]
    /// to hold a `MostRecentStartPosition`.
    ///
    /// Note that all the setters affecting `start_position` are
    /// mutually exclusive.
    pub fn set_most_recent_start_position<
        T: std::convert::Into<std::boxed::Box<crate::model::cdc_strategy::MostRecentStartPosition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.start_position = std::option::Option::Some(
            crate::model::cdc_strategy::StartPosition::MostRecentStartPosition(v.into()),
        );
        self
    }

    /// The value of [start_position][crate::model::CdcStrategy::start_position]
    /// if it holds a `NextAvailableStartPosition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn next_available_start_position(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cdc_strategy::NextAvailableStartPosition>>
    {
        #[allow(unreachable_patterns)]
        self.start_position.as_ref().and_then(|v| match v {
            crate::model::cdc_strategy::StartPosition::NextAvailableStartPosition(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [start_position][crate::model::CdcStrategy::start_position]
    /// to hold a `NextAvailableStartPosition`.
    ///
    /// Note that all the setters affecting `start_position` are
    /// mutually exclusive.
    pub fn set_next_available_start_position<
        T: std::convert::Into<std::boxed::Box<crate::model::cdc_strategy::NextAvailableStartPosition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.start_position = std::option::Option::Some(
            crate::model::cdc_strategy::StartPosition::NextAvailableStartPosition(v.into()),
        );
        self
    }

    /// The value of [start_position][crate::model::CdcStrategy::start_position]
    /// if it holds a `SpecificStartPosition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn specific_start_position(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cdc_strategy::SpecificStartPosition>>
    {
        #[allow(unreachable_patterns)]
        self.start_position.as_ref().and_then(|v| match v {
            crate::model::cdc_strategy::StartPosition::SpecificStartPosition(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [start_position][crate::model::CdcStrategy::start_position]
    /// to hold a `SpecificStartPosition`.
    ///
    /// Note that all the setters affecting `start_position` are
    /// mutually exclusive.
    pub fn set_specific_start_position<
        T: std::convert::Into<std::boxed::Box<crate::model::cdc_strategy::SpecificStartPosition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.start_position = std::option::Option::Some(
            crate::model::cdc_strategy::StartPosition::SpecificStartPosition(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CdcStrategy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.CdcStrategy"
    }
}

/// Defines additional types related to [CdcStrategy].
pub mod cdc_strategy {
    #[allow(unused_imports)]
    use super::*;

    /// CDC strategy to start replicating from the most recent position in the
    /// source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MostRecentStartPosition {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MostRecentStartPosition {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for MostRecentStartPosition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.CdcStrategy.MostRecentStartPosition"
        }
    }

    /// CDC strategy to resume replication from the next available position in the
    /// source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NextAvailableStartPosition {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NextAvailableStartPosition {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for NextAvailableStartPosition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.CdcStrategy.NextAvailableStartPosition"
        }
    }

    /// CDC strategy to start replicating from a specific position in the source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SpecificStartPosition {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub position:
            std::option::Option<crate::model::cdc_strategy::specific_start_position::Position>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SpecificStartPosition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [position][crate::model::cdc_strategy::SpecificStartPosition::position].
        ///
        /// Note that all the setters affecting `position` are mutually
        /// exclusive.
        pub fn set_position<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::cdc_strategy::specific_start_position::Position,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.position = v.into();
            self
        }

        /// The value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// if it holds a `MysqlLogPosition`, `None` if the field is not set or
        /// holds a different branch.
        pub fn mysql_log_position(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::MysqlLogPosition>> {
            #[allow(unreachable_patterns)]
            self.position.as_ref().and_then(|v| match v {
                crate::model::cdc_strategy::specific_start_position::Position::MysqlLogPosition(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// to hold a `MysqlLogPosition`.
        ///
        /// Note that all the setters affecting `position` are
        /// mutually exclusive.
        pub fn set_mysql_log_position<
            T: std::convert::Into<std::boxed::Box<crate::model::MysqlLogPosition>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.position = std::option::Option::Some(
                crate::model::cdc_strategy::specific_start_position::Position::MysqlLogPosition(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// if it holds a `OracleScnPosition`, `None` if the field is not set or
        /// holds a different branch.
        pub fn oracle_scn_position(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::OracleScnPosition>> {
            #[allow(unreachable_patterns)]
            self.position.as_ref().and_then(|v| match v {
                crate::model::cdc_strategy::specific_start_position::Position::OracleScnPosition(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// to hold a `OracleScnPosition`.
        ///
        /// Note that all the setters affecting `position` are
        /// mutually exclusive.
        pub fn set_oracle_scn_position<
            T: std::convert::Into<std::boxed::Box<crate::model::OracleScnPosition>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.position = std::option::Option::Some(
                crate::model::cdc_strategy::specific_start_position::Position::OracleScnPosition(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// if it holds a `SqlServerLsnPosition`, `None` if the field is not set or
        /// holds a different branch.
        pub fn sql_server_lsn_position(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerLsnPosition>> {
            #[allow(unreachable_patterns)]
            self.position.as_ref().and_then(|v| match v {
                crate::model::cdc_strategy::specific_start_position::Position::SqlServerLsnPosition(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// to hold a `SqlServerLsnPosition`.
        ///
        /// Note that all the setters affecting `position` are
        /// mutually exclusive.
        pub fn set_sql_server_lsn_position<
            T: std::convert::Into<std::boxed::Box<crate::model::SqlServerLsnPosition>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.position = std::option::Option::Some(
                crate::model::cdc_strategy::specific_start_position::Position::SqlServerLsnPosition(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// if it holds a `MysqlGtidPosition`, `None` if the field is not set or
        /// holds a different branch.
        pub fn mysql_gtid_position(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::MysqlGtidPosition>> {
            #[allow(unreachable_patterns)]
            self.position.as_ref().and_then(|v| match v {
                crate::model::cdc_strategy::specific_start_position::Position::MysqlGtidPosition(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// to hold a `MysqlGtidPosition`.
        ///
        /// Note that all the setters affecting `position` are
        /// mutually exclusive.
        pub fn set_mysql_gtid_position<
            T: std::convert::Into<std::boxed::Box<crate::model::MysqlGtidPosition>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.position = std::option::Option::Some(
                crate::model::cdc_strategy::specific_start_position::Position::MysqlGtidPosition(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for SpecificStartPosition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.CdcStrategy.SpecificStartPosition"
        }
    }

    /// Defines additional types related to [SpecificStartPosition].
    pub mod specific_start_position {
        #[allow(unused_imports)]
        use super::*;

        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Position {
            /// MySQL specific log position to start replicating from.
            MysqlLogPosition(std::boxed::Box<crate::model::MysqlLogPosition>),
            /// Oracle SCN to start replicating from.
            OracleScnPosition(std::boxed::Box<crate::model::OracleScnPosition>),
            /// SqlServer LSN to start replicating from.
            SqlServerLsnPosition(std::boxed::Box<crate::model::SqlServerLsnPosition>),
            /// MySQL GTID set to start replicating from.
            MysqlGtidPosition(std::boxed::Box<crate::model::MysqlGtidPosition>),
        }
    }

    /// The position to start reading from when starting, resuming, or recovering
    /// the stream.
    /// If not set, the system's default value will be used.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum StartPosition {
        /// Optional. Start replicating from the most recent position in the source.
        MostRecentStartPosition(
            std::boxed::Box<crate::model::cdc_strategy::MostRecentStartPosition>,
        ),
        /// Optional. Resume replication from the next available position in the
        /// source.
        NextAvailableStartPosition(
            std::boxed::Box<crate::model::cdc_strategy::NextAvailableStartPosition>,
        ),
        /// Optional. Start replicating from a specific position in the source.
        SpecificStartPosition(std::boxed::Box<crate::model::cdc_strategy::SpecificStartPosition>),
    }
}

/// SQL Server LSN position
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerLsnPosition {
    /// Required. Log sequence number (LSN) from where Logs will be read
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub lsn: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerLsnPosition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lsn][crate::model::SqlServerLsnPosition::lsn].
    pub fn set_lsn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lsn = v.into();
        self
    }
}

impl wkt::message::Message for SqlServerLsnPosition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerLsnPosition"
    }
}

/// Oracle SCN position
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OracleScnPosition {
    /// Required. SCN number from where Logs will be read
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub scn: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleScnPosition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scn][crate::model::OracleScnPosition::scn].
    pub fn set_scn<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.scn = v.into();
        self
    }
}

impl wkt::message::Message for OracleScnPosition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleScnPosition"
    }
}

/// MySQL log position
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MysqlLogPosition {
    /// Required. The binary log file name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub log_file: std::string::String,

    /// Optional. The position within the binary log file. Default is head of file.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::I32>")]
    pub log_position: std::option::Option<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlLogPosition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_file][crate::model::MysqlLogPosition::log_file].
    pub fn set_log_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_file = v.into();
        self
    }

    /// Sets the value of [log_position][crate::model::MysqlLogPosition::log_position].
    pub fn set_log_position<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.log_position = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [log_position][crate::model::MysqlLogPosition::log_position].
    pub fn set_or_clear_log_position<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.log_position = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MysqlLogPosition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlLogPosition"
    }
}

/// MySQL GTID position
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MysqlGtidPosition {
    /// Required. The gtid set to start replication from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gtid_set: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlGtidPosition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gtid_set][crate::model::MysqlGtidPosition::gtid_set].
    pub fn set_gtid_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gtid_set = v.into();
        self
    }
}

impl wkt::message::Message for MysqlGtidPosition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlGtidPosition"
    }
}
