// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for 'discover' ConnectionProfile request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoverConnectionProfileRequest {
    /// Required. The parent resource of the connection profile type. Must be in
    /// the format `projects/*/locations/*`.
    pub parent: std::string::String,

    /// The connection profile on which to run discover.
    pub target: std::option::Option<crate::model::discover_connection_profile_request::Target>,

    /// The depth of the retrieved hierarchy of data objects.
    pub hierarchy:
        std::option::Option<crate::model::discover_connection_profile_request::Hierarchy>,

    /// The data object to populate with child data objects and metadata.
    pub data_object:
        std::option::Option<crate::model::discover_connection_profile_request::DataObject>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoverConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::DiscoverConnectionProfileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [target][crate::model::DiscoverConnectionProfileRequest::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<
                std::option::Option<crate::model::discover_connection_profile_request::Target>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::DiscoverConnectionProfileRequest::target]
    /// if it holds a `ConnectionProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn connection_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::Target::ConnectionProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoverConnectionProfileRequest::target]
    /// to hold a `ConnectionProfile`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_connection_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::ConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discover_connection_profile_request::Target::ConnectionProfile(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::DiscoverConnectionProfileRequest::target]
    /// if it holds a `ConnectionProfileName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn connection_profile_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::Target::ConnectionProfileName(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoverConnectionProfileRequest::target]
    /// to hold a `ConnectionProfileName`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_connection_profile_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discover_connection_profile_request::Target::ConnectionProfileName(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [hierarchy][crate::model::DiscoverConnectionProfileRequest::hierarchy].
    ///
    /// Note that all the setters affecting `hierarchy` are mutually
    /// exclusive.
    pub fn set_hierarchy<
        T: std::convert::Into<
                std::option::Option<crate::model::discover_connection_profile_request::Hierarchy>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hierarchy = v.into();
        self
    }

    /// The value of [hierarchy][crate::model::DiscoverConnectionProfileRequest::hierarchy]
    /// if it holds a `FullHierarchy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn full_hierarchy(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.hierarchy.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::Hierarchy::FullHierarchy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [hierarchy][crate::model::DiscoverConnectionProfileRequest::hierarchy]
    /// to hold a `FullHierarchy`.
    ///
    /// Note that all the setters affecting `hierarchy` are
    /// mutually exclusive.
    pub fn set_full_hierarchy<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.hierarchy = std::option::Option::Some(
            crate::model::discover_connection_profile_request::Hierarchy::FullHierarchy(v.into()),
        );
        self
    }

    /// The value of [hierarchy][crate::model::DiscoverConnectionProfileRequest::hierarchy]
    /// if it holds a `HierarchyDepth`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hierarchy_depth(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.hierarchy.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::Hierarchy::HierarchyDepth(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [hierarchy][crate::model::DiscoverConnectionProfileRequest::hierarchy]
    /// to hold a `HierarchyDepth`.
    ///
    /// Note that all the setters affecting `hierarchy` are
    /// mutually exclusive.
    pub fn set_hierarchy_depth<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.hierarchy = std::option::Option::Some(
            crate::model::discover_connection_profile_request::Hierarchy::HierarchyDepth(v.into()),
        );
        self
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object].
    ///
    /// Note that all the setters affecting `data_object` are mutually
    /// exclusive.
    pub fn set_data_object<
        T: std::convert::Into<
                std::option::Option<crate::model::discover_connection_profile_request::DataObject>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = v.into();
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// if it holds a `OracleRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle_rdbms(&self) -> std::option::Option<&std::boxed::Box<crate::model::OracleRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::DataObject::OracleRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// to hold a `OracleRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_oracle_rdbms<T: std::convert::Into<std::boxed::Box<crate::model::OracleRdbms>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_request::DataObject::OracleRdbms(v.into()),
        );
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// if it holds a `MysqlRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_rdbms(&self) -> std::option::Option<&std::boxed::Box<crate::model::MysqlRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::DataObject::MysqlRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// to hold a `MysqlRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_mysql_rdbms<T: std::convert::Into<std::boxed::Box<crate::model::MysqlRdbms>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_request::DataObject::MysqlRdbms(v.into()),
        );
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// if it holds a `PostgresqlRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql_rdbms(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostgresqlRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::DataObject::PostgresqlRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// to hold a `PostgresqlRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_postgresql_rdbms<
        T: std::convert::Into<std::boxed::Box<crate::model::PostgresqlRdbms>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_request::DataObject::PostgresqlRdbms(
                v.into(),
            ),
        );
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// if it holds a `SqlServerRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_server_rdbms(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_request::DataObject::SqlServerRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileRequest::data_object]
    /// to hold a `SqlServerRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_sql_server_rdbms<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerRdbms>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_request::DataObject::SqlServerRdbms(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoverConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DiscoverConnectionProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoverConnectionProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __connection_profile,
            __connection_profile_name,
            __full_hierarchy,
            __hierarchy_depth,
            __oracle_rdbms,
            __mysql_rdbms,
            __postgresql_rdbms,
            __sql_server_rdbms,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoverConnectionProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "connectionProfile" => Ok(__FieldTag::__connection_profile),
                            "connection_profile" => Ok(__FieldTag::__connection_profile),
                            "connectionProfileName" => Ok(__FieldTag::__connection_profile_name),
                            "connection_profile_name" => Ok(__FieldTag::__connection_profile_name),
                            "fullHierarchy" => Ok(__FieldTag::__full_hierarchy),
                            "full_hierarchy" => Ok(__FieldTag::__full_hierarchy),
                            "hierarchyDepth" => Ok(__FieldTag::__hierarchy_depth),
                            "hierarchy_depth" => Ok(__FieldTag::__hierarchy_depth),
                            "oracleRdbms" => Ok(__FieldTag::__oracle_rdbms),
                            "oracle_rdbms" => Ok(__FieldTag::__oracle_rdbms),
                            "mysqlRdbms" => Ok(__FieldTag::__mysql_rdbms),
                            "mysql_rdbms" => Ok(__FieldTag::__mysql_rdbms),
                            "postgresqlRdbms" => Ok(__FieldTag::__postgresql_rdbms),
                            "postgresql_rdbms" => Ok(__FieldTag::__postgresql_rdbms),
                            "sqlServerRdbms" => Ok(__FieldTag::__sql_server_rdbms),
                            "sql_server_rdbms" => Ok(__FieldTag::__sql_server_rdbms),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoverConnectionProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoverConnectionProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_profile => {
                            if !fields.insert(__FieldTag::__connection_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_profile",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.cloud.datastream.v1.DiscoverConnectionProfileRequest.connection_profile, latest field was connectionProfile",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::discover_connection_profile_request::Target::ConnectionProfile(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ConnectionProfile>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__connection_profile_name => {
                            if !fields.insert(__FieldTag::__connection_profile_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_profile_name",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.cloud.datastream.v1.DiscoverConnectionProfileRequest.connection_profile_name, latest field was connectionProfileName",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::discover_connection_profile_request::Target::ConnectionProfileName(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__full_hierarchy => {
                            if !fields.insert(__FieldTag::__full_hierarchy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_hierarchy",
                                ));
                            }
                            if result.hierarchy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `hierarchy`, a oneof with full ID .google.cloud.datastream.v1.DiscoverConnectionProfileRequest.full_hierarchy, latest field was fullHierarchy",
                                ));
                            }
                            result.hierarchy = std::option::Option::Some(
                                crate::model::discover_connection_profile_request::Hierarchy::FullHierarchy(
                                    map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__hierarchy_depth => {
                            if !fields.insert(__FieldTag::__hierarchy_depth) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hierarchy_depth",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.hierarchy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `hierarchy`, a oneof with full ID .google.cloud.datastream.v1.DiscoverConnectionProfileRequest.hierarchy_depth, latest field was hierarchyDepth",
                                ));
                            }
                            result.hierarchy = std::option::Option::Some(
                                crate::model::discover_connection_profile_request::Hierarchy::HierarchyDepth(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__oracle_rdbms => {
                            if !fields.insert(__FieldTag::__oracle_rdbms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oracle_rdbms",
                                ));
                            }
                            if result.data_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_object`, a oneof with full ID .google.cloud.datastream.v1.DiscoverConnectionProfileRequest.oracle_rdbms, latest field was oracleRdbms",
                                ));
                            }
                            result.data_object = std::option::Option::Some(
                                crate::model::discover_connection_profile_request::DataObject::OracleRdbms(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::OracleRdbms>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__mysql_rdbms => {
                            if !fields.insert(__FieldTag::__mysql_rdbms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql_rdbms",
                                ));
                            }
                            if result.data_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_object`, a oneof with full ID .google.cloud.datastream.v1.DiscoverConnectionProfileRequest.mysql_rdbms, latest field was mysqlRdbms",
                                ));
                            }
                            result.data_object = std::option::Option::Some(
                                crate::model::discover_connection_profile_request::DataObject::MysqlRdbms(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::MysqlRdbms>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__postgresql_rdbms => {
                            if !fields.insert(__FieldTag::__postgresql_rdbms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postgresql_rdbms",
                                ));
                            }
                            if result.data_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_object`, a oneof with full ID .google.cloud.datastream.v1.DiscoverConnectionProfileRequest.postgresql_rdbms, latest field was postgresqlRdbms",
                                ));
                            }
                            result.data_object = std::option::Option::Some(
                                crate::model::discover_connection_profile_request::DataObject::PostgresqlRdbms(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::PostgresqlRdbms>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__sql_server_rdbms => {
                            if !fields.insert(__FieldTag::__sql_server_rdbms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_server_rdbms",
                                ));
                            }
                            if result.data_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_object`, a oneof with full ID .google.cloud.datastream.v1.DiscoverConnectionProfileRequest.sql_server_rdbms, latest field was sqlServerRdbms",
                                ));
                            }
                            result.data_object = std::option::Option::Some(
                                crate::model::discover_connection_profile_request::DataObject::SqlServerRdbms(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SqlServerRdbms>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoverConnectionProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.connection_profile() {
            state.serialize_entry("connectionProfile", value)?;
        }
        if let Some(value) = self.connection_profile_name() {
            state.serialize_entry("connectionProfileName", value)?;
        }
        if let Some(value) = self.full_hierarchy() {
            state.serialize_entry("fullHierarchy", value)?;
        }
        if let Some(value) = self.hierarchy_depth() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hierarchyDepth", &__With(value))?;
        }
        if let Some(value) = self.oracle_rdbms() {
            state.serialize_entry("oracleRdbms", value)?;
        }
        if let Some(value) = self.mysql_rdbms() {
            state.serialize_entry("mysqlRdbms", value)?;
        }
        if let Some(value) = self.postgresql_rdbms() {
            state.serialize_entry("postgresqlRdbms", value)?;
        }
        if let Some(value) = self.sql_server_rdbms() {
            state.serialize_entry("sqlServerRdbms", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiscoverConnectionProfileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiscoverConnectionProfileRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("target", &self.target);
        debug_struct.field("hierarchy", &self.hierarchy);
        debug_struct.field("data_object", &self.data_object);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DiscoverConnectionProfileRequest].
pub mod discover_connection_profile_request {
    #[allow(unused_imports)]
    use super::*;

    /// The connection profile on which to run discover.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// An ad-hoc connection profile configuration.
        ConnectionProfile(std::boxed::Box<crate::model::ConnectionProfile>),
        /// A reference to an existing connection profile.
        ConnectionProfileName(std::string::String),
    }

    /// The depth of the retrieved hierarchy of data objects.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Hierarchy {
        /// Whether to retrieve the full hierarchy of data objects (TRUE) or only the
        /// current level (FALSE).
        FullHierarchy(bool),
        /// The number of hierarchy levels below the current level to be retrieved.
        HierarchyDepth(i32),
    }

    /// The data object to populate with child data objects and metadata.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataObject {
        /// Oracle RDBMS to enrich with child data objects and metadata.
        OracleRdbms(std::boxed::Box<crate::model::OracleRdbms>),
        /// MySQL RDBMS to enrich with child data objects and metadata.
        MysqlRdbms(std::boxed::Box<crate::model::MysqlRdbms>),
        /// PostgreSQL RDBMS to enrich with child data objects and metadata.
        PostgresqlRdbms(std::boxed::Box<crate::model::PostgresqlRdbms>),
        /// SQLServer RDBMS to enrich with child data objects and metadata.
        SqlServerRdbms(std::boxed::Box<crate::model::SqlServerRdbms>),
    }
}

/// Response from a discover request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoverConnectionProfileResponse {
    /// The data object that has been enriched by the discover API call.
    pub data_object:
        std::option::Option<crate::model::discover_connection_profile_response::DataObject>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoverConnectionProfileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object].
    ///
    /// Note that all the setters affecting `data_object` are mutually
    /// exclusive.
    pub fn set_data_object<
        T: std::convert::Into<
                std::option::Option<crate::model::discover_connection_profile_response::DataObject>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = v.into();
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// if it holds a `OracleRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle_rdbms(&self) -> std::option::Option<&std::boxed::Box<crate::model::OracleRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_response::DataObject::OracleRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// to hold a `OracleRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_oracle_rdbms<T: std::convert::Into<std::boxed::Box<crate::model::OracleRdbms>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_response::DataObject::OracleRdbms(v.into()),
        );
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// if it holds a `MysqlRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_rdbms(&self) -> std::option::Option<&std::boxed::Box<crate::model::MysqlRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_response::DataObject::MysqlRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// to hold a `MysqlRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_mysql_rdbms<T: std::convert::Into<std::boxed::Box<crate::model::MysqlRdbms>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_response::DataObject::MysqlRdbms(v.into()),
        );
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// if it holds a `PostgresqlRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql_rdbms(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostgresqlRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_response::DataObject::PostgresqlRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// to hold a `PostgresqlRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_postgresql_rdbms<
        T: std::convert::Into<std::boxed::Box<crate::model::PostgresqlRdbms>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_response::DataObject::PostgresqlRdbms(
                v.into(),
            ),
        );
        self
    }

    /// The value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// if it holds a `SqlServerRdbms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_server_rdbms(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerRdbms>> {
        #[allow(unreachable_patterns)]
        self.data_object.as_ref().and_then(|v| match v {
            crate::model::discover_connection_profile_response::DataObject::SqlServerRdbms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_object][crate::model::DiscoverConnectionProfileResponse::data_object]
    /// to hold a `SqlServerRdbms`.
    ///
    /// Note that all the setters affecting `data_object` are
    /// mutually exclusive.
    pub fn set_sql_server_rdbms<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerRdbms>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_object = std::option::Option::Some(
            crate::model::discover_connection_profile_response::DataObject::SqlServerRdbms(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DiscoverConnectionProfileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DiscoverConnectionProfileResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoverConnectionProfileResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __oracle_rdbms,
            __mysql_rdbms,
            __postgresql_rdbms,
            __sql_server_rdbms,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoverConnectionProfileResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "oracleRdbms" => Ok(__FieldTag::__oracle_rdbms),
                            "oracle_rdbms" => Ok(__FieldTag::__oracle_rdbms),
                            "mysqlRdbms" => Ok(__FieldTag::__mysql_rdbms),
                            "mysql_rdbms" => Ok(__FieldTag::__mysql_rdbms),
                            "postgresqlRdbms" => Ok(__FieldTag::__postgresql_rdbms),
                            "postgresql_rdbms" => Ok(__FieldTag::__postgresql_rdbms),
                            "sqlServerRdbms" => Ok(__FieldTag::__sql_server_rdbms),
                            "sql_server_rdbms" => Ok(__FieldTag::__sql_server_rdbms),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoverConnectionProfileResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoverConnectionProfileResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__oracle_rdbms => {
                            if !fields.insert(__FieldTag::__oracle_rdbms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oracle_rdbms",
                                ));
                            }
                            if result.data_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_object`, a oneof with full ID .google.cloud.datastream.v1.DiscoverConnectionProfileResponse.oracle_rdbms, latest field was oracleRdbms",
                                ));
                            }
                            result.data_object = std::option::Option::Some(
                                crate::model::discover_connection_profile_response::DataObject::OracleRdbms(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::OracleRdbms>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__mysql_rdbms => {
                            if !fields.insert(__FieldTag::__mysql_rdbms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql_rdbms",
                                ));
                            }
                            if result.data_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_object`, a oneof with full ID .google.cloud.datastream.v1.DiscoverConnectionProfileResponse.mysql_rdbms, latest field was mysqlRdbms",
                                ));
                            }
                            result.data_object = std::option::Option::Some(
                                crate::model::discover_connection_profile_response::DataObject::MysqlRdbms(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::MysqlRdbms>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__postgresql_rdbms => {
                            if !fields.insert(__FieldTag::__postgresql_rdbms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postgresql_rdbms",
                                ));
                            }
                            if result.data_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_object`, a oneof with full ID .google.cloud.datastream.v1.DiscoverConnectionProfileResponse.postgresql_rdbms, latest field was postgresqlRdbms",
                                ));
                            }
                            result.data_object = std::option::Option::Some(
                                crate::model::discover_connection_profile_response::DataObject::PostgresqlRdbms(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::PostgresqlRdbms>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__sql_server_rdbms => {
                            if !fields.insert(__FieldTag::__sql_server_rdbms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_server_rdbms",
                                ));
                            }
                            if result.data_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_object`, a oneof with full ID .google.cloud.datastream.v1.DiscoverConnectionProfileResponse.sql_server_rdbms, latest field was sqlServerRdbms",
                                ));
                            }
                            result.data_object = std::option::Option::Some(
                                crate::model::discover_connection_profile_response::DataObject::SqlServerRdbms(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SqlServerRdbms>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoverConnectionProfileResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.oracle_rdbms() {
            state.serialize_entry("oracleRdbms", value)?;
        }
        if let Some(value) = self.mysql_rdbms() {
            state.serialize_entry("mysqlRdbms", value)?;
        }
        if let Some(value) = self.postgresql_rdbms() {
            state.serialize_entry("postgresqlRdbms", value)?;
        }
        if let Some(value) = self.sql_server_rdbms() {
            state.serialize_entry("sqlServerRdbms", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiscoverConnectionProfileResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiscoverConnectionProfileResponse");
        debug_struct.field("data_object", &self.data_object);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DiscoverConnectionProfileResponse].
pub mod discover_connection_profile_response {
    #[allow(unused_imports)]
    use super::*;

    /// The data object that has been enriched by the discover API call.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataObject {
        /// Enriched Oracle RDBMS object.
        OracleRdbms(std::boxed::Box<crate::model::OracleRdbms>),
        /// Enriched MySQL RDBMS object.
        MysqlRdbms(std::boxed::Box<crate::model::MysqlRdbms>),
        /// Enriched PostgreSQL RDBMS object.
        PostgresqlRdbms(std::boxed::Box<crate::model::PostgresqlRdbms>),
        /// Enriched SQLServer RDBMS object.
        SqlServerRdbms(std::boxed::Box<crate::model::SqlServerRdbms>),
    }
}

/// Request message for 'FetchStaticIps' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchStaticIpsRequest {
    /// Required. The resource name for the location for which static IPs should be
    /// returned. Must be in the format `projects/*/locations/*`.
    pub name: std::string::String,

    /// Maximum number of Ips to return, will likely not be specified.
    pub page_size: i32,

    /// A page token, received from a previous `ListStaticIps` call.
    /// will likely not be specified.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchStaticIpsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FetchStaticIpsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchStaticIpsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchStaticIpsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchStaticIpsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.FetchStaticIpsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchStaticIpsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchStaticIpsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchStaticIpsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchStaticIpsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchStaticIpsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchStaticIpsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchStaticIpsRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for a 'FetchStaticIps' response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchStaticIpsResponse {
    /// list of static ips by account
    pub static_ips: std::vec::Vec<std::string::String>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchStaticIpsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [static_ips][crate::model::FetchStaticIpsResponse::static_ips].
    pub fn set_static_ips<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.static_ips = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchStaticIpsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchStaticIpsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.FetchStaticIpsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchStaticIpsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __static_ips,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchStaticIpsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "staticIps" => Ok(__FieldTag::__static_ips),
                            "static_ips" => Ok(__FieldTag::__static_ips),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchStaticIpsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchStaticIpsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__static_ips => {
                            if !fields.insert(__FieldTag::__static_ips) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for static_ips",
                                ));
                            }
                            result.static_ips = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchStaticIpsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.static_ips.is_empty() {
            state.serialize_entry("staticIps", &self.static_ips)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchStaticIpsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchStaticIpsResponse");
        debug_struct.field("static_ips", &self.static_ips);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for listing connection profiles.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionProfilesRequest {
    /// Required. The parent that owns the collection of connection profiles.
    pub parent: std::string::String,

    /// Maximum number of connection profiles to return.
    /// If unspecified, at most 50 connection profiles will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Page token received from a previous `ListConnectionProfiles` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListConnectionProfiles`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Filter request.
    pub filter: std::string::String,

    /// Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectionProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConnectionProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListConnectionProfilesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionProfilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionProfilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionProfilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionProfilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionProfilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectionProfilesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionProfilesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing connection profiles.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionProfilesResponse {
    /// List of connection profiles.
    pub connection_profiles: std::vec::Vec<crate::model::ConnectionProfile>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_profiles][crate::model::ListConnectionProfilesResponse::connection_profiles].
    pub fn set_connection_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectionProfile>,
    {
        use std::iter::Iterator;
        self.connection_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectionProfilesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListConnectionProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionProfilesResponse {
    type PageItem = crate::model::ConnectionProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connection_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionProfilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection_profiles,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionProfilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connectionProfiles" => Ok(__FieldTag::__connection_profiles),
                            "connection_profiles" => Ok(__FieldTag::__connection_profiles),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionProfilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionProfilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection_profiles => {
                            if !fields.insert(__FieldTag::__connection_profiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_profiles",
                                ));
                            }
                            result.connection_profiles =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConnectionProfile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionProfilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connection_profiles.is_empty() {
            state.serialize_entry("connectionProfiles", &self.connection_profiles)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectionProfilesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionProfilesResponse");
        debug_struct.field("connection_profiles", &self.connection_profiles);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for getting a connection profile.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConnectionProfileRequest {
    /// Required. The name of the connection profile resource to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GetConnectionProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConnectionProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectionProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConnectionProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectionProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConnectionProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetConnectionProfileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectionProfileRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for creating a connection profile.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConnectionProfileRequest {
    /// Required. The parent that owns the collection of ConnectionProfiles.
    pub parent: std::string::String,

    /// Required. The connection profile identifier.
    pub connection_profile_id: std::string::String,

    /// Required. The connection profile resource to create.
    pub connection_profile: std::option::Option<crate::model::ConnectionProfile>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. Only validate the connection profile, but don't create any
    /// resources. The default is false.
    pub validate_only: bool,

    /// Optional. Create the connection profile without validating it.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionProfileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection_profile_id][crate::model::CreateConnectionProfileRequest::connection_profile_id].
    pub fn set_connection_profile_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile_id = v.into();
        self
    }

    /// Sets the value of [connection_profile][crate::model::CreateConnectionProfileRequest::connection_profile].
    pub fn set_connection_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionProfile>,
    {
        self.connection_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_profile][crate::model::CreateConnectionProfileRequest::connection_profile].
    pub fn set_or_clear_connection_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionProfile>,
    {
        self.connection_profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateConnectionProfileRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::CreateConnectionProfileRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for CreateConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.CreateConnectionProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConnectionProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __connection_profile_id,
            __connection_profile,
            __request_id,
            __validate_only,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConnectionProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "connectionProfileId" => Ok(__FieldTag::__connection_profile_id),
                            "connection_profile_id" => Ok(__FieldTag::__connection_profile_id),
                            "connectionProfile" => Ok(__FieldTag::__connection_profile),
                            "connection_profile" => Ok(__FieldTag::__connection_profile),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConnectionProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConnectionProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_profile_id => {
                            if !fields.insert(__FieldTag::__connection_profile_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_profile_id",
                                ));
                            }
                            result.connection_profile_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_profile => {
                            if !fields.insert(__FieldTag::__connection_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_profile",
                                ));
                            }
                            result.connection_profile = map
                                .next_value::<std::option::Option<crate::model::ConnectionProfile>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateConnectionProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.connection_profile_id.is_empty() {
            state.serialize_entry("connectionProfileId", &self.connection_profile_id)?;
        }
        if self.connection_profile.is_some() {
            state.serialize_entry("connectionProfile", &self.connection_profile)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateConnectionProfileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateConnectionProfileRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("connection_profile_id", &self.connection_profile_id);
        debug_struct.field("connection_profile", &self.connection_profile);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Connection profile update message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateConnectionProfileRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// ConnectionProfile resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The connection profile to update.
    pub connection_profile: std::option::Option<crate::model::ConnectionProfile>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. Only validate the connection profile, but don't update any
    /// resources. The default is false.
    pub validate_only: bool,

    /// Optional. Update the connection profile without validating it.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionProfileRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConnectionProfileRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connection_profile][crate::model::UpdateConnectionProfileRequest::connection_profile].
    pub fn set_connection_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionProfile>,
    {
        self.connection_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_profile][crate::model::UpdateConnectionProfileRequest::connection_profile].
    pub fn set_or_clear_connection_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionProfile>,
    {
        self.connection_profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateConnectionProfileRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::UpdateConnectionProfileRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.UpdateConnectionProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateConnectionProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __connection_profile,
            __request_id,
            __validate_only,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConnectionProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "connectionProfile" => Ok(__FieldTag::__connection_profile),
                            "connection_profile" => Ok(__FieldTag::__connection_profile),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateConnectionProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConnectionProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__connection_profile => {
                            if !fields.insert(__FieldTag::__connection_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_profile",
                                ));
                            }
                            result.connection_profile = map
                                .next_value::<std::option::Option<crate::model::ConnectionProfile>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateConnectionProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.connection_profile.is_some() {
            state.serialize_entry("connectionProfile", &self.connection_profile)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateConnectionProfileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateConnectionProfileRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("connection_profile", &self.connection_profile);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for deleting a connection profile.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConnectionProfileRequest {
    /// Required. The name of the connection profile resource to delete.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DeleteConnectionProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConnectionProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConnectionProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConnectionProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConnectionProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteConnectionProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteConnectionProfileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteConnectionProfileRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for listing streams.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListStreamsRequest {
    /// Required. The parent that owns the collection of streams.
    pub parent: std::string::String,

    /// Maximum number of streams to return.
    /// If unspecified, at most 50 streams will  be returned. The maximum
    /// value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Page token received from a previous `ListStreams` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListStreams`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Filter request.
    pub filter: std::string::String,

    /// Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStreamsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListStreamsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListStreamsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListStreamsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListStreamsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListStreamsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListStreamsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListStreamsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListStreamsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListStreamsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListStreamsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListStreamsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListStreamsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListStreamsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListStreamsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing streams.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListStreamsResponse {
    /// List of streams
    pub streams: std::vec::Vec<crate::model::Stream>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStreamsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [streams][crate::model::ListStreamsResponse::streams].
    pub fn set_streams<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Stream>,
    {
        use std::iter::Iterator;
        self.streams = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListStreamsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListStreamsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListStreamsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListStreamsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListStreamsResponse {
    type PageItem = crate::model::Stream;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.streams
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListStreamsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __streams,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListStreamsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "streams" => Ok(__FieldTag::__streams),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListStreamsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListStreamsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__streams => {
                            if !fields.insert(__FieldTag::__streams) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for streams",
                                ));
                            }
                            result.streams = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Stream>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListStreamsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.streams.is_empty() {
            state.serialize_entry("streams", &self.streams)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListStreamsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListStreamsResponse");
        debug_struct.field("streams", &self.streams);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for getting a stream.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetStreamRequest {
    /// Required. The name of the stream resource to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetStreamRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStreamRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStreamRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GetStreamRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetStreamRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetStreamRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetStreamRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetStreamRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetStreamRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetStreamRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetStreamRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for creating a stream.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateStreamRequest {
    /// Required. The parent that owns the collection of streams.
    pub parent: std::string::String,

    /// Required. The stream identifier.
    pub stream_id: std::string::String,

    /// Required. The stream resource to create.
    pub stream: std::option::Option<crate::model::Stream>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. Only validate the stream, but don't create any resources.
    /// The default is false.
    pub validate_only: bool,

    /// Optional. Create the stream without validating it.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateStreamRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateStreamRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [stream_id][crate::model::CreateStreamRequest::stream_id].
    pub fn set_stream_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.stream_id = v.into();
        self
    }

    /// Sets the value of [stream][crate::model::CreateStreamRequest::stream].
    pub fn set_stream<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Stream>,
    {
        self.stream = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stream][crate::model::CreateStreamRequest::stream].
    pub fn set_or_clear_stream<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Stream>,
    {
        self.stream = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateStreamRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateStreamRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::CreateStreamRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for CreateStreamRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.CreateStreamRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateStreamRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __stream_id,
            __stream,
            __request_id,
            __validate_only,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateStreamRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "streamId" => Ok(__FieldTag::__stream_id),
                            "stream_id" => Ok(__FieldTag::__stream_id),
                            "stream" => Ok(__FieldTag::__stream),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateStreamRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateStreamRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stream_id => {
                            if !fields.insert(__FieldTag::__stream_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_id",
                                ));
                            }
                            result.stream_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stream => {
                            if !fields.insert(__FieldTag::__stream) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream",
                                ));
                            }
                            result.stream =
                                map.next_value::<std::option::Option<crate::model::Stream>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateStreamRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.stream_id.is_empty() {
            state.serialize_entry("streamId", &self.stream_id)?;
        }
        if self.stream.is_some() {
            state.serialize_entry("stream", &self.stream)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateStreamRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateStreamRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("stream_id", &self.stream_id);
        debug_struct.field("stream", &self.stream);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for updating a stream.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateStreamRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// stream resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The stream resource to update.
    pub stream: std::option::Option<crate::model::Stream>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. Only validate the stream with the changes, without actually
    /// updating it. The default is false.
    pub validate_only: bool,

    /// Optional. Update the stream without validating it.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateStreamRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateStreamRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateStreamRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stream][crate::model::UpdateStreamRequest::stream].
    pub fn set_stream<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Stream>,
    {
        self.stream = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stream][crate::model::UpdateStreamRequest::stream].
    pub fn set_or_clear_stream<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Stream>,
    {
        self.stream = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateStreamRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateStreamRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::UpdateStreamRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for UpdateStreamRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.UpdateStreamRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateStreamRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __stream,
            __request_id,
            __validate_only,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateStreamRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "stream" => Ok(__FieldTag::__stream),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateStreamRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateStreamRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__stream => {
                            if !fields.insert(__FieldTag::__stream) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream",
                                ));
                            }
                            result.stream =
                                map.next_value::<std::option::Option<crate::model::Stream>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateStreamRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.stream.is_some() {
            state.serialize_entry("stream", &self.stream)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateStreamRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateStreamRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("stream", &self.stream);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for deleting a stream.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteStreamRequest {
    /// Required. The name of the stream resource to delete.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteStreamRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteStreamRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteStreamRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteStreamRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DeleteStreamRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteStreamRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteStreamRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteStreamRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteStreamRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteStreamRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteStreamRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteStreamRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for running a stream.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RunStreamRequest {
    /// Required. Name of the stream resource to start, in the format:
    /// projects/{project_id}/locations/{location}/streams/{stream_name}
    pub name: std::string::String,

    /// Optional. The CDC strategy of the stream. If not set, the system's default
    /// value will be used.
    pub cdc_strategy: std::option::Option<crate::model::CdcStrategy>,

    /// Optional. Update the stream without validating it.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunStreamRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunStreamRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cdc_strategy][crate::model::RunStreamRequest::cdc_strategy].
    pub fn set_cdc_strategy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CdcStrategy>,
    {
        self.cdc_strategy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cdc_strategy][crate::model::RunStreamRequest::cdc_strategy].
    pub fn set_or_clear_cdc_strategy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CdcStrategy>,
    {
        self.cdc_strategy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [force][crate::model::RunStreamRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for RunStreamRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.RunStreamRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunStreamRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __cdc_strategy,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunStreamRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "cdcStrategy" => Ok(__FieldTag::__cdc_strategy),
                            "cdc_strategy" => Ok(__FieldTag::__cdc_strategy),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunStreamRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunStreamRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cdc_strategy => {
                            if !fields.insert(__FieldTag::__cdc_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cdc_strategy",
                                ));
                            }
                            result.cdc_strategy =
                                map.next_value::<std::option::Option<crate::model::CdcStrategy>>()?;
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunStreamRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.cdc_strategy.is_some() {
            state.serialize_entry("cdcStrategy", &self.cdc_strategy)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RunStreamRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunStreamRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("cdc_strategy", &self.cdc_strategy);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for fetching a specific stream object.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetStreamObjectRequest {
    /// Required. The name of the stream object resource to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetStreamObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStreamObjectRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStreamObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GetStreamObjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetStreamObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetStreamObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetStreamObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetStreamObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetStreamObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetStreamObjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetStreamObjectRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for looking up a specific stream object by its source object
/// identifier.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LookupStreamObjectRequest {
    /// Required. The parent stream that owns the collection of objects.
    pub parent: std::string::String,

    /// Required. The source object identifier which maps to the stream object.
    pub source_object_identifier: std::option::Option<crate::model::SourceObjectIdentifier>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookupStreamObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::LookupStreamObjectRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_object_identifier][crate::model::LookupStreamObjectRequest::source_object_identifier].
    pub fn set_source_object_identifier<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceObjectIdentifier>,
    {
        self.source_object_identifier = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_object_identifier][crate::model::LookupStreamObjectRequest::source_object_identifier].
    pub fn set_or_clear_source_object_identifier<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceObjectIdentifier>,
    {
        self.source_object_identifier = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LookupStreamObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.LookupStreamObjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LookupStreamObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __source_object_identifier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LookupStreamObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sourceObjectIdentifier" => Ok(__FieldTag::__source_object_identifier),
                            "source_object_identifier" => {
                                Ok(__FieldTag::__source_object_identifier)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LookupStreamObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LookupStreamObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_object_identifier => {
                            if !fields.insert(__FieldTag::__source_object_identifier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_object_identifier",
                                ));
                            }
                            result.source_object_identifier = map.next_value::<std::option::Option<crate::model::SourceObjectIdentifier>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LookupStreamObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.source_object_identifier.is_some() {
            state.serialize_entry("sourceObjectIdentifier", &self.source_object_identifier)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LookupStreamObjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LookupStreamObjectRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("source_object_identifier", &self.source_object_identifier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for manually initiating a backfill job for a specific stream object.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartBackfillJobRequest {
    /// Required. The name of the stream object resource to start a backfill job
    /// for.
    pub object: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartBackfillJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object][crate::model::StartBackfillJobRequest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }
}

impl wkt::message::Message for StartBackfillJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.StartBackfillJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartBackfillJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __object,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartBackfillJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "object" => Ok(__FieldTag::__object),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartBackfillJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartBackfillJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartBackfillJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StartBackfillJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartBackfillJobRequest");
        debug_struct.field("object", &self.object);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for manually initiating a backfill job for a specific stream object.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartBackfillJobResponse {
    /// The stream object resource a backfill job was started for.
    pub object: std::option::Option<crate::model::StreamObject>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartBackfillJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object][crate::model::StartBackfillJobResponse::object].
    pub fn set_object<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StreamObject>,
    {
        self.object = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object][crate::model::StartBackfillJobResponse::object].
    pub fn set_or_clear_object<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StreamObject>,
    {
        self.object = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StartBackfillJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.StartBackfillJobResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartBackfillJobResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __object,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartBackfillJobResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "object" => Ok(__FieldTag::__object),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartBackfillJobResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartBackfillJobResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<crate::model::StreamObject>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartBackfillJobResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.object.is_some() {
            state.serialize_entry("object", &self.object)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StartBackfillJobResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartBackfillJobResponse");
        debug_struct.field("object", &self.object);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for manually stopping a running backfill job for a specific stream
/// object.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StopBackfillJobRequest {
    /// Required. The name of the stream object resource to stop the backfill job
    /// for.
    pub object: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopBackfillJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object][crate::model::StopBackfillJobRequest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }
}

impl wkt::message::Message for StopBackfillJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.StopBackfillJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopBackfillJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __object,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopBackfillJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "object" => Ok(__FieldTag::__object),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopBackfillJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopBackfillJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopBackfillJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StopBackfillJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StopBackfillJobRequest");
        debug_struct.field("object", &self.object);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for manually stop a backfill job for a specific stream object.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StopBackfillJobResponse {
    /// The stream object resource the backfill job was stopped for.
    pub object: std::option::Option<crate::model::StreamObject>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopBackfillJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object][crate::model::StopBackfillJobResponse::object].
    pub fn set_object<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StreamObject>,
    {
        self.object = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object][crate::model::StopBackfillJobResponse::object].
    pub fn set_or_clear_object<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StreamObject>,
    {
        self.object = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StopBackfillJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.StopBackfillJobResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopBackfillJobResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __object,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopBackfillJobResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "object" => Ok(__FieldTag::__object),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopBackfillJobResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopBackfillJobResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<crate::model::StreamObject>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopBackfillJobResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.object.is_some() {
            state.serialize_entry("object", &self.object)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StopBackfillJobResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StopBackfillJobResponse");
        debug_struct.field("object", &self.object);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for listing all objects for a specific stream.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListStreamObjectsRequest {
    /// Required. The parent stream that owns the collection of objects.
    pub parent: std::string::String,

    /// Maximum number of objects to return. Default is 50.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Page token received from a previous `ListStreamObjectsRequest` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListStreamObjectsRequest` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStreamObjectsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListStreamObjectsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListStreamObjectsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListStreamObjectsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListStreamObjectsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListStreamObjectsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListStreamObjectsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListStreamObjectsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListStreamObjectsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListStreamObjectsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListStreamObjectsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListStreamObjectsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListStreamObjectsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response containing the objects for a stream.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListStreamObjectsResponse {
    /// List of stream objects.
    pub stream_objects: std::vec::Vec<crate::model::StreamObject>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStreamObjectsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stream_objects][crate::model::ListStreamObjectsResponse::stream_objects].
    pub fn set_stream_objects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StreamObject>,
    {
        use std::iter::Iterator;
        self.stream_objects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListStreamObjectsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListStreamObjectsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListStreamObjectsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListStreamObjectsResponse {
    type PageItem = crate::model::StreamObject;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.stream_objects
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListStreamObjectsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stream_objects,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListStreamObjectsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "streamObjects" => Ok(__FieldTag::__stream_objects),
                            "stream_objects" => Ok(__FieldTag::__stream_objects),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListStreamObjectsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListStreamObjectsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stream_objects => {
                            if !fields.insert(__FieldTag::__stream_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_objects",
                                ));
                            }
                            result.stream_objects = map.next_value::<std::option::Option<std::vec::Vec<crate::model::StreamObject>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListStreamObjectsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.stream_objects.is_empty() {
            state.serialize_entry("streamObjects", &self.stream_objects)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListStreamObjectsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListStreamObjectsResponse");
        debug_struct.field("stream_objects", &self.stream_objects);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    /// Output only. Results of executed validations if there are any.
    pub validation_result: std::option::Option<crate::model::ValidationResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [validation_result][crate::model::OperationMetadata::validation_result].
    pub fn set_validation_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ValidationResult>,
    {
        self.validation_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [validation_result][crate::model::OperationMetadata::validation_result].
    pub fn set_or_clear_validation_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ValidationResult>,
    {
        self.validation_result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            __validation_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            "validationResult" => Ok(__FieldTag::__validation_result),
                            "validation_result" => Ok(__FieldTag::__validation_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validation_result => {
                            if !fields.insert(__FieldTag::__validation_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validation_result",
                                ));
                            }
                            result.validation_result = map
                                .next_value::<std::option::Option<crate::model::ValidationResult>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if self.validation_result.is_some() {
            state.serialize_entry("validationResult", &self.validation_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);
        debug_struct.field("validation_result", &self.validation_result);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for creating a private connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePrivateConnectionRequest {
    /// Required. The parent that owns the collection of PrivateConnections.
    pub parent: std::string::String,

    /// Required. The private connectivity identifier.
    pub private_connection_id: std::string::String,

    /// Required. The Private Connectivity resource to create.
    pub private_connection: std::option::Option<crate::model::PrivateConnection>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, will skip validations.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePrivateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [private_connection_id][crate::model::CreatePrivateConnectionRequest::private_connection_id].
    pub fn set_private_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_connection_id = v.into();
        self
    }

    /// Sets the value of [private_connection][crate::model::CreatePrivateConnectionRequest::private_connection].
    pub fn set_private_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivateConnection>,
    {
        self.private_connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_connection][crate::model::CreatePrivateConnectionRequest::private_connection].
    pub fn set_or_clear_private_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivateConnection>,
    {
        self.private_connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreatePrivateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::CreatePrivateConnectionRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for CreatePrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.CreatePrivateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatePrivateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __private_connection_id,
            __private_connection,
            __request_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePrivateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "privateConnectionId" => Ok(__FieldTag::__private_connection_id),
                            "private_connection_id" => Ok(__FieldTag::__private_connection_id),
                            "privateConnection" => Ok(__FieldTag::__private_connection),
                            "private_connection" => Ok(__FieldTag::__private_connection),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatePrivateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePrivateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_connection_id => {
                            if !fields.insert(__FieldTag::__private_connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_connection_id",
                                ));
                            }
                            result.private_connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_connection => {
                            if !fields.insert(__FieldTag::__private_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_connection",
                                ));
                            }
                            result.private_connection = map
                                .next_value::<std::option::Option<crate::model::PrivateConnection>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatePrivateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.private_connection_id.is_empty() {
            state.serialize_entry("privateConnectionId", &self.private_connection_id)?;
        }
        if self.private_connection.is_some() {
            state.serialize_entry("privateConnection", &self.private_connection)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreatePrivateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreatePrivateConnectionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("private_connection_id", &self.private_connection_id);
        debug_struct.field("private_connection", &self.private_connection);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for listing private connections.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPrivateConnectionsRequest {
    /// Required. The parent that owns the collection of private connectivity
    /// configurations.
    pub parent: std::string::String,

    /// Maximum number of private connectivity configurations to return.
    /// If unspecified, at most 50 private connectivity configurations that will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Page token received from a previous `ListPrivateConnections` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListPrivateConnections` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Filter request.
    pub filter: std::string::String,

    /// Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPrivateConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPrivateConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPrivateConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPrivateConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPrivateConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListPrivateConnectionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPrivateConnectionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPrivateConnectionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPrivateConnectionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPrivateConnectionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPrivateConnectionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPrivateConnectionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPrivateConnectionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response containing a list of private connection configurations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPrivateConnectionsResponse {
    /// List of private connectivity configurations.
    pub private_connections: std::vec::Vec<crate::model::PrivateConnection>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_connections][crate::model::ListPrivateConnectionsResponse::private_connections].
    pub fn set_private_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PrivateConnection>,
    {
        use std::iter::Iterator;
        self.private_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPrivateConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListPrivateConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListPrivateConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPrivateConnectionsResponse {
    type PageItem = crate::model::PrivateConnection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.private_connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPrivateConnectionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __private_connections,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPrivateConnectionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "privateConnections" => Ok(__FieldTag::__private_connections),
                            "private_connections" => Ok(__FieldTag::__private_connections),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPrivateConnectionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPrivateConnectionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__private_connections => {
                            if !fields.insert(__FieldTag::__private_connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_connections",
                                ));
                            }
                            result.private_connections =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PrivateConnection>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPrivateConnectionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.private_connections.is_empty() {
            state.serialize_entry("privateConnections", &self.private_connections)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPrivateConnectionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPrivateConnectionsResponse");
        debug_struct.field("private_connections", &self.private_connections);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to delete a private connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePrivateConnectionRequest {
    /// Required. The name of the private connectivity configuration to delete.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, any child routes that belong to this
    /// PrivateConnection will also be deleted.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePrivateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeletePrivateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeletePrivateConnectionRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeletePrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DeletePrivateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeletePrivateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePrivateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeletePrivateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePrivateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeletePrivateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeletePrivateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeletePrivateConnectionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to get a private connection configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPrivateConnectionRequest {
    /// Required. The name of the  private connectivity configuration to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPrivateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GetPrivateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPrivateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPrivateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPrivateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPrivateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPrivateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetPrivateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetPrivateConnectionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Route creation request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateRouteRequest {
    /// Required. The parent that owns the collection of Routes.
    pub parent: std::string::String,

    /// Required. The Route identifier.
    pub route_id: std::string::String,

    /// Required. The Route resource to create.
    pub route: std::option::Option<crate::model::Route>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRouteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRouteRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [route_id][crate::model::CreateRouteRequest::route_id].
    pub fn set_route_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.route_id = v.into();
        self
    }

    /// Sets the value of [route][crate::model::CreateRouteRequest::route].
    pub fn set_route<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Route>,
    {
        self.route = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [route][crate::model::CreateRouteRequest::route].
    pub fn set_or_clear_route<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Route>,
    {
        self.route = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateRouteRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateRouteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.CreateRouteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateRouteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __route_id,
            __route,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateRouteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "routeId" => Ok(__FieldTag::__route_id),
                            "route_id" => Ok(__FieldTag::__route_id),
                            "route" => Ok(__FieldTag::__route),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateRouteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateRouteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__route_id => {
                            if !fields.insert(__FieldTag::__route_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_id",
                                ));
                            }
                            result.route_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__route => {
                            if !fields.insert(__FieldTag::__route) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route",
                                ));
                            }
                            result.route =
                                map.next_value::<std::option::Option<crate::model::Route>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateRouteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.route_id.is_empty() {
            state.serialize_entry("routeId", &self.route_id)?;
        }
        if self.route.is_some() {
            state.serialize_entry("route", &self.route)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateRouteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateRouteRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("route_id", &self.route_id);
        debug_struct.field("route", &self.route);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Route list request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRoutesRequest {
    /// Required. The parent that owns the collection of Routess.
    pub parent: std::string::String,

    /// Maximum number of Routes to return. The service may return
    /// fewer than this value. If unspecified, at most 50 Routes
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    pub page_size: i32,

    /// Page token received from a previous `ListRoutes` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListRoutes` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Filter request.
    pub filter: std::string::String,

    /// Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRoutesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRoutesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRoutesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRoutesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRoutesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListRoutesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListRoutesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListRoutesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRoutesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRoutesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRoutesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRoutesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRoutesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListRoutesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRoutesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Route list response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRoutesResponse {
    /// List of Routes.
    pub routes: std::vec::Vec<crate::model::Route>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRoutesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [routes][crate::model::ListRoutesResponse::routes].
    pub fn set_routes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Route>,
    {
        use std::iter::Iterator;
        self.routes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRoutesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListRoutesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRoutesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ListRoutesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRoutesResponse {
    type PageItem = crate::model::Route;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.routes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRoutesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __routes,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRoutesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "routes" => Ok(__FieldTag::__routes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRoutesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRoutesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__routes => {
                            if !fields.insert(__FieldTag::__routes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routes",
                                ));
                            }
                            result.routes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Route>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRoutesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.routes.is_empty() {
            state.serialize_entry("routes", &self.routes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListRoutesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRoutesResponse");
        debug_struct.field("routes", &self.routes);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Route deletion request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteRouteRequest {
    /// Required. The name of the Route resource to delete.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRouteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRouteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteRouteRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRouteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DeleteRouteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteRouteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteRouteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteRouteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteRouteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteRouteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteRouteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteRouteRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Route get request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRouteRequest {
    /// Required. The name of the Route resource to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRouteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRouteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRouteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GetRouteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRouteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRouteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRouteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRouteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRouteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetRouteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetRouteRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Oracle database profile.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OracleProfile {
    /// Required. Hostname for the Oracle connection.
    pub hostname: std::string::String,

    /// Port for the Oracle connection, default value is 1521.
    pub port: i32,

    /// Required. Username for the Oracle connection.
    pub username: std::string::String,

    /// Optional. Password for the Oracle connection. Mutually exclusive with the
    /// `secret_manager_stored_password` field.
    pub password: std::string::String,

    /// Required. Database for the Oracle connection.
    pub database_service: std::string::String,

    /// Connection string attributes
    pub connection_attributes: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. SSL configuration for the Oracle connection.
    pub oracle_ssl_config: std::option::Option<crate::model::OracleSslConfig>,

    /// Optional. Configuration for Oracle ASM connection.
    pub oracle_asm_config: std::option::Option<crate::model::OracleAsmConfig>,

    /// Optional. A reference to a Secret Manager resource name storing the Oracle
    /// connection password. Mutually exclusive with the `password` field.
    pub secret_manager_stored_password: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::OracleProfile::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [port][crate::model::OracleProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::OracleProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::OracleProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [database_service][crate::model::OracleProfile::database_service].
    pub fn set_database_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_service = v.into();
        self
    }

    /// Sets the value of [connection_attributes][crate::model::OracleProfile::connection_attributes].
    pub fn set_connection_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.connection_attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [oracle_ssl_config][crate::model::OracleProfile::oracle_ssl_config].
    pub fn set_oracle_ssl_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OracleSslConfig>,
    {
        self.oracle_ssl_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [oracle_ssl_config][crate::model::OracleProfile::oracle_ssl_config].
    pub fn set_or_clear_oracle_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OracleSslConfig>,
    {
        self.oracle_ssl_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [oracle_asm_config][crate::model::OracleProfile::oracle_asm_config].
    pub fn set_oracle_asm_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OracleAsmConfig>,
    {
        self.oracle_asm_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [oracle_asm_config][crate::model::OracleProfile::oracle_asm_config].
    pub fn set_or_clear_oracle_asm_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OracleAsmConfig>,
    {
        self.oracle_asm_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secret_manager_stored_password][crate::model::OracleProfile::secret_manager_stored_password].
    pub fn set_secret_manager_stored_password<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secret_manager_stored_password = v.into();
        self
    }
}

impl wkt::message::Message for OracleProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OracleProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hostname,
            __port,
            __username,
            __password,
            __database_service,
            __connection_attributes,
            __oracle_ssl_config,
            __oracle_asm_config,
            __secret_manager_stored_password,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OracleProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostname" => Ok(__FieldTag::__hostname),
                            "port" => Ok(__FieldTag::__port),
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "databaseService" => Ok(__FieldTag::__database_service),
                            "database_service" => Ok(__FieldTag::__database_service),
                            "connectionAttributes" => Ok(__FieldTag::__connection_attributes),
                            "connection_attributes" => Ok(__FieldTag::__connection_attributes),
                            "oracleSslConfig" => Ok(__FieldTag::__oracle_ssl_config),
                            "oracle_ssl_config" => Ok(__FieldTag::__oracle_ssl_config),
                            "oracleAsmConfig" => Ok(__FieldTag::__oracle_asm_config),
                            "oracle_asm_config" => Ok(__FieldTag::__oracle_asm_config),
                            "secretManagerStoredPassword" => {
                                Ok(__FieldTag::__secret_manager_stored_password)
                            }
                            "secret_manager_stored_password" => {
                                Ok(__FieldTag::__secret_manager_stored_password)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OracleProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OracleProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_service => {
                            if !fields.insert(__FieldTag::__database_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_service",
                                ));
                            }
                            result.database_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_attributes => {
                            if !fields.insert(__FieldTag::__connection_attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_attributes",
                                ));
                            }
                            result.connection_attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oracle_ssl_config => {
                            if !fields.insert(__FieldTag::__oracle_ssl_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oracle_ssl_config",
                                ));
                            }
                            result.oracle_ssl_config = map
                                .next_value::<std::option::Option<crate::model::OracleSslConfig>>(
                                )?;
                        }
                        __FieldTag::__oracle_asm_config => {
                            if !fields.insert(__FieldTag::__oracle_asm_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oracle_asm_config",
                                ));
                            }
                            result.oracle_asm_config = map
                                .next_value::<std::option::Option<crate::model::OracleAsmConfig>>(
                                )?;
                        }
                        __FieldTag::__secret_manager_stored_password => {
                            if !fields.insert(__FieldTag::__secret_manager_stored_password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_manager_stored_password",
                                ));
                            }
                            result.secret_manager_stored_password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OracleProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self.database_service.is_empty() {
            state.serialize_entry("databaseService", &self.database_service)?;
        }
        if !self.connection_attributes.is_empty() {
            state.serialize_entry("connectionAttributes", &self.connection_attributes)?;
        }
        if self.oracle_ssl_config.is_some() {
            state.serialize_entry("oracleSslConfig", &self.oracle_ssl_config)?;
        }
        if self.oracle_asm_config.is_some() {
            state.serialize_entry("oracleAsmConfig", &self.oracle_asm_config)?;
        }
        if !self.secret_manager_stored_password.is_empty() {
            state.serialize_entry(
                "secretManagerStoredPassword",
                &self.secret_manager_stored_password,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OracleProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OracleProfile");
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("port", &self.port);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("database_service", &self.database_service);
        debug_struct.field("connection_attributes", &self.connection_attributes);
        debug_struct.field("oracle_ssl_config", &self.oracle_ssl_config);
        debug_struct.field("oracle_asm_config", &self.oracle_asm_config);
        debug_struct.field(
            "secret_manager_stored_password",
            &self.secret_manager_stored_password,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for Oracle Automatic Storage Management (ASM) connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OracleAsmConfig {
    /// Required. Hostname for the Oracle ASM connection.
    pub hostname: std::string::String,

    /// Required. Port for the Oracle ASM connection.
    pub port: i32,

    /// Required. Username for the Oracle ASM connection.
    pub username: std::string::String,

    /// Optional. Password for the Oracle ASM connection. Mutually exclusive with
    /// the `secret_manager_stored_password` field.
    pub password: std::string::String,

    /// Required. ASM service name for the Oracle ASM connection.
    pub asm_service: std::string::String,

    /// Optional. Connection string attributes
    pub connection_attributes: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. SSL configuration for the Oracle connection.
    pub oracle_ssl_config: std::option::Option<crate::model::OracleSslConfig>,

    /// Optional. A reference to a Secret Manager resource name storing the Oracle
    /// ASM connection password. Mutually exclusive with the `password` field.
    pub secret_manager_stored_password: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleAsmConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::OracleAsmConfig::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [port][crate::model::OracleAsmConfig::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::OracleAsmConfig::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::OracleAsmConfig::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [asm_service][crate::model::OracleAsmConfig::asm_service].
    pub fn set_asm_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asm_service = v.into();
        self
    }

    /// Sets the value of [connection_attributes][crate::model::OracleAsmConfig::connection_attributes].
    pub fn set_connection_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.connection_attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [oracle_ssl_config][crate::model::OracleAsmConfig::oracle_ssl_config].
    pub fn set_oracle_ssl_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OracleSslConfig>,
    {
        self.oracle_ssl_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [oracle_ssl_config][crate::model::OracleAsmConfig::oracle_ssl_config].
    pub fn set_or_clear_oracle_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OracleSslConfig>,
    {
        self.oracle_ssl_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secret_manager_stored_password][crate::model::OracleAsmConfig::secret_manager_stored_password].
    pub fn set_secret_manager_stored_password<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secret_manager_stored_password = v.into();
        self
    }
}

impl wkt::message::Message for OracleAsmConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleAsmConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OracleAsmConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hostname,
            __port,
            __username,
            __password,
            __asm_service,
            __connection_attributes,
            __oracle_ssl_config,
            __secret_manager_stored_password,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OracleAsmConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostname" => Ok(__FieldTag::__hostname),
                            "port" => Ok(__FieldTag::__port),
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "asmService" => Ok(__FieldTag::__asm_service),
                            "asm_service" => Ok(__FieldTag::__asm_service),
                            "connectionAttributes" => Ok(__FieldTag::__connection_attributes),
                            "connection_attributes" => Ok(__FieldTag::__connection_attributes),
                            "oracleSslConfig" => Ok(__FieldTag::__oracle_ssl_config),
                            "oracle_ssl_config" => Ok(__FieldTag::__oracle_ssl_config),
                            "secretManagerStoredPassword" => {
                                Ok(__FieldTag::__secret_manager_stored_password)
                            }
                            "secret_manager_stored_password" => {
                                Ok(__FieldTag::__secret_manager_stored_password)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OracleAsmConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OracleAsmConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asm_service => {
                            if !fields.insert(__FieldTag::__asm_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asm_service",
                                ));
                            }
                            result.asm_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_attributes => {
                            if !fields.insert(__FieldTag::__connection_attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_attributes",
                                ));
                            }
                            result.connection_attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oracle_ssl_config => {
                            if !fields.insert(__FieldTag::__oracle_ssl_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oracle_ssl_config",
                                ));
                            }
                            result.oracle_ssl_config = map
                                .next_value::<std::option::Option<crate::model::OracleSslConfig>>(
                                )?;
                        }
                        __FieldTag::__secret_manager_stored_password => {
                            if !fields.insert(__FieldTag::__secret_manager_stored_password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_manager_stored_password",
                                ));
                            }
                            result.secret_manager_stored_password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OracleAsmConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self.asm_service.is_empty() {
            state.serialize_entry("asmService", &self.asm_service)?;
        }
        if !self.connection_attributes.is_empty() {
            state.serialize_entry("connectionAttributes", &self.connection_attributes)?;
        }
        if self.oracle_ssl_config.is_some() {
            state.serialize_entry("oracleSslConfig", &self.oracle_ssl_config)?;
        }
        if !self.secret_manager_stored_password.is_empty() {
            state.serialize_entry(
                "secretManagerStoredPassword",
                &self.secret_manager_stored_password,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OracleAsmConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OracleAsmConfig");
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("port", &self.port);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("asm_service", &self.asm_service);
        debug_struct.field("connection_attributes", &self.connection_attributes);
        debug_struct.field("oracle_ssl_config", &self.oracle_ssl_config);
        debug_struct.field(
            "secret_manager_stored_password",
            &self.secret_manager_stored_password,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MySQL database profile.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MysqlProfile {
    /// Required. Hostname for the MySQL connection.
    pub hostname: std::string::String,

    /// Port for the MySQL connection, default value is 3306.
    pub port: i32,

    /// Required. Username for the MySQL connection.
    pub username: std::string::String,

    /// Optional. Input only. Password for the MySQL connection. Mutually exclusive
    /// with the `secret_manager_stored_password` field.
    pub password: std::string::String,

    /// SSL configuration for the MySQL connection.
    pub ssl_config: std::option::Option<crate::model::MysqlSslConfig>,

    /// Optional. A reference to a Secret Manager resource name storing the MySQL
    /// connection password. Mutually exclusive with the `password` field.
    pub secret_manager_stored_password: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::MysqlProfile::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [port][crate::model::MysqlProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::MysqlProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::MysqlProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [ssl_config][crate::model::MysqlProfile::ssl_config].
    pub fn set_ssl_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MysqlSslConfig>,
    {
        self.ssl_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl_config][crate::model::MysqlProfile::ssl_config].
    pub fn set_or_clear_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MysqlSslConfig>,
    {
        self.ssl_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secret_manager_stored_password][crate::model::MysqlProfile::secret_manager_stored_password].
    pub fn set_secret_manager_stored_password<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secret_manager_stored_password = v.into();
        self
    }
}

impl wkt::message::Message for MysqlProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MysqlProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hostname,
            __port,
            __username,
            __password,
            __ssl_config,
            __secret_manager_stored_password,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MysqlProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostname" => Ok(__FieldTag::__hostname),
                            "port" => Ok(__FieldTag::__port),
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "sslConfig" => Ok(__FieldTag::__ssl_config),
                            "ssl_config" => Ok(__FieldTag::__ssl_config),
                            "secretManagerStoredPassword" => {
                                Ok(__FieldTag::__secret_manager_stored_password)
                            }
                            "secret_manager_stored_password" => {
                                Ok(__FieldTag::__secret_manager_stored_password)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MysqlProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MysqlProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssl_config => {
                            if !fields.insert(__FieldTag::__ssl_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_config",
                                ));
                            }
                            result.ssl_config = map
                                .next_value::<std::option::Option<crate::model::MysqlSslConfig>>(
                                )?;
                        }
                        __FieldTag::__secret_manager_stored_password => {
                            if !fields.insert(__FieldTag::__secret_manager_stored_password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_manager_stored_password",
                                ));
                            }
                            result.secret_manager_stored_password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MysqlProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if self.ssl_config.is_some() {
            state.serialize_entry("sslConfig", &self.ssl_config)?;
        }
        if !self.secret_manager_stored_password.is_empty() {
            state.serialize_entry(
                "secretManagerStoredPassword",
                &self.secret_manager_stored_password,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MysqlProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MysqlProfile");
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("port", &self.port);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("ssl_config", &self.ssl_config);
        debug_struct.field(
            "secret_manager_stored_password",
            &self.secret_manager_stored_password,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// PostgreSQL database profile.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PostgresqlProfile {
    /// Required. Hostname for the PostgreSQL connection.
    pub hostname: std::string::String,

    /// Port for the PostgreSQL connection, default value is 5432.
    pub port: i32,

    /// Required. Username for the PostgreSQL connection.
    pub username: std::string::String,

    /// Optional. Password for the PostgreSQL connection. Mutually exclusive with
    /// the `secret_manager_stored_password` field.
    pub password: std::string::String,

    /// Required. Database for the PostgreSQL connection.
    pub database: std::string::String,

    /// Optional. A reference to a Secret Manager resource name storing the
    /// PostgreSQL connection password. Mutually exclusive with the `password`
    /// field.
    pub secret_manager_stored_password: std::string::String,

    /// Optional. SSL configuration for the PostgreSQL connection.
    /// In case PostgresqlSslConfig is not set, the connection will use the default
    /// SSL mode, which is `prefer` (i.e. this mode will only use encryption if
    /// enabled from database side, otherwise will use unencrypted communication)
    pub ssl_config: std::option::Option<crate::model::PostgresqlSslConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::PostgresqlProfile::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [port][crate::model::PostgresqlProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::PostgresqlProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::PostgresqlProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [database][crate::model::PostgresqlProfile::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [secret_manager_stored_password][crate::model::PostgresqlProfile::secret_manager_stored_password].
    pub fn set_secret_manager_stored_password<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secret_manager_stored_password = v.into();
        self
    }

    /// Sets the value of [ssl_config][crate::model::PostgresqlProfile::ssl_config].
    pub fn set_ssl_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PostgresqlSslConfig>,
    {
        self.ssl_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl_config][crate::model::PostgresqlProfile::ssl_config].
    pub fn set_or_clear_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PostgresqlSslConfig>,
    {
        self.ssl_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PostgresqlProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostgresqlProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hostname,
            __port,
            __username,
            __password,
            __database,
            __secret_manager_stored_password,
            __ssl_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostgresqlProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostname" => Ok(__FieldTag::__hostname),
                            "port" => Ok(__FieldTag::__port),
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "database" => Ok(__FieldTag::__database),
                            "secretManagerStoredPassword" => {
                                Ok(__FieldTag::__secret_manager_stored_password)
                            }
                            "secret_manager_stored_password" => {
                                Ok(__FieldTag::__secret_manager_stored_password)
                            }
                            "sslConfig" => Ok(__FieldTag::__ssl_config),
                            "ssl_config" => Ok(__FieldTag::__ssl_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostgresqlProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostgresqlProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_manager_stored_password => {
                            if !fields.insert(__FieldTag::__secret_manager_stored_password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_manager_stored_password",
                                ));
                            }
                            result.secret_manager_stored_password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssl_config => {
                            if !fields.insert(__FieldTag::__ssl_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_config",
                                ));
                            }
                            result.ssl_config = map.next_value::<std::option::Option<crate::model::PostgresqlSslConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostgresqlProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.secret_manager_stored_password.is_empty() {
            state.serialize_entry(
                "secretManagerStoredPassword",
                &self.secret_manager_stored_password,
            )?;
        }
        if self.ssl_config.is_some() {
            state.serialize_entry("sslConfig", &self.ssl_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PostgresqlProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostgresqlProfile");
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("port", &self.port);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("database", &self.database);
        debug_struct.field(
            "secret_manager_stored_password",
            &self.secret_manager_stored_password,
        );
        debug_struct.field("ssl_config", &self.ssl_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SQLServer database profile.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlServerProfile {
    /// Required. Hostname for the SQLServer connection.
    pub hostname: std::string::String,

    /// Port for the SQLServer connection, default value is 1433.
    pub port: i32,

    /// Required. Username for the SQLServer connection.
    pub username: std::string::String,

    /// Optional. Password for the SQLServer connection. Mutually exclusive with
    /// the `secret_manager_stored_password` field.
    pub password: std::string::String,

    /// Required. Database for the SQLServer connection.
    pub database: std::string::String,

    /// Optional. A reference to a Secret Manager resource name storing the
    /// SQLServer connection password. Mutually exclusive with the `password`
    /// field.
    pub secret_manager_stored_password: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::SqlServerProfile::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [port][crate::model::SqlServerProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::SqlServerProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::SqlServerProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [database][crate::model::SqlServerProfile::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [secret_manager_stored_password][crate::model::SqlServerProfile::secret_manager_stored_password].
    pub fn set_secret_manager_stored_password<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secret_manager_stored_password = v.into();
        self
    }
}

impl wkt::message::Message for SqlServerProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlServerProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hostname,
            __port,
            __username,
            __password,
            __database,
            __secret_manager_stored_password,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlServerProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostname" => Ok(__FieldTag::__hostname),
                            "port" => Ok(__FieldTag::__port),
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "database" => Ok(__FieldTag::__database),
                            "secretManagerStoredPassword" => {
                                Ok(__FieldTag::__secret_manager_stored_password)
                            }
                            "secret_manager_stored_password" => {
                                Ok(__FieldTag::__secret_manager_stored_password)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlServerProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlServerProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_manager_stored_password => {
                            if !fields.insert(__FieldTag::__secret_manager_stored_password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_manager_stored_password",
                                ));
                            }
                            result.secret_manager_stored_password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlServerProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.secret_manager_stored_password.is_empty() {
            state.serialize_entry(
                "secretManagerStoredPassword",
                &self.secret_manager_stored_password,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SqlServerProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlServerProfile");
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("port", &self.port);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("database", &self.database);
        debug_struct.field(
            "secret_manager_stored_password",
            &self.secret_manager_stored_password,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Salesforce profile
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SalesforceProfile {
    /// Required. Domain endpoint for the Salesforce connection.
    pub domain: std::string::String,

    /// Credentials for Salesforce connection.
    pub credentials: std::option::Option<crate::model::salesforce_profile::Credentials>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SalesforceProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domain][crate::model::SalesforceProfile::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [credentials][crate::model::SalesforceProfile::credentials].
    ///
    /// Note that all the setters affecting `credentials` are mutually
    /// exclusive.
    pub fn set_credentials<
        T: std::convert::Into<std::option::Option<crate::model::salesforce_profile::Credentials>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials = v.into();
        self
    }

    /// The value of [credentials][crate::model::SalesforceProfile::credentials]
    /// if it holds a `UserCredentials`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_credentials(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::salesforce_profile::UserCredentials>>
    {
        #[allow(unreachable_patterns)]
        self.credentials.as_ref().and_then(|v| match v {
            crate::model::salesforce_profile::Credentials::UserCredentials(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [credentials][crate::model::SalesforceProfile::credentials]
    /// to hold a `UserCredentials`.
    ///
    /// Note that all the setters affecting `credentials` are
    /// mutually exclusive.
    pub fn set_user_credentials<
        T: std::convert::Into<std::boxed::Box<crate::model::salesforce_profile::UserCredentials>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials = std::option::Option::Some(
            crate::model::salesforce_profile::Credentials::UserCredentials(v.into()),
        );
        self
    }

    /// The value of [credentials][crate::model::SalesforceProfile::credentials]
    /// if it holds a `Oauth2ClientCredentials`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oauth2_client_credentials(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::salesforce_profile::Oauth2ClientCredentials>,
    > {
        #[allow(unreachable_patterns)]
        self.credentials.as_ref().and_then(|v| match v {
            crate::model::salesforce_profile::Credentials::Oauth2ClientCredentials(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [credentials][crate::model::SalesforceProfile::credentials]
    /// to hold a `Oauth2ClientCredentials`.
    ///
    /// Note that all the setters affecting `credentials` are
    /// mutually exclusive.
    pub fn set_oauth2_client_credentials<
        T: std::convert::Into<
                std::boxed::Box<crate::model::salesforce_profile::Oauth2ClientCredentials>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials = std::option::Option::Some(
            crate::model::salesforce_profile::Credentials::Oauth2ClientCredentials(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SalesforceProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SalesforceProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SalesforceProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __domain,
            __user_credentials,
            __oauth2_client_credentials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SalesforceProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "domain" => Ok(__FieldTag::__domain),
                            "userCredentials" => Ok(__FieldTag::__user_credentials),
                            "user_credentials" => Ok(__FieldTag::__user_credentials),
                            "oauth2ClientCredentials" => {
                                Ok(__FieldTag::__oauth2_client_credentials)
                            }
                            "oauth2_client_credentials" => {
                                Ok(__FieldTag::__oauth2_client_credentials)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SalesforceProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SalesforceProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_credentials => {
                            if !fields.insert(__FieldTag::__user_credentials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_credentials",
                                ));
                            }
                            if result.credentials.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `credentials`, a oneof with full ID .google.cloud.datastream.v1.SalesforceProfile.user_credentials, latest field was userCredentials",
                                ));
                            }
                            result.credentials = std::option::Option::Some(
                                crate::model::salesforce_profile::Credentials::UserCredentials(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::salesforce_profile::UserCredentials,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__oauth2_client_credentials => {
                            if !fields.insert(__FieldTag::__oauth2_client_credentials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth2_client_credentials",
                                ));
                            }
                            if result.credentials.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `credentials`, a oneof with full ID .google.cloud.datastream.v1.SalesforceProfile.oauth2_client_credentials, latest field was oauth2ClientCredentials",
                                ));
                            }
                            result.credentials = std::option::Option::Some(
                                crate::model::salesforce_profile::Credentials::Oauth2ClientCredentials(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::salesforce_profile::Oauth2ClientCredentials>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SalesforceProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if let Some(value) = self.user_credentials() {
            state.serialize_entry("userCredentials", value)?;
        }
        if let Some(value) = self.oauth2_client_credentials() {
            state.serialize_entry("oauth2ClientCredentials", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SalesforceProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SalesforceProfile");
        debug_struct.field("domain", &self.domain);
        debug_struct.field("credentials", &self.credentials);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SalesforceProfile].
pub mod salesforce_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Username-password credentials.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UserCredentials {
        /// Required. Username for the Salesforce connection.
        pub username: std::string::String,

        /// Optional. Password for the Salesforce connection.
        /// Mutually exclusive with the `secret_manager_stored_password` field.
        pub password: std::string::String,

        /// Optional. Security token for the Salesforce connection.
        /// Mutually exclusive with the `secret_manager_stored_security_token` field.
        pub security_token: std::string::String,

        /// Optional. A reference to a Secret Manager resource name storing the
        /// Salesforce connection's password. Mutually exclusive with the `password`
        /// field.
        pub secret_manager_stored_password: std::string::String,

        /// Optional. A reference to a Secret Manager resource name storing the
        /// Salesforce connection's security token. Mutually exclusive with the
        /// `security_token` field.
        pub secret_manager_stored_security_token: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserCredentials {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [username][crate::model::salesforce_profile::UserCredentials::username].
        pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.username = v.into();
            self
        }

        /// Sets the value of [password][crate::model::salesforce_profile::UserCredentials::password].
        pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.password = v.into();
            self
        }

        /// Sets the value of [security_token][crate::model::salesforce_profile::UserCredentials::security_token].
        pub fn set_security_token<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.security_token = v.into();
            self
        }

        /// Sets the value of [secret_manager_stored_password][crate::model::salesforce_profile::UserCredentials::secret_manager_stored_password].
        pub fn set_secret_manager_stored_password<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.secret_manager_stored_password = v.into();
            self
        }

        /// Sets the value of [secret_manager_stored_security_token][crate::model::salesforce_profile::UserCredentials::secret_manager_stored_security_token].
        pub fn set_secret_manager_stored_security_token<
            T: std::convert::Into<std::string::String>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.secret_manager_stored_security_token = v.into();
            self
        }
    }

    impl wkt::message::Message for UserCredentials {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SalesforceProfile.UserCredentials"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UserCredentials {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __username,
                __password,
                __security_token,
                __secret_manager_stored_password,
                __secret_manager_stored_security_token,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UserCredentials")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "username" => Ok(__FieldTag::__username),
                                "password" => Ok(__FieldTag::__password),
                                "securityToken" => Ok(__FieldTag::__security_token),
                                "security_token" => Ok(__FieldTag::__security_token),
                                "secretManagerStoredPassword" => {
                                    Ok(__FieldTag::__secret_manager_stored_password)
                                }
                                "secret_manager_stored_password" => {
                                    Ok(__FieldTag::__secret_manager_stored_password)
                                }
                                "secretManagerStoredSecurityToken" => {
                                    Ok(__FieldTag::__secret_manager_stored_security_token)
                                }
                                "secret_manager_stored_security_token" => {
                                    Ok(__FieldTag::__secret_manager_stored_security_token)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UserCredentials;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UserCredentials")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__username => {
                                if !fields.insert(__FieldTag::__username) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for username",
                                    ));
                                }
                                result.username = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__password => {
                                if !fields.insert(__FieldTag::__password) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for password",
                                    ));
                                }
                                result.password = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__security_token => {
                                if !fields.insert(__FieldTag::__security_token) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for security_token",
                                    ));
                                }
                                result.security_token = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__secret_manager_stored_password => {
                                if !fields.insert(__FieldTag::__secret_manager_stored_password) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for secret_manager_stored_password",
                                    ));
                                }
                                result.secret_manager_stored_password = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__secret_manager_stored_security_token => {
                                if !fields
                                    .insert(__FieldTag::__secret_manager_stored_security_token)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for secret_manager_stored_security_token",
                                    ));
                                }
                                result.secret_manager_stored_security_token = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UserCredentials {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.username.is_empty() {
                state.serialize_entry("username", &self.username)?;
            }
            if !self.password.is_empty() {
                state.serialize_entry("password", &self.password)?;
            }
            if !self.security_token.is_empty() {
                state.serialize_entry("securityToken", &self.security_token)?;
            }
            if !self.secret_manager_stored_password.is_empty() {
                state.serialize_entry(
                    "secretManagerStoredPassword",
                    &self.secret_manager_stored_password,
                )?;
            }
            if !self.secret_manager_stored_security_token.is_empty() {
                state.serialize_entry(
                    "secretManagerStoredSecurityToken",
                    &self.secret_manager_stored_security_token,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for UserCredentials {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("UserCredentials");
            debug_struct.field("username", &self.username);
            debug_struct.field("password", &self.password);
            debug_struct.field("security_token", &self.security_token);
            debug_struct.field(
                "secret_manager_stored_password",
                &self.secret_manager_stored_password,
            );
            debug_struct.field(
                "secret_manager_stored_security_token",
                &self.secret_manager_stored_security_token,
            );
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// OAuth2 Client Credentials.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Oauth2ClientCredentials {
        /// Required. Client ID for Salesforce OAuth2 Client Credentials.
        pub client_id: std::string::String,

        /// Optional. Client secret for Salesforce OAuth2 Client Credentials.
        /// Mutually exclusive with the `secret_manager_stored_client_secret` field.
        pub client_secret: std::string::String,

        /// Optional. A reference to a Secret Manager resource name storing the
        /// Salesforce OAuth2 client_secret. Mutually exclusive with the
        /// `client_secret` field.
        pub secret_manager_stored_client_secret: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Oauth2ClientCredentials {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [client_id][crate::model::salesforce_profile::Oauth2ClientCredentials::client_id].
        pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client_id = v.into();
            self
        }

        /// Sets the value of [client_secret][crate::model::salesforce_profile::Oauth2ClientCredentials::client_secret].
        pub fn set_client_secret<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.client_secret = v.into();
            self
        }

        /// Sets the value of [secret_manager_stored_client_secret][crate::model::salesforce_profile::Oauth2ClientCredentials::secret_manager_stored_client_secret].
        pub fn set_secret_manager_stored_client_secret<
            T: std::convert::Into<std::string::String>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.secret_manager_stored_client_secret = v.into();
            self
        }
    }

    impl wkt::message::Message for Oauth2ClientCredentials {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SalesforceProfile.Oauth2ClientCredentials"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Oauth2ClientCredentials {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __client_id,
                __client_secret,
                __secret_manager_stored_client_secret,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Oauth2ClientCredentials")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "clientId" => Ok(__FieldTag::__client_id),
                                "client_id" => Ok(__FieldTag::__client_id),
                                "clientSecret" => Ok(__FieldTag::__client_secret),
                                "client_secret" => Ok(__FieldTag::__client_secret),
                                "secretManagerStoredClientSecret" => {
                                    Ok(__FieldTag::__secret_manager_stored_client_secret)
                                }
                                "secret_manager_stored_client_secret" => {
                                    Ok(__FieldTag::__secret_manager_stored_client_secret)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Oauth2ClientCredentials;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Oauth2ClientCredentials")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__client_id => {
                                if !fields.insert(__FieldTag::__client_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_id",
                                    ));
                                }
                                result.client_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__client_secret => {
                                if !fields.insert(__FieldTag::__client_secret) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_secret",
                                    ));
                                }
                                result.client_secret = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__secret_manager_stored_client_secret => {
                                if !fields.insert(__FieldTag::__secret_manager_stored_client_secret)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for secret_manager_stored_client_secret",
                                    ));
                                }
                                result.secret_manager_stored_client_secret = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Oauth2ClientCredentials {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.client_id.is_empty() {
                state.serialize_entry("clientId", &self.client_id)?;
            }
            if !self.client_secret.is_empty() {
                state.serialize_entry("clientSecret", &self.client_secret)?;
            }
            if !self.secret_manager_stored_client_secret.is_empty() {
                state.serialize_entry(
                    "secretManagerStoredClientSecret",
                    &self.secret_manager_stored_client_secret,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Oauth2ClientCredentials {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Oauth2ClientCredentials");
            debug_struct.field("client_id", &self.client_id);
            debug_struct.field("client_secret", &self.client_secret);
            debug_struct.field(
                "secret_manager_stored_client_secret",
                &self.secret_manager_stored_client_secret,
            );
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Credentials for Salesforce connection.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Credentials {
        /// User-password authentication.
        UserCredentials(std::boxed::Box<crate::model::salesforce_profile::UserCredentials>),
        /// Connected app authentication.
        Oauth2ClientCredentials(
            std::boxed::Box<crate::model::salesforce_profile::Oauth2ClientCredentials>,
        ),
    }
}

/// Cloud Storage bucket profile.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsProfile {
    /// Required. The Cloud Storage bucket name.
    pub bucket: std::string::String,

    /// The root path inside the Cloud Storage bucket.
    pub root_path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::GcsProfile::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [root_path][crate::model::GcsProfile::root_path].
    pub fn set_root_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_path = v.into();
        self
    }
}

impl wkt::message::Message for GcsProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GcsProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __root_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "rootPath" => Ok(__FieldTag::__root_path),
                            "root_path" => Ok(__FieldTag::__root_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__root_path => {
                            if !fields.insert(__FieldTag::__root_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_path",
                                ));
                            }
                            result.root_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.root_path.is_empty() {
            state.serialize_entry("rootPath", &self.root_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsProfile");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("root_path", &self.root_path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// BigQuery warehouse profile.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryProfile {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BigQueryProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.BigQueryProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BigQueryProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigQueryProfile");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Static IP address connectivity. Used when the source database is configured
/// to allow incoming connections from the Datastream public IP addresses
/// for the region specified in the connection profile.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StaticServiceIpConnectivity {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StaticServiceIpConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StaticServiceIpConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.StaticServiceIpConnectivity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StaticServiceIpConnectivity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StaticServiceIpConnectivity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StaticServiceIpConnectivity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StaticServiceIpConnectivity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StaticServiceIpConnectivity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StaticServiceIpConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StaticServiceIpConnectivity");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Forward SSH Tunnel connectivity.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ForwardSshTunnelConnectivity {
    /// Required. Hostname for the SSH tunnel.
    pub hostname: std::string::String,

    /// Required. Username for the SSH tunnel.
    pub username: std::string::String,

    /// Port for the SSH tunnel, default value is 22.
    pub port: i32,

    pub authentication_method:
        std::option::Option<crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ForwardSshTunnelConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::ForwardSshTunnelConnectivity::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [username][crate::model::ForwardSshTunnelConnectivity::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [port][crate::model::ForwardSshTunnelConnectivity::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method].
    ///
    /// Note that all the setters affecting `authentication_method` are mutually
    /// exclusive.
    pub fn set_authentication_method<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = v.into();
        self
    }

    /// The value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// if it holds a `Password`, `None` if the field is not set or
    /// holds a different branch.
    pub fn password(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::Password(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// to hold a `Password`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::Password(v.into()),
        );
        self
    }

    /// The value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// if it holds a `PrivateKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_key(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::PrivateKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// to hold a `PrivateKey`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::PrivateKey(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ForwardSshTunnelConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ForwardSshTunnelConnectivity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ForwardSshTunnelConnectivity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hostname,
            __username,
            __port,
            __password,
            __private_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForwardSshTunnelConnectivity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostname" => Ok(__FieldTag::__hostname),
                            "username" => Ok(__FieldTag::__username),
                            "port" => Ok(__FieldTag::__port),
                            "password" => Ok(__FieldTag::__password),
                            "privateKey" => Ok(__FieldTag::__private_key),
                            "private_key" => Ok(__FieldTag::__private_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ForwardSshTunnelConnectivity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForwardSshTunnelConnectivity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            if result.authentication_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `authentication_method`, a oneof with full ID .google.cloud.datastream.v1.ForwardSshTunnelConnectivity.password, latest field was password",
                                ));
                            }
                            result.authentication_method = std::option::Option::Some(
                                crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::Password(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__private_key => {
                            if !fields.insert(__FieldTag::__private_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_key",
                                ));
                            }
                            if result.authentication_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `authentication_method`, a oneof with full ID .google.cloud.datastream.v1.ForwardSshTunnelConnectivity.private_key, latest field was privateKey",
                                ));
                            }
                            result.authentication_method = std::option::Option::Some(
                                crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::PrivateKey(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ForwardSshTunnelConnectivity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if let Some(value) = self.password() {
            state.serialize_entry("password", value)?;
        }
        if let Some(value) = self.private_key() {
            state.serialize_entry("privateKey", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ForwardSshTunnelConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ForwardSshTunnelConnectivity");
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("username", &self.username);
        debug_struct.field("port", &self.port);
        debug_struct.field("authentication_method", &self.authentication_method);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ForwardSshTunnelConnectivity].
pub mod forward_ssh_tunnel_connectivity {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthenticationMethod {
        /// Input only. SSH password.
        Password(std::string::String),
        /// Input only. SSH private key.
        PrivateKey(std::string::String),
    }
}

/// The VPC Peering configuration is used to create VPC peering between
/// Datastream and the consumer's VPC.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VpcPeeringConfig {
    /// Required. Fully qualified name of the VPC that Datastream will peer to.
    /// Format: `projects/{project}/global/{networks}/{name}`
    pub vpc: std::string::String,

    /// Required. A free subnet for peering. (CIDR of /29)
    pub subnet: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpcPeeringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpc][crate::model::VpcPeeringConfig::vpc].
    pub fn set_vpc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::VpcPeeringConfig::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }
}

impl wkt::message::Message for VpcPeeringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.VpcPeeringConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VpcPeeringConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vpc,
            __subnet,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpcPeeringConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vpc" => Ok(__FieldTag::__vpc),
                            "subnet" => Ok(__FieldTag::__subnet),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VpcPeeringConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpcPeeringConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vpc => {
                            if !fields.insert(__FieldTag::__vpc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc",
                                ));
                            }
                            result.vpc = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnet => {
                            if !fields.insert(__FieldTag::__subnet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet",
                                ));
                            }
                            result.subnet = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VpcPeeringConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vpc.is_empty() {
            state.serialize_entry("vpc", &self.vpc)?;
        }
        if !self.subnet.is_empty() {
            state.serialize_entry("subnet", &self.subnet)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VpcPeeringConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VpcPeeringConfig");
        debug_struct.field("vpc", &self.vpc);
        debug_struct.field("subnet", &self.subnet);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The PrivateConnection resource is used to establish private connectivity
/// between Datastream and a customer's network.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivateConnection {
    /// Output only. Identifier. The resource's name.
    pub name: std::string::String,

    /// Output only. The create time of the resource.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time of the resource.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Display name.
    pub display_name: std::string::String,

    /// Output only. The state of the Private Connection.
    pub state: crate::model::private_connection::State,

    /// Output only. In case of error, the details of the error in a user-friendly
    /// format.
    pub error: std::option::Option<crate::model::Error>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: std::option::Option<bool>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: std::option::Option<bool>,

    /// VPC Peering Config.
    pub vpc_peering_config: std::option::Option<crate::model::VpcPeeringConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PrivateConnection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PrivateConnection::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PrivateConnection::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PrivateConnection::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PrivateConnection::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::PrivateConnection::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::PrivateConnection::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PrivateConnection::state].
    pub fn set_state<T: std::convert::Into<crate::model::private_connection::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::PrivateConnection::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Error>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::PrivateConnection::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Error>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::PrivateConnection::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::PrivateConnection::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::PrivateConnection::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::PrivateConnection::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vpc_peering_config][crate::model::PrivateConnection::vpc_peering_config].
    pub fn set_vpc_peering_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VpcPeeringConfig>,
    {
        self.vpc_peering_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpc_peering_config][crate::model::PrivateConnection::vpc_peering_config].
    pub fn set_or_clear_vpc_peering_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VpcPeeringConfig>,
    {
        self.vpc_peering_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PrivateConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PrivateConnection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivateConnection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __display_name,
            __state,
            __error,
            __satisfies_pzs,
            __satisfies_pzi,
            __vpc_peering_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivateConnection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            "vpcPeeringConfig" => Ok(__FieldTag::__vpc_peering_config),
                            "vpc_peering_config" => Ok(__FieldTag::__vpc_peering_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivateConnection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivateConnection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::private_connection::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<crate::model::Error>>()?;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__vpc_peering_config => {
                            if !fields.insert(__FieldTag::__vpc_peering_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_peering_config",
                                ));
                            }
                            result.vpc_peering_config = map
                                .next_value::<std::option::Option<crate::model::VpcPeeringConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivateConnection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.vpc_peering_config.is_some() {
            state.serialize_entry("vpcPeeringConfig", &self.vpc_peering_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PrivateConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateConnection");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("error", &self.error);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field("vpc_peering_config", &self.vpc_peering_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PrivateConnection].
pub mod private_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Private Connection state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// The private connection is in creation state - creating resources.
        Creating,
        /// The private connection has been created with all of its resources.
        Created,
        /// The private connection creation has failed.
        Failed,
        /// The private connection is being deleted.
        Deleting,
        /// Delete request has failed, resource is in invalid state.
        FailedToDelete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Created => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::FailedToDelete => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Created => std::option::Option::Some("CREATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::FailedToDelete => std::option::Option::Some("FAILED_TO_DELETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Created,
                3 => Self::Failed,
                4 => Self::Deleting,
                5 => Self::FailedToDelete,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "CREATED" => Self::Created,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                "FAILED_TO_DELETE" => Self::FailedToDelete,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Created => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::FailedToDelete => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.datastream.v1.PrivateConnection.State",
            ))
        }
    }
}

/// Private Connectivity
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivateConnectivity {
    /// Required. A reference to a private connection resource.
    /// Format: `projects/{project}/locations/{location}/privateConnections/{name}`
    pub private_connection: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_connection][crate::model::PrivateConnectivity::private_connection].
    pub fn set_private_connection<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_connection = v.into();
        self
    }
}

impl wkt::message::Message for PrivateConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PrivateConnectivity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivateConnectivity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __private_connection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivateConnectivity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "privateConnection" => Ok(__FieldTag::__private_connection),
                            "private_connection" => Ok(__FieldTag::__private_connection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivateConnectivity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivateConnectivity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__private_connection => {
                            if !fields.insert(__FieldTag::__private_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_connection",
                                ));
                            }
                            result.private_connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivateConnectivity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.private_connection.is_empty() {
            state.serialize_entry("privateConnection", &self.private_connection)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PrivateConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateConnectivity");
        debug_struct.field("private_connection", &self.private_connection);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The route resource is the child of the private connection resource,
/// used for defining a route for a private connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Route {
    /// Output only. Identifier. The resource's name.
    pub name: std::string::String,

    /// Output only. The create time of the resource.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time of the resource.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Display name.
    pub display_name: std::string::String,

    /// Required. Destination address for connection
    pub destination_address: std::string::String,

    /// Destination port for connection
    pub destination_port: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Route {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Route::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Route::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Route::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Route::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Route::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Route::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::Route::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [destination_address][crate::model::Route::destination_address].
    pub fn set_destination_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_address = v.into();
        self
    }

    /// Sets the value of [destination_port][crate::model::Route::destination_port].
    pub fn set_destination_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.destination_port = v.into();
        self
    }
}

impl wkt::message::Message for Route {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.Route"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Route {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __display_name,
            __destination_address,
            __destination_port,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Route")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "destinationAddress" => Ok(__FieldTag::__destination_address),
                            "destination_address" => Ok(__FieldTag::__destination_address),
                            "destinationPort" => Ok(__FieldTag::__destination_port),
                            "destination_port" => Ok(__FieldTag::__destination_port),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Route;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Route")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_address => {
                            if !fields.insert(__FieldTag::__destination_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_address",
                                ));
                            }
                            result.destination_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_port => {
                            if !fields.insert(__FieldTag::__destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.destination_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Route {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.destination_address.is_empty() {
            state.serialize_entry("destinationAddress", &self.destination_address)?;
        }
        if !wkt::internal::is_default(&self.destination_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("destinationPort", &__With(&self.destination_port))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Route {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Route");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("destination_address", &self.destination_address);
        debug_struct.field("destination_port", &self.destination_port);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MySQL SSL configuration information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MysqlSslConfig {
    /// Optional. Input only. PEM-encoded private key associated with the Client
    /// Certificate. If this field is used then the 'client_certificate' and the
    /// 'ca_certificate' fields are mandatory.
    pub client_key: std::string::String,

    /// Output only. Indicates whether the client_key field is set.
    pub client_key_set: bool,

    /// Optional. Input only. PEM-encoded certificate that will be used by the
    /// replica to authenticate against the source database server. If this field
    /// is used then the 'client_key' and the 'ca_certificate' fields are
    /// mandatory.
    pub client_certificate: std::string::String,

    /// Output only. Indicates whether the client_certificate field is set.
    pub client_certificate_set: bool,

    /// Input only. PEM-encoded certificate of the CA that signed the source
    /// database server's certificate.
    pub ca_certificate: std::string::String,

    /// Output only. Indicates whether the ca_certificate field is set.
    pub ca_certificate_set: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlSslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [client_key][crate::model::MysqlSslConfig::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [client_key_set][crate::model::MysqlSslConfig::client_key_set].
    pub fn set_client_key_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.client_key_set = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::MysqlSslConfig::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [client_certificate_set][crate::model::MysqlSslConfig::client_certificate_set].
    pub fn set_client_certificate_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.client_certificate_set = v.into();
        self
    }

    /// Sets the value of [ca_certificate][crate::model::MysqlSslConfig::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }

    /// Sets the value of [ca_certificate_set][crate::model::MysqlSslConfig::ca_certificate_set].
    pub fn set_ca_certificate_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ca_certificate_set = v.into();
        self
    }
}

impl wkt::message::Message for MysqlSslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlSslConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MysqlSslConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __client_key,
            __client_key_set,
            __client_certificate,
            __client_certificate_set,
            __ca_certificate,
            __ca_certificate_set,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MysqlSslConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clientKey" => Ok(__FieldTag::__client_key),
                            "client_key" => Ok(__FieldTag::__client_key),
                            "clientKeySet" => Ok(__FieldTag::__client_key_set),
                            "client_key_set" => Ok(__FieldTag::__client_key_set),
                            "clientCertificate" => Ok(__FieldTag::__client_certificate),
                            "client_certificate" => Ok(__FieldTag::__client_certificate),
                            "clientCertificateSet" => Ok(__FieldTag::__client_certificate_set),
                            "client_certificate_set" => Ok(__FieldTag::__client_certificate_set),
                            "caCertificate" => Ok(__FieldTag::__ca_certificate),
                            "ca_certificate" => Ok(__FieldTag::__ca_certificate),
                            "caCertificateSet" => Ok(__FieldTag::__ca_certificate_set),
                            "ca_certificate_set" => Ok(__FieldTag::__ca_certificate_set),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MysqlSslConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MysqlSslConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__client_key => {
                            if !fields.insert(__FieldTag::__client_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_key",
                                ));
                            }
                            result.client_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_key_set => {
                            if !fields.insert(__FieldTag::__client_key_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_key_set",
                                ));
                            }
                            result.client_key_set = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_certificate => {
                            if !fields.insert(__FieldTag::__client_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_certificate",
                                ));
                            }
                            result.client_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_certificate_set => {
                            if !fields.insert(__FieldTag::__client_certificate_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_certificate_set",
                                ));
                            }
                            result.client_certificate_set = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ca_certificate => {
                            if !fields.insert(__FieldTag::__ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_certificate",
                                ));
                            }
                            result.ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ca_certificate_set => {
                            if !fields.insert(__FieldTag::__ca_certificate_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_certificate_set",
                                ));
                            }
                            result.ca_certificate_set = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MysqlSslConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.client_key.is_empty() {
            state.serialize_entry("clientKey", &self.client_key)?;
        }
        if !wkt::internal::is_default(&self.client_key_set) {
            state.serialize_entry("clientKeySet", &self.client_key_set)?;
        }
        if !self.client_certificate.is_empty() {
            state.serialize_entry("clientCertificate", &self.client_certificate)?;
        }
        if !wkt::internal::is_default(&self.client_certificate_set) {
            state.serialize_entry("clientCertificateSet", &self.client_certificate_set)?;
        }
        if !self.ca_certificate.is_empty() {
            state.serialize_entry("caCertificate", &self.ca_certificate)?;
        }
        if !wkt::internal::is_default(&self.ca_certificate_set) {
            state.serialize_entry("caCertificateSet", &self.ca_certificate_set)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MysqlSslConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MysqlSslConfig");
        debug_struct.field("client_key", &self.client_key);
        debug_struct.field("client_key_set", &self.client_key_set);
        debug_struct.field("client_certificate", &self.client_certificate);
        debug_struct.field("client_certificate_set", &self.client_certificate_set);
        debug_struct.field("ca_certificate", &self.ca_certificate);
        debug_struct.field("ca_certificate_set", &self.ca_certificate_set);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Oracle SSL configuration information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OracleSslConfig {
    /// Input only. PEM-encoded certificate of the CA that signed the source
    /// database server's certificate.
    pub ca_certificate: std::string::String,

    /// Output only. Indicates whether the ca_certificate field has been set for
    /// this Connection-Profile.
    pub ca_certificate_set: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleSslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ca_certificate][crate::model::OracleSslConfig::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }

    /// Sets the value of [ca_certificate_set][crate::model::OracleSslConfig::ca_certificate_set].
    pub fn set_ca_certificate_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ca_certificate_set = v.into();
        self
    }
}

impl wkt::message::Message for OracleSslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleSslConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OracleSslConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ca_certificate,
            __ca_certificate_set,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OracleSslConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "caCertificate" => Ok(__FieldTag::__ca_certificate),
                            "ca_certificate" => Ok(__FieldTag::__ca_certificate),
                            "caCertificateSet" => Ok(__FieldTag::__ca_certificate_set),
                            "ca_certificate_set" => Ok(__FieldTag::__ca_certificate_set),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OracleSslConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OracleSslConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ca_certificate => {
                            if !fields.insert(__FieldTag::__ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_certificate",
                                ));
                            }
                            result.ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ca_certificate_set => {
                            if !fields.insert(__FieldTag::__ca_certificate_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_certificate_set",
                                ));
                            }
                            result.ca_certificate_set = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OracleSslConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ca_certificate.is_empty() {
            state.serialize_entry("caCertificate", &self.ca_certificate)?;
        }
        if !wkt::internal::is_default(&self.ca_certificate_set) {
            state.serialize_entry("caCertificateSet", &self.ca_certificate_set)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OracleSslConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OracleSslConfig");
        debug_struct.field("ca_certificate", &self.ca_certificate);
        debug_struct.field("ca_certificate_set", &self.ca_certificate_set);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// PostgreSQL SSL configuration information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PostgresqlSslConfig {
    /// The encryption settings available for PostgreSQL connection profiles.
    /// This captures various SSL mode supported by PostgreSQL, which includes
    /// TLS encryption with server verification, TLS encryption with both server
    /// and client verification and no TLS encryption.
    pub encryption_setting:
        std::option::Option<crate::model::postgresql_ssl_config::EncryptionSetting>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlSslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_setting][crate::model::PostgresqlSslConfig::encryption_setting].
    ///
    /// Note that all the setters affecting `encryption_setting` are mutually
    /// exclusive.
    pub fn set_encryption_setting<
        T: std::convert::Into<
                std::option::Option<crate::model::postgresql_ssl_config::EncryptionSetting>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_setting = v.into();
        self
    }

    /// The value of [encryption_setting][crate::model::PostgresqlSslConfig::encryption_setting]
    /// if it holds a `ServerVerification`, `None` if the field is not set or
    /// holds a different branch.
    pub fn server_verification(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::postgresql_ssl_config::ServerVerification>,
    > {
        #[allow(unreachable_patterns)]
        self.encryption_setting.as_ref().and_then(|v| match v {
            crate::model::postgresql_ssl_config::EncryptionSetting::ServerVerification(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [encryption_setting][crate::model::PostgresqlSslConfig::encryption_setting]
    /// to hold a `ServerVerification`.
    ///
    /// Note that all the setters affecting `encryption_setting` are
    /// mutually exclusive.
    pub fn set_server_verification<
        T: std::convert::Into<
                std::boxed::Box<crate::model::postgresql_ssl_config::ServerVerification>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_setting = std::option::Option::Some(
            crate::model::postgresql_ssl_config::EncryptionSetting::ServerVerification(v.into()),
        );
        self
    }

    /// The value of [encryption_setting][crate::model::PostgresqlSslConfig::encryption_setting]
    /// if it holds a `ServerAndClientVerification`, `None` if the field is not set or
    /// holds a different branch.
    pub fn server_and_client_verification(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::postgresql_ssl_config::ServerAndClientVerification>,
    > {
        #[allow(unreachable_patterns)]
        self.encryption_setting.as_ref().and_then(|v| match v {
            crate::model::postgresql_ssl_config::EncryptionSetting::ServerAndClientVerification(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [encryption_setting][crate::model::PostgresqlSslConfig::encryption_setting]
    /// to hold a `ServerAndClientVerification`.
    ///
    /// Note that all the setters affecting `encryption_setting` are
    /// mutually exclusive.
    pub fn set_server_and_client_verification<
        T: std::convert::Into<
                std::boxed::Box<crate::model::postgresql_ssl_config::ServerAndClientVerification>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_setting = std::option::Option::Some(
            crate::model::postgresql_ssl_config::EncryptionSetting::ServerAndClientVerification(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for PostgresqlSslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlSslConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostgresqlSslConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __server_verification,
            __server_and_client_verification,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostgresqlSslConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serverVerification" => Ok(__FieldTag::__server_verification),
                            "server_verification" => Ok(__FieldTag::__server_verification),
                            "serverAndClientVerification" => {
                                Ok(__FieldTag::__server_and_client_verification)
                            }
                            "server_and_client_verification" => {
                                Ok(__FieldTag::__server_and_client_verification)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostgresqlSslConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostgresqlSslConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__server_verification => {
                            if !fields.insert(__FieldTag::__server_verification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_verification",
                                ));
                            }
                            if result.encryption_setting.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `encryption_setting`, a oneof with full ID .google.cloud.datastream.v1.PostgresqlSslConfig.server_verification, latest field was serverVerification",
                                ));
                            }
                            result.encryption_setting = std::option::Option::Some(
                                crate::model::postgresql_ssl_config::EncryptionSetting::ServerVerification(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::postgresql_ssl_config::ServerVerification>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__server_and_client_verification => {
                            if !fields.insert(__FieldTag::__server_and_client_verification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_and_client_verification",
                                ));
                            }
                            if result.encryption_setting.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `encryption_setting`, a oneof with full ID .google.cloud.datastream.v1.PostgresqlSslConfig.server_and_client_verification, latest field was serverAndClientVerification",
                                ));
                            }
                            result.encryption_setting = std::option::Option::Some(
                                crate::model::postgresql_ssl_config::EncryptionSetting::ServerAndClientVerification(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::postgresql_ssl_config::ServerAndClientVerification>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostgresqlSslConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.server_verification() {
            state.serialize_entry("serverVerification", value)?;
        }
        if let Some(value) = self.server_and_client_verification() {
            state.serialize_entry("serverAndClientVerification", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PostgresqlSslConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostgresqlSslConfig");
        debug_struct.field("encryption_setting", &self.encryption_setting);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PostgresqlSslConfig].
pub mod postgresql_ssl_config {
    #[allow(unused_imports)]
    use super::*;

    /// Message represents the option where Datastream will enforce the encryption
    /// and authenticate the server identity. ca_certificate must be set if user
    /// selects this option.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ServerVerification {
        /// Required. Input only. PEM-encoded server root CA certificate.
        pub ca_certificate: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ServerVerification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ca_certificate][crate::model::postgresql_ssl_config::ServerVerification::ca_certificate].
        pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.ca_certificate = v.into();
            self
        }
    }

    impl wkt::message::Message for ServerVerification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.PostgresqlSslConfig.ServerVerification"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ServerVerification {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __ca_certificate,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ServerVerification")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "caCertificate" => Ok(__FieldTag::__ca_certificate),
                                "ca_certificate" => Ok(__FieldTag::__ca_certificate),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ServerVerification;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ServerVerification")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__ca_certificate => {
                                if !fields.insert(__FieldTag::__ca_certificate) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ca_certificate",
                                    ));
                                }
                                result.ca_certificate = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ServerVerification {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.ca_certificate.is_empty() {
                state.serialize_entry("caCertificate", &self.ca_certificate)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ServerVerification {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ServerVerification");
            debug_struct.field("ca_certificate", &self.ca_certificate);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Message represents the option where Datastream will enforce the encryption
    /// and authenticate the server identity as well as the client identity.
    /// ca_certificate, client_certificate and client_key must be set if user
    /// selects this option.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ServerAndClientVerification {
        /// Required. Input only. PEM-encoded certificate used by the source database
        /// to authenticate the client identity (i.e., the Datastream's identity).
        /// This certificate is signed by either a root certificate trusted by the
        /// server or one or more intermediate certificates (which is stored with the
        /// leaf certificate) to link the this certificate to the trusted root
        /// certificate.
        pub client_certificate: std::string::String,

        /// Optional. Input only. PEM-encoded private key associated with the client
        /// certificate. This value will be used during the SSL/TLS handshake,
        /// allowing the PostgreSQL server to authenticate the client's identity,
        /// i.e. identity of the Datastream.
        pub client_key: std::string::String,

        /// Required. Input only. PEM-encoded server root CA certificate.
        pub ca_certificate: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ServerAndClientVerification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [client_certificate][crate::model::postgresql_ssl_config::ServerAndClientVerification::client_certificate].
        pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.client_certificate = v.into();
            self
        }

        /// Sets the value of [client_key][crate::model::postgresql_ssl_config::ServerAndClientVerification::client_key].
        pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client_key = v.into();
            self
        }

        /// Sets the value of [ca_certificate][crate::model::postgresql_ssl_config::ServerAndClientVerification::ca_certificate].
        pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.ca_certificate = v.into();
            self
        }
    }

    impl wkt::message::Message for ServerAndClientVerification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.PostgresqlSslConfig.ServerAndClientVerification"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ServerAndClientVerification {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __client_certificate,
                __client_key,
                __ca_certificate,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ServerAndClientVerification")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "clientCertificate" => Ok(__FieldTag::__client_certificate),
                                "client_certificate" => Ok(__FieldTag::__client_certificate),
                                "clientKey" => Ok(__FieldTag::__client_key),
                                "client_key" => Ok(__FieldTag::__client_key),
                                "caCertificate" => Ok(__FieldTag::__ca_certificate),
                                "ca_certificate" => Ok(__FieldTag::__ca_certificate),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ServerAndClientVerification;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ServerAndClientVerification")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__client_certificate => {
                                if !fields.insert(__FieldTag::__client_certificate) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_certificate",
                                    ));
                                }
                                result.client_certificate = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__client_key => {
                                if !fields.insert(__FieldTag::__client_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_key",
                                    ));
                                }
                                result.client_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ca_certificate => {
                                if !fields.insert(__FieldTag::__ca_certificate) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ca_certificate",
                                    ));
                                }
                                result.ca_certificate = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ServerAndClientVerification {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.client_certificate.is_empty() {
                state.serialize_entry("clientCertificate", &self.client_certificate)?;
            }
            if !self.client_key.is_empty() {
                state.serialize_entry("clientKey", &self.client_key)?;
            }
            if !self.ca_certificate.is_empty() {
                state.serialize_entry("caCertificate", &self.ca_certificate)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ServerAndClientVerification {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ServerAndClientVerification");
            debug_struct.field("client_certificate", &self.client_certificate);
            debug_struct.field("client_key", &self.client_key);
            debug_struct.field("ca_certificate", &self.ca_certificate);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The encryption settings available for PostgreSQL connection profiles.
    /// This captures various SSL mode supported by PostgreSQL, which includes
    /// TLS encryption with server verification, TLS encryption with both server
    /// and client verification and no TLS encryption.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EncryptionSetting {
        /// If this field is set, the communication will be encrypted with TLS
        /// encryption and the server identity will be authenticated.
        ServerVerification(
            std::boxed::Box<crate::model::postgresql_ssl_config::ServerVerification>,
        ),
        /// If this field is set, the communication will be encrypted with TLS
        /// encryption and both the server identity and the client identity will be
        /// authenticated.
        ServerAndClientVerification(
            std::boxed::Box<crate::model::postgresql_ssl_config::ServerAndClientVerification>,
        ),
    }
}

/// A set of reusable connection configurations to be used as a source or
/// destination for a stream.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConnectionProfile {
    /// Output only. Identifier. The resource's name.
    pub name: std::string::String,

    /// Output only. The create time of the resource.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time of the resource.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Display name.
    pub display_name: std::string::String,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: std::option::Option<bool>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: std::option::Option<bool>,

    /// Connection configuration for the ConnectionProfile.
    pub profile: std::option::Option<crate::model::connection_profile::Profile>,

    /// Connectivity options used to establish a connection to the profile.
    pub connectivity: std::option::Option<crate::model::connection_profile::Connectivity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConnectionProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConnectionProfile::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ConnectionProfile::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ConnectionProfile::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ConnectionProfile::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ConnectionProfile::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::ConnectionProfile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::ConnectionProfile::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::ConnectionProfile::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::ConnectionProfile::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::ConnectionProfile::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile].
    ///
    /// Note that all the setters affecting `profile` are mutually
    /// exclusive.
    pub fn set_profile<
        T: std::convert::Into<std::option::Option<crate::model::connection_profile::Profile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = v.into();
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `OracleProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OracleProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::OracleProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `OracleProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_oracle_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::OracleProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::OracleProfile(v.into()),
        );
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `GcsProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_profile(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::GcsProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `GcsProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_gcs_profile<T: std::convert::Into<std::boxed::Box<crate::model::GcsProfile>>>(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::GcsProfile(v.into()),
        );
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `MysqlProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MysqlProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::MysqlProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `MysqlProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_mysql_profile<T: std::convert::Into<std::boxed::Box<crate::model::MysqlProfile>>>(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::MysqlProfile(v.into()),
        );
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `BigqueryProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::BigqueryProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `BigqueryProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_bigquery_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::BigqueryProfile(v.into()),
        );
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `PostgresqlProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostgresqlProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::PostgresqlProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `PostgresqlProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_postgresql_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::PostgresqlProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::PostgresqlProfile(v.into()),
        );
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `SqlServerProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_server_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::SqlServerProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `SqlServerProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_sql_server_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::SqlServerProfile(v.into()),
        );
        self
    }

    /// The value of [profile][crate::model::ConnectionProfile::profile]
    /// if it holds a `SalesforceProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn salesforce_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SalesforceProfile>> {
        #[allow(unreachable_patterns)]
        self.profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Profile::SalesforceProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [profile][crate::model::ConnectionProfile::profile]
    /// to hold a `SalesforceProfile`.
    ///
    /// Note that all the setters affecting `profile` are
    /// mutually exclusive.
    pub fn set_salesforce_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::SalesforceProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = std::option::Option::Some(
            crate::model::connection_profile::Profile::SalesforceProfile(v.into()),
        );
        self
    }

    /// Sets the value of [connectivity][crate::model::ConnectionProfile::connectivity].
    ///
    /// Note that all the setters affecting `connectivity` are mutually
    /// exclusive.
    pub fn set_connectivity<
        T: std::convert::Into<std::option::Option<crate::model::connection_profile::Connectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::ConnectionProfile::connectivity]
    /// if it holds a `StaticServiceIpConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn static_service_ip_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticServiceIpConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Connectivity::StaticServiceIpConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::ConnectionProfile::connectivity]
    /// to hold a `StaticServiceIpConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_static_service_ip_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticServiceIpConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::connection_profile::Connectivity::StaticServiceIpConnectivity(v.into()),
        );
        self
    }

    /// The value of [connectivity][crate::model::ConnectionProfile::connectivity]
    /// if it holds a `ForwardSshConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn forward_ssh_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Connectivity::ForwardSshConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::ConnectionProfile::connectivity]
    /// to hold a `ForwardSshConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_forward_ssh_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::connection_profile::Connectivity::ForwardSshConnectivity(v.into()),
        );
        self
    }

    /// The value of [connectivity][crate::model::ConnectionProfile::connectivity]
    /// if it holds a `PrivateConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrivateConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::connection_profile::Connectivity::PrivateConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::ConnectionProfile::connectivity]
    /// to hold a `PrivateConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_private_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::PrivateConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::connection_profile::Connectivity::PrivateConnectivity(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ConnectionProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConnectionProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __display_name,
            __satisfies_pzs,
            __satisfies_pzi,
            __oracle_profile,
            __gcs_profile,
            __mysql_profile,
            __bigquery_profile,
            __postgresql_profile,
            __sql_server_profile,
            __salesforce_profile,
            __static_service_ip_connectivity,
            __forward_ssh_connectivity,
            __private_connectivity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectionProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            "oracleProfile" => Ok(__FieldTag::__oracle_profile),
                            "oracle_profile" => Ok(__FieldTag::__oracle_profile),
                            "gcsProfile" => Ok(__FieldTag::__gcs_profile),
                            "gcs_profile" => Ok(__FieldTag::__gcs_profile),
                            "mysqlProfile" => Ok(__FieldTag::__mysql_profile),
                            "mysql_profile" => Ok(__FieldTag::__mysql_profile),
                            "bigqueryProfile" => Ok(__FieldTag::__bigquery_profile),
                            "bigquery_profile" => Ok(__FieldTag::__bigquery_profile),
                            "postgresqlProfile" => Ok(__FieldTag::__postgresql_profile),
                            "postgresql_profile" => Ok(__FieldTag::__postgresql_profile),
                            "sqlServerProfile" => Ok(__FieldTag::__sql_server_profile),
                            "sql_server_profile" => Ok(__FieldTag::__sql_server_profile),
                            "salesforceProfile" => Ok(__FieldTag::__salesforce_profile),
                            "salesforce_profile" => Ok(__FieldTag::__salesforce_profile),
                            "staticServiceIpConnectivity" => {
                                Ok(__FieldTag::__static_service_ip_connectivity)
                            }
                            "static_service_ip_connectivity" => {
                                Ok(__FieldTag::__static_service_ip_connectivity)
                            }
                            "forwardSshConnectivity" => Ok(__FieldTag::__forward_ssh_connectivity),
                            "forward_ssh_connectivity" => {
                                Ok(__FieldTag::__forward_ssh_connectivity)
                            }
                            "privateConnectivity" => Ok(__FieldTag::__private_connectivity),
                            "private_connectivity" => Ok(__FieldTag::__private_connectivity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConnectionProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectionProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__oracle_profile => {
                            if !fields.insert(__FieldTag::__oracle_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oracle_profile",
                                ));
                            }
                            if result.profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `profile`, a oneof with full ID .google.cloud.datastream.v1.ConnectionProfile.oracle_profile, latest field was oracleProfile",
                                ));
                            }
                            result.profile = std::option::Option::Some(
                                crate::model::connection_profile::Profile::OracleProfile(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::OracleProfile>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gcs_profile => {
                            if !fields.insert(__FieldTag::__gcs_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_profile",
                                ));
                            }
                            if result.profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `profile`, a oneof with full ID .google.cloud.datastream.v1.ConnectionProfile.gcs_profile, latest field was gcsProfile",
                                ));
                            }
                            result.profile = std::option::Option::Some(
                                crate::model::connection_profile::Profile::GcsProfile(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsProfile>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__mysql_profile => {
                            if !fields.insert(__FieldTag::__mysql_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql_profile",
                                ));
                            }
                            if result.profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `profile`, a oneof with full ID .google.cloud.datastream.v1.ConnectionProfile.mysql_profile, latest field was mysqlProfile",
                                ));
                            }
                            result.profile = std::option::Option::Some(
                                crate::model::connection_profile::Profile::MysqlProfile(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MysqlProfile>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bigquery_profile => {
                            if !fields.insert(__FieldTag::__bigquery_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_profile",
                                ));
                            }
                            if result.profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `profile`, a oneof with full ID .google.cloud.datastream.v1.ConnectionProfile.bigquery_profile, latest field was bigqueryProfile",
                                ));
                            }
                            result.profile = std::option::Option::Some(
                                crate::model::connection_profile::Profile::BigqueryProfile(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryProfile>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__postgresql_profile => {
                            if !fields.insert(__FieldTag::__postgresql_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postgresql_profile",
                                ));
                            }
                            if result.profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `profile`, a oneof with full ID .google.cloud.datastream.v1.ConnectionProfile.postgresql_profile, latest field was postgresqlProfile",
                                ));
                            }
                            result.profile = std::option::Option::Some(
                                crate::model::connection_profile::Profile::PostgresqlProfile(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PostgresqlProfile>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sql_server_profile => {
                            if !fields.insert(__FieldTag::__sql_server_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_server_profile",
                                ));
                            }
                            if result.profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `profile`, a oneof with full ID .google.cloud.datastream.v1.ConnectionProfile.sql_server_profile, latest field was sqlServerProfile",
                                ));
                            }
                            result.profile = std::option::Option::Some(
                                crate::model::connection_profile::Profile::SqlServerProfile(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SqlServerProfile>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__salesforce_profile => {
                            if !fields.insert(__FieldTag::__salesforce_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for salesforce_profile",
                                ));
                            }
                            if result.profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `profile`, a oneof with full ID .google.cloud.datastream.v1.ConnectionProfile.salesforce_profile, latest field was salesforceProfile",
                                ));
                            }
                            result.profile = std::option::Option::Some(
                                crate::model::connection_profile::Profile::SalesforceProfile(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SalesforceProfile>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__static_service_ip_connectivity => {
                            if !fields.insert(__FieldTag::__static_service_ip_connectivity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for static_service_ip_connectivity",
                                ));
                            }
                            if result.connectivity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connectivity`, a oneof with full ID .google.cloud.datastream.v1.ConnectionProfile.static_service_ip_connectivity, latest field was staticServiceIpConnectivity",
                                ));
                            }
                            result.connectivity = std::option::Option::Some(
                                crate::model::connection_profile::Connectivity::StaticServiceIpConnectivity(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StaticServiceIpConnectivity>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__forward_ssh_connectivity => {
                            if !fields.insert(__FieldTag::__forward_ssh_connectivity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forward_ssh_connectivity",
                                ));
                            }
                            if result.connectivity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connectivity`, a oneof with full ID .google.cloud.datastream.v1.ConnectionProfile.forward_ssh_connectivity, latest field was forwardSshConnectivity",
                                ));
                            }
                            result.connectivity = std::option::Option::Some(
                                crate::model::connection_profile::Connectivity::ForwardSshConnectivity(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__private_connectivity => {
                            if !fields.insert(__FieldTag::__private_connectivity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_connectivity",
                                ));
                            }
                            if result.connectivity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connectivity`, a oneof with full ID .google.cloud.datastream.v1.ConnectionProfile.private_connectivity, latest field was privateConnectivity",
                                ));
                            }
                            result.connectivity = std::option::Option::Some(
                                crate::model::connection_profile::Connectivity::PrivateConnectivity(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PrivateConnectivity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConnectionProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if let Some(value) = self.oracle_profile() {
            state.serialize_entry("oracleProfile", value)?;
        }
        if let Some(value) = self.gcs_profile() {
            state.serialize_entry("gcsProfile", value)?;
        }
        if let Some(value) = self.mysql_profile() {
            state.serialize_entry("mysqlProfile", value)?;
        }
        if let Some(value) = self.bigquery_profile() {
            state.serialize_entry("bigqueryProfile", value)?;
        }
        if let Some(value) = self.postgresql_profile() {
            state.serialize_entry("postgresqlProfile", value)?;
        }
        if let Some(value) = self.sql_server_profile() {
            state.serialize_entry("sqlServerProfile", value)?;
        }
        if let Some(value) = self.salesforce_profile() {
            state.serialize_entry("salesforceProfile", value)?;
        }
        if let Some(value) = self.static_service_ip_connectivity() {
            state.serialize_entry("staticServiceIpConnectivity", value)?;
        }
        if let Some(value) = self.forward_ssh_connectivity() {
            state.serialize_entry("forwardSshConnectivity", value)?;
        }
        if let Some(value) = self.private_connectivity() {
            state.serialize_entry("privateConnectivity", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConnectionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConnectionProfile");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field("profile", &self.profile);
        debug_struct.field("connectivity", &self.connectivity);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConnectionProfile].
pub mod connection_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Connection configuration for the ConnectionProfile.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Profile {
        /// Oracle ConnectionProfile configuration.
        OracleProfile(std::boxed::Box<crate::model::OracleProfile>),
        /// Cloud Storage ConnectionProfile configuration.
        GcsProfile(std::boxed::Box<crate::model::GcsProfile>),
        /// MySQL ConnectionProfile configuration.
        MysqlProfile(std::boxed::Box<crate::model::MysqlProfile>),
        /// BigQuery Connection Profile configuration.
        BigqueryProfile(std::boxed::Box<crate::model::BigQueryProfile>),
        /// PostgreSQL Connection Profile configuration.
        PostgresqlProfile(std::boxed::Box<crate::model::PostgresqlProfile>),
        /// SQLServer Connection Profile configuration.
        SqlServerProfile(std::boxed::Box<crate::model::SqlServerProfile>),
        /// Salesforce Connection Profile configuration.
        SalesforceProfile(std::boxed::Box<crate::model::SalesforceProfile>),
    }

    /// Connectivity options used to establish a connection to the profile.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Connectivity {
        /// Static Service IP connectivity.
        StaticServiceIpConnectivity(std::boxed::Box<crate::model::StaticServiceIpConnectivity>),
        /// Forward SSH tunnel connectivity.
        ForwardSshConnectivity(std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>),
        /// Private connectivity.
        PrivateConnectivity(std::boxed::Box<crate::model::PrivateConnectivity>),
    }
}

/// Oracle Column.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OracleColumn {
    /// Column name.
    pub column: std::string::String,

    /// The Oracle data type.
    pub data_type: std::string::String,

    /// Column length.
    pub length: i32,

    /// Column precision.
    pub precision: i32,

    /// Column scale.
    pub scale: i32,

    /// Column encoding.
    pub encoding: std::string::String,

    /// Whether or not the column represents a primary key.
    pub primary_key: bool,

    /// Whether or not the column can accept a null value.
    pub nullable: bool,

    /// The ordinal position of the column in the table.
    pub ordinal_position: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::OracleColumn::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::OracleColumn::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [length][crate::model::OracleColumn::length].
    pub fn set_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::OracleColumn::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::OracleColumn::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [encoding][crate::model::OracleColumn::encoding].
    pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [primary_key][crate::model::OracleColumn::primary_key].
    pub fn set_primary_key<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.primary_key = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::OracleColumn::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::OracleColumn::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }
}

impl wkt::message::Message for OracleColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleColumn"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OracleColumn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __column,
            __data_type,
            __length,
            __precision,
            __scale,
            __encoding,
            __primary_key,
            __nullable,
            __ordinal_position,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OracleColumn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "column" => Ok(__FieldTag::__column),
                            "dataType" => Ok(__FieldTag::__data_type),
                            "data_type" => Ok(__FieldTag::__data_type),
                            "length" => Ok(__FieldTag::__length),
                            "precision" => Ok(__FieldTag::__precision),
                            "scale" => Ok(__FieldTag::__scale),
                            "encoding" => Ok(__FieldTag::__encoding),
                            "primaryKey" => Ok(__FieldTag::__primary_key),
                            "primary_key" => Ok(__FieldTag::__primary_key),
                            "nullable" => Ok(__FieldTag::__nullable),
                            "ordinalPosition" => Ok(__FieldTag::__ordinal_position),
                            "ordinal_position" => Ok(__FieldTag::__ordinal_position),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OracleColumn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OracleColumn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__column => {
                            if !fields.insert(__FieldTag::__column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column",
                                ));
                            }
                            result.column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_type => {
                            if !fields.insert(__FieldTag::__data_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_type",
                                ));
                            }
                            result.data_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__length => {
                            if !fields.insert(__FieldTag::__length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for length",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.length = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__precision => {
                            if !fields.insert(__FieldTag::__precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for precision",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.precision = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scale => {
                            if !fields.insert(__FieldTag::__scale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scale = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__primary_key => {
                            if !fields.insert(__FieldTag::__primary_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_key",
                                ));
                            }
                            result.primary_key = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nullable => {
                            if !fields.insert(__FieldTag::__nullable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nullable",
                                ));
                            }
                            result.nullable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ordinal_position => {
                            if !fields.insert(__FieldTag::__ordinal_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ordinal_position",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ordinal_position =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OracleColumn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.column.is_empty() {
            state.serialize_entry("column", &self.column)?;
        }
        if !self.data_type.is_empty() {
            state.serialize_entry("dataType", &self.data_type)?;
        }
        if !wkt::internal::is_default(&self.length) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("length", &__With(&self.length))?;
        }
        if !wkt::internal::is_default(&self.precision) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("precision", &__With(&self.precision))?;
        }
        if !wkt::internal::is_default(&self.scale) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scale", &__With(&self.scale))?;
        }
        if !self.encoding.is_empty() {
            state.serialize_entry("encoding", &self.encoding)?;
        }
        if !wkt::internal::is_default(&self.primary_key) {
            state.serialize_entry("primaryKey", &self.primary_key)?;
        }
        if !wkt::internal::is_default(&self.nullable) {
            state.serialize_entry("nullable", &self.nullable)?;
        }
        if !wkt::internal::is_default(&self.ordinal_position) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ordinalPosition", &__With(&self.ordinal_position))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OracleColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OracleColumn");
        debug_struct.field("column", &self.column);
        debug_struct.field("data_type", &self.data_type);
        debug_struct.field("length", &self.length);
        debug_struct.field("precision", &self.precision);
        debug_struct.field("scale", &self.scale);
        debug_struct.field("encoding", &self.encoding);
        debug_struct.field("primary_key", &self.primary_key);
        debug_struct.field("nullable", &self.nullable);
        debug_struct.field("ordinal_position", &self.ordinal_position);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Oracle table.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OracleTable {
    /// Table name.
    pub table: std::string::String,

    /// Oracle columns in the schema.
    /// When unspecified as part of include/exclude objects, includes/excludes
    /// everything.
    pub oracle_columns: std::vec::Vec<crate::model::OracleColumn>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::OracleTable::table].
    pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [oracle_columns][crate::model::OracleTable::oracle_columns].
    pub fn set_oracle_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OracleColumn>,
    {
        use std::iter::Iterator;
        self.oracle_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OracleTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleTable"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OracleTable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table,
            __oracle_columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OracleTable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "table" => Ok(__FieldTag::__table),
                            "oracleColumns" => Ok(__FieldTag::__oracle_columns),
                            "oracle_columns" => Ok(__FieldTag::__oracle_columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OracleTable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OracleTable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oracle_columns => {
                            if !fields.insert(__FieldTag::__oracle_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oracle_columns",
                                ));
                            }
                            result.oracle_columns = map.next_value::<std::option::Option<std::vec::Vec<crate::model::OracleColumn>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OracleTable {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.table.is_empty() {
            state.serialize_entry("table", &self.table)?;
        }
        if !self.oracle_columns.is_empty() {
            state.serialize_entry("oracleColumns", &self.oracle_columns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OracleTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OracleTable");
        debug_struct.field("table", &self.table);
        debug_struct.field("oracle_columns", &self.oracle_columns);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Oracle schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OracleSchema {
    /// Schema name.
    pub schema: std::string::String,

    /// Tables in the schema.
    pub oracle_tables: std::vec::Vec<crate::model::OracleTable>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema][crate::model::OracleSchema::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [oracle_tables][crate::model::OracleSchema::oracle_tables].
    pub fn set_oracle_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OracleTable>,
    {
        use std::iter::Iterator;
        self.oracle_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OracleSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleSchema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OracleSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schema,
            __oracle_tables,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OracleSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schema" => Ok(__FieldTag::__schema),
                            "oracleTables" => Ok(__FieldTag::__oracle_tables),
                            "oracle_tables" => Ok(__FieldTag::__oracle_tables),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OracleSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OracleSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oracle_tables => {
                            if !fields.insert(__FieldTag::__oracle_tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oracle_tables",
                                ));
                            }
                            result.oracle_tables = map.next_value::<std::option::Option<std::vec::Vec<crate::model::OracleTable>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OracleSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.schema.is_empty() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self.oracle_tables.is_empty() {
            state.serialize_entry("oracleTables", &self.oracle_tables)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OracleSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OracleSchema");
        debug_struct.field("schema", &self.schema);
        debug_struct.field("oracle_tables", &self.oracle_tables);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Oracle database structure.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OracleRdbms {
    /// Oracle schemas/databases in the database server.
    pub oracle_schemas: std::vec::Vec<crate::model::OracleSchema>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleRdbms {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [oracle_schemas][crate::model::OracleRdbms::oracle_schemas].
    pub fn set_oracle_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OracleSchema>,
    {
        use std::iter::Iterator;
        self.oracle_schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OracleRdbms {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleRdbms"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OracleRdbms {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __oracle_schemas,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OracleRdbms")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "oracleSchemas" => Ok(__FieldTag::__oracle_schemas),
                            "oracle_schemas" => Ok(__FieldTag::__oracle_schemas),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OracleRdbms;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OracleRdbms")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__oracle_schemas => {
                            if !fields.insert(__FieldTag::__oracle_schemas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oracle_schemas",
                                ));
                            }
                            result.oracle_schemas = map.next_value::<std::option::Option<std::vec::Vec<crate::model::OracleSchema>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OracleRdbms {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.oracle_schemas.is_empty() {
            state.serialize_entry("oracleSchemas", &self.oracle_schemas)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OracleRdbms {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OracleRdbms");
        debug_struct.field("oracle_schemas", &self.oracle_schemas);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Oracle data source configuration
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OracleSourceConfig {
    /// Oracle objects to include in the stream.
    pub include_objects: std::option::Option<crate::model::OracleRdbms>,

    /// Oracle objects to exclude from the stream.
    pub exclude_objects: std::option::Option<crate::model::OracleRdbms>,

    /// Maximum number of concurrent CDC tasks. The number should be non-negative.
    /// If not set (or set to 0), the system's default value is used.
    pub max_concurrent_cdc_tasks: i32,

    /// Maximum number of concurrent backfill tasks. The number should be
    /// non-negative. If not set (or set to 0), the system's default value is used.
    pub max_concurrent_backfill_tasks: i32,

    /// The configuration for handle Oracle large objects.
    pub large_objects_handling:
        std::option::Option<crate::model::oracle_source_config::LargeObjectsHandling>,

    /// Configuration to select the CDC method.
    pub cdc_method: std::option::Option<crate::model::oracle_source_config::CdcMethod>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleSourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_objects][crate::model::OracleSourceConfig::include_objects].
    pub fn set_include_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OracleRdbms>,
    {
        self.include_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [include_objects][crate::model::OracleSourceConfig::include_objects].
    pub fn set_or_clear_include_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OracleRdbms>,
    {
        self.include_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exclude_objects][crate::model::OracleSourceConfig::exclude_objects].
    pub fn set_exclude_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OracleRdbms>,
    {
        self.exclude_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclude_objects][crate::model::OracleSourceConfig::exclude_objects].
    pub fn set_or_clear_exclude_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OracleRdbms>,
    {
        self.exclude_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_concurrent_cdc_tasks][crate::model::OracleSourceConfig::max_concurrent_cdc_tasks].
    pub fn set_max_concurrent_cdc_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_cdc_tasks = v.into();
        self
    }

    /// Sets the value of [max_concurrent_backfill_tasks][crate::model::OracleSourceConfig::max_concurrent_backfill_tasks].
    pub fn set_max_concurrent_backfill_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_backfill_tasks = v.into();
        self
    }

    /// Sets the value of [large_objects_handling][crate::model::OracleSourceConfig::large_objects_handling].
    ///
    /// Note that all the setters affecting `large_objects_handling` are mutually
    /// exclusive.
    pub fn set_large_objects_handling<
        T: std::convert::Into<
                std::option::Option<crate::model::oracle_source_config::LargeObjectsHandling>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.large_objects_handling = v.into();
        self
    }

    /// The value of [large_objects_handling][crate::model::OracleSourceConfig::large_objects_handling]
    /// if it holds a `DropLargeObjects`, `None` if the field is not set or
    /// holds a different branch.
    pub fn drop_large_objects(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::oracle_source_config::DropLargeObjects>>
    {
        #[allow(unreachable_patterns)]
        self.large_objects_handling.as_ref().and_then(|v| match v {
            crate::model::oracle_source_config::LargeObjectsHandling::DropLargeObjects(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [large_objects_handling][crate::model::OracleSourceConfig::large_objects_handling]
    /// to hold a `DropLargeObjects`.
    ///
    /// Note that all the setters affecting `large_objects_handling` are
    /// mutually exclusive.
    pub fn set_drop_large_objects<
        T: std::convert::Into<std::boxed::Box<crate::model::oracle_source_config::DropLargeObjects>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.large_objects_handling = std::option::Option::Some(
            crate::model::oracle_source_config::LargeObjectsHandling::DropLargeObjects(v.into()),
        );
        self
    }

    /// The value of [large_objects_handling][crate::model::OracleSourceConfig::large_objects_handling]
    /// if it holds a `StreamLargeObjects`, `None` if the field is not set or
    /// holds a different branch.
    pub fn stream_large_objects(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::oracle_source_config::StreamLargeObjects>>
    {
        #[allow(unreachable_patterns)]
        self.large_objects_handling.as_ref().and_then(|v| match v {
            crate::model::oracle_source_config::LargeObjectsHandling::StreamLargeObjects(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [large_objects_handling][crate::model::OracleSourceConfig::large_objects_handling]
    /// to hold a `StreamLargeObjects`.
    ///
    /// Note that all the setters affecting `large_objects_handling` are
    /// mutually exclusive.
    pub fn set_stream_large_objects<
        T: std::convert::Into<std::boxed::Box<crate::model::oracle_source_config::StreamLargeObjects>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.large_objects_handling = std::option::Option::Some(
            crate::model::oracle_source_config::LargeObjectsHandling::StreamLargeObjects(v.into()),
        );
        self
    }

    /// Sets the value of [cdc_method][crate::model::OracleSourceConfig::cdc_method].
    ///
    /// Note that all the setters affecting `cdc_method` are mutually
    /// exclusive.
    pub fn set_cdc_method<
        T: std::convert::Into<std::option::Option<crate::model::oracle_source_config::CdcMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = v.into();
        self
    }

    /// The value of [cdc_method][crate::model::OracleSourceConfig::cdc_method]
    /// if it holds a `LogMiner`, `None` if the field is not set or
    /// holds a different branch.
    pub fn log_miner(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::oracle_source_config::LogMiner>> {
        #[allow(unreachable_patterns)]
        self.cdc_method.as_ref().and_then(|v| match v {
            crate::model::oracle_source_config::CdcMethod::LogMiner(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdc_method][crate::model::OracleSourceConfig::cdc_method]
    /// to hold a `LogMiner`.
    ///
    /// Note that all the setters affecting `cdc_method` are
    /// mutually exclusive.
    pub fn set_log_miner<
        T: std::convert::Into<std::boxed::Box<crate::model::oracle_source_config::LogMiner>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = std::option::Option::Some(
            crate::model::oracle_source_config::CdcMethod::LogMiner(v.into()),
        );
        self
    }

    /// The value of [cdc_method][crate::model::OracleSourceConfig::cdc_method]
    /// if it holds a `BinaryLogParser`, `None` if the field is not set or
    /// holds a different branch.
    pub fn binary_log_parser(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::oracle_source_config::BinaryLogParser>>
    {
        #[allow(unreachable_patterns)]
        self.cdc_method.as_ref().and_then(|v| match v {
            crate::model::oracle_source_config::CdcMethod::BinaryLogParser(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdc_method][crate::model::OracleSourceConfig::cdc_method]
    /// to hold a `BinaryLogParser`.
    ///
    /// Note that all the setters affecting `cdc_method` are
    /// mutually exclusive.
    pub fn set_binary_log_parser<
        T: std::convert::Into<std::boxed::Box<crate::model::oracle_source_config::BinaryLogParser>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = std::option::Option::Some(
            crate::model::oracle_source_config::CdcMethod::BinaryLogParser(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OracleSourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OracleSourceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __include_objects,
            __exclude_objects,
            __max_concurrent_cdc_tasks,
            __max_concurrent_backfill_tasks,
            __drop_large_objects,
            __stream_large_objects,
            __log_miner,
            __binary_log_parser,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OracleSourceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includeObjects" => Ok(__FieldTag::__include_objects),
                            "include_objects" => Ok(__FieldTag::__include_objects),
                            "excludeObjects" => Ok(__FieldTag::__exclude_objects),
                            "exclude_objects" => Ok(__FieldTag::__exclude_objects),
                            "maxConcurrentCdcTasks" => Ok(__FieldTag::__max_concurrent_cdc_tasks),
                            "max_concurrent_cdc_tasks" => {
                                Ok(__FieldTag::__max_concurrent_cdc_tasks)
                            }
                            "maxConcurrentBackfillTasks" => {
                                Ok(__FieldTag::__max_concurrent_backfill_tasks)
                            }
                            "max_concurrent_backfill_tasks" => {
                                Ok(__FieldTag::__max_concurrent_backfill_tasks)
                            }
                            "dropLargeObjects" => Ok(__FieldTag::__drop_large_objects),
                            "drop_large_objects" => Ok(__FieldTag::__drop_large_objects),
                            "streamLargeObjects" => Ok(__FieldTag::__stream_large_objects),
                            "stream_large_objects" => Ok(__FieldTag::__stream_large_objects),
                            "logMiner" => Ok(__FieldTag::__log_miner),
                            "log_miner" => Ok(__FieldTag::__log_miner),
                            "binaryLogParser" => Ok(__FieldTag::__binary_log_parser),
                            "binary_log_parser" => Ok(__FieldTag::__binary_log_parser),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OracleSourceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OracleSourceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__include_objects => {
                            if !fields.insert(__FieldTag::__include_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_objects",
                                ));
                            }
                            result.include_objects =
                                map.next_value::<std::option::Option<crate::model::OracleRdbms>>()?;
                        }
                        __FieldTag::__exclude_objects => {
                            if !fields.insert(__FieldTag::__exclude_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_objects",
                                ));
                            }
                            result.exclude_objects =
                                map.next_value::<std::option::Option<crate::model::OracleRdbms>>()?;
                        }
                        __FieldTag::__max_concurrent_cdc_tasks => {
                            if !fields.insert(__FieldTag::__max_concurrent_cdc_tasks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_concurrent_cdc_tasks",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_concurrent_cdc_tasks =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_concurrent_backfill_tasks => {
                            if !fields.insert(__FieldTag::__max_concurrent_backfill_tasks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_concurrent_backfill_tasks",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_concurrent_backfill_tasks =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__drop_large_objects => {
                            if !fields.insert(__FieldTag::__drop_large_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for drop_large_objects",
                                ));
                            }
                            if result.large_objects_handling.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `large_objects_handling`, a oneof with full ID .google.cloud.datastream.v1.OracleSourceConfig.drop_large_objects, latest field was dropLargeObjects",
                                ));
                            }
                            result.large_objects_handling = std::option::Option::Some(
                                crate::model::oracle_source_config::LargeObjectsHandling::DropLargeObjects(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::oracle_source_config::DropLargeObjects>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__stream_large_objects => {
                            if !fields.insert(__FieldTag::__stream_large_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_large_objects",
                                ));
                            }
                            if result.large_objects_handling.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `large_objects_handling`, a oneof with full ID .google.cloud.datastream.v1.OracleSourceConfig.stream_large_objects, latest field was streamLargeObjects",
                                ));
                            }
                            result.large_objects_handling = std::option::Option::Some(
                                crate::model::oracle_source_config::LargeObjectsHandling::StreamLargeObjects(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::oracle_source_config::StreamLargeObjects>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__log_miner => {
                            if !fields.insert(__FieldTag::__log_miner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_miner",
                                ));
                            }
                            if result.cdc_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cdc_method`, a oneof with full ID .google.cloud.datastream.v1.OracleSourceConfig.log_miner, latest field was logMiner",
                                ));
                            }
                            result.cdc_method = std::option::Option::Some(
                                crate::model::oracle_source_config::CdcMethod::LogMiner(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::oracle_source_config::LogMiner,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__binary_log_parser => {
                            if !fields.insert(__FieldTag::__binary_log_parser) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binary_log_parser",
                                ));
                            }
                            if result.cdc_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cdc_method`, a oneof with full ID .google.cloud.datastream.v1.OracleSourceConfig.binary_log_parser, latest field was binaryLogParser",
                                ));
                            }
                            result.cdc_method = std::option::Option::Some(
                                crate::model::oracle_source_config::CdcMethod::BinaryLogParser(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::oracle_source_config::BinaryLogParser,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OracleSourceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.include_objects.is_some() {
            state.serialize_entry("includeObjects", &self.include_objects)?;
        }
        if self.exclude_objects.is_some() {
            state.serialize_entry("excludeObjects", &self.exclude_objects)?;
        }
        if !wkt::internal::is_default(&self.max_concurrent_cdc_tasks) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxConcurrentCdcTasks",
                &__With(&self.max_concurrent_cdc_tasks),
            )?;
        }
        if !wkt::internal::is_default(&self.max_concurrent_backfill_tasks) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxConcurrentBackfillTasks",
                &__With(&self.max_concurrent_backfill_tasks),
            )?;
        }
        if let Some(value) = self.drop_large_objects() {
            state.serialize_entry("dropLargeObjects", value)?;
        }
        if let Some(value) = self.stream_large_objects() {
            state.serialize_entry("streamLargeObjects", value)?;
        }
        if let Some(value) = self.log_miner() {
            state.serialize_entry("logMiner", value)?;
        }
        if let Some(value) = self.binary_log_parser() {
            state.serialize_entry("binaryLogParser", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OracleSourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OracleSourceConfig");
        debug_struct.field("include_objects", &self.include_objects);
        debug_struct.field("exclude_objects", &self.exclude_objects);
        debug_struct.field("max_concurrent_cdc_tasks", &self.max_concurrent_cdc_tasks);
        debug_struct.field(
            "max_concurrent_backfill_tasks",
            &self.max_concurrent_backfill_tasks,
        );
        debug_struct.field("large_objects_handling", &self.large_objects_handling);
        debug_struct.field("cdc_method", &self.cdc_method);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OracleSourceConfig].
pub mod oracle_source_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration to drop large object values.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DropLargeObjects {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DropLargeObjects {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for DropLargeObjects {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig.DropLargeObjects"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DropLargeObjects {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DropLargeObjects")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DropLargeObjects;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DropLargeObjects")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DropLargeObjects {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DropLargeObjects {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DropLargeObjects");
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Configuration to stream large object values.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StreamLargeObjects {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StreamLargeObjects {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for StreamLargeObjects {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig.StreamLargeObjects"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StreamLargeObjects {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StreamLargeObjects")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StreamLargeObjects;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StreamLargeObjects")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StreamLargeObjects {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for StreamLargeObjects {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("StreamLargeObjects");
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Configuration to use LogMiner CDC method.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LogMiner {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LogMiner {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for LogMiner {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig.LogMiner"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LogMiner {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LogMiner")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LogMiner;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LogMiner")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LogMiner {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for LogMiner {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("LogMiner");
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Configuration to use Binary Log Parser CDC technique.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BinaryLogParser {
        /// Configuration to specify how the log file should be accessed.
        pub log_file_access: std::option::Option<
            crate::model::oracle_source_config::binary_log_parser::LogFileAccess,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BinaryLogParser {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [log_file_access][crate::model::oracle_source_config::BinaryLogParser::log_file_access].
        ///
        /// Note that all the setters affecting `log_file_access` are mutually
        /// exclusive.
        pub fn set_log_file_access<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::oracle_source_config::binary_log_parser::LogFileAccess,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.log_file_access = v.into();
            self
        }

        /// The value of [log_file_access][crate::model::oracle_source_config::BinaryLogParser::log_file_access]
        /// if it holds a `OracleAsmLogFileAccess`, `None` if the field is not set or
        /// holds a different branch.
        pub fn oracle_asm_log_file_access(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::oracle_source_config::binary_log_parser::OracleAsmLogFileAccess,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.log_file_access.as_ref().and_then(|v| match v {
                crate::model::oracle_source_config::binary_log_parser::LogFileAccess::OracleAsmLogFileAccess(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [log_file_access][crate::model::oracle_source_config::BinaryLogParser::log_file_access]
        /// to hold a `OracleAsmLogFileAccess`.
        ///
        /// Note that all the setters affecting `log_file_access` are
        /// mutually exclusive.
        pub fn set_oracle_asm_log_file_access<T: std::convert::Into<std::boxed::Box<crate::model::oracle_source_config::binary_log_parser::OracleAsmLogFileAccess>>>(mut self, v: T) -> Self{
            self.log_file_access = std::option::Option::Some(
                crate::model::oracle_source_config::binary_log_parser::LogFileAccess::OracleAsmLogFileAccess(
                    v.into()
                )
            );
            self
        }

        /// The value of [log_file_access][crate::model::oracle_source_config::BinaryLogParser::log_file_access]
        /// if it holds a `LogFileDirectories`, `None` if the field is not set or
        /// holds a different branch.
        pub fn log_file_directories(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::oracle_source_config::binary_log_parser::LogFileDirectories,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.log_file_access.as_ref().and_then(|v| match v {
                crate::model::oracle_source_config::binary_log_parser::LogFileAccess::LogFileDirectories(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [log_file_access][crate::model::oracle_source_config::BinaryLogParser::log_file_access]
        /// to hold a `LogFileDirectories`.
        ///
        /// Note that all the setters affecting `log_file_access` are
        /// mutually exclusive.
        pub fn set_log_file_directories<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::oracle_source_config::binary_log_parser::LogFileDirectories,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.log_file_access = std::option::Option::Some(
                crate::model::oracle_source_config::binary_log_parser::LogFileAccess::LogFileDirectories(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for BinaryLogParser {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig.BinaryLogParser"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BinaryLogParser {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __oracle_asm_log_file_access,
                __log_file_directories,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BinaryLogParser")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "oracleAsmLogFileAccess" => {
                                    Ok(__FieldTag::__oracle_asm_log_file_access)
                                }
                                "oracle_asm_log_file_access" => {
                                    Ok(__FieldTag::__oracle_asm_log_file_access)
                                }
                                "logFileDirectories" => Ok(__FieldTag::__log_file_directories),
                                "log_file_directories" => Ok(__FieldTag::__log_file_directories),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BinaryLogParser;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BinaryLogParser")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__oracle_asm_log_file_access => {
                                if !fields.insert(__FieldTag::__oracle_asm_log_file_access) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for oracle_asm_log_file_access",
                                    ));
                                }
                                if result.log_file_access.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `log_file_access`, a oneof with full ID .google.cloud.datastream.v1.OracleSourceConfig.BinaryLogParser.oracle_asm_log_file_access, latest field was oracleAsmLogFileAccess",
                                    ));
                                }
                                result.log_file_access = std::option::Option::Some(
                                    crate::model::oracle_source_config::binary_log_parser::LogFileAccess::OracleAsmLogFileAccess(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::oracle_source_config::binary_log_parser::OracleAsmLogFileAccess>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__log_file_directories => {
                                if !fields.insert(__FieldTag::__log_file_directories) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for log_file_directories",
                                    ));
                                }
                                if result.log_file_access.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `log_file_access`, a oneof with full ID .google.cloud.datastream.v1.OracleSourceConfig.BinaryLogParser.log_file_directories, latest field was logFileDirectories",
                                    ));
                                }
                                result.log_file_access = std::option::Option::Some(
                                    crate::model::oracle_source_config::binary_log_parser::LogFileAccess::LogFileDirectories(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::oracle_source_config::binary_log_parser::LogFileDirectories>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BinaryLogParser {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.oracle_asm_log_file_access() {
                state.serialize_entry("oracleAsmLogFileAccess", value)?;
            }
            if let Some(value) = self.log_file_directories() {
                state.serialize_entry("logFileDirectories", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BinaryLogParser {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BinaryLogParser");
            debug_struct.field("log_file_access", &self.log_file_access);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [BinaryLogParser].
    pub mod binary_log_parser {
        #[allow(unused_imports)]
        use super::*;

        /// Configuration to use Oracle ASM to access the log files.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct OracleAsmLogFileAccess {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl OracleAsmLogFileAccess {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for OracleAsmLogFileAccess {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig.BinaryLogParser.OracleAsmLogFileAccess"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for OracleAsmLogFileAccess {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for OracleAsmLogFileAccess")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = OracleAsmLogFileAccess;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct OracleAsmLogFileAccess")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for OracleAsmLogFileAccess {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for OracleAsmLogFileAccess {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("OracleAsmLogFileAccess");
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Configuration to specify the Oracle directories to access the log files.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct LogFileDirectories {
            /// Required. Oracle directory for online logs.
            pub online_log_directory: std::string::String,

            /// Required. Oracle directory for archived logs.
            pub archived_log_directory: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl LogFileDirectories {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [online_log_directory][crate::model::oracle_source_config::binary_log_parser::LogFileDirectories::online_log_directory].
            pub fn set_online_log_directory<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.online_log_directory = v.into();
                self
            }

            /// Sets the value of [archived_log_directory][crate::model::oracle_source_config::binary_log_parser::LogFileDirectories::archived_log_directory].
            pub fn set_archived_log_directory<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.archived_log_directory = v.into();
                self
            }
        }

        impl wkt::message::Message for LogFileDirectories {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.datastream.v1.OracleSourceConfig.BinaryLogParser.LogFileDirectories"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for LogFileDirectories {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __online_log_directory,
                    __archived_log_directory,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for LogFileDirectories")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "onlineLogDirectory" => Ok(__FieldTag::__online_log_directory),
                                    "online_log_directory" => {
                                        Ok(__FieldTag::__online_log_directory)
                                    }
                                    "archivedLogDirectory" => {
                                        Ok(__FieldTag::__archived_log_directory)
                                    }
                                    "archived_log_directory" => {
                                        Ok(__FieldTag::__archived_log_directory)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = LogFileDirectories;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct LogFileDirectories")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__online_log_directory => {
                                    if !fields.insert(__FieldTag::__online_log_directory) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for online_log_directory",
                                            ),
                                        );
                                    }
                                    result.online_log_directory = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__archived_log_directory => {
                                    if !fields.insert(__FieldTag::__archived_log_directory) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for archived_log_directory",
                                            ),
                                        );
                                    }
                                    result.archived_log_directory = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for LogFileDirectories {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.online_log_directory.is_empty() {
                    state.serialize_entry("onlineLogDirectory", &self.online_log_directory)?;
                }
                if !self.archived_log_directory.is_empty() {
                    state.serialize_entry("archivedLogDirectory", &self.archived_log_directory)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for LogFileDirectories {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("LogFileDirectories");
                debug_struct.field("online_log_directory", &self.online_log_directory);
                debug_struct.field("archived_log_directory", &self.archived_log_directory);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Configuration to specify how the log file should be accessed.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum LogFileAccess {
            /// Use Oracle ASM.
            OracleAsmLogFileAccess(
                std::boxed::Box<
                    crate::model::oracle_source_config::binary_log_parser::OracleAsmLogFileAccess,
                >,
            ),
            /// Use Oracle directories.
            LogFileDirectories(
                std::boxed::Box<
                    crate::model::oracle_source_config::binary_log_parser::LogFileDirectories,
                >,
            ),
        }
    }

    /// The configuration for handle Oracle large objects.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LargeObjectsHandling {
        /// Drop large object values.
        DropLargeObjects(std::boxed::Box<crate::model::oracle_source_config::DropLargeObjects>),
        /// Stream large object values.
        StreamLargeObjects(std::boxed::Box<crate::model::oracle_source_config::StreamLargeObjects>),
    }

    /// Configuration to select the CDC method.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CdcMethod {
        /// Use LogMiner.
        LogMiner(std::boxed::Box<crate::model::oracle_source_config::LogMiner>),
        /// Use Binary Log Parser.
        BinaryLogParser(std::boxed::Box<crate::model::oracle_source_config::BinaryLogParser>),
    }
}

/// PostgreSQL Column.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PostgresqlColumn {
    /// Column name.
    pub column: std::string::String,

    /// The PostgreSQL data type.
    pub data_type: std::string::String,

    /// Column length.
    pub length: i32,

    /// Column precision.
    pub precision: i32,

    /// Column scale.
    pub scale: i32,

    /// Whether or not the column represents a primary key.
    pub primary_key: bool,

    /// Whether or not the column can accept a null value.
    pub nullable: bool,

    /// The ordinal position of the column in the table.
    pub ordinal_position: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::PostgresqlColumn::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::PostgresqlColumn::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [length][crate::model::PostgresqlColumn::length].
    pub fn set_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::PostgresqlColumn::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::PostgresqlColumn::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [primary_key][crate::model::PostgresqlColumn::primary_key].
    pub fn set_primary_key<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.primary_key = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::PostgresqlColumn::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::PostgresqlColumn::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }
}

impl wkt::message::Message for PostgresqlColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlColumn"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostgresqlColumn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __column,
            __data_type,
            __length,
            __precision,
            __scale,
            __primary_key,
            __nullable,
            __ordinal_position,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostgresqlColumn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "column" => Ok(__FieldTag::__column),
                            "dataType" => Ok(__FieldTag::__data_type),
                            "data_type" => Ok(__FieldTag::__data_type),
                            "length" => Ok(__FieldTag::__length),
                            "precision" => Ok(__FieldTag::__precision),
                            "scale" => Ok(__FieldTag::__scale),
                            "primaryKey" => Ok(__FieldTag::__primary_key),
                            "primary_key" => Ok(__FieldTag::__primary_key),
                            "nullable" => Ok(__FieldTag::__nullable),
                            "ordinalPosition" => Ok(__FieldTag::__ordinal_position),
                            "ordinal_position" => Ok(__FieldTag::__ordinal_position),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostgresqlColumn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostgresqlColumn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__column => {
                            if !fields.insert(__FieldTag::__column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column",
                                ));
                            }
                            result.column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_type => {
                            if !fields.insert(__FieldTag::__data_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_type",
                                ));
                            }
                            result.data_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__length => {
                            if !fields.insert(__FieldTag::__length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for length",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.length = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__precision => {
                            if !fields.insert(__FieldTag::__precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for precision",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.precision = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scale => {
                            if !fields.insert(__FieldTag::__scale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scale = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__primary_key => {
                            if !fields.insert(__FieldTag::__primary_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_key",
                                ));
                            }
                            result.primary_key = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nullable => {
                            if !fields.insert(__FieldTag::__nullable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nullable",
                                ));
                            }
                            result.nullable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ordinal_position => {
                            if !fields.insert(__FieldTag::__ordinal_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ordinal_position",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ordinal_position =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostgresqlColumn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.column.is_empty() {
            state.serialize_entry("column", &self.column)?;
        }
        if !self.data_type.is_empty() {
            state.serialize_entry("dataType", &self.data_type)?;
        }
        if !wkt::internal::is_default(&self.length) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("length", &__With(&self.length))?;
        }
        if !wkt::internal::is_default(&self.precision) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("precision", &__With(&self.precision))?;
        }
        if !wkt::internal::is_default(&self.scale) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scale", &__With(&self.scale))?;
        }
        if !wkt::internal::is_default(&self.primary_key) {
            state.serialize_entry("primaryKey", &self.primary_key)?;
        }
        if !wkt::internal::is_default(&self.nullable) {
            state.serialize_entry("nullable", &self.nullable)?;
        }
        if !wkt::internal::is_default(&self.ordinal_position) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ordinalPosition", &__With(&self.ordinal_position))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PostgresqlColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostgresqlColumn");
        debug_struct.field("column", &self.column);
        debug_struct.field("data_type", &self.data_type);
        debug_struct.field("length", &self.length);
        debug_struct.field("precision", &self.precision);
        debug_struct.field("scale", &self.scale);
        debug_struct.field("primary_key", &self.primary_key);
        debug_struct.field("nullable", &self.nullable);
        debug_struct.field("ordinal_position", &self.ordinal_position);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// PostgreSQL table.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PostgresqlTable {
    /// Table name.
    pub table: std::string::String,

    /// PostgreSQL columns in the schema.
    /// When unspecified as part of include/exclude objects,
    /// includes/excludes everything.
    pub postgresql_columns: std::vec::Vec<crate::model::PostgresqlColumn>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::PostgresqlTable::table].
    pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [postgresql_columns][crate::model::PostgresqlTable::postgresql_columns].
    pub fn set_postgresql_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PostgresqlColumn>,
    {
        use std::iter::Iterator;
        self.postgresql_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PostgresqlTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlTable"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostgresqlTable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table,
            __postgresql_columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostgresqlTable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "table" => Ok(__FieldTag::__table),
                            "postgresqlColumns" => Ok(__FieldTag::__postgresql_columns),
                            "postgresql_columns" => Ok(__FieldTag::__postgresql_columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostgresqlTable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostgresqlTable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__postgresql_columns => {
                            if !fields.insert(__FieldTag::__postgresql_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postgresql_columns",
                                ));
                            }
                            result.postgresql_columns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PostgresqlColumn>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostgresqlTable {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.table.is_empty() {
            state.serialize_entry("table", &self.table)?;
        }
        if !self.postgresql_columns.is_empty() {
            state.serialize_entry("postgresqlColumns", &self.postgresql_columns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PostgresqlTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostgresqlTable");
        debug_struct.field("table", &self.table);
        debug_struct.field("postgresql_columns", &self.postgresql_columns);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// PostgreSQL schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PostgresqlSchema {
    /// Schema name.
    pub schema: std::string::String,

    /// Tables in the schema.
    pub postgresql_tables: std::vec::Vec<crate::model::PostgresqlTable>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema][crate::model::PostgresqlSchema::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [postgresql_tables][crate::model::PostgresqlSchema::postgresql_tables].
    pub fn set_postgresql_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PostgresqlTable>,
    {
        use std::iter::Iterator;
        self.postgresql_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PostgresqlSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlSchema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostgresqlSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schema,
            __postgresql_tables,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostgresqlSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schema" => Ok(__FieldTag::__schema),
                            "postgresqlTables" => Ok(__FieldTag::__postgresql_tables),
                            "postgresql_tables" => Ok(__FieldTag::__postgresql_tables),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostgresqlSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostgresqlSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__postgresql_tables => {
                            if !fields.insert(__FieldTag::__postgresql_tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postgresql_tables",
                                ));
                            }
                            result.postgresql_tables =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PostgresqlTable>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostgresqlSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.schema.is_empty() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self.postgresql_tables.is_empty() {
            state.serialize_entry("postgresqlTables", &self.postgresql_tables)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PostgresqlSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostgresqlSchema");
        debug_struct.field("schema", &self.schema);
        debug_struct.field("postgresql_tables", &self.postgresql_tables);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// PostgreSQL database structure.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PostgresqlRdbms {
    /// PostgreSQL schemas in the database server.
    pub postgresql_schemas: std::vec::Vec<crate::model::PostgresqlSchema>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlRdbms {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [postgresql_schemas][crate::model::PostgresqlRdbms::postgresql_schemas].
    pub fn set_postgresql_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PostgresqlSchema>,
    {
        use std::iter::Iterator;
        self.postgresql_schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PostgresqlRdbms {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlRdbms"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostgresqlRdbms {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __postgresql_schemas,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostgresqlRdbms")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "postgresqlSchemas" => Ok(__FieldTag::__postgresql_schemas),
                            "postgresql_schemas" => Ok(__FieldTag::__postgresql_schemas),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostgresqlRdbms;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostgresqlRdbms")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__postgresql_schemas => {
                            if !fields.insert(__FieldTag::__postgresql_schemas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postgresql_schemas",
                                ));
                            }
                            result.postgresql_schemas =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PostgresqlSchema>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostgresqlRdbms {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.postgresql_schemas.is_empty() {
            state.serialize_entry("postgresqlSchemas", &self.postgresql_schemas)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PostgresqlRdbms {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostgresqlRdbms");
        debug_struct.field("postgresql_schemas", &self.postgresql_schemas);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// PostgreSQL data source configuration
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PostgresqlSourceConfig {
    /// PostgreSQL objects to include in the stream.
    pub include_objects: std::option::Option<crate::model::PostgresqlRdbms>,

    /// PostgreSQL objects to exclude from the stream.
    pub exclude_objects: std::option::Option<crate::model::PostgresqlRdbms>,

    /// Required. Immutable. The name of the logical replication slot that's
    /// configured with the pgoutput plugin.
    pub replication_slot: std::string::String,

    /// Required. The name of the publication that includes the set of all tables
    /// that are defined in the stream's include_objects.
    pub publication: std::string::String,

    /// Maximum number of concurrent backfill tasks. The number should be non
    /// negative. If not set (or set to 0), the system's default value will be
    /// used.
    pub max_concurrent_backfill_tasks: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlSourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_objects][crate::model::PostgresqlSourceConfig::include_objects].
    pub fn set_include_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PostgresqlRdbms>,
    {
        self.include_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [include_objects][crate::model::PostgresqlSourceConfig::include_objects].
    pub fn set_or_clear_include_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PostgresqlRdbms>,
    {
        self.include_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exclude_objects][crate::model::PostgresqlSourceConfig::exclude_objects].
    pub fn set_exclude_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PostgresqlRdbms>,
    {
        self.exclude_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclude_objects][crate::model::PostgresqlSourceConfig::exclude_objects].
    pub fn set_or_clear_exclude_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PostgresqlRdbms>,
    {
        self.exclude_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replication_slot][crate::model::PostgresqlSourceConfig::replication_slot].
    pub fn set_replication_slot<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.replication_slot = v.into();
        self
    }

    /// Sets the value of [publication][crate::model::PostgresqlSourceConfig::publication].
    pub fn set_publication<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.publication = v.into();
        self
    }

    /// Sets the value of [max_concurrent_backfill_tasks][crate::model::PostgresqlSourceConfig::max_concurrent_backfill_tasks].
    pub fn set_max_concurrent_backfill_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_backfill_tasks = v.into();
        self
    }
}

impl wkt::message::Message for PostgresqlSourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.PostgresqlSourceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostgresqlSourceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __include_objects,
            __exclude_objects,
            __replication_slot,
            __publication,
            __max_concurrent_backfill_tasks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostgresqlSourceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includeObjects" => Ok(__FieldTag::__include_objects),
                            "include_objects" => Ok(__FieldTag::__include_objects),
                            "excludeObjects" => Ok(__FieldTag::__exclude_objects),
                            "exclude_objects" => Ok(__FieldTag::__exclude_objects),
                            "replicationSlot" => Ok(__FieldTag::__replication_slot),
                            "replication_slot" => Ok(__FieldTag::__replication_slot),
                            "publication" => Ok(__FieldTag::__publication),
                            "maxConcurrentBackfillTasks" => {
                                Ok(__FieldTag::__max_concurrent_backfill_tasks)
                            }
                            "max_concurrent_backfill_tasks" => {
                                Ok(__FieldTag::__max_concurrent_backfill_tasks)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostgresqlSourceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostgresqlSourceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__include_objects => {
                            if !fields.insert(__FieldTag::__include_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_objects",
                                ));
                            }
                            result.include_objects = map
                                .next_value::<std::option::Option<crate::model::PostgresqlRdbms>>(
                                )?;
                        }
                        __FieldTag::__exclude_objects => {
                            if !fields.insert(__FieldTag::__exclude_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_objects",
                                ));
                            }
                            result.exclude_objects = map
                                .next_value::<std::option::Option<crate::model::PostgresqlRdbms>>(
                                )?;
                        }
                        __FieldTag::__replication_slot => {
                            if !fields.insert(__FieldTag::__replication_slot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_slot",
                                ));
                            }
                            result.replication_slot = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__publication => {
                            if !fields.insert(__FieldTag::__publication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publication",
                                ));
                            }
                            result.publication = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_concurrent_backfill_tasks => {
                            if !fields.insert(__FieldTag::__max_concurrent_backfill_tasks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_concurrent_backfill_tasks",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_concurrent_backfill_tasks =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostgresqlSourceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.include_objects.is_some() {
            state.serialize_entry("includeObjects", &self.include_objects)?;
        }
        if self.exclude_objects.is_some() {
            state.serialize_entry("excludeObjects", &self.exclude_objects)?;
        }
        if !self.replication_slot.is_empty() {
            state.serialize_entry("replicationSlot", &self.replication_slot)?;
        }
        if !self.publication.is_empty() {
            state.serialize_entry("publication", &self.publication)?;
        }
        if !wkt::internal::is_default(&self.max_concurrent_backfill_tasks) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxConcurrentBackfillTasks",
                &__With(&self.max_concurrent_backfill_tasks),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PostgresqlSourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostgresqlSourceConfig");
        debug_struct.field("include_objects", &self.include_objects);
        debug_struct.field("exclude_objects", &self.exclude_objects);
        debug_struct.field("replication_slot", &self.replication_slot);
        debug_struct.field("publication", &self.publication);
        debug_struct.field(
            "max_concurrent_backfill_tasks",
            &self.max_concurrent_backfill_tasks,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SQLServer Column.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlServerColumn {
    /// Column name.
    pub column: std::string::String,

    /// The SQLServer data type.
    pub data_type: std::string::String,

    /// Column length.
    pub length: i32,

    /// Column precision.
    pub precision: i32,

    /// Column scale.
    pub scale: i32,

    /// Whether or not the column represents a primary key.
    pub primary_key: bool,

    /// Whether or not the column can accept a null value.
    pub nullable: bool,

    /// The ordinal position of the column in the table.
    pub ordinal_position: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::SqlServerColumn::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::SqlServerColumn::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [length][crate::model::SqlServerColumn::length].
    pub fn set_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::SqlServerColumn::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::SqlServerColumn::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [primary_key][crate::model::SqlServerColumn::primary_key].
    pub fn set_primary_key<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.primary_key = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::SqlServerColumn::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::SqlServerColumn::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }
}

impl wkt::message::Message for SqlServerColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerColumn"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlServerColumn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __column,
            __data_type,
            __length,
            __precision,
            __scale,
            __primary_key,
            __nullable,
            __ordinal_position,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlServerColumn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "column" => Ok(__FieldTag::__column),
                            "dataType" => Ok(__FieldTag::__data_type),
                            "data_type" => Ok(__FieldTag::__data_type),
                            "length" => Ok(__FieldTag::__length),
                            "precision" => Ok(__FieldTag::__precision),
                            "scale" => Ok(__FieldTag::__scale),
                            "primaryKey" => Ok(__FieldTag::__primary_key),
                            "primary_key" => Ok(__FieldTag::__primary_key),
                            "nullable" => Ok(__FieldTag::__nullable),
                            "ordinalPosition" => Ok(__FieldTag::__ordinal_position),
                            "ordinal_position" => Ok(__FieldTag::__ordinal_position),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlServerColumn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlServerColumn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__column => {
                            if !fields.insert(__FieldTag::__column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column",
                                ));
                            }
                            result.column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_type => {
                            if !fields.insert(__FieldTag::__data_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_type",
                                ));
                            }
                            result.data_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__length => {
                            if !fields.insert(__FieldTag::__length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for length",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.length = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__precision => {
                            if !fields.insert(__FieldTag::__precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for precision",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.precision = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scale => {
                            if !fields.insert(__FieldTag::__scale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scale = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__primary_key => {
                            if !fields.insert(__FieldTag::__primary_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_key",
                                ));
                            }
                            result.primary_key = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nullable => {
                            if !fields.insert(__FieldTag::__nullable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nullable",
                                ));
                            }
                            result.nullable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ordinal_position => {
                            if !fields.insert(__FieldTag::__ordinal_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ordinal_position",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ordinal_position =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlServerColumn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.column.is_empty() {
            state.serialize_entry("column", &self.column)?;
        }
        if !self.data_type.is_empty() {
            state.serialize_entry("dataType", &self.data_type)?;
        }
        if !wkt::internal::is_default(&self.length) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("length", &__With(&self.length))?;
        }
        if !wkt::internal::is_default(&self.precision) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("precision", &__With(&self.precision))?;
        }
        if !wkt::internal::is_default(&self.scale) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scale", &__With(&self.scale))?;
        }
        if !wkt::internal::is_default(&self.primary_key) {
            state.serialize_entry("primaryKey", &self.primary_key)?;
        }
        if !wkt::internal::is_default(&self.nullable) {
            state.serialize_entry("nullable", &self.nullable)?;
        }
        if !wkt::internal::is_default(&self.ordinal_position) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ordinalPosition", &__With(&self.ordinal_position))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SqlServerColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlServerColumn");
        debug_struct.field("column", &self.column);
        debug_struct.field("data_type", &self.data_type);
        debug_struct.field("length", &self.length);
        debug_struct.field("precision", &self.precision);
        debug_struct.field("scale", &self.scale);
        debug_struct.field("primary_key", &self.primary_key);
        debug_struct.field("nullable", &self.nullable);
        debug_struct.field("ordinal_position", &self.ordinal_position);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SQLServer table.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlServerTable {
    /// Table name.
    pub table: std::string::String,

    /// SQLServer columns in the schema.
    /// When unspecified as part of include/exclude objects,
    /// includes/excludes everything.
    pub columns: std::vec::Vec<crate::model::SqlServerColumn>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::SqlServerTable::table].
    pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [columns][crate::model::SqlServerTable::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlServerColumn>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlServerTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerTable"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlServerTable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table,
            __columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlServerTable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "table" => Ok(__FieldTag::__table),
                            "columns" => Ok(__FieldTag::__columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlServerTable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlServerTable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SqlServerColumn>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlServerTable {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.table.is_empty() {
            state.serialize_entry("table", &self.table)?;
        }
        if !self.columns.is_empty() {
            state.serialize_entry("columns", &self.columns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SqlServerTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlServerTable");
        debug_struct.field("table", &self.table);
        debug_struct.field("columns", &self.columns);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SQLServer schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlServerSchema {
    /// Schema name.
    pub schema: std::string::String,

    /// Tables in the schema.
    pub tables: std::vec::Vec<crate::model::SqlServerTable>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema][crate::model::SqlServerSchema::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [tables][crate::model::SqlServerSchema::tables].
    pub fn set_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlServerTable>,
    {
        use std::iter::Iterator;
        self.tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlServerSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerSchema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlServerSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schema,
            __tables,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlServerSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schema" => Ok(__FieldTag::__schema),
                            "tables" => Ok(__FieldTag::__tables),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlServerSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlServerSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tables => {
                            if !fields.insert(__FieldTag::__tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tables",
                                ));
                            }
                            result.tables =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SqlServerTable>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlServerSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.schema.is_empty() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self.tables.is_empty() {
            state.serialize_entry("tables", &self.tables)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SqlServerSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlServerSchema");
        debug_struct.field("schema", &self.schema);
        debug_struct.field("tables", &self.tables);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SQLServer database structure.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlServerRdbms {
    /// SQLServer schemas in the database server.
    pub schemas: std::vec::Vec<crate::model::SqlServerSchema>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerRdbms {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schemas][crate::model::SqlServerRdbms::schemas].
    pub fn set_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlServerSchema>,
    {
        use std::iter::Iterator;
        self.schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlServerRdbms {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerRdbms"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlServerRdbms {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schemas,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlServerRdbms")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schemas" => Ok(__FieldTag::__schemas),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlServerRdbms;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlServerRdbms")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schemas => {
                            if !fields.insert(__FieldTag::__schemas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schemas",
                                ));
                            }
                            result.schemas =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SqlServerSchema>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlServerRdbms {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.schemas.is_empty() {
            state.serialize_entry("schemas", &self.schemas)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SqlServerRdbms {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlServerRdbms");
        debug_struct.field("schemas", &self.schemas);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SQLServer data source configuration
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlServerSourceConfig {
    /// SQLServer objects to include in the stream.
    pub include_objects: std::option::Option<crate::model::SqlServerRdbms>,

    /// SQLServer objects to exclude from the stream.
    pub exclude_objects: std::option::Option<crate::model::SqlServerRdbms>,

    /// Max concurrent CDC tasks.
    pub max_concurrent_cdc_tasks: i32,

    /// Max concurrent backfill tasks.
    pub max_concurrent_backfill_tasks: i32,

    /// Configuration to select the CDC read method for the stream.
    pub cdc_method: std::option::Option<crate::model::sql_server_source_config::CdcMethod>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerSourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_objects][crate::model::SqlServerSourceConfig::include_objects].
    pub fn set_include_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SqlServerRdbms>,
    {
        self.include_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [include_objects][crate::model::SqlServerSourceConfig::include_objects].
    pub fn set_or_clear_include_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SqlServerRdbms>,
    {
        self.include_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exclude_objects][crate::model::SqlServerSourceConfig::exclude_objects].
    pub fn set_exclude_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SqlServerRdbms>,
    {
        self.exclude_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclude_objects][crate::model::SqlServerSourceConfig::exclude_objects].
    pub fn set_or_clear_exclude_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SqlServerRdbms>,
    {
        self.exclude_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_concurrent_cdc_tasks][crate::model::SqlServerSourceConfig::max_concurrent_cdc_tasks].
    pub fn set_max_concurrent_cdc_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_cdc_tasks = v.into();
        self
    }

    /// Sets the value of [max_concurrent_backfill_tasks][crate::model::SqlServerSourceConfig::max_concurrent_backfill_tasks].
    pub fn set_max_concurrent_backfill_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_backfill_tasks = v.into();
        self
    }

    /// Sets the value of [cdc_method][crate::model::SqlServerSourceConfig::cdc_method].
    ///
    /// Note that all the setters affecting `cdc_method` are mutually
    /// exclusive.
    pub fn set_cdc_method<
        T: std::convert::Into<std::option::Option<crate::model::sql_server_source_config::CdcMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = v.into();
        self
    }

    /// The value of [cdc_method][crate::model::SqlServerSourceConfig::cdc_method]
    /// if it holds a `TransactionLogs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn transaction_logs(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerTransactionLogs>> {
        #[allow(unreachable_patterns)]
        self.cdc_method.as_ref().and_then(|v| match v {
            crate::model::sql_server_source_config::CdcMethod::TransactionLogs(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdc_method][crate::model::SqlServerSourceConfig::cdc_method]
    /// to hold a `TransactionLogs`.
    ///
    /// Note that all the setters affecting `cdc_method` are
    /// mutually exclusive.
    pub fn set_transaction_logs<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerTransactionLogs>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = std::option::Option::Some(
            crate::model::sql_server_source_config::CdcMethod::TransactionLogs(v.into()),
        );
        self
    }

    /// The value of [cdc_method][crate::model::SqlServerSourceConfig::cdc_method]
    /// if it holds a `ChangeTables`, `None` if the field is not set or
    /// holds a different branch.
    pub fn change_tables(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerChangeTables>> {
        #[allow(unreachable_patterns)]
        self.cdc_method.as_ref().and_then(|v| match v {
            crate::model::sql_server_source_config::CdcMethod::ChangeTables(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdc_method][crate::model::SqlServerSourceConfig::cdc_method]
    /// to hold a `ChangeTables`.
    ///
    /// Note that all the setters affecting `cdc_method` are
    /// mutually exclusive.
    pub fn set_change_tables<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerChangeTables>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = std::option::Option::Some(
            crate::model::sql_server_source_config::CdcMethod::ChangeTables(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SqlServerSourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerSourceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlServerSourceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __include_objects,
            __exclude_objects,
            __max_concurrent_cdc_tasks,
            __max_concurrent_backfill_tasks,
            __transaction_logs,
            __change_tables,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlServerSourceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includeObjects" => Ok(__FieldTag::__include_objects),
                            "include_objects" => Ok(__FieldTag::__include_objects),
                            "excludeObjects" => Ok(__FieldTag::__exclude_objects),
                            "exclude_objects" => Ok(__FieldTag::__exclude_objects),
                            "maxConcurrentCdcTasks" => Ok(__FieldTag::__max_concurrent_cdc_tasks),
                            "max_concurrent_cdc_tasks" => {
                                Ok(__FieldTag::__max_concurrent_cdc_tasks)
                            }
                            "maxConcurrentBackfillTasks" => {
                                Ok(__FieldTag::__max_concurrent_backfill_tasks)
                            }
                            "max_concurrent_backfill_tasks" => {
                                Ok(__FieldTag::__max_concurrent_backfill_tasks)
                            }
                            "transactionLogs" => Ok(__FieldTag::__transaction_logs),
                            "transaction_logs" => Ok(__FieldTag::__transaction_logs),
                            "changeTables" => Ok(__FieldTag::__change_tables),
                            "change_tables" => Ok(__FieldTag::__change_tables),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlServerSourceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlServerSourceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__include_objects => {
                            if !fields.insert(__FieldTag::__include_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_objects",
                                ));
                            }
                            result.include_objects = map
                                .next_value::<std::option::Option<crate::model::SqlServerRdbms>>(
                                )?;
                        }
                        __FieldTag::__exclude_objects => {
                            if !fields.insert(__FieldTag::__exclude_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_objects",
                                ));
                            }
                            result.exclude_objects = map
                                .next_value::<std::option::Option<crate::model::SqlServerRdbms>>(
                                )?;
                        }
                        __FieldTag::__max_concurrent_cdc_tasks => {
                            if !fields.insert(__FieldTag::__max_concurrent_cdc_tasks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_concurrent_cdc_tasks",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_concurrent_cdc_tasks =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_concurrent_backfill_tasks => {
                            if !fields.insert(__FieldTag::__max_concurrent_backfill_tasks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_concurrent_backfill_tasks",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_concurrent_backfill_tasks =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__transaction_logs => {
                            if !fields.insert(__FieldTag::__transaction_logs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction_logs",
                                ));
                            }
                            if result.cdc_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cdc_method`, a oneof with full ID .google.cloud.datastream.v1.SqlServerSourceConfig.transaction_logs, latest field was transactionLogs",
                                ));
                            }
                            result.cdc_method = std::option::Option::Some(
                                crate::model::sql_server_source_config::CdcMethod::TransactionLogs(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SqlServerTransactionLogs>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__change_tables => {
                            if !fields.insert(__FieldTag::__change_tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for change_tables",
                                ));
                            }
                            if result.cdc_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cdc_method`, a oneof with full ID .google.cloud.datastream.v1.SqlServerSourceConfig.change_tables, latest field was changeTables",
                                ));
                            }
                            result.cdc_method = std::option::Option::Some(
                                crate::model::sql_server_source_config::CdcMethod::ChangeTables(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SqlServerChangeTables>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlServerSourceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.include_objects.is_some() {
            state.serialize_entry("includeObjects", &self.include_objects)?;
        }
        if self.exclude_objects.is_some() {
            state.serialize_entry("excludeObjects", &self.exclude_objects)?;
        }
        if !wkt::internal::is_default(&self.max_concurrent_cdc_tasks) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxConcurrentCdcTasks",
                &__With(&self.max_concurrent_cdc_tasks),
            )?;
        }
        if !wkt::internal::is_default(&self.max_concurrent_backfill_tasks) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxConcurrentBackfillTasks",
                &__With(&self.max_concurrent_backfill_tasks),
            )?;
        }
        if let Some(value) = self.transaction_logs() {
            state.serialize_entry("transactionLogs", value)?;
        }
        if let Some(value) = self.change_tables() {
            state.serialize_entry("changeTables", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SqlServerSourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlServerSourceConfig");
        debug_struct.field("include_objects", &self.include_objects);
        debug_struct.field("exclude_objects", &self.exclude_objects);
        debug_struct.field("max_concurrent_cdc_tasks", &self.max_concurrent_cdc_tasks);
        debug_struct.field(
            "max_concurrent_backfill_tasks",
            &self.max_concurrent_backfill_tasks,
        );
        debug_struct.field("cdc_method", &self.cdc_method);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SqlServerSourceConfig].
pub mod sql_server_source_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration to select the CDC read method for the stream.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CdcMethod {
        /// CDC reader reads from transaction logs.
        TransactionLogs(std::boxed::Box<crate::model::SqlServerTransactionLogs>),
        /// CDC reader reads from change tables.
        ChangeTables(std::boxed::Box<crate::model::SqlServerChangeTables>),
    }
}

/// Configuration to use Transaction Logs CDC read method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlServerTransactionLogs {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerTransactionLogs {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SqlServerTransactionLogs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerTransactionLogs"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlServerTransactionLogs {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlServerTransactionLogs")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlServerTransactionLogs;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlServerTransactionLogs")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlServerTransactionLogs {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SqlServerTransactionLogs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlServerTransactionLogs");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration to use Change Tables CDC read method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlServerChangeTables {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerChangeTables {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SqlServerChangeTables {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerChangeTables"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlServerChangeTables {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlServerChangeTables")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlServerChangeTables;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlServerChangeTables")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlServerChangeTables {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SqlServerChangeTables {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlServerChangeTables");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MySQL Column.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MysqlColumn {
    /// Column name.
    pub column: std::string::String,

    /// The MySQL data type. Full data types list can be found here:
    /// <https://dev.mysql.com/doc/refman/8.0/en/data-types.html>
    pub data_type: std::string::String,

    /// Column length.
    pub length: i32,

    /// Column collation.
    pub collation: std::string::String,

    /// Whether or not the column represents a primary key.
    pub primary_key: bool,

    /// Whether or not the column can accept a null value.
    pub nullable: bool,

    /// The ordinal position of the column in the table.
    pub ordinal_position: i32,

    /// Column precision.
    pub precision: i32,

    /// Column scale.
    pub scale: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::MysqlColumn::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::MysqlColumn::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [length][crate::model::MysqlColumn::length].
    pub fn set_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::MysqlColumn::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [primary_key][crate::model::MysqlColumn::primary_key].
    pub fn set_primary_key<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.primary_key = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::MysqlColumn::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::MysqlColumn::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::MysqlColumn::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::MysqlColumn::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }
}

impl wkt::message::Message for MysqlColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlColumn"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MysqlColumn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __column,
            __data_type,
            __length,
            __collation,
            __primary_key,
            __nullable,
            __ordinal_position,
            __precision,
            __scale,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MysqlColumn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "column" => Ok(__FieldTag::__column),
                            "dataType" => Ok(__FieldTag::__data_type),
                            "data_type" => Ok(__FieldTag::__data_type),
                            "length" => Ok(__FieldTag::__length),
                            "collation" => Ok(__FieldTag::__collation),
                            "primaryKey" => Ok(__FieldTag::__primary_key),
                            "primary_key" => Ok(__FieldTag::__primary_key),
                            "nullable" => Ok(__FieldTag::__nullable),
                            "ordinalPosition" => Ok(__FieldTag::__ordinal_position),
                            "ordinal_position" => Ok(__FieldTag::__ordinal_position),
                            "precision" => Ok(__FieldTag::__precision),
                            "scale" => Ok(__FieldTag::__scale),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MysqlColumn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MysqlColumn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__column => {
                            if !fields.insert(__FieldTag::__column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column",
                                ));
                            }
                            result.column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_type => {
                            if !fields.insert(__FieldTag::__data_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_type",
                                ));
                            }
                            result.data_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__length => {
                            if !fields.insert(__FieldTag::__length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for length",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.length = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__collation => {
                            if !fields.insert(__FieldTag::__collation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collation",
                                ));
                            }
                            result.collation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__primary_key => {
                            if !fields.insert(__FieldTag::__primary_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_key",
                                ));
                            }
                            result.primary_key = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nullable => {
                            if !fields.insert(__FieldTag::__nullable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nullable",
                                ));
                            }
                            result.nullable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ordinal_position => {
                            if !fields.insert(__FieldTag::__ordinal_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ordinal_position",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ordinal_position =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__precision => {
                            if !fields.insert(__FieldTag::__precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for precision",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.precision = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scale => {
                            if !fields.insert(__FieldTag::__scale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scale = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MysqlColumn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.column.is_empty() {
            state.serialize_entry("column", &self.column)?;
        }
        if !self.data_type.is_empty() {
            state.serialize_entry("dataType", &self.data_type)?;
        }
        if !wkt::internal::is_default(&self.length) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("length", &__With(&self.length))?;
        }
        if !self.collation.is_empty() {
            state.serialize_entry("collation", &self.collation)?;
        }
        if !wkt::internal::is_default(&self.primary_key) {
            state.serialize_entry("primaryKey", &self.primary_key)?;
        }
        if !wkt::internal::is_default(&self.nullable) {
            state.serialize_entry("nullable", &self.nullable)?;
        }
        if !wkt::internal::is_default(&self.ordinal_position) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ordinalPosition", &__With(&self.ordinal_position))?;
        }
        if !wkt::internal::is_default(&self.precision) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("precision", &__With(&self.precision))?;
        }
        if !wkt::internal::is_default(&self.scale) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scale", &__With(&self.scale))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MysqlColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MysqlColumn");
        debug_struct.field("column", &self.column);
        debug_struct.field("data_type", &self.data_type);
        debug_struct.field("length", &self.length);
        debug_struct.field("collation", &self.collation);
        debug_struct.field("primary_key", &self.primary_key);
        debug_struct.field("nullable", &self.nullable);
        debug_struct.field("ordinal_position", &self.ordinal_position);
        debug_struct.field("precision", &self.precision);
        debug_struct.field("scale", &self.scale);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MySQL table.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MysqlTable {
    /// Table name.
    pub table: std::string::String,

    /// MySQL columns in the database.
    /// When unspecified as part of include/exclude objects, includes/excludes
    /// everything.
    pub mysql_columns: std::vec::Vec<crate::model::MysqlColumn>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::MysqlTable::table].
    pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [mysql_columns][crate::model::MysqlTable::mysql_columns].
    pub fn set_mysql_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MysqlColumn>,
    {
        use std::iter::Iterator;
        self.mysql_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MysqlTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlTable"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MysqlTable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table,
            __mysql_columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MysqlTable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "table" => Ok(__FieldTag::__table),
                            "mysqlColumns" => Ok(__FieldTag::__mysql_columns),
                            "mysql_columns" => Ok(__FieldTag::__mysql_columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MysqlTable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MysqlTable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mysql_columns => {
                            if !fields.insert(__FieldTag::__mysql_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql_columns",
                                ));
                            }
                            result.mysql_columns = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MysqlColumn>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MysqlTable {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.table.is_empty() {
            state.serialize_entry("table", &self.table)?;
        }
        if !self.mysql_columns.is_empty() {
            state.serialize_entry("mysqlColumns", &self.mysql_columns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MysqlTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MysqlTable");
        debug_struct.field("table", &self.table);
        debug_struct.field("mysql_columns", &self.mysql_columns);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MySQL database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MysqlDatabase {
    /// Database name.
    pub database: std::string::String,

    /// Tables in the database.
    pub mysql_tables: std::vec::Vec<crate::model::MysqlTable>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlDatabase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::MysqlDatabase::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [mysql_tables][crate::model::MysqlDatabase::mysql_tables].
    pub fn set_mysql_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MysqlTable>,
    {
        use std::iter::Iterator;
        self.mysql_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MysqlDatabase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlDatabase"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MysqlDatabase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __mysql_tables,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MysqlDatabase")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "mysqlTables" => Ok(__FieldTag::__mysql_tables),
                            "mysql_tables" => Ok(__FieldTag::__mysql_tables),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MysqlDatabase;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MysqlDatabase")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mysql_tables => {
                            if !fields.insert(__FieldTag::__mysql_tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql_tables",
                                ));
                            }
                            result.mysql_tables = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MysqlTable>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MysqlDatabase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.mysql_tables.is_empty() {
            state.serialize_entry("mysqlTables", &self.mysql_tables)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MysqlDatabase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MysqlDatabase");
        debug_struct.field("database", &self.database);
        debug_struct.field("mysql_tables", &self.mysql_tables);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MySQL database structure
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MysqlRdbms {
    /// Mysql databases on the server
    pub mysql_databases: std::vec::Vec<crate::model::MysqlDatabase>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlRdbms {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mysql_databases][crate::model::MysqlRdbms::mysql_databases].
    pub fn set_mysql_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MysqlDatabase>,
    {
        use std::iter::Iterator;
        self.mysql_databases = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MysqlRdbms {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlRdbms"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MysqlRdbms {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mysql_databases,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MysqlRdbms")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mysqlDatabases" => Ok(__FieldTag::__mysql_databases),
                            "mysql_databases" => Ok(__FieldTag::__mysql_databases),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MysqlRdbms;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MysqlRdbms")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mysql_databases => {
                            if !fields.insert(__FieldTag::__mysql_databases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql_databases",
                                ));
                            }
                            result.mysql_databases = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MysqlDatabase>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MysqlRdbms {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mysql_databases.is_empty() {
            state.serialize_entry("mysqlDatabases", &self.mysql_databases)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MysqlRdbms {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MysqlRdbms");
        debug_struct.field("mysql_databases", &self.mysql_databases);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MySQL source configuration
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MysqlSourceConfig {
    /// MySQL objects to retrieve from the source.
    pub include_objects: std::option::Option<crate::model::MysqlRdbms>,

    /// MySQL objects to exclude from the stream.
    pub exclude_objects: std::option::Option<crate::model::MysqlRdbms>,

    /// Maximum number of concurrent CDC tasks. The number should be non negative.
    /// If not set (or set to 0), the system's default value will be used.
    pub max_concurrent_cdc_tasks: i32,

    /// Maximum number of concurrent backfill tasks. The number should be non
    /// negative. If not set (or set to 0), the system's default value will be
    /// used.
    pub max_concurrent_backfill_tasks: i32,

    /// The CDC method to use for the stream.
    pub cdc_method: std::option::Option<crate::model::mysql_source_config::CdcMethod>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlSourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_objects][crate::model::MysqlSourceConfig::include_objects].
    pub fn set_include_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MysqlRdbms>,
    {
        self.include_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [include_objects][crate::model::MysqlSourceConfig::include_objects].
    pub fn set_or_clear_include_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MysqlRdbms>,
    {
        self.include_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exclude_objects][crate::model::MysqlSourceConfig::exclude_objects].
    pub fn set_exclude_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MysqlRdbms>,
    {
        self.exclude_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclude_objects][crate::model::MysqlSourceConfig::exclude_objects].
    pub fn set_or_clear_exclude_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MysqlRdbms>,
    {
        self.exclude_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_concurrent_cdc_tasks][crate::model::MysqlSourceConfig::max_concurrent_cdc_tasks].
    pub fn set_max_concurrent_cdc_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_cdc_tasks = v.into();
        self
    }

    /// Sets the value of [max_concurrent_backfill_tasks][crate::model::MysqlSourceConfig::max_concurrent_backfill_tasks].
    pub fn set_max_concurrent_backfill_tasks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_backfill_tasks = v.into();
        self
    }

    /// Sets the value of [cdc_method][crate::model::MysqlSourceConfig::cdc_method].
    ///
    /// Note that all the setters affecting `cdc_method` are mutually
    /// exclusive.
    pub fn set_cdc_method<
        T: std::convert::Into<std::option::Option<crate::model::mysql_source_config::CdcMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = v.into();
        self
    }

    /// The value of [cdc_method][crate::model::MysqlSourceConfig::cdc_method]
    /// if it holds a `BinaryLogPosition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn binary_log_position(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::mysql_source_config::BinaryLogPosition>>
    {
        #[allow(unreachable_patterns)]
        self.cdc_method.as_ref().and_then(|v| match v {
            crate::model::mysql_source_config::CdcMethod::BinaryLogPosition(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdc_method][crate::model::MysqlSourceConfig::cdc_method]
    /// to hold a `BinaryLogPosition`.
    ///
    /// Note that all the setters affecting `cdc_method` are
    /// mutually exclusive.
    pub fn set_binary_log_position<
        T: std::convert::Into<std::boxed::Box<crate::model::mysql_source_config::BinaryLogPosition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method = std::option::Option::Some(
            crate::model::mysql_source_config::CdcMethod::BinaryLogPosition(v.into()),
        );
        self
    }

    /// The value of [cdc_method][crate::model::MysqlSourceConfig::cdc_method]
    /// if it holds a `Gtid`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gtid(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::mysql_source_config::Gtid>> {
        #[allow(unreachable_patterns)]
        self.cdc_method.as_ref().and_then(|v| match v {
            crate::model::mysql_source_config::CdcMethod::Gtid(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdc_method][crate::model::MysqlSourceConfig::cdc_method]
    /// to hold a `Gtid`.
    ///
    /// Note that all the setters affecting `cdc_method` are
    /// mutually exclusive.
    pub fn set_gtid<
        T: std::convert::Into<std::boxed::Box<crate::model::mysql_source_config::Gtid>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdc_method =
            std::option::Option::Some(crate::model::mysql_source_config::CdcMethod::Gtid(v.into()));
        self
    }
}

impl wkt::message::Message for MysqlSourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlSourceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MysqlSourceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __include_objects,
            __exclude_objects,
            __max_concurrent_cdc_tasks,
            __max_concurrent_backfill_tasks,
            __binary_log_position,
            __gtid,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MysqlSourceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includeObjects" => Ok(__FieldTag::__include_objects),
                            "include_objects" => Ok(__FieldTag::__include_objects),
                            "excludeObjects" => Ok(__FieldTag::__exclude_objects),
                            "exclude_objects" => Ok(__FieldTag::__exclude_objects),
                            "maxConcurrentCdcTasks" => Ok(__FieldTag::__max_concurrent_cdc_tasks),
                            "max_concurrent_cdc_tasks" => {
                                Ok(__FieldTag::__max_concurrent_cdc_tasks)
                            }
                            "maxConcurrentBackfillTasks" => {
                                Ok(__FieldTag::__max_concurrent_backfill_tasks)
                            }
                            "max_concurrent_backfill_tasks" => {
                                Ok(__FieldTag::__max_concurrent_backfill_tasks)
                            }
                            "binaryLogPosition" => Ok(__FieldTag::__binary_log_position),
                            "binary_log_position" => Ok(__FieldTag::__binary_log_position),
                            "gtid" => Ok(__FieldTag::__gtid),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MysqlSourceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MysqlSourceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__include_objects => {
                            if !fields.insert(__FieldTag::__include_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_objects",
                                ));
                            }
                            result.include_objects =
                                map.next_value::<std::option::Option<crate::model::MysqlRdbms>>()?;
                        }
                        __FieldTag::__exclude_objects => {
                            if !fields.insert(__FieldTag::__exclude_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_objects",
                                ));
                            }
                            result.exclude_objects =
                                map.next_value::<std::option::Option<crate::model::MysqlRdbms>>()?;
                        }
                        __FieldTag::__max_concurrent_cdc_tasks => {
                            if !fields.insert(__FieldTag::__max_concurrent_cdc_tasks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_concurrent_cdc_tasks",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_concurrent_cdc_tasks =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_concurrent_backfill_tasks => {
                            if !fields.insert(__FieldTag::__max_concurrent_backfill_tasks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_concurrent_backfill_tasks",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_concurrent_backfill_tasks =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__binary_log_position => {
                            if !fields.insert(__FieldTag::__binary_log_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binary_log_position",
                                ));
                            }
                            if result.cdc_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cdc_method`, a oneof with full ID .google.cloud.datastream.v1.MysqlSourceConfig.binary_log_position, latest field was binaryLogPosition",
                                ));
                            }
                            result.cdc_method = std::option::Option::Some(
                                crate::model::mysql_source_config::CdcMethod::BinaryLogPosition(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::mysql_source_config::BinaryLogPosition,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gtid => {
                            if !fields.insert(__FieldTag::__gtid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gtid",
                                ));
                            }
                            if result.cdc_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cdc_method`, a oneof with full ID .google.cloud.datastream.v1.MysqlSourceConfig.gtid, latest field was gtid",
                                ));
                            }
                            result.cdc_method = std::option::Option::Some(
                                crate::model::mysql_source_config::CdcMethod::Gtid(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::mysql_source_config::Gtid>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MysqlSourceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.include_objects.is_some() {
            state.serialize_entry("includeObjects", &self.include_objects)?;
        }
        if self.exclude_objects.is_some() {
            state.serialize_entry("excludeObjects", &self.exclude_objects)?;
        }
        if !wkt::internal::is_default(&self.max_concurrent_cdc_tasks) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxConcurrentCdcTasks",
                &__With(&self.max_concurrent_cdc_tasks),
            )?;
        }
        if !wkt::internal::is_default(&self.max_concurrent_backfill_tasks) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxConcurrentBackfillTasks",
                &__With(&self.max_concurrent_backfill_tasks),
            )?;
        }
        if let Some(value) = self.binary_log_position() {
            state.serialize_entry("binaryLogPosition", value)?;
        }
        if let Some(value) = self.gtid() {
            state.serialize_entry("gtid", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MysqlSourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MysqlSourceConfig");
        debug_struct.field("include_objects", &self.include_objects);
        debug_struct.field("exclude_objects", &self.exclude_objects);
        debug_struct.field("max_concurrent_cdc_tasks", &self.max_concurrent_cdc_tasks);
        debug_struct.field(
            "max_concurrent_backfill_tasks",
            &self.max_concurrent_backfill_tasks,
        );
        debug_struct.field("cdc_method", &self.cdc_method);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MysqlSourceConfig].
pub mod mysql_source_config {
    #[allow(unused_imports)]
    use super::*;

    /// Use Binary log position based replication.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BinaryLogPosition {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BinaryLogPosition {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for BinaryLogPosition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.MysqlSourceConfig.BinaryLogPosition"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BinaryLogPosition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BinaryLogPosition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BinaryLogPosition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BinaryLogPosition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BinaryLogPosition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BinaryLogPosition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BinaryLogPosition");
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Use GTID based replication.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Gtid {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Gtid {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Gtid {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.MysqlSourceConfig.Gtid"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Gtid {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Gtid")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Gtid;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Gtid")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Gtid {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Gtid {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Gtid");
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The CDC method to use for the stream.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CdcMethod {
        /// Use Binary log position based replication.
        BinaryLogPosition(std::boxed::Box<crate::model::mysql_source_config::BinaryLogPosition>),
        /// Use GTID based replication.
        Gtid(std::boxed::Box<crate::model::mysql_source_config::Gtid>),
    }
}

/// Salesforce source configuration
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SalesforceSourceConfig {
    /// Salesforce objects to retrieve from the source.
    pub include_objects: std::option::Option<crate::model::SalesforceOrg>,

    /// Salesforce objects to exclude from the stream.
    pub exclude_objects: std::option::Option<crate::model::SalesforceOrg>,

    /// Required. Salesforce objects polling interval. The interval at which new
    /// changes will be polled for each object. The duration must be between 5
    /// minutes and 24 hours.
    pub polling_interval: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SalesforceSourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_objects][crate::model::SalesforceSourceConfig::include_objects].
    pub fn set_include_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SalesforceOrg>,
    {
        self.include_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [include_objects][crate::model::SalesforceSourceConfig::include_objects].
    pub fn set_or_clear_include_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SalesforceOrg>,
    {
        self.include_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exclude_objects][crate::model::SalesforceSourceConfig::exclude_objects].
    pub fn set_exclude_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SalesforceOrg>,
    {
        self.exclude_objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclude_objects][crate::model::SalesforceSourceConfig::exclude_objects].
    pub fn set_or_clear_exclude_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SalesforceOrg>,
    {
        self.exclude_objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [polling_interval][crate::model::SalesforceSourceConfig::polling_interval].
    pub fn set_polling_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.polling_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [polling_interval][crate::model::SalesforceSourceConfig::polling_interval].
    pub fn set_or_clear_polling_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.polling_interval = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SalesforceSourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SalesforceSourceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SalesforceSourceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __include_objects,
            __exclude_objects,
            __polling_interval,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SalesforceSourceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includeObjects" => Ok(__FieldTag::__include_objects),
                            "include_objects" => Ok(__FieldTag::__include_objects),
                            "excludeObjects" => Ok(__FieldTag::__exclude_objects),
                            "exclude_objects" => Ok(__FieldTag::__exclude_objects),
                            "pollingInterval" => Ok(__FieldTag::__polling_interval),
                            "polling_interval" => Ok(__FieldTag::__polling_interval),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SalesforceSourceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SalesforceSourceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__include_objects => {
                            if !fields.insert(__FieldTag::__include_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_objects",
                                ));
                            }
                            result.include_objects = map
                                .next_value::<std::option::Option<crate::model::SalesforceOrg>>()?;
                        }
                        __FieldTag::__exclude_objects => {
                            if !fields.insert(__FieldTag::__exclude_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_objects",
                                ));
                            }
                            result.exclude_objects = map
                                .next_value::<std::option::Option<crate::model::SalesforceOrg>>()?;
                        }
                        __FieldTag::__polling_interval => {
                            if !fields.insert(__FieldTag::__polling_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for polling_interval",
                                ));
                            }
                            result.polling_interval =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SalesforceSourceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.include_objects.is_some() {
            state.serialize_entry("includeObjects", &self.include_objects)?;
        }
        if self.exclude_objects.is_some() {
            state.serialize_entry("excludeObjects", &self.exclude_objects)?;
        }
        if self.polling_interval.is_some() {
            state.serialize_entry("pollingInterval", &self.polling_interval)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SalesforceSourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SalesforceSourceConfig");
        debug_struct.field("include_objects", &self.include_objects);
        debug_struct.field("exclude_objects", &self.exclude_objects);
        debug_struct.field("polling_interval", &self.polling_interval);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Salesforce organization structure.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SalesforceOrg {
    /// Salesforce objects in the database server.
    pub objects: std::vec::Vec<crate::model::SalesforceObject>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SalesforceOrg {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [objects][crate::model::SalesforceOrg::objects].
    pub fn set_objects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SalesforceObject>,
    {
        use std::iter::Iterator;
        self.objects = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SalesforceOrg {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SalesforceOrg"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SalesforceOrg {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __objects,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SalesforceOrg")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "objects" => Ok(__FieldTag::__objects),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SalesforceOrg;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SalesforceOrg")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__objects => {
                            if !fields.insert(__FieldTag::__objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects",
                                ));
                            }
                            result.objects =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SalesforceObject>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SalesforceOrg {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.objects.is_empty() {
            state.serialize_entry("objects", &self.objects)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SalesforceOrg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SalesforceOrg");
        debug_struct.field("objects", &self.objects);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Salesforce object.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SalesforceObject {
    /// Object name.
    pub object_name: std::string::String,

    /// Salesforce fields.
    /// When unspecified as part of include objects,
    /// includes everything, when unspecified as part of exclude objects,
    /// excludes nothing.
    pub fields: std::vec::Vec<crate::model::SalesforceField>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SalesforceObject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object_name][crate::model::SalesforceObject::object_name].
    pub fn set_object_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object_name = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::SalesforceObject::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SalesforceField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SalesforceObject {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SalesforceObject"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SalesforceObject {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __object_name,
            __fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SalesforceObject")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "objectName" => Ok(__FieldTag::__object_name),
                            "object_name" => Ok(__FieldTag::__object_name),
                            "fields" => Ok(__FieldTag::__fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SalesforceObject;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SalesforceObject")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__object_name => {
                            if !fields.insert(__FieldTag::__object_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_name",
                                ));
                            }
                            result.object_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SalesforceField>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SalesforceObject {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.object_name.is_empty() {
            state.serialize_entry("objectName", &self.object_name)?;
        }
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SalesforceObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SalesforceObject");
        debug_struct.field("object_name", &self.object_name);
        debug_struct.field("fields", &self.fields);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Salesforce field.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SalesforceField {
    /// Field name.
    pub name: std::string::String,

    /// The data type.
    pub data_type: std::string::String,

    /// Indicates whether the field can accept nil values.
    pub nillable: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SalesforceField {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SalesforceField::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::SalesforceField::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [nillable][crate::model::SalesforceField::nillable].
    pub fn set_nillable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nillable = v.into();
        self
    }
}

impl wkt::message::Message for SalesforceField {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SalesforceField"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SalesforceField {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __data_type,
            __nillable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SalesforceField")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "dataType" => Ok(__FieldTag::__data_type),
                            "data_type" => Ok(__FieldTag::__data_type),
                            "nillable" => Ok(__FieldTag::__nillable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SalesforceField;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SalesforceField")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_type => {
                            if !fields.insert(__FieldTag::__data_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_type",
                                ));
                            }
                            result.data_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nillable => {
                            if !fields.insert(__FieldTag::__nillable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nillable",
                                ));
                            }
                            result.nillable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SalesforceField {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.data_type.is_empty() {
            state.serialize_entry("dataType", &self.data_type)?;
        }
        if !wkt::internal::is_default(&self.nillable) {
            state.serialize_entry("nillable", &self.nillable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SalesforceField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SalesforceField");
        debug_struct.field("name", &self.name);
        debug_struct.field("data_type", &self.data_type);
        debug_struct.field("nillable", &self.nillable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The configuration of the stream source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceConfig {
    /// Required. Source connection profile resource.
    /// Format: `projects/{project}/locations/{location}/connectionProfiles/{name}`
    pub source_connection_profile: std::string::String,

    /// Stream configuration that is specific to the data source type.
    pub source_stream_config: std::option::Option<crate::model::source_config::SourceStreamConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_connection_profile][crate::model::SourceConfig::source_connection_profile].
    pub fn set_source_connection_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_connection_profile = v.into();
        self
    }

    /// Sets the value of [source_stream_config][crate::model::SourceConfig::source_stream_config].
    ///
    /// Note that all the setters affecting `source_stream_config` are mutually
    /// exclusive.
    pub fn set_source_stream_config<
        T: std::convert::Into<std::option::Option<crate::model::source_config::SourceStreamConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_stream_config = v.into();
        self
    }

    /// The value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// if it holds a `OracleSourceConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle_source_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OracleSourceConfig>> {
        #[allow(unreachable_patterns)]
        self.source_stream_config.as_ref().and_then(|v| match v {
            crate::model::source_config::SourceStreamConfig::OracleSourceConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// to hold a `OracleSourceConfig`.
    ///
    /// Note that all the setters affecting `source_stream_config` are
    /// mutually exclusive.
    pub fn set_oracle_source_config<
        T: std::convert::Into<std::boxed::Box<crate::model::OracleSourceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_stream_config = std::option::Option::Some(
            crate::model::source_config::SourceStreamConfig::OracleSourceConfig(v.into()),
        );
        self
    }

    /// The value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// if it holds a `MysqlSourceConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_source_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MysqlSourceConfig>> {
        #[allow(unreachable_patterns)]
        self.source_stream_config.as_ref().and_then(|v| match v {
            crate::model::source_config::SourceStreamConfig::MysqlSourceConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// to hold a `MysqlSourceConfig`.
    ///
    /// Note that all the setters affecting `source_stream_config` are
    /// mutually exclusive.
    pub fn set_mysql_source_config<
        T: std::convert::Into<std::boxed::Box<crate::model::MysqlSourceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_stream_config = std::option::Option::Some(
            crate::model::source_config::SourceStreamConfig::MysqlSourceConfig(v.into()),
        );
        self
    }

    /// The value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// if it holds a `PostgresqlSourceConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql_source_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostgresqlSourceConfig>> {
        #[allow(unreachable_patterns)]
        self.source_stream_config.as_ref().and_then(|v| match v {
            crate::model::source_config::SourceStreamConfig::PostgresqlSourceConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// to hold a `PostgresqlSourceConfig`.
    ///
    /// Note that all the setters affecting `source_stream_config` are
    /// mutually exclusive.
    pub fn set_postgresql_source_config<
        T: std::convert::Into<std::boxed::Box<crate::model::PostgresqlSourceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_stream_config = std::option::Option::Some(
            crate::model::source_config::SourceStreamConfig::PostgresqlSourceConfig(v.into()),
        );
        self
    }

    /// The value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// if it holds a `SqlServerSourceConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_server_source_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerSourceConfig>> {
        #[allow(unreachable_patterns)]
        self.source_stream_config.as_ref().and_then(|v| match v {
            crate::model::source_config::SourceStreamConfig::SqlServerSourceConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// to hold a `SqlServerSourceConfig`.
    ///
    /// Note that all the setters affecting `source_stream_config` are
    /// mutually exclusive.
    pub fn set_sql_server_source_config<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerSourceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_stream_config = std::option::Option::Some(
            crate::model::source_config::SourceStreamConfig::SqlServerSourceConfig(v.into()),
        );
        self
    }

    /// The value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// if it holds a `SalesforceSourceConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn salesforce_source_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SalesforceSourceConfig>> {
        #[allow(unreachable_patterns)]
        self.source_stream_config.as_ref().and_then(|v| match v {
            crate::model::source_config::SourceStreamConfig::SalesforceSourceConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_stream_config][crate::model::SourceConfig::source_stream_config]
    /// to hold a `SalesforceSourceConfig`.
    ///
    /// Note that all the setters affecting `source_stream_config` are
    /// mutually exclusive.
    pub fn set_salesforce_source_config<
        T: std::convert::Into<std::boxed::Box<crate::model::SalesforceSourceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_stream_config = std::option::Option::Some(
            crate::model::source_config::SourceStreamConfig::SalesforceSourceConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SourceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SourceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_connection_profile,
            __oracle_source_config,
            __mysql_source_config,
            __postgresql_source_config,
            __sql_server_source_config,
            __salesforce_source_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceConnectionProfile" => {
                                Ok(__FieldTag::__source_connection_profile)
                            }
                            "source_connection_profile" => {
                                Ok(__FieldTag::__source_connection_profile)
                            }
                            "oracleSourceConfig" => Ok(__FieldTag::__oracle_source_config),
                            "oracle_source_config" => Ok(__FieldTag::__oracle_source_config),
                            "mysqlSourceConfig" => Ok(__FieldTag::__mysql_source_config),
                            "mysql_source_config" => Ok(__FieldTag::__mysql_source_config),
                            "postgresqlSourceConfig" => Ok(__FieldTag::__postgresql_source_config),
                            "postgresql_source_config" => {
                                Ok(__FieldTag::__postgresql_source_config)
                            }
                            "sqlServerSourceConfig" => Ok(__FieldTag::__sql_server_source_config),
                            "sql_server_source_config" => {
                                Ok(__FieldTag::__sql_server_source_config)
                            }
                            "salesforceSourceConfig" => Ok(__FieldTag::__salesforce_source_config),
                            "salesforce_source_config" => {
                                Ok(__FieldTag::__salesforce_source_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SourceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_connection_profile => {
                            if !fields.insert(__FieldTag::__source_connection_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_connection_profile",
                                ));
                            }
                            result.source_connection_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oracle_source_config => {
                            if !fields.insert(__FieldTag::__oracle_source_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oracle_source_config",
                                ));
                            }
                            if result.source_stream_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_stream_config`, a oneof with full ID .google.cloud.datastream.v1.SourceConfig.oracle_source_config, latest field was oracleSourceConfig",
                                ));
                            }
                            result.source_stream_config = std::option::Option::Some(
                                crate::model::source_config::SourceStreamConfig::OracleSourceConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::OracleSourceConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__mysql_source_config => {
                            if !fields.insert(__FieldTag::__mysql_source_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql_source_config",
                                ));
                            }
                            if result.source_stream_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_stream_config`, a oneof with full ID .google.cloud.datastream.v1.SourceConfig.mysql_source_config, latest field was mysqlSourceConfig",
                                ));
                            }
                            result.source_stream_config = std::option::Option::Some(
                                crate::model::source_config::SourceStreamConfig::MysqlSourceConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MysqlSourceConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__postgresql_source_config => {
                            if !fields.insert(__FieldTag::__postgresql_source_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postgresql_source_config",
                                ));
                            }
                            if result.source_stream_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_stream_config`, a oneof with full ID .google.cloud.datastream.v1.SourceConfig.postgresql_source_config, latest field was postgresqlSourceConfig",
                                ));
                            }
                            result.source_stream_config = std::option::Option::Some(
                                crate::model::source_config::SourceStreamConfig::PostgresqlSourceConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::PostgresqlSourceConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__sql_server_source_config => {
                            if !fields.insert(__FieldTag::__sql_server_source_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_server_source_config",
                                ));
                            }
                            if result.source_stream_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_stream_config`, a oneof with full ID .google.cloud.datastream.v1.SourceConfig.sql_server_source_config, latest field was sqlServerSourceConfig",
                                ));
                            }
                            result.source_stream_config = std::option::Option::Some(
                                crate::model::source_config::SourceStreamConfig::SqlServerSourceConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SqlServerSourceConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__salesforce_source_config => {
                            if !fields.insert(__FieldTag::__salesforce_source_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for salesforce_source_config",
                                ));
                            }
                            if result.source_stream_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_stream_config`, a oneof with full ID .google.cloud.datastream.v1.SourceConfig.salesforce_source_config, latest field was salesforceSourceConfig",
                                ));
                            }
                            result.source_stream_config = std::option::Option::Some(
                                crate::model::source_config::SourceStreamConfig::SalesforceSourceConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SalesforceSourceConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SourceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_connection_profile.is_empty() {
            state.serialize_entry("sourceConnectionProfile", &self.source_connection_profile)?;
        }
        if let Some(value) = self.oracle_source_config() {
            state.serialize_entry("oracleSourceConfig", value)?;
        }
        if let Some(value) = self.mysql_source_config() {
            state.serialize_entry("mysqlSourceConfig", value)?;
        }
        if let Some(value) = self.postgresql_source_config() {
            state.serialize_entry("postgresqlSourceConfig", value)?;
        }
        if let Some(value) = self.sql_server_source_config() {
            state.serialize_entry("sqlServerSourceConfig", value)?;
        }
        if let Some(value) = self.salesforce_source_config() {
            state.serialize_entry("salesforceSourceConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceConfig");
        debug_struct.field("source_connection_profile", &self.source_connection_profile);
        debug_struct.field("source_stream_config", &self.source_stream_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SourceConfig].
pub mod source_config {
    #[allow(unused_imports)]
    use super::*;

    /// Stream configuration that is specific to the data source type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceStreamConfig {
        /// Oracle data source configuration.
        OracleSourceConfig(std::boxed::Box<crate::model::OracleSourceConfig>),
        /// MySQL data source configuration.
        MysqlSourceConfig(std::boxed::Box<crate::model::MysqlSourceConfig>),
        /// PostgreSQL data source configuration.
        PostgresqlSourceConfig(std::boxed::Box<crate::model::PostgresqlSourceConfig>),
        /// SQLServer data source configuration.
        SqlServerSourceConfig(std::boxed::Box<crate::model::SqlServerSourceConfig>),
        /// Salesforce data source configuration.
        SalesforceSourceConfig(std::boxed::Box<crate::model::SalesforceSourceConfig>),
    }
}

/// AVRO file format configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AvroFileFormat {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AvroFileFormat {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AvroFileFormat {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.AvroFileFormat"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AvroFileFormat {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AvroFileFormat")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AvroFileFormat;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AvroFileFormat")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AvroFileFormat {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AvroFileFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AvroFileFormat");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// JSON file format configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct JsonFileFormat {
    /// The schema file format along JSON data files.
    pub schema_file_format: crate::model::json_file_format::SchemaFileFormat,

    /// Compression of the loaded JSON file.
    pub compression: crate::model::json_file_format::JsonCompression,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JsonFileFormat {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema_file_format][crate::model::JsonFileFormat::schema_file_format].
    pub fn set_schema_file_format<
        T: std::convert::Into<crate::model::json_file_format::SchemaFileFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema_file_format = v.into();
        self
    }

    /// Sets the value of [compression][crate::model::JsonFileFormat::compression].
    pub fn set_compression<
        T: std::convert::Into<crate::model::json_file_format::JsonCompression>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compression = v.into();
        self
    }
}

impl wkt::message::Message for JsonFileFormat {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.JsonFileFormat"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JsonFileFormat {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schema_file_format,
            __compression,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JsonFileFormat")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schemaFileFormat" => Ok(__FieldTag::__schema_file_format),
                            "schema_file_format" => Ok(__FieldTag::__schema_file_format),
                            "compression" => Ok(__FieldTag::__compression),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JsonFileFormat;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JsonFileFormat")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schema_file_format => {
                            if !fields.insert(__FieldTag::__schema_file_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_file_format",
                                ));
                            }
                            result.schema_file_format = map
                                .next_value::<std::option::Option<
                                    crate::model::json_file_format::SchemaFileFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compression => {
                            if !fields.insert(__FieldTag::__compression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compression",
                                ));
                            }
                            result.compression = map
                                .next_value::<std::option::Option<
                                    crate::model::json_file_format::JsonCompression,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JsonFileFormat {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.schema_file_format) {
            state.serialize_entry("schemaFileFormat", &self.schema_file_format)?;
        }
        if !wkt::internal::is_default(&self.compression) {
            state.serialize_entry("compression", &self.compression)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for JsonFileFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JsonFileFormat");
        debug_struct.field("schema_file_format", &self.schema_file_format);
        debug_struct.field("compression", &self.compression);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [JsonFileFormat].
pub mod json_file_format {
    #[allow(unused_imports)]
    use super::*;

    /// Schema file format.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SchemaFileFormat {
        /// Unspecified schema file format.
        Unspecified,
        /// Do not attach schema file.
        NoSchemaFile,
        /// Avro schema format.
        AvroSchemaFile,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SchemaFileFormat::value] or
        /// [SchemaFileFormat::name].
        UnknownValue(schema_file_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod schema_file_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SchemaFileFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoSchemaFile => std::option::Option::Some(1),
                Self::AvroSchemaFile => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCHEMA_FILE_FORMAT_UNSPECIFIED"),
                Self::NoSchemaFile => std::option::Option::Some("NO_SCHEMA_FILE"),
                Self::AvroSchemaFile => std::option::Option::Some("AVRO_SCHEMA_FILE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SchemaFileFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SchemaFileFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SchemaFileFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoSchemaFile,
                2 => Self::AvroSchemaFile,
                _ => Self::UnknownValue(schema_file_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SchemaFileFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCHEMA_FILE_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "NO_SCHEMA_FILE" => Self::NoSchemaFile,
                "AVRO_SCHEMA_FILE" => Self::AvroSchemaFile,
                _ => Self::UnknownValue(schema_file_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SchemaFileFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoSchemaFile => serializer.serialize_i32(1),
                Self::AvroSchemaFile => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SchemaFileFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SchemaFileFormat>::new(
                ".google.cloud.datastream.v1.JsonFileFormat.SchemaFileFormat",
            ))
        }
    }

    /// Json file compression.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JsonCompression {
        /// Unspecified json file compression.
        Unspecified,
        /// Do not compress JSON file.
        NoCompression,
        /// Gzip compression.
        Gzip,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [JsonCompression::value] or
        /// [JsonCompression::name].
        UnknownValue(json_compression::UnknownValue),
    }

    #[doc(hidden)]
    pub mod json_compression {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl JsonCompression {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoCompression => std::option::Option::Some(1),
                Self::Gzip => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("JSON_COMPRESSION_UNSPECIFIED"),
                Self::NoCompression => std::option::Option::Some("NO_COMPRESSION"),
                Self::Gzip => std::option::Option::Some("GZIP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for JsonCompression {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for JsonCompression {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for JsonCompression {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoCompression,
                2 => Self::Gzip,
                _ => Self::UnknownValue(json_compression::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for JsonCompression {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "JSON_COMPRESSION_UNSPECIFIED" => Self::Unspecified,
                "NO_COMPRESSION" => Self::NoCompression,
                "GZIP" => Self::Gzip,
                _ => Self::UnknownValue(json_compression::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for JsonCompression {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoCompression => serializer.serialize_i32(1),
                Self::Gzip => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for JsonCompression {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<JsonCompression>::new(
                ".google.cloud.datastream.v1.JsonFileFormat.JsonCompression",
            ))
        }
    }
}

/// Google Cloud Storage destination configuration
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsDestinationConfig {
    /// Path inside the Cloud Storage bucket to write data to.
    pub path: std::string::String,

    /// The maximum file size to be saved in the bucket.
    pub file_rotation_mb: i32,

    /// The maximum duration for which new events are added before a file is
    /// closed and a new file is created. Values within the range of 15-60 seconds
    /// are allowed.
    pub file_rotation_interval: std::option::Option<wkt::Duration>,

    /// File Format that the data should be written in.
    pub file_format: std::option::Option<crate::model::gcs_destination_config::FileFormat>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsDestinationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::GcsDestinationConfig::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [file_rotation_mb][crate::model::GcsDestinationConfig::file_rotation_mb].
    pub fn set_file_rotation_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.file_rotation_mb = v.into();
        self
    }

    /// Sets the value of [file_rotation_interval][crate::model::GcsDestinationConfig::file_rotation_interval].
    pub fn set_file_rotation_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.file_rotation_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_rotation_interval][crate::model::GcsDestinationConfig::file_rotation_interval].
    pub fn set_or_clear_file_rotation_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.file_rotation_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [file_format][crate::model::GcsDestinationConfig::file_format].
    ///
    /// Note that all the setters affecting `file_format` are mutually
    /// exclusive.
    pub fn set_file_format<
        T: std::convert::Into<std::option::Option<crate::model::gcs_destination_config::FileFormat>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_format = v.into();
        self
    }

    /// The value of [file_format][crate::model::GcsDestinationConfig::file_format]
    /// if it holds a `AvroFileFormat`, `None` if the field is not set or
    /// holds a different branch.
    pub fn avro_file_format(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AvroFileFormat>> {
        #[allow(unreachable_patterns)]
        self.file_format.as_ref().and_then(|v| match v {
            crate::model::gcs_destination_config::FileFormat::AvroFileFormat(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [file_format][crate::model::GcsDestinationConfig::file_format]
    /// to hold a `AvroFileFormat`.
    ///
    /// Note that all the setters affecting `file_format` are
    /// mutually exclusive.
    pub fn set_avro_file_format<
        T: std::convert::Into<std::boxed::Box<crate::model::AvroFileFormat>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_format = std::option::Option::Some(
            crate::model::gcs_destination_config::FileFormat::AvroFileFormat(v.into()),
        );
        self
    }

    /// The value of [file_format][crate::model::GcsDestinationConfig::file_format]
    /// if it holds a `JsonFileFormat`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json_file_format(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::JsonFileFormat>> {
        #[allow(unreachable_patterns)]
        self.file_format.as_ref().and_then(|v| match v {
            crate::model::gcs_destination_config::FileFormat::JsonFileFormat(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [file_format][crate::model::GcsDestinationConfig::file_format]
    /// to hold a `JsonFileFormat`.
    ///
    /// Note that all the setters affecting `file_format` are
    /// mutually exclusive.
    pub fn set_json_file_format<
        T: std::convert::Into<std::boxed::Box<crate::model::JsonFileFormat>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_format = std::option::Option::Some(
            crate::model::gcs_destination_config::FileFormat::JsonFileFormat(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GcsDestinationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.GcsDestinationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsDestinationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            __file_rotation_mb,
            __file_rotation_interval,
            __avro_file_format,
            __json_file_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsDestinationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            "fileRotationMb" => Ok(__FieldTag::__file_rotation_mb),
                            "file_rotation_mb" => Ok(__FieldTag::__file_rotation_mb),
                            "fileRotationInterval" => Ok(__FieldTag::__file_rotation_interval),
                            "file_rotation_interval" => Ok(__FieldTag::__file_rotation_interval),
                            "avroFileFormat" => Ok(__FieldTag::__avro_file_format),
                            "avro_file_format" => Ok(__FieldTag::__avro_file_format),
                            "jsonFileFormat" => Ok(__FieldTag::__json_file_format),
                            "json_file_format" => Ok(__FieldTag::__json_file_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsDestinationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsDestinationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_rotation_mb => {
                            if !fields.insert(__FieldTag::__file_rotation_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_rotation_mb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.file_rotation_mb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__file_rotation_interval => {
                            if !fields.insert(__FieldTag::__file_rotation_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_rotation_interval",
                                ));
                            }
                            result.file_rotation_interval =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__avro_file_format => {
                            if !fields.insert(__FieldTag::__avro_file_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avro_file_format",
                                ));
                            }
                            if result.file_format.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `file_format`, a oneof with full ID .google.cloud.datastream.v1.GcsDestinationConfig.avro_file_format, latest field was avroFileFormat",
                                ));
                            }
                            result.file_format = std::option::Option::Some(
                                crate::model::gcs_destination_config::FileFormat::AvroFileFormat(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AvroFileFormat>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__json_file_format => {
                            if !fields.insert(__FieldTag::__json_file_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for json_file_format",
                                ));
                            }
                            if result.file_format.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `file_format`, a oneof with full ID .google.cloud.datastream.v1.GcsDestinationConfig.json_file_format, latest field was jsonFileFormat",
                                ));
                            }
                            result.file_format = std::option::Option::Some(
                                crate::model::gcs_destination_config::FileFormat::JsonFileFormat(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::JsonFileFormat>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsDestinationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !wkt::internal::is_default(&self.file_rotation_mb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fileRotationMb", &__With(&self.file_rotation_mb))?;
        }
        if self.file_rotation_interval.is_some() {
            state.serialize_entry("fileRotationInterval", &self.file_rotation_interval)?;
        }
        if let Some(value) = self.avro_file_format() {
            state.serialize_entry("avroFileFormat", value)?;
        }
        if let Some(value) = self.json_file_format() {
            state.serialize_entry("jsonFileFormat", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsDestinationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsDestinationConfig");
        debug_struct.field("path", &self.path);
        debug_struct.field("file_rotation_mb", &self.file_rotation_mb);
        debug_struct.field("file_rotation_interval", &self.file_rotation_interval);
        debug_struct.field("file_format", &self.file_format);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GcsDestinationConfig].
pub mod gcs_destination_config {
    #[allow(unused_imports)]
    use super::*;

    /// File Format that the data should be written in.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FileFormat {
        /// AVRO file format configuration.
        AvroFileFormat(std::boxed::Box<crate::model::AvroFileFormat>),
        /// JSON file format configuration.
        JsonFileFormat(std::boxed::Box<crate::model::JsonFileFormat>),
    }
}

/// BigQuery destination configuration
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryDestinationConfig {
    /// The guaranteed data freshness (in seconds) when querying tables created by
    /// the stream. Editing this field will only affect new tables created in the
    /// future, but existing tables will not be impacted. Lower values mean that
    /// queries will return fresher data, but may result in higher cost.
    pub data_freshness: std::option::Option<wkt::Duration>,

    /// Optional. Big Lake Managed Tables (BLMT) configuration.
    pub blmt_config: std::option::Option<crate::model::big_query_destination_config::BlmtConfig>,

    /// Target dataset(s) configuration.
    pub dataset_config:
        std::option::Option<crate::model::big_query_destination_config::DatasetConfig>,

    pub write_mode: std::option::Option<crate::model::big_query_destination_config::WriteMode>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryDestinationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_freshness][crate::model::BigQueryDestinationConfig::data_freshness].
    pub fn set_data_freshness<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.data_freshness = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_freshness][crate::model::BigQueryDestinationConfig::data_freshness].
    pub fn set_or_clear_data_freshness<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.data_freshness = v.map(|x| x.into());
        self
    }

    /// Sets the value of [blmt_config][crate::model::BigQueryDestinationConfig::blmt_config].
    pub fn set_blmt_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::big_query_destination_config::BlmtConfig>,
    {
        self.blmt_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [blmt_config][crate::model::BigQueryDestinationConfig::blmt_config].
    pub fn set_or_clear_blmt_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::big_query_destination_config::BlmtConfig>,
    {
        self.blmt_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dataset_config][crate::model::BigQueryDestinationConfig::dataset_config].
    ///
    /// Note that all the setters affecting `dataset_config` are mutually
    /// exclusive.
    pub fn set_dataset_config<
        T: std::convert::Into<
                std::option::Option<crate::model::big_query_destination_config::DatasetConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_config = v.into();
        self
    }

    /// The value of [dataset_config][crate::model::BigQueryDestinationConfig::dataset_config]
    /// if it holds a `SingleTargetDataset`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_target_dataset(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::big_query_destination_config::SingleTargetDataset>,
    > {
        #[allow(unreachable_patterns)]
        self.dataset_config.as_ref().and_then(|v| match v {
            crate::model::big_query_destination_config::DatasetConfig::SingleTargetDataset(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dataset_config][crate::model::BigQueryDestinationConfig::dataset_config]
    /// to hold a `SingleTargetDataset`.
    ///
    /// Note that all the setters affecting `dataset_config` are
    /// mutually exclusive.
    pub fn set_single_target_dataset<
        T: std::convert::Into<
                std::boxed::Box<crate::model::big_query_destination_config::SingleTargetDataset>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_config = std::option::Option::Some(
            crate::model::big_query_destination_config::DatasetConfig::SingleTargetDataset(
                v.into(),
            ),
        );
        self
    }

    /// The value of [dataset_config][crate::model::BigQueryDestinationConfig::dataset_config]
    /// if it holds a `SourceHierarchyDatasets`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_hierarchy_datasets(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::big_query_destination_config::SourceHierarchyDatasets>,
    > {
        #[allow(unreachable_patterns)]
        self.dataset_config.as_ref().and_then(|v| match v {
            crate::model::big_query_destination_config::DatasetConfig::SourceHierarchyDatasets(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dataset_config][crate::model::BigQueryDestinationConfig::dataset_config]
    /// to hold a `SourceHierarchyDatasets`.
    ///
    /// Note that all the setters affecting `dataset_config` are
    /// mutually exclusive.
    pub fn set_source_hierarchy_datasets<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::big_query_destination_config::SourceHierarchyDatasets,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_config = std::option::Option::Some(
            crate::model::big_query_destination_config::DatasetConfig::SourceHierarchyDatasets(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [write_mode][crate::model::BigQueryDestinationConfig::write_mode].
    ///
    /// Note that all the setters affecting `write_mode` are mutually
    /// exclusive.
    pub fn set_write_mode<
        T: std::convert::Into<
                std::option::Option<crate::model::big_query_destination_config::WriteMode>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_mode = v.into();
        self
    }

    /// The value of [write_mode][crate::model::BigQueryDestinationConfig::write_mode]
    /// if it holds a `Merge`, `None` if the field is not set or
    /// holds a different branch.
    pub fn merge(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::big_query_destination_config::Merge>>
    {
        #[allow(unreachable_patterns)]
        self.write_mode.as_ref().and_then(|v| match v {
            crate::model::big_query_destination_config::WriteMode::Merge(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [write_mode][crate::model::BigQueryDestinationConfig::write_mode]
    /// to hold a `Merge`.
    ///
    /// Note that all the setters affecting `write_mode` are
    /// mutually exclusive.
    pub fn set_merge<
        T: std::convert::Into<std::boxed::Box<crate::model::big_query_destination_config::Merge>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_mode = std::option::Option::Some(
            crate::model::big_query_destination_config::WriteMode::Merge(v.into()),
        );
        self
    }

    /// The value of [write_mode][crate::model::BigQueryDestinationConfig::write_mode]
    /// if it holds a `AppendOnly`, `None` if the field is not set or
    /// holds a different branch.
    pub fn append_only(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::big_query_destination_config::AppendOnly>>
    {
        #[allow(unreachable_patterns)]
        self.write_mode.as_ref().and_then(|v| match v {
            crate::model::big_query_destination_config::WriteMode::AppendOnly(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [write_mode][crate::model::BigQueryDestinationConfig::write_mode]
    /// to hold a `AppendOnly`.
    ///
    /// Note that all the setters affecting `write_mode` are
    /// mutually exclusive.
    pub fn set_append_only<
        T: std::convert::Into<std::boxed::Box<crate::model::big_query_destination_config::AppendOnly>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_mode = std::option::Option::Some(
            crate::model::big_query_destination_config::WriteMode::AppendOnly(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQueryDestinationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryDestinationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __single_target_dataset,
            __source_hierarchy_datasets,
            __data_freshness,
            __blmt_config,
            __merge,
            __append_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryDestinationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singleTargetDataset" => Ok(__FieldTag::__single_target_dataset),
                            "single_target_dataset" => Ok(__FieldTag::__single_target_dataset),
                            "sourceHierarchyDatasets" => {
                                Ok(__FieldTag::__source_hierarchy_datasets)
                            }
                            "source_hierarchy_datasets" => {
                                Ok(__FieldTag::__source_hierarchy_datasets)
                            }
                            "dataFreshness" => Ok(__FieldTag::__data_freshness),
                            "data_freshness" => Ok(__FieldTag::__data_freshness),
                            "blmtConfig" => Ok(__FieldTag::__blmt_config),
                            "blmt_config" => Ok(__FieldTag::__blmt_config),
                            "merge" => Ok(__FieldTag::__merge),
                            "appendOnly" => Ok(__FieldTag::__append_only),
                            "append_only" => Ok(__FieldTag::__append_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryDestinationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryDestinationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__single_target_dataset => {
                            if !fields.insert(__FieldTag::__single_target_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_target_dataset",
                                ));
                            }
                            if result.dataset_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dataset_config`, a oneof with full ID .google.cloud.datastream.v1.BigQueryDestinationConfig.single_target_dataset, latest field was singleTargetDataset",
                                ));
                            }
                            result.dataset_config = std::option::Option::Some(
                                crate::model::big_query_destination_config::DatasetConfig::SingleTargetDataset(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::big_query_destination_config::SingleTargetDataset>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__source_hierarchy_datasets => {
                            if !fields.insert(__FieldTag::__source_hierarchy_datasets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_hierarchy_datasets",
                                ));
                            }
                            if result.dataset_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dataset_config`, a oneof with full ID .google.cloud.datastream.v1.BigQueryDestinationConfig.source_hierarchy_datasets, latest field was sourceHierarchyDatasets",
                                ));
                            }
                            result.dataset_config = std::option::Option::Some(
                                crate::model::big_query_destination_config::DatasetConfig::SourceHierarchyDatasets(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::big_query_destination_config::SourceHierarchyDatasets>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__data_freshness => {
                            if !fields.insert(__FieldTag::__data_freshness) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_freshness",
                                ));
                            }
                            result.data_freshness =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__blmt_config => {
                            if !fields.insert(__FieldTag::__blmt_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blmt_config",
                                ));
                            }
                            result.blmt_config = map.next_value::<std::option::Option<
                                crate::model::big_query_destination_config::BlmtConfig,
                            >>()?;
                        }
                        __FieldTag::__merge => {
                            if !fields.insert(__FieldTag::__merge) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for merge",
                                ));
                            }
                            if result.write_mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `write_mode`, a oneof with full ID .google.cloud.datastream.v1.BigQueryDestinationConfig.merge, latest field was merge",
                                ));
                            }
                            result.write_mode = std::option::Option::Some(
                                crate::model::big_query_destination_config::WriteMode::Merge(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::big_query_destination_config::Merge,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__append_only => {
                            if !fields.insert(__FieldTag::__append_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for append_only",
                                ));
                            }
                            if result.write_mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `write_mode`, a oneof with full ID .google.cloud.datastream.v1.BigQueryDestinationConfig.append_only, latest field was appendOnly",
                                ));
                            }
                            result.write_mode = std::option::Option::Some(
                                crate::model::big_query_destination_config::WriteMode::AppendOnly(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::big_query_destination_config::AppendOnly,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryDestinationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.single_target_dataset() {
            state.serialize_entry("singleTargetDataset", value)?;
        }
        if let Some(value) = self.source_hierarchy_datasets() {
            state.serialize_entry("sourceHierarchyDatasets", value)?;
        }
        if self.data_freshness.is_some() {
            state.serialize_entry("dataFreshness", &self.data_freshness)?;
        }
        if self.blmt_config.is_some() {
            state.serialize_entry("blmtConfig", &self.blmt_config)?;
        }
        if let Some(value) = self.merge() {
            state.serialize_entry("merge", value)?;
        }
        if let Some(value) = self.append_only() {
            state.serialize_entry("appendOnly", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BigQueryDestinationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigQueryDestinationConfig");
        debug_struct.field("data_freshness", &self.data_freshness);
        debug_struct.field("blmt_config", &self.blmt_config);
        debug_struct.field("dataset_config", &self.dataset_config);
        debug_struct.field("write_mode", &self.write_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BigQueryDestinationConfig].
pub mod big_query_destination_config {
    #[allow(unused_imports)]
    use super::*;

    /// A single target dataset to which all data will be streamed.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SingleTargetDataset {
        /// The dataset ID of the target dataset.
        /// DatasetIds allowed characters:
        /// <https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets#datasetreference>.
        pub dataset_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SingleTargetDataset {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset_id][crate::model::big_query_destination_config::SingleTargetDataset::dataset_id].
        pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset_id = v.into();
            self
        }
    }

    impl wkt::message::Message for SingleTargetDataset {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig.SingleTargetDataset"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SingleTargetDataset {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dataset_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SingleTargetDataset")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "datasetId" => Ok(__FieldTag::__dataset_id),
                                "dataset_id" => Ok(__FieldTag::__dataset_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SingleTargetDataset;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SingleTargetDataset")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dataset_id => {
                                if !fields.insert(__FieldTag::__dataset_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataset_id",
                                    ));
                                }
                                result.dataset_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SingleTargetDataset {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dataset_id.is_empty() {
                state.serialize_entry("datasetId", &self.dataset_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SingleTargetDataset {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SingleTargetDataset");
            debug_struct.field("dataset_id", &self.dataset_id);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Destination datasets are created so that hierarchy of the destination data
    /// objects matches the source hierarchy.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SourceHierarchyDatasets {
        /// The dataset template to use for dynamic dataset creation.
        pub dataset_template: std::option::Option<
            crate::model::big_query_destination_config::source_hierarchy_datasets::DatasetTemplate,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SourceHierarchyDatasets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset_template][crate::model::big_query_destination_config::SourceHierarchyDatasets::dataset_template].
        pub fn set_dataset_template<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::big_query_destination_config::source_hierarchy_datasets::DatasetTemplate>
        {
            self.dataset_template = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [dataset_template][crate::model::big_query_destination_config::SourceHierarchyDatasets::dataset_template].
        pub fn set_or_clear_dataset_template<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::big_query_destination_config::source_hierarchy_datasets::DatasetTemplate>
        {
            self.dataset_template = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SourceHierarchyDatasets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig.SourceHierarchyDatasets"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SourceHierarchyDatasets {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dataset_template,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SourceHierarchyDatasets")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "datasetTemplate" => Ok(__FieldTag::__dataset_template),
                                "dataset_template" => Ok(__FieldTag::__dataset_template),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SourceHierarchyDatasets;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SourceHierarchyDatasets")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dataset_template => {
                                if !fields.insert(__FieldTag::__dataset_template) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataset_template",
                                    ));
                                }
                                result.dataset_template = map.next_value::<std::option::Option<crate::model::big_query_destination_config::source_hierarchy_datasets::DatasetTemplate>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SourceHierarchyDatasets {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.dataset_template.is_some() {
                state.serialize_entry("datasetTemplate", &self.dataset_template)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SourceHierarchyDatasets {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SourceHierarchyDatasets");
            debug_struct.field("dataset_template", &self.dataset_template);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [SourceHierarchyDatasets].
    pub mod source_hierarchy_datasets {
        #[allow(unused_imports)]
        use super::*;

        /// Dataset template used for dynamic dataset creation.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DatasetTemplate {
            /// Required. The geographic location where the dataset should reside. See
            /// <https://cloud.google.com/bigquery/docs/locations> for supported
            /// locations.
            pub location: std::string::String,

            /// If supplied, every created dataset will have its name prefixed by the
            /// provided value. The prefix and name will be separated by an underscore.
            /// i.e. \<prefix\>_<dataset_name>.
            pub dataset_id_prefix: std::string::String,

            /// Describes the Cloud KMS encryption key that will be used to
            /// protect destination BigQuery table. The BigQuery Service Account
            /// associated with your project requires access to this encryption key.
            /// i.e.
            /// projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{cryptoKey}.
            /// See <https://cloud.google.com/bigquery/docs/customer-managed-encryption>
            /// for more information.
            pub kms_key_name: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DatasetTemplate {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [location][crate::model::big_query_destination_config::source_hierarchy_datasets::DatasetTemplate::location].
            pub fn set_location<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.location = v.into();
                self
            }

            /// Sets the value of [dataset_id_prefix][crate::model::big_query_destination_config::source_hierarchy_datasets::DatasetTemplate::dataset_id_prefix].
            pub fn set_dataset_id_prefix<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.dataset_id_prefix = v.into();
                self
            }

            /// Sets the value of [kms_key_name][crate::model::big_query_destination_config::source_hierarchy_datasets::DatasetTemplate::kms_key_name].
            pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.kms_key_name = v.into();
                self
            }
        }

        impl wkt::message::Message for DatasetTemplate {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig.SourceHierarchyDatasets.DatasetTemplate"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DatasetTemplate {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __location,
                    __dataset_id_prefix,
                    __kms_key_name,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for DatasetTemplate")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "location" => Ok(__FieldTag::__location),
                                    "datasetIdPrefix" => Ok(__FieldTag::__dataset_id_prefix),
                                    "dataset_id_prefix" => Ok(__FieldTag::__dataset_id_prefix),
                                    "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                                    "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DatasetTemplate;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DatasetTemplate")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__location => {
                                    if !fields.insert(__FieldTag::__location) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for location",
                                            ),
                                        );
                                    }
                                    result.location = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__dataset_id_prefix => {
                                    if !fields.insert(__FieldTag::__dataset_id_prefix) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for dataset_id_prefix",
                                            ),
                                        );
                                    }
                                    result.dataset_id_prefix = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__kms_key_name => {
                                    if !fields.insert(__FieldTag::__kms_key_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for kms_key_name",
                                            ),
                                        );
                                    }
                                    result.kms_key_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for DatasetTemplate {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.location.is_empty() {
                    state.serialize_entry("location", &self.location)?;
                }
                if !self.dataset_id_prefix.is_empty() {
                    state.serialize_entry("datasetIdPrefix", &self.dataset_id_prefix)?;
                }
                if !self.kms_key_name.is_empty() {
                    state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for DatasetTemplate {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("DatasetTemplate");
                debug_struct.field("location", &self.location);
                debug_struct.field("dataset_id_prefix", &self.dataset_id_prefix);
                debug_struct.field("kms_key_name", &self.kms_key_name);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// The configuration for BLMT.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BlmtConfig {
        /// Required. The Cloud Storage bucket name.
        pub bucket: std::string::String,

        /// The root path inside the Cloud Storage bucket.
        pub root_path: std::string::String,

        /// Required. The bigquery connection.
        /// Format: `{project}.{location}.{name}`
        pub connection_name: std::string::String,

        /// Required. The file format.
        pub file_format: crate::model::big_query_destination_config::blmt_config::FileFormat,

        /// Required. The table format.
        pub table_format: crate::model::big_query_destination_config::blmt_config::TableFormat,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BlmtConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bucket][crate::model::big_query_destination_config::BlmtConfig::bucket].
        pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.bucket = v.into();
            self
        }

        /// Sets the value of [root_path][crate::model::big_query_destination_config::BlmtConfig::root_path].
        pub fn set_root_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.root_path = v.into();
            self
        }

        /// Sets the value of [connection_name][crate::model::big_query_destination_config::BlmtConfig::connection_name].
        pub fn set_connection_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.connection_name = v.into();
            self
        }

        /// Sets the value of [file_format][crate::model::big_query_destination_config::BlmtConfig::file_format].
        pub fn set_file_format<
            T: std::convert::Into<crate::model::big_query_destination_config::blmt_config::FileFormat>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.file_format = v.into();
            self
        }

        /// Sets the value of [table_format][crate::model::big_query_destination_config::BlmtConfig::table_format].
        pub fn set_table_format<
            T: std::convert::Into<
                    crate::model::big_query_destination_config::blmt_config::TableFormat,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.table_format = v.into();
            self
        }
    }

    impl wkt::message::Message for BlmtConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig.BlmtConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BlmtConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __bucket,
                __root_path,
                __connection_name,
                __file_format,
                __table_format,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BlmtConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "bucket" => Ok(__FieldTag::__bucket),
                                "rootPath" => Ok(__FieldTag::__root_path),
                                "root_path" => Ok(__FieldTag::__root_path),
                                "connectionName" => Ok(__FieldTag::__connection_name),
                                "connection_name" => Ok(__FieldTag::__connection_name),
                                "fileFormat" => Ok(__FieldTag::__file_format),
                                "file_format" => Ok(__FieldTag::__file_format),
                                "tableFormat" => Ok(__FieldTag::__table_format),
                                "table_format" => Ok(__FieldTag::__table_format),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BlmtConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BlmtConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__bucket => {
                                if !fields.insert(__FieldTag::__bucket) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bucket",
                                    ));
                                }
                                result.bucket = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__root_path => {
                                if !fields.insert(__FieldTag::__root_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for root_path",
                                    ));
                                }
                                result.root_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__connection_name => {
                                if !fields.insert(__FieldTag::__connection_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for connection_name",
                                    ));
                                }
                                result.connection_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__file_format => {
                                if !fields.insert(__FieldTag::__file_format) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for file_format",
                                    ));
                                }
                                result.file_format = map.next_value::<std::option::Option<crate::model::big_query_destination_config::blmt_config::FileFormat>>()?.unwrap_or_default();
                            }
                            __FieldTag::__table_format => {
                                if !fields.insert(__FieldTag::__table_format) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table_format",
                                    ));
                                }
                                result.table_format = map.next_value::<std::option::Option<crate::model::big_query_destination_config::blmt_config::TableFormat>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BlmtConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.bucket.is_empty() {
                state.serialize_entry("bucket", &self.bucket)?;
            }
            if !self.root_path.is_empty() {
                state.serialize_entry("rootPath", &self.root_path)?;
            }
            if !self.connection_name.is_empty() {
                state.serialize_entry("connectionName", &self.connection_name)?;
            }
            if !wkt::internal::is_default(&self.file_format) {
                state.serialize_entry("fileFormat", &self.file_format)?;
            }
            if !wkt::internal::is_default(&self.table_format) {
                state.serialize_entry("tableFormat", &self.table_format)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BlmtConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BlmtConfig");
            debug_struct.field("bucket", &self.bucket);
            debug_struct.field("root_path", &self.root_path);
            debug_struct.field("connection_name", &self.connection_name);
            debug_struct.field("file_format", &self.file_format);
            debug_struct.field("table_format", &self.table_format);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [BlmtConfig].
    pub mod blmt_config {
        #[allow(unused_imports)]
        use super::*;

        /// Supported file formats for BigLake managed tables.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum FileFormat {
            /// Default value.
            Unspecified,
            /// Parquet file format.
            Parquet,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [FileFormat::value] or
            /// [FileFormat::name].
            UnknownValue(file_format::UnknownValue),
        }

        #[doc(hidden)]
        pub mod file_format {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl FileFormat {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Parquet => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("FILE_FORMAT_UNSPECIFIED"),
                    Self::Parquet => std::option::Option::Some("PARQUET"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for FileFormat {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for FileFormat {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for FileFormat {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Parquet,
                    _ => Self::UnknownValue(file_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for FileFormat {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "FILE_FORMAT_UNSPECIFIED" => Self::Unspecified,
                    "PARQUET" => Self::Parquet,
                    _ => Self::UnknownValue(file_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for FileFormat {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Parquet => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for FileFormat {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<FileFormat>::new(
                    ".google.cloud.datastream.v1.BigQueryDestinationConfig.BlmtConfig.FileFormat",
                ))
            }
        }

        /// Supported table formats for BigLake managed tables.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TableFormat {
            /// Default value.
            Unspecified,
            /// Iceberg table format.
            Iceberg,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [TableFormat::value] or
            /// [TableFormat::name].
            UnknownValue(table_format::UnknownValue),
        }

        #[doc(hidden)]
        pub mod table_format {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl TableFormat {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Iceberg => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TABLE_FORMAT_UNSPECIFIED"),
                    Self::Iceberg => std::option::Option::Some("ICEBERG"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for TableFormat {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for TableFormat {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for TableFormat {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Iceberg,
                    _ => Self::UnknownValue(table_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for TableFormat {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TABLE_FORMAT_UNSPECIFIED" => Self::Unspecified,
                    "ICEBERG" => Self::Iceberg,
                    _ => Self::UnknownValue(table_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for TableFormat {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Iceberg => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for TableFormat {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<TableFormat>::new(
                    ".google.cloud.datastream.v1.BigQueryDestinationConfig.BlmtConfig.TableFormat",
                ))
            }
        }
    }

    /// AppendOnly mode defines that all changes to a table will be written to the
    /// destination table.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AppendOnly {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AppendOnly {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for AppendOnly {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig.AppendOnly"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AppendOnly {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AppendOnly")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AppendOnly;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AppendOnly")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AppendOnly {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AppendOnly {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AppendOnly");
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Merge mode defines that all changes to a table will be merged at the
    /// destination table.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Merge {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Merge {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Merge {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.BigQueryDestinationConfig.Merge"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Merge {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Merge")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Merge;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Merge")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Merge {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Merge {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Merge");
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Target dataset(s) configuration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatasetConfig {
        /// Single destination dataset.
        SingleTargetDataset(
            std::boxed::Box<crate::model::big_query_destination_config::SingleTargetDataset>,
        ),
        /// Source hierarchy datasets.
        SourceHierarchyDatasets(
            std::boxed::Box<crate::model::big_query_destination_config::SourceHierarchyDatasets>,
        ),
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WriteMode {
        /// The standard mode
        Merge(std::boxed::Box<crate::model::big_query_destination_config::Merge>),
        /// Append only mode
        AppendOnly(std::boxed::Box<crate::model::big_query_destination_config::AppendOnly>),
    }
}

/// The configuration of the stream destination.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DestinationConfig {
    /// Required. Destination connection profile resource.
    /// Format: `projects/{project}/locations/{location}/connectionProfiles/{name}`
    pub destination_connection_profile: std::string::String,

    /// Stream configuration that is specific to the data destination type.
    pub destination_stream_config:
        std::option::Option<crate::model::destination_config::DestinationStreamConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DestinationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination_connection_profile][crate::model::DestinationConfig::destination_connection_profile].
    pub fn set_destination_connection_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_connection_profile = v.into();
        self
    }

    /// Sets the value of [destination_stream_config][crate::model::DestinationConfig::destination_stream_config].
    ///
    /// Note that all the setters affecting `destination_stream_config` are mutually
    /// exclusive.
    pub fn set_destination_stream_config<
        T: std::convert::Into<
                std::option::Option<crate::model::destination_config::DestinationStreamConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_stream_config = v.into();
        self
    }

    /// The value of [destination_stream_config][crate::model::DestinationConfig::destination_stream_config]
    /// if it holds a `GcsDestinationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestinationConfig>> {
        #[allow(unreachable_patterns)]
        self.destination_stream_config
            .as_ref()
            .and_then(|v| match v {
                crate::model::destination_config::DestinationStreamConfig::GcsDestinationConfig(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
    }

    /// Sets the value of [destination_stream_config][crate::model::DestinationConfig::destination_stream_config]
    /// to hold a `GcsDestinationConfig`.
    ///
    /// Note that all the setters affecting `destination_stream_config` are
    /// mutually exclusive.
    pub fn set_gcs_destination_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestinationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_stream_config = std::option::Option::Some(
            crate::model::destination_config::DestinationStreamConfig::GcsDestinationConfig(
                v.into(),
            ),
        );
        self
    }

    /// The value of [destination_stream_config][crate::model::DestinationConfig::destination_stream_config]
    /// if it holds a `BigqueryDestinationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_destination_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestinationConfig>> {
        #[allow(unreachable_patterns)]
        self.destination_stream_config.as_ref().and_then(|v| match v {
            crate::model::destination_config::DestinationStreamConfig::BigqueryDestinationConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination_stream_config][crate::model::DestinationConfig::destination_stream_config]
    /// to hold a `BigqueryDestinationConfig`.
    ///
    /// Note that all the setters affecting `destination_stream_config` are
    /// mutually exclusive.
    pub fn set_bigquery_destination_config<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestinationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_stream_config = std::option::Option::Some(
            crate::model::destination_config::DestinationStreamConfig::BigqueryDestinationConfig(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DestinationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.DestinationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DestinationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __destination_connection_profile,
            __gcs_destination_config,
            __bigquery_destination_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DestinationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "destinationConnectionProfile" => {
                                Ok(__FieldTag::__destination_connection_profile)
                            }
                            "destination_connection_profile" => {
                                Ok(__FieldTag::__destination_connection_profile)
                            }
                            "gcsDestinationConfig" => Ok(__FieldTag::__gcs_destination_config),
                            "gcs_destination_config" => Ok(__FieldTag::__gcs_destination_config),
                            "bigqueryDestinationConfig" => {
                                Ok(__FieldTag::__bigquery_destination_config)
                            }
                            "bigquery_destination_config" => {
                                Ok(__FieldTag::__bigquery_destination_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DestinationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DestinationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__destination_connection_profile => {
                            if !fields.insert(__FieldTag::__destination_connection_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_connection_profile",
                                ));
                            }
                            result.destination_connection_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcs_destination_config => {
                            if !fields.insert(__FieldTag::__gcs_destination_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination_config",
                                ));
                            }
                            if result.destination_stream_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination_stream_config`, a oneof with full ID .google.cloud.datastream.v1.DestinationConfig.gcs_destination_config, latest field was gcsDestinationConfig",
                                ));
                            }
                            result.destination_stream_config = std::option::Option::Some(
                                crate::model::destination_config::DestinationStreamConfig::GcsDestinationConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GcsDestinationConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__bigquery_destination_config => {
                            if !fields.insert(__FieldTag::__bigquery_destination_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_destination_config",
                                ));
                            }
                            if result.destination_stream_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination_stream_config`, a oneof with full ID .google.cloud.datastream.v1.DestinationConfig.bigquery_destination_config, latest field was bigqueryDestinationConfig",
                                ));
                            }
                            result.destination_stream_config = std::option::Option::Some(
                                crate::model::destination_config::DestinationStreamConfig::BigqueryDestinationConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::BigQueryDestinationConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DestinationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.destination_connection_profile.is_empty() {
            state.serialize_entry(
                "destinationConnectionProfile",
                &self.destination_connection_profile,
            )?;
        }
        if let Some(value) = self.gcs_destination_config() {
            state.serialize_entry("gcsDestinationConfig", value)?;
        }
        if let Some(value) = self.bigquery_destination_config() {
            state.serialize_entry("bigqueryDestinationConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DestinationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DestinationConfig");
        debug_struct.field(
            "destination_connection_profile",
            &self.destination_connection_profile,
        );
        debug_struct.field("destination_stream_config", &self.destination_stream_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DestinationConfig].
pub mod destination_config {
    #[allow(unused_imports)]
    use super::*;

    /// Stream configuration that is specific to the data destination type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DestinationStreamConfig {
        /// A configuration for how data should be loaded to Cloud Storage.
        GcsDestinationConfig(std::boxed::Box<crate::model::GcsDestinationConfig>),
        /// BigQuery destination configuration.
        BigqueryDestinationConfig(std::boxed::Box<crate::model::BigQueryDestinationConfig>),
    }
}

/// A resource representing streaming data from a source to a destination.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Stream {
    /// Output only. Identifier. The stream's name.
    pub name: std::string::String,

    /// Output only. The creation time of the stream.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update time of the stream.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Display name.
    pub display_name: std::string::String,

    /// Required. Source connection profile configuration.
    pub source_config: std::option::Option<crate::model::SourceConfig>,

    /// Required. Destination connection profile configuration.
    pub destination_config: std::option::Option<crate::model::DestinationConfig>,

    /// The state of the stream.
    pub state: crate::model::stream::State,

    /// Output only. Errors on the Stream.
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Immutable. A reference to a KMS encryption key.
    /// If provided, it will be used to encrypt the data.
    /// If left blank, data will be encrypted using an internal Stream-specific
    /// encryption key provisioned through KMS.
    pub customer_managed_encryption_key: std::option::Option<std::string::String>,

    /// Output only. If the stream was recovered, the time of the last recovery.
    /// Note: This field is currently experimental.
    pub last_recovery_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: std::option::Option<bool>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: std::option::Option<bool>,

    /// Stream backfill strategy.
    pub backfill_strategy: std::option::Option<crate::model::stream::BackfillStrategy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Stream {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Stream::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Stream::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Stream::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Stream::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Stream::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Stream::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::Stream::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [source_config][crate::model::Stream::source_config].
    pub fn set_source_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceConfig>,
    {
        self.source_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_config][crate::model::Stream::source_config].
    pub fn set_or_clear_source_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceConfig>,
    {
        self.source_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_config][crate::model::Stream::destination_config].
    pub fn set_destination_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DestinationConfig>,
    {
        self.destination_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destination_config][crate::model::Stream::destination_config].
    pub fn set_or_clear_destination_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DestinationConfig>,
    {
        self.destination_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Stream::state].
    pub fn set_state<T: std::convert::Into<crate::model::stream::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::Stream::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [customer_managed_encryption_key][crate::model::Stream::customer_managed_encryption_key].
    pub fn set_customer_managed_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.customer_managed_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [customer_managed_encryption_key][crate::model::Stream::customer_managed_encryption_key].
    pub fn set_or_clear_customer_managed_encryption_key<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.customer_managed_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_recovery_time][crate::model::Stream::last_recovery_time].
    pub fn set_last_recovery_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_recovery_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_recovery_time][crate::model::Stream::last_recovery_time].
    pub fn set_or_clear_last_recovery_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_recovery_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Stream::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::Stream::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Stream::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::Stream::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backfill_strategy][crate::model::Stream::backfill_strategy].
    ///
    /// Note that all the setters affecting `backfill_strategy` are mutually
    /// exclusive.
    pub fn set_backfill_strategy<
        T: std::convert::Into<std::option::Option<crate::model::stream::BackfillStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backfill_strategy = v.into();
        self
    }

    /// The value of [backfill_strategy][crate::model::Stream::backfill_strategy]
    /// if it holds a `BackfillAll`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backfill_all(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::stream::BackfillAllStrategy>> {
        #[allow(unreachable_patterns)]
        self.backfill_strategy.as_ref().and_then(|v| match v {
            crate::model::stream::BackfillStrategy::BackfillAll(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backfill_strategy][crate::model::Stream::backfill_strategy]
    /// to hold a `BackfillAll`.
    ///
    /// Note that all the setters affecting `backfill_strategy` are
    /// mutually exclusive.
    pub fn set_backfill_all<
        T: std::convert::Into<std::boxed::Box<crate::model::stream::BackfillAllStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backfill_strategy = std::option::Option::Some(
            crate::model::stream::BackfillStrategy::BackfillAll(v.into()),
        );
        self
    }

    /// The value of [backfill_strategy][crate::model::Stream::backfill_strategy]
    /// if it holds a `BackfillNone`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backfill_none(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::stream::BackfillNoneStrategy>> {
        #[allow(unreachable_patterns)]
        self.backfill_strategy.as_ref().and_then(|v| match v {
            crate::model::stream::BackfillStrategy::BackfillNone(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backfill_strategy][crate::model::Stream::backfill_strategy]
    /// to hold a `BackfillNone`.
    ///
    /// Note that all the setters affecting `backfill_strategy` are
    /// mutually exclusive.
    pub fn set_backfill_none<
        T: std::convert::Into<std::boxed::Box<crate::model::stream::BackfillNoneStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backfill_strategy = std::option::Option::Some(
            crate::model::stream::BackfillStrategy::BackfillNone(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Stream {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.Stream"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Stream {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __display_name,
            __source_config,
            __destination_config,
            __state,
            __backfill_all,
            __backfill_none,
            __errors,
            __customer_managed_encryption_key,
            __last_recovery_time,
            __satisfies_pzs,
            __satisfies_pzi,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Stream")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "sourceConfig" => Ok(__FieldTag::__source_config),
                            "source_config" => Ok(__FieldTag::__source_config),
                            "destinationConfig" => Ok(__FieldTag::__destination_config),
                            "destination_config" => Ok(__FieldTag::__destination_config),
                            "state" => Ok(__FieldTag::__state),
                            "backfillAll" => Ok(__FieldTag::__backfill_all),
                            "backfill_all" => Ok(__FieldTag::__backfill_all),
                            "backfillNone" => Ok(__FieldTag::__backfill_none),
                            "backfill_none" => Ok(__FieldTag::__backfill_none),
                            "errors" => Ok(__FieldTag::__errors),
                            "customerManagedEncryptionKey" => {
                                Ok(__FieldTag::__customer_managed_encryption_key)
                            }
                            "customer_managed_encryption_key" => {
                                Ok(__FieldTag::__customer_managed_encryption_key)
                            }
                            "lastRecoveryTime" => Ok(__FieldTag::__last_recovery_time),
                            "last_recovery_time" => Ok(__FieldTag::__last_recovery_time),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Stream;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Stream")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_config => {
                            if !fields.insert(__FieldTag::__source_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_config",
                                ));
                            }
                            result.source_config = map
                                .next_value::<std::option::Option<crate::model::SourceConfig>>()?;
                        }
                        __FieldTag::__destination_config => {
                            if !fields.insert(__FieldTag::__destination_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_config",
                                ));
                            }
                            result.destination_config = map
                                .next_value::<std::option::Option<crate::model::DestinationConfig>>(
                                )?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::stream::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backfill_all => {
                            if !fields.insert(__FieldTag::__backfill_all) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backfill_all",
                                ));
                            }
                            if result.backfill_strategy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `backfill_strategy`, a oneof with full ID .google.cloud.datastream.v1.Stream.backfill_all, latest field was backfillAll",
                                ));
                            }
                            result.backfill_strategy = std::option::Option::Some(
                                crate::model::stream::BackfillStrategy::BackfillAll(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::stream::BackfillAllStrategy>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__backfill_none => {
                            if !fields.insert(__FieldTag::__backfill_none) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backfill_none",
                                ));
                            }
                            if result.backfill_strategy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `backfill_strategy`, a oneof with full ID .google.cloud.datastream.v1.Stream.backfill_none, latest field was backfillNone",
                                ));
                            }
                            result.backfill_strategy = std::option::Option::Some(
                                crate::model::stream::BackfillStrategy::BackfillNone(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::stream::BackfillNoneStrategy>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Error>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__customer_managed_encryption_key => {
                            if !fields.insert(__FieldTag::__customer_managed_encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_managed_encryption_key",
                                ));
                            }
                            result.customer_managed_encryption_key =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__last_recovery_time => {
                            if !fields.insert(__FieldTag::__last_recovery_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_recovery_time",
                                ));
                            }
                            result.last_recovery_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Stream {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.source_config.is_some() {
            state.serialize_entry("sourceConfig", &self.source_config)?;
        }
        if self.destination_config.is_some() {
            state.serialize_entry("destinationConfig", &self.destination_config)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if let Some(value) = self.backfill_all() {
            state.serialize_entry("backfillAll", value)?;
        }
        if let Some(value) = self.backfill_none() {
            state.serialize_entry("backfillNone", value)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if self.customer_managed_encryption_key.is_some() {
            state.serialize_entry(
                "customerManagedEncryptionKey",
                &self.customer_managed_encryption_key,
            )?;
        }
        if self.last_recovery_time.is_some() {
            state.serialize_entry("lastRecoveryTime", &self.last_recovery_time)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Stream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Stream");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("source_config", &self.source_config);
        debug_struct.field("destination_config", &self.destination_config);
        debug_struct.field("state", &self.state);
        debug_struct.field("errors", &self.errors);
        debug_struct.field(
            "customer_managed_encryption_key",
            &self.customer_managed_encryption_key,
        );
        debug_struct.field("last_recovery_time", &self.last_recovery_time);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field("backfill_strategy", &self.backfill_strategy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Stream].
pub mod stream {
    #[allow(unused_imports)]
    use super::*;

    /// Backfill strategy to automatically backfill the Stream's objects.
    /// Specific objects can be excluded.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BackfillAllStrategy {
        /// List of objects to exclude.
        pub excluded_objects:
            std::option::Option<crate::model::stream::backfill_all_strategy::ExcludedObjects>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BackfillAllStrategy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects].
        ///
        /// Note that all the setters affecting `excluded_objects` are mutually
        /// exclusive.
        pub fn set_excluded_objects<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::stream::backfill_all_strategy::ExcludedObjects,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.excluded_objects = v.into();
            self
        }

        /// The value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// if it holds a `OracleExcludedObjects`, `None` if the field is not set or
        /// holds a different branch.
        pub fn oracle_excluded_objects(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::OracleRdbms>> {
            #[allow(unreachable_patterns)]
            self.excluded_objects.as_ref().and_then(|v| match v {
                crate::model::stream::backfill_all_strategy::ExcludedObjects::OracleExcludedObjects(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// to hold a `OracleExcludedObjects`.
        ///
        /// Note that all the setters affecting `excluded_objects` are
        /// mutually exclusive.
        pub fn set_oracle_excluded_objects<
            T: std::convert::Into<std::boxed::Box<crate::model::OracleRdbms>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.excluded_objects = std::option::Option::Some(
                crate::model::stream::backfill_all_strategy::ExcludedObjects::OracleExcludedObjects(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// if it holds a `MysqlExcludedObjects`, `None` if the field is not set or
        /// holds a different branch.
        pub fn mysql_excluded_objects(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::MysqlRdbms>> {
            #[allow(unreachable_patterns)]
            self.excluded_objects.as_ref().and_then(|v| match v {
                crate::model::stream::backfill_all_strategy::ExcludedObjects::MysqlExcludedObjects(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// to hold a `MysqlExcludedObjects`.
        ///
        /// Note that all the setters affecting `excluded_objects` are
        /// mutually exclusive.
        pub fn set_mysql_excluded_objects<
            T: std::convert::Into<std::boxed::Box<crate::model::MysqlRdbms>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.excluded_objects = std::option::Option::Some(
                crate::model::stream::backfill_all_strategy::ExcludedObjects::MysqlExcludedObjects(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// if it holds a `PostgresqlExcludedObjects`, `None` if the field is not set or
        /// holds a different branch.
        pub fn postgresql_excluded_objects(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::PostgresqlRdbms>> {
            #[allow(unreachable_patterns)]
            self.excluded_objects.as_ref().and_then(|v| match v {
                crate::model::stream::backfill_all_strategy::ExcludedObjects::PostgresqlExcludedObjects(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// to hold a `PostgresqlExcludedObjects`.
        ///
        /// Note that all the setters affecting `excluded_objects` are
        /// mutually exclusive.
        pub fn set_postgresql_excluded_objects<
            T: std::convert::Into<std::boxed::Box<crate::model::PostgresqlRdbms>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.excluded_objects = std::option::Option::Some(
                crate::model::stream::backfill_all_strategy::ExcludedObjects::PostgresqlExcludedObjects(
                    v.into()
                )
            );
            self
        }

        /// The value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// if it holds a `SqlServerExcludedObjects`, `None` if the field is not set or
        /// holds a different branch.
        pub fn sql_server_excluded_objects(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerRdbms>> {
            #[allow(unreachable_patterns)]
            self.excluded_objects.as_ref().and_then(|v| match v {
                crate::model::stream::backfill_all_strategy::ExcludedObjects::SqlServerExcludedObjects(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// to hold a `SqlServerExcludedObjects`.
        ///
        /// Note that all the setters affecting `excluded_objects` are
        /// mutually exclusive.
        pub fn set_sql_server_excluded_objects<
            T: std::convert::Into<std::boxed::Box<crate::model::SqlServerRdbms>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.excluded_objects = std::option::Option::Some(
                crate::model::stream::backfill_all_strategy::ExcludedObjects::SqlServerExcludedObjects(
                    v.into()
                )
            );
            self
        }

        /// The value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// if it holds a `SalesforceExcludedObjects`, `None` if the field is not set or
        /// holds a different branch.
        pub fn salesforce_excluded_objects(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::SalesforceOrg>> {
            #[allow(unreachable_patterns)]
            self.excluded_objects.as_ref().and_then(|v| match v {
                crate::model::stream::backfill_all_strategy::ExcludedObjects::SalesforceExcludedObjects(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [excluded_objects][crate::model::stream::BackfillAllStrategy::excluded_objects]
        /// to hold a `SalesforceExcludedObjects`.
        ///
        /// Note that all the setters affecting `excluded_objects` are
        /// mutually exclusive.
        pub fn set_salesforce_excluded_objects<
            T: std::convert::Into<std::boxed::Box<crate::model::SalesforceOrg>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.excluded_objects = std::option::Option::Some(
                crate::model::stream::backfill_all_strategy::ExcludedObjects::SalesforceExcludedObjects(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for BackfillAllStrategy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.Stream.BackfillAllStrategy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BackfillAllStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __oracle_excluded_objects,
                __mysql_excluded_objects,
                __postgresql_excluded_objects,
                __sql_server_excluded_objects,
                __salesforce_excluded_objects,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BackfillAllStrategy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "oracleExcludedObjects" => {
                                    Ok(__FieldTag::__oracle_excluded_objects)
                                }
                                "oracle_excluded_objects" => {
                                    Ok(__FieldTag::__oracle_excluded_objects)
                                }
                                "mysqlExcludedObjects" => Ok(__FieldTag::__mysql_excluded_objects),
                                "mysql_excluded_objects" => {
                                    Ok(__FieldTag::__mysql_excluded_objects)
                                }
                                "postgresqlExcludedObjects" => {
                                    Ok(__FieldTag::__postgresql_excluded_objects)
                                }
                                "postgresql_excluded_objects" => {
                                    Ok(__FieldTag::__postgresql_excluded_objects)
                                }
                                "sqlServerExcludedObjects" => {
                                    Ok(__FieldTag::__sql_server_excluded_objects)
                                }
                                "sql_server_excluded_objects" => {
                                    Ok(__FieldTag::__sql_server_excluded_objects)
                                }
                                "salesforceExcludedObjects" => {
                                    Ok(__FieldTag::__salesforce_excluded_objects)
                                }
                                "salesforce_excluded_objects" => {
                                    Ok(__FieldTag::__salesforce_excluded_objects)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BackfillAllStrategy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BackfillAllStrategy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__oracle_excluded_objects => {
                                if !fields.insert(__FieldTag::__oracle_excluded_objects) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for oracle_excluded_objects",
                                    ));
                                }
                                if result.excluded_objects.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `excluded_objects`, a oneof with full ID .google.cloud.datastream.v1.Stream.BackfillAllStrategy.oracle_excluded_objects, latest field was oracleExcludedObjects",
                                    ));
                                }
                                result.excluded_objects = std::option::Option::Some(
                                    crate::model::stream::backfill_all_strategy::ExcludedObjects::OracleExcludedObjects(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::OracleRdbms>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__mysql_excluded_objects => {
                                if !fields.insert(__FieldTag::__mysql_excluded_objects) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mysql_excluded_objects",
                                    ));
                                }
                                if result.excluded_objects.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `excluded_objects`, a oneof with full ID .google.cloud.datastream.v1.Stream.BackfillAllStrategy.mysql_excluded_objects, latest field was mysqlExcludedObjects",
                                    ));
                                }
                                result.excluded_objects = std::option::Option::Some(
                                    crate::model::stream::backfill_all_strategy::ExcludedObjects::MysqlExcludedObjects(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::MysqlRdbms>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__postgresql_excluded_objects => {
                                if !fields.insert(__FieldTag::__postgresql_excluded_objects) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for postgresql_excluded_objects",
                                    ));
                                }
                                if result.excluded_objects.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `excluded_objects`, a oneof with full ID .google.cloud.datastream.v1.Stream.BackfillAllStrategy.postgresql_excluded_objects, latest field was postgresqlExcludedObjects",
                                    ));
                                }
                                result.excluded_objects = std::option::Option::Some(
                                    crate::model::stream::backfill_all_strategy::ExcludedObjects::PostgresqlExcludedObjects(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::PostgresqlRdbms>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__sql_server_excluded_objects => {
                                if !fields.insert(__FieldTag::__sql_server_excluded_objects) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sql_server_excluded_objects",
                                    ));
                                }
                                if result.excluded_objects.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `excluded_objects`, a oneof with full ID .google.cloud.datastream.v1.Stream.BackfillAllStrategy.sql_server_excluded_objects, latest field was sqlServerExcludedObjects",
                                    ));
                                }
                                result.excluded_objects = std::option::Option::Some(
                                    crate::model::stream::backfill_all_strategy::ExcludedObjects::SqlServerExcludedObjects(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::SqlServerRdbms>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__salesforce_excluded_objects => {
                                if !fields.insert(__FieldTag::__salesforce_excluded_objects) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for salesforce_excluded_objects",
                                    ));
                                }
                                if result.excluded_objects.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `excluded_objects`, a oneof with full ID .google.cloud.datastream.v1.Stream.BackfillAllStrategy.salesforce_excluded_objects, latest field was salesforceExcludedObjects",
                                    ));
                                }
                                result.excluded_objects = std::option::Option::Some(
                                    crate::model::stream::backfill_all_strategy::ExcludedObjects::SalesforceExcludedObjects(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::SalesforceOrg>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BackfillAllStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.oracle_excluded_objects() {
                state.serialize_entry("oracleExcludedObjects", value)?;
            }
            if let Some(value) = self.mysql_excluded_objects() {
                state.serialize_entry("mysqlExcludedObjects", value)?;
            }
            if let Some(value) = self.postgresql_excluded_objects() {
                state.serialize_entry("postgresqlExcludedObjects", value)?;
            }
            if let Some(value) = self.sql_server_excluded_objects() {
                state.serialize_entry("sqlServerExcludedObjects", value)?;
            }
            if let Some(value) = self.salesforce_excluded_objects() {
                state.serialize_entry("salesforceExcludedObjects", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BackfillAllStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BackfillAllStrategy");
            debug_struct.field("excluded_objects", &self.excluded_objects);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [BackfillAllStrategy].
    pub mod backfill_all_strategy {
        #[allow(unused_imports)]
        use super::*;

        /// List of objects to exclude.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ExcludedObjects {
            /// Oracle data source objects to avoid backfilling.
            OracleExcludedObjects(std::boxed::Box<crate::model::OracleRdbms>),
            /// MySQL data source objects to avoid backfilling.
            MysqlExcludedObjects(std::boxed::Box<crate::model::MysqlRdbms>),
            /// PostgreSQL data source objects to avoid backfilling.
            PostgresqlExcludedObjects(std::boxed::Box<crate::model::PostgresqlRdbms>),
            /// SQLServer data source objects to avoid backfilling
            SqlServerExcludedObjects(std::boxed::Box<crate::model::SqlServerRdbms>),
            /// Salesforce data source objects to avoid backfilling
            SalesforceExcludedObjects(std::boxed::Box<crate::model::SalesforceOrg>),
        }
    }

    /// Backfill strategy to disable automatic backfill for the Stream's objects.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BackfillNoneStrategy {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BackfillNoneStrategy {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for BackfillNoneStrategy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.Stream.BackfillNoneStrategy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BackfillNoneStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BackfillNoneStrategy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BackfillNoneStrategy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BackfillNoneStrategy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BackfillNoneStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BackfillNoneStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BackfillNoneStrategy");
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Stream state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified stream state.
        Unspecified,
        /// The stream has been created but has not yet started streaming data.
        NotStarted,
        /// The stream is running.
        Running,
        /// The stream is paused.
        Paused,
        /// The stream is in maintenance mode.
        ///
        /// Updates are rejected on the resource in this state.
        Maintenance,
        /// The stream is experiencing an error that is preventing data from being
        /// streamed.
        Failed,
        /// The stream has experienced a terminal failure.
        FailedPermanently,
        /// The stream is starting, but not yet running.
        Starting,
        /// The Stream is no longer reading new events, but still writing events in
        /// the buffer.
        Draining,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotStarted => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Paused => std::option::Option::Some(3),
                Self::Maintenance => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::FailedPermanently => std::option::Option::Some(6),
                Self::Starting => std::option::Option::Some(7),
                Self::Draining => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::NotStarted => std::option::Option::Some("NOT_STARTED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::FailedPermanently => std::option::Option::Some("FAILED_PERMANENTLY"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Draining => std::option::Option::Some("DRAINING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotStarted,
                2 => Self::Running,
                3 => Self::Paused,
                4 => Self::Maintenance,
                5 => Self::Failed,
                6 => Self::FailedPermanently,
                7 => Self::Starting,
                8 => Self::Draining,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "NOT_STARTED" => Self::NotStarted,
                "RUNNING" => Self::Running,
                "PAUSED" => Self::Paused,
                "MAINTENANCE" => Self::Maintenance,
                "FAILED" => Self::Failed,
                "FAILED_PERMANENTLY" => Self::FailedPermanently,
                "STARTING" => Self::Starting,
                "DRAINING" => Self::Draining,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotStarted => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Paused => serializer.serialize_i32(3),
                Self::Maintenance => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::FailedPermanently => serializer.serialize_i32(6),
                Self::Starting => serializer.serialize_i32(7),
                Self::Draining => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.datastream.v1.Stream.State",
            ))
        }
    }

    /// Stream backfill strategy.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackfillStrategy {
        /// Automatically backfill objects included in the stream source
        /// configuration. Specific objects can be excluded.
        BackfillAll(std::boxed::Box<crate::model::stream::BackfillAllStrategy>),
        /// Do not automatically backfill any objects.
        BackfillNone(std::boxed::Box<crate::model::stream::BackfillNoneStrategy>),
    }
}

/// A specific stream object (e.g a specific DB table).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamObject {
    /// Output only. Identifier. The object resource's name.
    pub name: std::string::String,

    /// Output only. The creation time of the object.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update time of the object.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. Display name.
    pub display_name: std::string::String,

    /// Output only. Active errors on the object.
    pub errors: std::vec::Vec<crate::model::Error>,

    /// The latest backfill job that was initiated for the stream object.
    pub backfill_job: std::option::Option<crate::model::BackfillJob>,

    /// The object identifier in the data source.
    pub source_object: std::option::Option<crate::model::SourceObjectIdentifier>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamObject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StreamObject::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::StreamObject::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::StreamObject::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::StreamObject::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::StreamObject::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::StreamObject::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::StreamObject::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [backfill_job][crate::model::StreamObject::backfill_job].
    pub fn set_backfill_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackfillJob>,
    {
        self.backfill_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backfill_job][crate::model::StreamObject::backfill_job].
    pub fn set_or_clear_backfill_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackfillJob>,
    {
        self.backfill_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_object][crate::model::StreamObject::source_object].
    pub fn set_source_object<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceObjectIdentifier>,
    {
        self.source_object = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_object][crate::model::StreamObject::source_object].
    pub fn set_or_clear_source_object<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceObjectIdentifier>,
    {
        self.source_object = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StreamObject {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.StreamObject"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamObject {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __display_name,
            __errors,
            __backfill_job,
            __source_object,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamObject")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "errors" => Ok(__FieldTag::__errors),
                            "backfillJob" => Ok(__FieldTag::__backfill_job),
                            "backfill_job" => Ok(__FieldTag::__backfill_job),
                            "sourceObject" => Ok(__FieldTag::__source_object),
                            "source_object" => Ok(__FieldTag::__source_object),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamObject;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamObject")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Error>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__backfill_job => {
                            if !fields.insert(__FieldTag::__backfill_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backfill_job",
                                ));
                            }
                            result.backfill_job =
                                map.next_value::<std::option::Option<crate::model::BackfillJob>>()?;
                        }
                        __FieldTag::__source_object => {
                            if !fields.insert(__FieldTag::__source_object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_object",
                                ));
                            }
                            result.source_object = map.next_value::<std::option::Option<crate::model::SourceObjectIdentifier>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamObject {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if self.backfill_job.is_some() {
            state.serialize_entry("backfillJob", &self.backfill_job)?;
        }
        if self.source_object.is_some() {
            state.serialize_entry("sourceObject", &self.source_object)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StreamObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StreamObject");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("errors", &self.errors);
        debug_struct.field("backfill_job", &self.backfill_job);
        debug_struct.field("source_object", &self.source_object);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents an identifier of an object in the data source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceObjectIdentifier {
    /// The identifier for an object in the data source.
    pub source_identifier:
        std::option::Option<crate::model::source_object_identifier::SourceIdentifier>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceObjectIdentifier {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier].
    ///
    /// Note that all the setters affecting `source_identifier` are mutually
    /// exclusive.
    pub fn set_source_identifier<
        T: std::convert::Into<
                std::option::Option<crate::model::source_object_identifier::SourceIdentifier>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_identifier = v.into();
        self
    }

    /// The value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// if it holds a `OracleIdentifier`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle_identifier(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::source_object_identifier::OracleObjectIdentifier>,
    > {
        #[allow(unreachable_patterns)]
        self.source_identifier.as_ref().and_then(|v| match v {
            crate::model::source_object_identifier::SourceIdentifier::OracleIdentifier(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// to hold a `OracleIdentifier`.
    ///
    /// Note that all the setters affecting `source_identifier` are
    /// mutually exclusive.
    pub fn set_oracle_identifier<
        T: std::convert::Into<
                std::boxed::Box<crate::model::source_object_identifier::OracleObjectIdentifier>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_identifier = std::option::Option::Some(
            crate::model::source_object_identifier::SourceIdentifier::OracleIdentifier(v.into()),
        );
        self
    }

    /// The value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// if it holds a `MysqlIdentifier`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_identifier(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::source_object_identifier::MysqlObjectIdentifier>,
    > {
        #[allow(unreachable_patterns)]
        self.source_identifier.as_ref().and_then(|v| match v {
            crate::model::source_object_identifier::SourceIdentifier::MysqlIdentifier(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// to hold a `MysqlIdentifier`.
    ///
    /// Note that all the setters affecting `source_identifier` are
    /// mutually exclusive.
    pub fn set_mysql_identifier<
        T: std::convert::Into<
                std::boxed::Box<crate::model::source_object_identifier::MysqlObjectIdentifier>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_identifier = std::option::Option::Some(
            crate::model::source_object_identifier::SourceIdentifier::MysqlIdentifier(v.into()),
        );
        self
    }

    /// The value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// if it holds a `PostgresqlIdentifier`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql_identifier(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::source_object_identifier::PostgresqlObjectIdentifier>,
    > {
        #[allow(unreachable_patterns)]
        self.source_identifier.as_ref().and_then(|v| match v {
            crate::model::source_object_identifier::SourceIdentifier::PostgresqlIdentifier(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// to hold a `PostgresqlIdentifier`.
    ///
    /// Note that all the setters affecting `source_identifier` are
    /// mutually exclusive.
    pub fn set_postgresql_identifier<
        T: std::convert::Into<
                std::boxed::Box<crate::model::source_object_identifier::PostgresqlObjectIdentifier>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_identifier = std::option::Option::Some(
            crate::model::source_object_identifier::SourceIdentifier::PostgresqlIdentifier(
                v.into(),
            ),
        );
        self
    }

    /// The value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// if it holds a `SqlServerIdentifier`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_server_identifier(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::source_object_identifier::SqlServerObjectIdentifier>,
    > {
        #[allow(unreachable_patterns)]
        self.source_identifier.as_ref().and_then(|v| match v {
            crate::model::source_object_identifier::SourceIdentifier::SqlServerIdentifier(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// to hold a `SqlServerIdentifier`.
    ///
    /// Note that all the setters affecting `source_identifier` are
    /// mutually exclusive.
    pub fn set_sql_server_identifier<
        T: std::convert::Into<
                std::boxed::Box<crate::model::source_object_identifier::SqlServerObjectIdentifier>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_identifier = std::option::Option::Some(
            crate::model::source_object_identifier::SourceIdentifier::SqlServerIdentifier(v.into()),
        );
        self
    }

    /// The value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// if it holds a `SalesforceIdentifier`, `None` if the field is not set or
    /// holds a different branch.
    pub fn salesforce_identifier(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::source_object_identifier::SalesforceObjectIdentifier>,
    > {
        #[allow(unreachable_patterns)]
        self.source_identifier.as_ref().and_then(|v| match v {
            crate::model::source_object_identifier::SourceIdentifier::SalesforceIdentifier(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_identifier][crate::model::SourceObjectIdentifier::source_identifier]
    /// to hold a `SalesforceIdentifier`.
    ///
    /// Note that all the setters affecting `source_identifier` are
    /// mutually exclusive.
    pub fn set_salesforce_identifier<
        T: std::convert::Into<
                std::boxed::Box<crate::model::source_object_identifier::SalesforceObjectIdentifier>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_identifier = std::option::Option::Some(
            crate::model::source_object_identifier::SourceIdentifier::SalesforceIdentifier(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for SourceObjectIdentifier {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SourceObjectIdentifier"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SourceObjectIdentifier {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __oracle_identifier,
            __mysql_identifier,
            __postgresql_identifier,
            __sql_server_identifier,
            __salesforce_identifier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceObjectIdentifier")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "oracleIdentifier" => Ok(__FieldTag::__oracle_identifier),
                            "oracle_identifier" => Ok(__FieldTag::__oracle_identifier),
                            "mysqlIdentifier" => Ok(__FieldTag::__mysql_identifier),
                            "mysql_identifier" => Ok(__FieldTag::__mysql_identifier),
                            "postgresqlIdentifier" => Ok(__FieldTag::__postgresql_identifier),
                            "postgresql_identifier" => Ok(__FieldTag::__postgresql_identifier),
                            "sqlServerIdentifier" => Ok(__FieldTag::__sql_server_identifier),
                            "sql_server_identifier" => Ok(__FieldTag::__sql_server_identifier),
                            "salesforceIdentifier" => Ok(__FieldTag::__salesforce_identifier),
                            "salesforce_identifier" => Ok(__FieldTag::__salesforce_identifier),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SourceObjectIdentifier;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceObjectIdentifier")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__oracle_identifier => {
                            if !fields.insert(__FieldTag::__oracle_identifier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oracle_identifier",
                                ));
                            }
                            if result.source_identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_identifier`, a oneof with full ID .google.cloud.datastream.v1.SourceObjectIdentifier.oracle_identifier, latest field was oracleIdentifier",
                                ));
                            }
                            result.source_identifier = std::option::Option::Some(
                                crate::model::source_object_identifier::SourceIdentifier::OracleIdentifier(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::source_object_identifier::OracleObjectIdentifier>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__mysql_identifier => {
                            if !fields.insert(__FieldTag::__mysql_identifier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql_identifier",
                                ));
                            }
                            if result.source_identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_identifier`, a oneof with full ID .google.cloud.datastream.v1.SourceObjectIdentifier.mysql_identifier, latest field was mysqlIdentifier",
                                ));
                            }
                            result.source_identifier = std::option::Option::Some(
                                crate::model::source_object_identifier::SourceIdentifier::MysqlIdentifier(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::source_object_identifier::MysqlObjectIdentifier>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__postgresql_identifier => {
                            if !fields.insert(__FieldTag::__postgresql_identifier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postgresql_identifier",
                                ));
                            }
                            if result.source_identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_identifier`, a oneof with full ID .google.cloud.datastream.v1.SourceObjectIdentifier.postgresql_identifier, latest field was postgresqlIdentifier",
                                ));
                            }
                            result.source_identifier = std::option::Option::Some(
                                crate::model::source_object_identifier::SourceIdentifier::PostgresqlIdentifier(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::source_object_identifier::PostgresqlObjectIdentifier>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__sql_server_identifier => {
                            if !fields.insert(__FieldTag::__sql_server_identifier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_server_identifier",
                                ));
                            }
                            if result.source_identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_identifier`, a oneof with full ID .google.cloud.datastream.v1.SourceObjectIdentifier.sql_server_identifier, latest field was sqlServerIdentifier",
                                ));
                            }
                            result.source_identifier = std::option::Option::Some(
                                crate::model::source_object_identifier::SourceIdentifier::SqlServerIdentifier(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::source_object_identifier::SqlServerObjectIdentifier>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__salesforce_identifier => {
                            if !fields.insert(__FieldTag::__salesforce_identifier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for salesforce_identifier",
                                ));
                            }
                            if result.source_identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_identifier`, a oneof with full ID .google.cloud.datastream.v1.SourceObjectIdentifier.salesforce_identifier, latest field was salesforceIdentifier",
                                ));
                            }
                            result.source_identifier = std::option::Option::Some(
                                crate::model::source_object_identifier::SourceIdentifier::SalesforceIdentifier(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::source_object_identifier::SalesforceObjectIdentifier>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SourceObjectIdentifier {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.oracle_identifier() {
            state.serialize_entry("oracleIdentifier", value)?;
        }
        if let Some(value) = self.mysql_identifier() {
            state.serialize_entry("mysqlIdentifier", value)?;
        }
        if let Some(value) = self.postgresql_identifier() {
            state.serialize_entry("postgresqlIdentifier", value)?;
        }
        if let Some(value) = self.sql_server_identifier() {
            state.serialize_entry("sqlServerIdentifier", value)?;
        }
        if let Some(value) = self.salesforce_identifier() {
            state.serialize_entry("salesforceIdentifier", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SourceObjectIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceObjectIdentifier");
        debug_struct.field("source_identifier", &self.source_identifier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SourceObjectIdentifier].
pub mod source_object_identifier {
    #[allow(unused_imports)]
    use super::*;

    /// Oracle data source object identifier.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OracleObjectIdentifier {
        /// Required. The schema name.
        pub schema: std::string::String,

        /// Required. The table name.
        pub table: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OracleObjectIdentifier {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [schema][crate::model::source_object_identifier::OracleObjectIdentifier::schema].
        pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.schema = v.into();
            self
        }

        /// Sets the value of [table][crate::model::source_object_identifier::OracleObjectIdentifier::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }
    }

    impl wkt::message::Message for OracleObjectIdentifier {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SourceObjectIdentifier.OracleObjectIdentifier"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OracleObjectIdentifier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __schema,
                __table,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OracleObjectIdentifier")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "schema" => Ok(__FieldTag::__schema),
                                "table" => Ok(__FieldTag::__table),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OracleObjectIdentifier;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OracleObjectIdentifier")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__schema => {
                                if !fields.insert(__FieldTag::__schema) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schema",
                                    ));
                                }
                                result.schema = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__table => {
                                if !fields.insert(__FieldTag::__table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table",
                                    ));
                                }
                                result.table = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for OracleObjectIdentifier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.schema.is_empty() {
                state.serialize_entry("schema", &self.schema)?;
            }
            if !self.table.is_empty() {
                state.serialize_entry("table", &self.table)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for OracleObjectIdentifier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("OracleObjectIdentifier");
            debug_struct.field("schema", &self.schema);
            debug_struct.field("table", &self.table);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// PostgreSQL data source object identifier.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PostgresqlObjectIdentifier {
        /// Required. The schema name.
        pub schema: std::string::String,

        /// Required. The table name.
        pub table: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PostgresqlObjectIdentifier {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [schema][crate::model::source_object_identifier::PostgresqlObjectIdentifier::schema].
        pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.schema = v.into();
            self
        }

        /// Sets the value of [table][crate::model::source_object_identifier::PostgresqlObjectIdentifier::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }
    }

    impl wkt::message::Message for PostgresqlObjectIdentifier {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SourceObjectIdentifier.PostgresqlObjectIdentifier"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PostgresqlObjectIdentifier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __schema,
                __table,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PostgresqlObjectIdentifier")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "schema" => Ok(__FieldTag::__schema),
                                "table" => Ok(__FieldTag::__table),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PostgresqlObjectIdentifier;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PostgresqlObjectIdentifier")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__schema => {
                                if !fields.insert(__FieldTag::__schema) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schema",
                                    ));
                                }
                                result.schema = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__table => {
                                if !fields.insert(__FieldTag::__table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table",
                                    ));
                                }
                                result.table = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PostgresqlObjectIdentifier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.schema.is_empty() {
                state.serialize_entry("schema", &self.schema)?;
            }
            if !self.table.is_empty() {
                state.serialize_entry("table", &self.table)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PostgresqlObjectIdentifier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PostgresqlObjectIdentifier");
            debug_struct.field("schema", &self.schema);
            debug_struct.field("table", &self.table);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Mysql data source object identifier.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MysqlObjectIdentifier {
        /// Required. The database name.
        pub database: std::string::String,

        /// Required. The table name.
        pub table: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MysqlObjectIdentifier {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [database][crate::model::source_object_identifier::MysqlObjectIdentifier::database].
        pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.database = v.into();
            self
        }

        /// Sets the value of [table][crate::model::source_object_identifier::MysqlObjectIdentifier::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }
    }

    impl wkt::message::Message for MysqlObjectIdentifier {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SourceObjectIdentifier.MysqlObjectIdentifier"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MysqlObjectIdentifier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __database,
                __table,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MysqlObjectIdentifier")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "database" => Ok(__FieldTag::__database),
                                "table" => Ok(__FieldTag::__table),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MysqlObjectIdentifier;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MysqlObjectIdentifier")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__database => {
                                if !fields.insert(__FieldTag::__database) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for database",
                                    ));
                                }
                                result.database = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__table => {
                                if !fields.insert(__FieldTag::__table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table",
                                    ));
                                }
                                result.table = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MysqlObjectIdentifier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.database.is_empty() {
                state.serialize_entry("database", &self.database)?;
            }
            if !self.table.is_empty() {
                state.serialize_entry("table", &self.table)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for MysqlObjectIdentifier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("MysqlObjectIdentifier");
            debug_struct.field("database", &self.database);
            debug_struct.field("table", &self.table);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// SQLServer data source object identifier.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlServerObjectIdentifier {
        /// Required. The schema name.
        pub schema: std::string::String,

        /// Required. The table name.
        pub table: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlServerObjectIdentifier {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [schema][crate::model::source_object_identifier::SqlServerObjectIdentifier::schema].
        pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.schema = v.into();
            self
        }

        /// Sets the value of [table][crate::model::source_object_identifier::SqlServerObjectIdentifier::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlServerObjectIdentifier {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SourceObjectIdentifier.SqlServerObjectIdentifier"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlServerObjectIdentifier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __schema,
                __table,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlServerObjectIdentifier")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "schema" => Ok(__FieldTag::__schema),
                                "table" => Ok(__FieldTag::__table),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlServerObjectIdentifier;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlServerObjectIdentifier")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__schema => {
                                if !fields.insert(__FieldTag::__schema) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schema",
                                    ));
                                }
                                result.schema = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__table => {
                                if !fields.insert(__FieldTag::__table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table",
                                    ));
                                }
                                result.table = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlServerObjectIdentifier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.schema.is_empty() {
                state.serialize_entry("schema", &self.schema)?;
            }
            if !self.table.is_empty() {
                state.serialize_entry("table", &self.table)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SqlServerObjectIdentifier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SqlServerObjectIdentifier");
            debug_struct.field("schema", &self.schema);
            debug_struct.field("table", &self.table);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Salesforce data source object identifier.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SalesforceObjectIdentifier {
        /// Required. The object name.
        pub object_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SalesforceObjectIdentifier {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [object_name][crate::model::source_object_identifier::SalesforceObjectIdentifier::object_name].
        pub fn set_object_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.object_name = v.into();
            self
        }
    }

    impl wkt::message::Message for SalesforceObjectIdentifier {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.SourceObjectIdentifier.SalesforceObjectIdentifier"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SalesforceObjectIdentifier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __object_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SalesforceObjectIdentifier")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "objectName" => Ok(__FieldTag::__object_name),
                                "object_name" => Ok(__FieldTag::__object_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SalesforceObjectIdentifier;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SalesforceObjectIdentifier")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__object_name => {
                                if !fields.insert(__FieldTag::__object_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for object_name",
                                    ));
                                }
                                result.object_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SalesforceObjectIdentifier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.object_name.is_empty() {
                state.serialize_entry("objectName", &self.object_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SalesforceObjectIdentifier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SalesforceObjectIdentifier");
            debug_struct.field("object_name", &self.object_name);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The identifier for an object in the data source.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceIdentifier {
        /// Oracle data source object identifier.
        OracleIdentifier(
            std::boxed::Box<crate::model::source_object_identifier::OracleObjectIdentifier>,
        ),
        /// Mysql data source object identifier.
        MysqlIdentifier(
            std::boxed::Box<crate::model::source_object_identifier::MysqlObjectIdentifier>,
        ),
        /// PostgreSQL data source object identifier.
        PostgresqlIdentifier(
            std::boxed::Box<crate::model::source_object_identifier::PostgresqlObjectIdentifier>,
        ),
        /// SQLServer data source object identifier.
        SqlServerIdentifier(
            std::boxed::Box<crate::model::source_object_identifier::SqlServerObjectIdentifier>,
        ),
        /// Salesforce data source object identifier.
        SalesforceIdentifier(
            std::boxed::Box<crate::model::source_object_identifier::SalesforceObjectIdentifier>,
        ),
    }
}

/// Represents a backfill job on a specific stream object.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BackfillJob {
    /// Output only. Backfill job state.
    pub state: crate::model::backfill_job::State,

    /// Backfill job's triggering reason.
    pub trigger: crate::model::backfill_job::Trigger,

    /// Output only. Backfill job's start time.
    pub last_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Backfill job's end time.
    pub last_end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Errors which caused the backfill job to fail.
    pub errors: std::vec::Vec<crate::model::Error>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackfillJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BackfillJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::backfill_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::BackfillJob::trigger].
    pub fn set_trigger<T: std::convert::Into<crate::model::backfill_job::Trigger>>(
        mut self,
        v: T,
    ) -> Self {
        self.trigger = v.into();
        self
    }

    /// Sets the value of [last_start_time][crate::model::BackfillJob::last_start_time].
    pub fn set_last_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_start_time][crate::model::BackfillJob::last_start_time].
    pub fn set_or_clear_last_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_end_time][crate::model::BackfillJob::last_end_time].
    pub fn set_last_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_end_time][crate::model::BackfillJob::last_end_time].
    pub fn set_or_clear_last_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [errors][crate::model::BackfillJob::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BackfillJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.BackfillJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackfillJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __trigger,
            __last_start_time,
            __last_end_time,
            __errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackfillJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "trigger" => Ok(__FieldTag::__trigger),
                            "lastStartTime" => Ok(__FieldTag::__last_start_time),
                            "last_start_time" => Ok(__FieldTag::__last_start_time),
                            "lastEndTime" => Ok(__FieldTag::__last_end_time),
                            "last_end_time" => Ok(__FieldTag::__last_end_time),
                            "errors" => Ok(__FieldTag::__errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackfillJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackfillJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::backfill_job::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__trigger => {
                            if !fields.insert(__FieldTag::__trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger",
                                ));
                            }
                            result.trigger = map.next_value::<std::option::Option<crate::model::backfill_job::Trigger>>()?.unwrap_or_default();
                        }
                        __FieldTag::__last_start_time => {
                            if !fields.insert(__FieldTag::__last_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_start_time",
                                ));
                            }
                            result.last_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_end_time => {
                            if !fields.insert(__FieldTag::__last_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_end_time",
                                ));
                            }
                            result.last_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Error>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackfillJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.trigger) {
            state.serialize_entry("trigger", &self.trigger)?;
        }
        if self.last_start_time.is_some() {
            state.serialize_entry("lastStartTime", &self.last_start_time)?;
        }
        if self.last_end_time.is_some() {
            state.serialize_entry("lastEndTime", &self.last_end_time)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BackfillJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackfillJob");
        debug_struct.field("state", &self.state);
        debug_struct.field("trigger", &self.trigger);
        debug_struct.field("last_start_time", &self.last_start_time);
        debug_struct.field("last_end_time", &self.last_end_time);
        debug_struct.field("errors", &self.errors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BackfillJob].
pub mod backfill_job {
    #[allow(unused_imports)]
    use super::*;

    /// State of the stream object's backfill job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value.
        Unspecified,
        /// Backfill job was never started for the stream object (stream has backfill
        /// strategy defined as manual or object was explicitly excluded from
        /// automatic backfill).
        NotStarted,
        /// Backfill job will start pending available resources.
        Pending,
        /// Backfill job is running.
        Active,
        /// Backfill job stopped (next job run will start from beginning).
        Stopped,
        /// Backfill job failed (due to an error).
        Failed,
        /// Backfill completed successfully.
        Completed,
        /// Backfill job failed since the table structure is currently unsupported
        /// for backfill.
        Unsupported,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotStarted => std::option::Option::Some(1),
                Self::Pending => std::option::Option::Some(2),
                Self::Active => std::option::Option::Some(3),
                Self::Stopped => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Completed => std::option::Option::Some(6),
                Self::Unsupported => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::NotStarted => std::option::Option::Some("NOT_STARTED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::Unsupported => std::option::Option::Some("UNSUPPORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotStarted,
                2 => Self::Pending,
                3 => Self::Active,
                4 => Self::Stopped,
                5 => Self::Failed,
                6 => Self::Completed,
                7 => Self::Unsupported,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "NOT_STARTED" => Self::NotStarted,
                "PENDING" => Self::Pending,
                "ACTIVE" => Self::Active,
                "STOPPED" => Self::Stopped,
                "FAILED" => Self::Failed,
                "COMPLETED" => Self::Completed,
                "UNSUPPORTED" => Self::Unsupported,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotStarted => serializer.serialize_i32(1),
                Self::Pending => serializer.serialize_i32(2),
                Self::Active => serializer.serialize_i32(3),
                Self::Stopped => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Completed => serializer.serialize_i32(6),
                Self::Unsupported => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.datastream.v1.BackfillJob.State",
            ))
        }
    }

    /// Triggering reason for a backfill job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Trigger {
        /// Default value.
        Unspecified,
        /// Object backfill job was triggered automatically according to the stream's
        /// backfill strategy.
        Automatic,
        /// Object backfill job was triggered manually using the dedicated API.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Trigger::value] or
        /// [Trigger::name].
        UnknownValue(trigger::UnknownValue),
    }

    #[doc(hidden)]
    pub mod trigger {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Trigger {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automatic => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TRIGGER_UNSPECIFIED"),
                Self::Automatic => std::option::Option::Some("AUTOMATIC"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Trigger {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Trigger {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Trigger {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automatic,
                2 => Self::Manual,
                _ => Self::UnknownValue(trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Trigger {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRIGGER_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC" => Self::Automatic,
                "MANUAL" => Self::Manual,
                _ => Self::UnknownValue(trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Trigger {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automatic => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Trigger {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Trigger>::new(
                ".google.cloud.datastream.v1.BackfillJob.Trigger",
            ))
        }
    }
}

/// Represent a user-facing Error.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Error {
    /// A title that explains the reason for the error.
    pub reason: std::string::String,

    /// A unique identifier for this specific error,
    /// allowing it to be traced throughout the system in logs and API responses.
    pub error_uuid: std::string::String,

    /// A message containing more information about the error that occurred.
    pub message: std::string::String,

    /// The time when the error occurred.
    pub error_time: std::option::Option<wkt::Timestamp>,

    /// Additional information about the error.
    pub details: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Error {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reason][crate::model::Error::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }

    /// Sets the value of [error_uuid][crate::model::Error::error_uuid].
    pub fn set_error_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_uuid = v.into();
        self
    }

    /// Sets the value of [message][crate::model::Error::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [error_time][crate::model::Error::error_time].
    pub fn set_error_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.error_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_time][crate::model::Error::error_time].
    pub fn set_or_clear_error_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.error_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [details][crate::model::Error::details].
    pub fn set_details<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Error {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.Error"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Error {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reason,
            __error_uuid,
            __message,
            __error_time,
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Error")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reason" => Ok(__FieldTag::__reason),
                            "errorUuid" => Ok(__FieldTag::__error_uuid),
                            "error_uuid" => Ok(__FieldTag::__error_uuid),
                            "message" => Ok(__FieldTag::__message),
                            "errorTime" => Ok(__FieldTag::__error_time),
                            "error_time" => Ok(__FieldTag::__error_time),
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Error;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Error")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            result.reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_uuid => {
                            if !fields.insert(__FieldTag::__error_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_uuid",
                                ));
                            }
                            result.error_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_time => {
                            if !fields.insert(__FieldTag::__error_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_time",
                                ));
                            }
                            result.error_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Error {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reason.is_empty() {
            state.serialize_entry("reason", &self.reason)?;
        }
        if !self.error_uuid.is_empty() {
            state.serialize_entry("errorUuid", &self.error_uuid)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if self.error_time.is_some() {
            state.serialize_entry("errorTime", &self.error_time)?;
        }
        if !self.details.is_empty() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Error");
        debug_struct.field("reason", &self.reason);
        debug_struct.field("error_uuid", &self.error_uuid);
        debug_struct.field("message", &self.message);
        debug_struct.field("error_time", &self.error_time);
        debug_struct.field("details", &self.details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains the current validation results.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidationResult {
    /// A list of validations (includes both executed as well as not executed
    /// validations).
    pub validations: std::vec::Vec<crate::model::Validation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidationResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [validations][crate::model::ValidationResult::validations].
    pub fn set_validations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Validation>,
    {
        use std::iter::Iterator;
        self.validations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ValidationResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ValidationResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __validations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidationResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "validations" => Ok(__FieldTag::__validations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidationResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidationResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__validations => {
                            if !fields.insert(__FieldTag::__validations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validations",
                                ));
                            }
                            result.validations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Validation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValidationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.validations.is_empty() {
            state.serialize_entry("validations", &self.validations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ValidationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValidationResult");
        debug_struct.field("validations", &self.validations);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A validation to perform on a stream.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Validation {
    /// A short description of the validation.
    pub description: std::string::String,

    /// Output only. Validation execution status.
    pub state: crate::model::validation::State,

    /// Messages reflecting the validation results.
    pub message: std::vec::Vec<crate::model::ValidationMessage>,

    /// A custom code identifying this validation.
    pub code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Validation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::Validation::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Validation::state].
    pub fn set_state<T: std::convert::Into<crate::model::validation::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [message][crate::model::Validation::message].
    pub fn set_message<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ValidationMessage>,
    {
        use std::iter::Iterator;
        self.message = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [code][crate::model::Validation::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for Validation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.Validation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Validation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __description,
            __state,
            __message,
            __code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Validation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "description" => Ok(__FieldTag::__description),
                            "state" => Ok(__FieldTag::__state),
                            "message" => Ok(__FieldTag::__message),
                            "code" => Ok(__FieldTag::__code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Validation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Validation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::validation::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ValidationMessage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Validation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Validation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Validation");
        debug_struct.field("description", &self.description);
        debug_struct.field("state", &self.state);
        debug_struct.field("message", &self.message);
        debug_struct.field("code", &self.code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Validation].
pub mod validation {
    #[allow(unused_imports)]
    use super::*;

    /// Validation execution state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// Validation did not execute.
        NotExecuted,
        /// Validation failed.
        Failed,
        /// Validation passed.
        Passed,
        /// Validation executed with warnings.
        Warning,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotExecuted => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Passed => std::option::Option::Some(3),
                Self::Warning => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::NotExecuted => std::option::Option::Some("NOT_EXECUTED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Passed => std::option::Option::Some("PASSED"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotExecuted,
                2 => Self::Failed,
                3 => Self::Passed,
                4 => Self::Warning,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "NOT_EXECUTED" => Self::NotExecuted,
                "FAILED" => Self::Failed,
                "PASSED" => Self::Passed,
                "WARNING" => Self::Warning,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotExecuted => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Passed => serializer.serialize_i32(3),
                Self::Warning => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.datastream.v1.Validation.State",
            ))
        }
    }
}

/// Represent user-facing validation result message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidationMessage {
    /// The result of the validation.
    pub message: std::string::String,

    /// Message severity level (warning or error).
    pub level: crate::model::validation_message::Level,

    /// Additional metadata related to the result.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// A custom code identifying this specific message.
    pub code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidationMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::ValidationMessage::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [level][crate::model::ValidationMessage::level].
    pub fn set_level<T: std::convert::Into<crate::model::validation_message::Level>>(
        mut self,
        v: T,
    ) -> Self {
        self.level = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ValidationMessage::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [code][crate::model::ValidationMessage::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for ValidationMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.ValidationMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidationMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __level,
            __metadata,
            __code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidationMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "level" => Ok(__FieldTag::__level),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "code" => Ok(__FieldTag::__code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidationMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidationMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__level => {
                            if !fields.insert(__FieldTag::__level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for level",
                                ));
                            }
                            result.level = map.next_value::<std::option::Option<crate::model::validation_message::Level>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValidationMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !wkt::internal::is_default(&self.level) {
            state.serialize_entry("level", &self.level)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ValidationMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValidationMessage");
        debug_struct.field("message", &self.message);
        debug_struct.field("level", &self.level);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("code", &self.code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ValidationMessage].
pub mod validation_message {
    #[allow(unused_imports)]
    use super::*;

    /// Validation message level.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Level {
        /// Unspecified level.
        Unspecified,
        /// Potentially cause issues with the Stream.
        Warning,
        /// Definitely cause issues with the Stream.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Level::value] or
        /// [Level::name].
        UnknownValue(level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Level {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Warning => std::option::Option::Some(1),
                Self::Error => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LEVEL_UNSPECIFIED"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Level {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Level {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Level {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Warning,
                2 => Self::Error,
                _ => Self::UnknownValue(level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Level {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LEVEL_UNSPECIFIED" => Self::Unspecified,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Level {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Warning => serializer.serialize_i32(1),
                Self::Error => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Level {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Level>::new(
                ".google.cloud.datastream.v1.ValidationMessage.Level",
            ))
        }
    }
}

/// The strategy that the stream uses for CDC replication.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CdcStrategy {
    /// The position to start reading from when starting, resuming, or recovering
    /// the stream.
    /// If not set, the system's default value will be used.
    pub start_position: std::option::Option<crate::model::cdc_strategy::StartPosition>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CdcStrategy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_position][crate::model::CdcStrategy::start_position].
    ///
    /// Note that all the setters affecting `start_position` are mutually
    /// exclusive.
    pub fn set_start_position<
        T: std::convert::Into<std::option::Option<crate::model::cdc_strategy::StartPosition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.start_position = v.into();
        self
    }

    /// The value of [start_position][crate::model::CdcStrategy::start_position]
    /// if it holds a `MostRecentStartPosition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn most_recent_start_position(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cdc_strategy::MostRecentStartPosition>>
    {
        #[allow(unreachable_patterns)]
        self.start_position.as_ref().and_then(|v| match v {
            crate::model::cdc_strategy::StartPosition::MostRecentStartPosition(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [start_position][crate::model::CdcStrategy::start_position]
    /// to hold a `MostRecentStartPosition`.
    ///
    /// Note that all the setters affecting `start_position` are
    /// mutually exclusive.
    pub fn set_most_recent_start_position<
        T: std::convert::Into<std::boxed::Box<crate::model::cdc_strategy::MostRecentStartPosition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.start_position = std::option::Option::Some(
            crate::model::cdc_strategy::StartPosition::MostRecentStartPosition(v.into()),
        );
        self
    }

    /// The value of [start_position][crate::model::CdcStrategy::start_position]
    /// if it holds a `NextAvailableStartPosition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn next_available_start_position(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cdc_strategy::NextAvailableStartPosition>>
    {
        #[allow(unreachable_patterns)]
        self.start_position.as_ref().and_then(|v| match v {
            crate::model::cdc_strategy::StartPosition::NextAvailableStartPosition(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [start_position][crate::model::CdcStrategy::start_position]
    /// to hold a `NextAvailableStartPosition`.
    ///
    /// Note that all the setters affecting `start_position` are
    /// mutually exclusive.
    pub fn set_next_available_start_position<
        T: std::convert::Into<std::boxed::Box<crate::model::cdc_strategy::NextAvailableStartPosition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.start_position = std::option::Option::Some(
            crate::model::cdc_strategy::StartPosition::NextAvailableStartPosition(v.into()),
        );
        self
    }

    /// The value of [start_position][crate::model::CdcStrategy::start_position]
    /// if it holds a `SpecificStartPosition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn specific_start_position(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cdc_strategy::SpecificStartPosition>>
    {
        #[allow(unreachable_patterns)]
        self.start_position.as_ref().and_then(|v| match v {
            crate::model::cdc_strategy::StartPosition::SpecificStartPosition(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [start_position][crate::model::CdcStrategy::start_position]
    /// to hold a `SpecificStartPosition`.
    ///
    /// Note that all the setters affecting `start_position` are
    /// mutually exclusive.
    pub fn set_specific_start_position<
        T: std::convert::Into<std::boxed::Box<crate::model::cdc_strategy::SpecificStartPosition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.start_position = std::option::Option::Some(
            crate::model::cdc_strategy::StartPosition::SpecificStartPosition(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CdcStrategy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.CdcStrategy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CdcStrategy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __most_recent_start_position,
            __next_available_start_position,
            __specific_start_position,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CdcStrategy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mostRecentStartPosition" => {
                                Ok(__FieldTag::__most_recent_start_position)
                            }
                            "most_recent_start_position" => {
                                Ok(__FieldTag::__most_recent_start_position)
                            }
                            "nextAvailableStartPosition" => {
                                Ok(__FieldTag::__next_available_start_position)
                            }
                            "next_available_start_position" => {
                                Ok(__FieldTag::__next_available_start_position)
                            }
                            "specificStartPosition" => Ok(__FieldTag::__specific_start_position),
                            "specific_start_position" => Ok(__FieldTag::__specific_start_position),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CdcStrategy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CdcStrategy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__most_recent_start_position => {
                            if !fields.insert(__FieldTag::__most_recent_start_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for most_recent_start_position",
                                ));
                            }
                            if result.start_position.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `start_position`, a oneof with full ID .google.cloud.datastream.v1.CdcStrategy.most_recent_start_position, latest field was mostRecentStartPosition",
                                ));
                            }
                            result.start_position = std::option::Option::Some(
                                crate::model::cdc_strategy::StartPosition::MostRecentStartPosition(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::cdc_strategy::MostRecentStartPosition,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__next_available_start_position => {
                            if !fields.insert(__FieldTag::__next_available_start_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_available_start_position",
                                ));
                            }
                            if result.start_position.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `start_position`, a oneof with full ID .google.cloud.datastream.v1.CdcStrategy.next_available_start_position, latest field was nextAvailableStartPosition",
                                ));
                            }
                            result.start_position = std::option::Option::Some(
                                crate::model::cdc_strategy::StartPosition::NextAvailableStartPosition(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::cdc_strategy::NextAvailableStartPosition>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__specific_start_position => {
                            if !fields.insert(__FieldTag::__specific_start_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for specific_start_position",
                                ));
                            }
                            if result.start_position.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `start_position`, a oneof with full ID .google.cloud.datastream.v1.CdcStrategy.specific_start_position, latest field was specificStartPosition",
                                ));
                            }
                            result.start_position = std::option::Option::Some(
                                crate::model::cdc_strategy::StartPosition::SpecificStartPosition(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::cdc_strategy::SpecificStartPosition,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CdcStrategy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.most_recent_start_position() {
            state.serialize_entry("mostRecentStartPosition", value)?;
        }
        if let Some(value) = self.next_available_start_position() {
            state.serialize_entry("nextAvailableStartPosition", value)?;
        }
        if let Some(value) = self.specific_start_position() {
            state.serialize_entry("specificStartPosition", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CdcStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CdcStrategy");
        debug_struct.field("start_position", &self.start_position);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CdcStrategy].
pub mod cdc_strategy {
    #[allow(unused_imports)]
    use super::*;

    /// CDC strategy to start replicating from the most recent position in the
    /// source.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MostRecentStartPosition {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MostRecentStartPosition {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for MostRecentStartPosition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.CdcStrategy.MostRecentStartPosition"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MostRecentStartPosition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MostRecentStartPosition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MostRecentStartPosition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MostRecentStartPosition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MostRecentStartPosition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for MostRecentStartPosition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("MostRecentStartPosition");
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// CDC strategy to resume replication from the next available position in the
    /// source.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NextAvailableStartPosition {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NextAvailableStartPosition {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for NextAvailableStartPosition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.CdcStrategy.NextAvailableStartPosition"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NextAvailableStartPosition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NextAvailableStartPosition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NextAvailableStartPosition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NextAvailableStartPosition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NextAvailableStartPosition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for NextAvailableStartPosition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("NextAvailableStartPosition");
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// CDC strategy to start replicating from a specific position in the source.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SpecificStartPosition {
        pub position:
            std::option::Option<crate::model::cdc_strategy::specific_start_position::Position>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SpecificStartPosition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [position][crate::model::cdc_strategy::SpecificStartPosition::position].
        ///
        /// Note that all the setters affecting `position` are mutually
        /// exclusive.
        pub fn set_position<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::cdc_strategy::specific_start_position::Position,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.position = v.into();
            self
        }

        /// The value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// if it holds a `MysqlLogPosition`, `None` if the field is not set or
        /// holds a different branch.
        pub fn mysql_log_position(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::MysqlLogPosition>> {
            #[allow(unreachable_patterns)]
            self.position.as_ref().and_then(|v| match v {
                crate::model::cdc_strategy::specific_start_position::Position::MysqlLogPosition(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// to hold a `MysqlLogPosition`.
        ///
        /// Note that all the setters affecting `position` are
        /// mutually exclusive.
        pub fn set_mysql_log_position<
            T: std::convert::Into<std::boxed::Box<crate::model::MysqlLogPosition>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.position = std::option::Option::Some(
                crate::model::cdc_strategy::specific_start_position::Position::MysqlLogPosition(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// if it holds a `OracleScnPosition`, `None` if the field is not set or
        /// holds a different branch.
        pub fn oracle_scn_position(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::OracleScnPosition>> {
            #[allow(unreachable_patterns)]
            self.position.as_ref().and_then(|v| match v {
                crate::model::cdc_strategy::specific_start_position::Position::OracleScnPosition(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// to hold a `OracleScnPosition`.
        ///
        /// Note that all the setters affecting `position` are
        /// mutually exclusive.
        pub fn set_oracle_scn_position<
            T: std::convert::Into<std::boxed::Box<crate::model::OracleScnPosition>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.position = std::option::Option::Some(
                crate::model::cdc_strategy::specific_start_position::Position::OracleScnPosition(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// if it holds a `SqlServerLsnPosition`, `None` if the field is not set or
        /// holds a different branch.
        pub fn sql_server_lsn_position(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerLsnPosition>> {
            #[allow(unreachable_patterns)]
            self.position.as_ref().and_then(|v| match v {
                crate::model::cdc_strategy::specific_start_position::Position::SqlServerLsnPosition(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// to hold a `SqlServerLsnPosition`.
        ///
        /// Note that all the setters affecting `position` are
        /// mutually exclusive.
        pub fn set_sql_server_lsn_position<
            T: std::convert::Into<std::boxed::Box<crate::model::SqlServerLsnPosition>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.position = std::option::Option::Some(
                crate::model::cdc_strategy::specific_start_position::Position::SqlServerLsnPosition(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// if it holds a `MysqlGtidPosition`, `None` if the field is not set or
        /// holds a different branch.
        pub fn mysql_gtid_position(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::MysqlGtidPosition>> {
            #[allow(unreachable_patterns)]
            self.position.as_ref().and_then(|v| match v {
                crate::model::cdc_strategy::specific_start_position::Position::MysqlGtidPosition(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [position][crate::model::cdc_strategy::SpecificStartPosition::position]
        /// to hold a `MysqlGtidPosition`.
        ///
        /// Note that all the setters affecting `position` are
        /// mutually exclusive.
        pub fn set_mysql_gtid_position<
            T: std::convert::Into<std::boxed::Box<crate::model::MysqlGtidPosition>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.position = std::option::Option::Some(
                crate::model::cdc_strategy::specific_start_position::Position::MysqlGtidPosition(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for SpecificStartPosition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datastream.v1.CdcStrategy.SpecificStartPosition"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SpecificStartPosition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __mysql_log_position,
                __oracle_scn_position,
                __sql_server_lsn_position,
                __mysql_gtid_position,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SpecificStartPosition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "mysqlLogPosition" => Ok(__FieldTag::__mysql_log_position),
                                "mysql_log_position" => Ok(__FieldTag::__mysql_log_position),
                                "oracleScnPosition" => Ok(__FieldTag::__oracle_scn_position),
                                "oracle_scn_position" => Ok(__FieldTag::__oracle_scn_position),
                                "sqlServerLsnPosition" => Ok(__FieldTag::__sql_server_lsn_position),
                                "sql_server_lsn_position" => {
                                    Ok(__FieldTag::__sql_server_lsn_position)
                                }
                                "mysqlGtidPosition" => Ok(__FieldTag::__mysql_gtid_position),
                                "mysql_gtid_position" => Ok(__FieldTag::__mysql_gtid_position),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SpecificStartPosition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SpecificStartPosition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__mysql_log_position => {
                                if !fields.insert(__FieldTag::__mysql_log_position) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mysql_log_position",
                                    ));
                                }
                                if result.position.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `position`, a oneof with full ID .google.cloud.datastream.v1.CdcStrategy.SpecificStartPosition.mysql_log_position, latest field was mysqlLogPosition",
                                    ));
                                }
                                result.position = std::option::Option::Some(
                                    crate::model::cdc_strategy::specific_start_position::Position::MysqlLogPosition(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::MysqlLogPosition>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__oracle_scn_position => {
                                if !fields.insert(__FieldTag::__oracle_scn_position) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for oracle_scn_position",
                                    ));
                                }
                                if result.position.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `position`, a oneof with full ID .google.cloud.datastream.v1.CdcStrategy.SpecificStartPosition.oracle_scn_position, latest field was oracleScnPosition",
                                    ));
                                }
                                result.position = std::option::Option::Some(
                                    crate::model::cdc_strategy::specific_start_position::Position::OracleScnPosition(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::OracleScnPosition>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__sql_server_lsn_position => {
                                if !fields.insert(__FieldTag::__sql_server_lsn_position) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sql_server_lsn_position",
                                    ));
                                }
                                if result.position.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `position`, a oneof with full ID .google.cloud.datastream.v1.CdcStrategy.SpecificStartPosition.sql_server_lsn_position, latest field was sqlServerLsnPosition",
                                    ));
                                }
                                result.position = std::option::Option::Some(
                                    crate::model::cdc_strategy::specific_start_position::Position::SqlServerLsnPosition(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::SqlServerLsnPosition>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__mysql_gtid_position => {
                                if !fields.insert(__FieldTag::__mysql_gtid_position) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mysql_gtid_position",
                                    ));
                                }
                                if result.position.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `position`, a oneof with full ID .google.cloud.datastream.v1.CdcStrategy.SpecificStartPosition.mysql_gtid_position, latest field was mysqlGtidPosition",
                                    ));
                                }
                                result.position = std::option::Option::Some(
                                    crate::model::cdc_strategy::specific_start_position::Position::MysqlGtidPosition(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::MysqlGtidPosition>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SpecificStartPosition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.mysql_log_position() {
                state.serialize_entry("mysqlLogPosition", value)?;
            }
            if let Some(value) = self.oracle_scn_position() {
                state.serialize_entry("oracleScnPosition", value)?;
            }
            if let Some(value) = self.sql_server_lsn_position() {
                state.serialize_entry("sqlServerLsnPosition", value)?;
            }
            if let Some(value) = self.mysql_gtid_position() {
                state.serialize_entry("mysqlGtidPosition", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SpecificStartPosition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SpecificStartPosition");
            debug_struct.field("position", &self.position);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [SpecificStartPosition].
    pub mod specific_start_position {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Position {
            /// MySQL specific log position to start replicating from.
            MysqlLogPosition(std::boxed::Box<crate::model::MysqlLogPosition>),
            /// Oracle SCN to start replicating from.
            OracleScnPosition(std::boxed::Box<crate::model::OracleScnPosition>),
            /// SqlServer LSN to start replicating from.
            SqlServerLsnPosition(std::boxed::Box<crate::model::SqlServerLsnPosition>),
            /// MySQL GTID set to start replicating from.
            MysqlGtidPosition(std::boxed::Box<crate::model::MysqlGtidPosition>),
        }
    }

    /// The position to start reading from when starting, resuming, or recovering
    /// the stream.
    /// If not set, the system's default value will be used.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StartPosition {
        /// Optional. Start replicating from the most recent position in the source.
        MostRecentStartPosition(
            std::boxed::Box<crate::model::cdc_strategy::MostRecentStartPosition>,
        ),
        /// Optional. Resume replication from the next available position in the
        /// source.
        NextAvailableStartPosition(
            std::boxed::Box<crate::model::cdc_strategy::NextAvailableStartPosition>,
        ),
        /// Optional. Start replicating from a specific position in the source.
        SpecificStartPosition(std::boxed::Box<crate::model::cdc_strategy::SpecificStartPosition>),
    }
}

/// SQL Server LSN position
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlServerLsnPosition {
    /// Required. Log sequence number (LSN) from where Logs will be read
    pub lsn: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerLsnPosition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lsn][crate::model::SqlServerLsnPosition::lsn].
    pub fn set_lsn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lsn = v.into();
        self
    }
}

impl wkt::message::Message for SqlServerLsnPosition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.SqlServerLsnPosition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlServerLsnPosition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __lsn,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlServerLsnPosition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lsn" => Ok(__FieldTag::__lsn),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlServerLsnPosition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlServerLsnPosition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__lsn => {
                            if !fields.insert(__FieldTag::__lsn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lsn",
                                ));
                            }
                            result.lsn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlServerLsnPosition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.lsn.is_empty() {
            state.serialize_entry("lsn", &self.lsn)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SqlServerLsnPosition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlServerLsnPosition");
        debug_struct.field("lsn", &self.lsn);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Oracle SCN position
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OracleScnPosition {
    /// Required. SCN number from where Logs will be read
    pub scn: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleScnPosition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scn][crate::model::OracleScnPosition::scn].
    pub fn set_scn<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.scn = v.into();
        self
    }
}

impl wkt::message::Message for OracleScnPosition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.OracleScnPosition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OracleScnPosition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scn,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OracleScnPosition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scn" => Ok(__FieldTag::__scn),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OracleScnPosition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OracleScnPosition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scn => {
                            if !fields.insert(__FieldTag::__scn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scn",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scn = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OracleScnPosition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.scn) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scn", &__With(&self.scn))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OracleScnPosition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OracleScnPosition");
        debug_struct.field("scn", &self.scn);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MySQL log position
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MysqlLogPosition {
    /// Required. The binary log file name.
    pub log_file: std::string::String,

    /// Optional. The position within the binary log file. Default is head of file.
    pub log_position: std::option::Option<i32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlLogPosition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_file][crate::model::MysqlLogPosition::log_file].
    pub fn set_log_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_file = v.into();
        self
    }

    /// Sets the value of [log_position][crate::model::MysqlLogPosition::log_position].
    pub fn set_log_position<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.log_position = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [log_position][crate::model::MysqlLogPosition::log_position].
    pub fn set_or_clear_log_position<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.log_position = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MysqlLogPosition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlLogPosition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MysqlLogPosition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_file,
            __log_position,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MysqlLogPosition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logFile" => Ok(__FieldTag::__log_file),
                            "log_file" => Ok(__FieldTag::__log_file),
                            "logPosition" => Ok(__FieldTag::__log_position),
                            "log_position" => Ok(__FieldTag::__log_position),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MysqlLogPosition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MysqlLogPosition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_file => {
                            if !fields.insert(__FieldTag::__log_file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_file",
                                ));
                            }
                            result.log_file = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__log_position => {
                            if !fields.insert(__FieldTag::__log_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_position",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.log_position = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MysqlLogPosition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.log_file.is_empty() {
            state.serialize_entry("logFile", &self.log_file)?;
        }
        if self.log_position.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("logPosition", &__With(&self.log_position))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MysqlLogPosition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MysqlLogPosition");
        debug_struct.field("log_file", &self.log_file);
        debug_struct.field("log_position", &self.log_position);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MySQL GTID position
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MysqlGtidPosition {
    /// Required. The gtid set to start replication from.
    pub gtid_set: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MysqlGtidPosition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gtid_set][crate::model::MysqlGtidPosition::gtid_set].
    pub fn set_gtid_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gtid_set = v.into();
        self
    }
}

impl wkt::message::Message for MysqlGtidPosition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datastream.v1.MysqlGtidPosition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MysqlGtidPosition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gtid_set,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MysqlGtidPosition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gtidSet" => Ok(__FieldTag::__gtid_set),
                            "gtid_set" => Ok(__FieldTag::__gtid_set),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MysqlGtidPosition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MysqlGtidPosition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gtid_set => {
                            if !fields.insert(__FieldTag::__gtid_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gtid_set",
                                ));
                            }
                            result.gtid_set = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MysqlGtidPosition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gtid_set.is_empty() {
            state.serialize_entry("gtidSet", &self.gtid_set)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MysqlGtidPosition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MysqlGtidPosition");
        debug_struct.field("gtid_set", &self.gtid_set);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
