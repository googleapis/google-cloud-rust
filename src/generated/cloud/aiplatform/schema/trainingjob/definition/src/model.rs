// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate std;
extern crate bytes;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// A TrainingJob that trains and uploads an AutoML Image Classification Model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlImageClassification {

    /// The input parameters of this TrainingJob.
    pub inputs: std::option::Option<crate::model::AutoMlImageClassificationInputs>,

    /// The metadata information.
    pub metadata: std::option::Option<crate::model::AutoMlImageClassificationMetadata>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlImageClassification {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inputs][crate::model::AutoMlImageClassification::inputs].
    pub fn set_inputs<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlImageClassificationInputs>
    {
        self.inputs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inputs][crate::model::AutoMlImageClassification::inputs].
    pub fn set_or_clear_inputs<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlImageClassificationInputs>
    {
        self.inputs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::AutoMlImageClassification::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlImageClassificationMetadata>
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::AutoMlImageClassification::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlImageClassificationMetadata>
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutoMlImageClassification {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageClassification"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlImageClassificationInputs {

    pub model_type: crate::model::auto_ml_image_classification_inputs::ModelType,

    /// The ID of the `base` model. If it is specified, the new model will be
    /// trained based on the `base` model. Otherwise, the new model will be
    /// trained from scratch. The `base` model must be in the same
    /// Project and Location as the new Model to train, and have the same
    /// modelType.
    pub base_model_id: std::string::String,

    /// The training budget of creating this model, expressed in milli node
    /// hours i.e. 1,000 value in this field means 1 node hour. The actual
    /// metadata.costMilliNodeHours will be equal or less than this value.
    /// If further model training ceases to provide any improvements, it will
    /// stop without using the full budget and the metadata.successfulStopReason
    /// will be `model-converged`.
    /// Note, node_hour  = actual_hour * number_of_nodes_involved.
    /// For modelType `cloud`(default), the budget must be between 8,000
    /// and 800,000 milli node hours, inclusive. The default value is 192,000
    /// which represents one day in wall time, considering 8 nodes are used.
    /// For model types `mobile-tf-low-latency-1`, `mobile-tf-versatile-1`,
    /// `mobile-tf-high-accuracy-1`, the training budget must be between
    /// 1,000 and 100,000 milli node hours, inclusive.
    /// The default value is 24,000 which represents one day in wall time on a
    /// single node that is used.
    pub budget_milli_node_hours: i64,

    /// Use the entire training budget. This disables the early stopping feature.
    /// When false the early stopping feature is enabled, which means that
    /// AutoML Image Classification might stop training before the entire
    /// training budget has been used.
    pub disable_early_stopping: bool,

    /// If false, a single-label (multi-class) Model will be trained (i.e.
    /// assuming that for each image just up to one annotation may be
    /// applicable). If true, a multi-label Model will be trained (i.e.
    /// assuming that for each image multiple annotations may be applicable).
    pub multi_label: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlImageClassificationInputs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_type][crate::model::AutoMlImageClassificationInputs::model_type].
    pub fn set_model_type<T: std::convert::Into<crate::model::auto_ml_image_classification_inputs::ModelType>>(mut self, v: T) -> Self {
        self.model_type = v.into();
        self
    }

    /// Sets the value of [base_model_id][crate::model::AutoMlImageClassificationInputs::base_model_id].
    pub fn set_base_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_model_id = v.into();
        self
    }

    /// Sets the value of [budget_milli_node_hours][crate::model::AutoMlImageClassificationInputs::budget_milli_node_hours].
    pub fn set_budget_milli_node_hours<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.budget_milli_node_hours = v.into();
        self
    }

    /// Sets the value of [disable_early_stopping][crate::model::AutoMlImageClassificationInputs::disable_early_stopping].
    pub fn set_disable_early_stopping<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_early_stopping = v.into();
        self
    }

    /// Sets the value of [multi_label][crate::model::AutoMlImageClassificationInputs::multi_label].
    pub fn set_multi_label<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.multi_label = v.into();
        self
    }
}

impl wkt::message::Message for AutoMlImageClassificationInputs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageClassificationInputs"
    }
}

/// Defines additional types related to [AutoMlImageClassificationInputs].
pub mod auto_ml_image_classification_inputs {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelType {
        /// Should not be set.
        Unspecified,
        /// A Model best tailored to be used within Google Cloud, and which cannot
        /// be exported.
        /// Default.
        Cloud,
        /// A model that, in addition to being available within Google
        /// Cloud, can also be exported (see ModelService.ExportModel) as TensorFlow
        /// or Core ML model and used on a mobile or edge device afterwards.
        /// Expected to have low latency, but may have lower prediction
        /// quality than other mobile models.
        MobileTfLowLatency1,
        /// A model that, in addition to being available within Google
        /// Cloud, can also be exported (see ModelService.ExportModel) as TensorFlow
        /// or Core ML model and used on a mobile or edge device with afterwards.
        MobileTfVersatile1,
        /// A model that, in addition to being available within Google
        /// Cloud, can also be exported (see ModelService.ExportModel) as TensorFlow
        /// or Core ML model and used on a mobile or edge device afterwards.
        /// Expected to have a higher latency, but should also have a higher
        /// prediction quality than other mobile models.
        MobileTfHighAccuracy1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelType::value] or
        /// [ModelType::name].
        UnknownValue(model_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Cloud => std::option::Option::Some(1),
                Self::MobileTfLowLatency1 => std::option::Option::Some(2),
                Self::MobileTfVersatile1 => std::option::Option::Some(3),
                Self::MobileTfHighAccuracy1 => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_TYPE_UNSPECIFIED"),
                Self::Cloud => std::option::Option::Some("CLOUD"),
                Self::MobileTfLowLatency1 => std::option::Option::Some("MOBILE_TF_LOW_LATENCY_1"),
                Self::MobileTfVersatile1 => std::option::Option::Some("MOBILE_TF_VERSATILE_1"),
                Self::MobileTfHighAccuracy1 => std::option::Option::Some("MOBILE_TF_HIGH_ACCURACY_1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Cloud,
                2 => Self::MobileTfLowLatency1,
                3 => Self::MobileTfVersatile1,
                4 => Self::MobileTfHighAccuracy1,
                _ => Self::UnknownValue(model_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ModelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD" => Self::Cloud,
                "MOBILE_TF_LOW_LATENCY_1" => Self::MobileTfLowLatency1,
                "MOBILE_TF_VERSATILE_1" => Self::MobileTfVersatile1,
                "MOBILE_TF_HIGH_ACCURACY_1" => Self::MobileTfHighAccuracy1,
                _ => Self::UnknownValue(model_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ModelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Cloud => serializer.serialize_i32(1),
                Self::MobileTfLowLatency1 => serializer.serialize_i32(2),
                Self::MobileTfVersatile1 => serializer.serialize_i32(3),
                Self::MobileTfHighAccuracy1 => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelType>::new(
                ".google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageClassificationInputs.ModelType"))
        }
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlImageClassificationMetadata {

    /// The actual training cost of creating this model, expressed in
    /// milli node hours, i.e. 1,000 value in this field means 1 node hour.
    /// Guaranteed to not exceed inputs.budgetMilliNodeHours.
    pub cost_milli_node_hours: i64,

    /// For successful job completions, this is the reason why the job has
    /// finished.
    pub successful_stop_reason: crate::model::auto_ml_image_classification_metadata::SuccessfulStopReason,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlImageClassificationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cost_milli_node_hours][crate::model::AutoMlImageClassificationMetadata::cost_milli_node_hours].
    pub fn set_cost_milli_node_hours<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.cost_milli_node_hours = v.into();
        self
    }

    /// Sets the value of [successful_stop_reason][crate::model::AutoMlImageClassificationMetadata::successful_stop_reason].
    pub fn set_successful_stop_reason<T: std::convert::Into<crate::model::auto_ml_image_classification_metadata::SuccessfulStopReason>>(mut self, v: T) -> Self {
        self.successful_stop_reason = v.into();
        self
    }
}

impl wkt::message::Message for AutoMlImageClassificationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageClassificationMetadata"
    }
}

/// Defines additional types related to [AutoMlImageClassificationMetadata].
pub mod auto_ml_image_classification_metadata {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SuccessfulStopReason {
        /// Should not be set.
        Unspecified,
        /// The inputs.budgetMilliNodeHours had been reached.
        BudgetReached,
        /// Further training of the Model ceased to increase its quality, since it
        /// already has converged.
        ModelConverged,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SuccessfulStopReason::value] or
        /// [SuccessfulStopReason::name].
        UnknownValue(successful_stop_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod successful_stop_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SuccessfulStopReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BudgetReached => std::option::Option::Some(1),
                Self::ModelConverged => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SUCCESSFUL_STOP_REASON_UNSPECIFIED"),
                Self::BudgetReached => std::option::Option::Some("BUDGET_REACHED"),
                Self::ModelConverged => std::option::Option::Some("MODEL_CONVERGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SuccessfulStopReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SuccessfulStopReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SuccessfulStopReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BudgetReached,
                2 => Self::ModelConverged,
                _ => Self::UnknownValue(successful_stop_reason::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for SuccessfulStopReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SUCCESSFUL_STOP_REASON_UNSPECIFIED" => Self::Unspecified,
                "BUDGET_REACHED" => Self::BudgetReached,
                "MODEL_CONVERGED" => Self::ModelConverged,
                _ => Self::UnknownValue(successful_stop_reason::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for SuccessfulStopReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BudgetReached => serializer.serialize_i32(1),
                Self::ModelConverged => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SuccessfulStopReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SuccessfulStopReason>::new(
                ".google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageClassificationMetadata.SuccessfulStopReason"))
        }
    }
}

/// A TrainingJob that trains and uploads an AutoML Image Object Detection Model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlImageObjectDetection {

    /// The input parameters of this TrainingJob.
    pub inputs: std::option::Option<crate::model::AutoMlImageObjectDetectionInputs>,

    /// The metadata information
    pub metadata: std::option::Option<crate::model::AutoMlImageObjectDetectionMetadata>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlImageObjectDetection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inputs][crate::model::AutoMlImageObjectDetection::inputs].
    pub fn set_inputs<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlImageObjectDetectionInputs>
    {
        self.inputs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inputs][crate::model::AutoMlImageObjectDetection::inputs].
    pub fn set_or_clear_inputs<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlImageObjectDetectionInputs>
    {
        self.inputs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::AutoMlImageObjectDetection::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlImageObjectDetectionMetadata>
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::AutoMlImageObjectDetection::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlImageObjectDetectionMetadata>
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutoMlImageObjectDetection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageObjectDetection"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlImageObjectDetectionInputs {

    pub model_type: crate::model::auto_ml_image_object_detection_inputs::ModelType,

    /// The training budget of creating this model, expressed in milli node
    /// hours i.e. 1,000 value in this field means 1 node hour. The actual
    /// metadata.costMilliNodeHours will be equal or less than this value.
    /// If further model training ceases to provide any improvements, it will
    /// stop without using the full budget and the metadata.successfulStopReason
    /// will be `model-converged`.
    /// Note, node_hour  = actual_hour * number_of_nodes_involved.
    /// For modelType `cloud`(default), the budget must be between 20,000
    /// and 900,000 milli node hours, inclusive. The default value is 216,000
    /// which represents one day in wall time, considering 9 nodes are used.
    /// For model types `mobile-tf-low-latency-1`, `mobile-tf-versatile-1`,
    /// `mobile-tf-high-accuracy-1`
    /// the training budget must be between 1,000 and 100,000 milli node hours,
    /// inclusive. The default value is 24,000 which represents one day in
    /// wall time on a single node that is used.
    pub budget_milli_node_hours: i64,

    /// Use the entire training budget. This disables the early stopping feature.
    /// When false the early stopping feature is enabled, which means that AutoML
    /// Image Object Detection might stop training before the entire training
    /// budget has been used.
    pub disable_early_stopping: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlImageObjectDetectionInputs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_type][crate::model::AutoMlImageObjectDetectionInputs::model_type].
    pub fn set_model_type<T: std::convert::Into<crate::model::auto_ml_image_object_detection_inputs::ModelType>>(mut self, v: T) -> Self {
        self.model_type = v.into();
        self
    }

    /// Sets the value of [budget_milli_node_hours][crate::model::AutoMlImageObjectDetectionInputs::budget_milli_node_hours].
    pub fn set_budget_milli_node_hours<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.budget_milli_node_hours = v.into();
        self
    }

    /// Sets the value of [disable_early_stopping][crate::model::AutoMlImageObjectDetectionInputs::disable_early_stopping].
    pub fn set_disable_early_stopping<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_early_stopping = v.into();
        self
    }
}

impl wkt::message::Message for AutoMlImageObjectDetectionInputs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageObjectDetectionInputs"
    }
}

/// Defines additional types related to [AutoMlImageObjectDetectionInputs].
pub mod auto_ml_image_object_detection_inputs {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelType {
        /// Should not be set.
        Unspecified,
        /// A model best tailored to be used within Google Cloud, and which cannot
        /// be exported. Expected to have a higher latency, but should also have a
        /// higher prediction quality than other cloud models.
        CloudHighAccuracy1,
        /// A model best tailored to be used within Google Cloud, and which cannot
        /// be exported. Expected to have a low latency, but may have lower
        /// prediction quality than other cloud models.
        CloudLowLatency1,
        /// A model that, in addition to being available within Google
        /// Cloud can also be exported (see ModelService.ExportModel) and
        /// used on a mobile or edge device with TensorFlow afterwards.
        /// Expected to have low latency, but may have lower prediction
        /// quality than other mobile models.
        MobileTfLowLatency1,
        /// A model that, in addition to being available within Google
        /// Cloud can also be exported (see ModelService.ExportModel) and
        /// used on a mobile or edge device with TensorFlow afterwards.
        MobileTfVersatile1,
        /// A model that, in addition to being available within Google
        /// Cloud, can also be exported (see ModelService.ExportModel) and
        /// used on a mobile or edge device with TensorFlow afterwards.
        /// Expected to have a higher latency, but should also have a higher
        /// prediction quality than other mobile models.
        MobileTfHighAccuracy1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelType::value] or
        /// [ModelType::name].
        UnknownValue(model_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudHighAccuracy1 => std::option::Option::Some(1),
                Self::CloudLowLatency1 => std::option::Option::Some(2),
                Self::MobileTfLowLatency1 => std::option::Option::Some(3),
                Self::MobileTfVersatile1 => std::option::Option::Some(4),
                Self::MobileTfHighAccuracy1 => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_TYPE_UNSPECIFIED"),
                Self::CloudHighAccuracy1 => std::option::Option::Some("CLOUD_HIGH_ACCURACY_1"),
                Self::CloudLowLatency1 => std::option::Option::Some("CLOUD_LOW_LATENCY_1"),
                Self::MobileTfLowLatency1 => std::option::Option::Some("MOBILE_TF_LOW_LATENCY_1"),
                Self::MobileTfVersatile1 => std::option::Option::Some("MOBILE_TF_VERSATILE_1"),
                Self::MobileTfHighAccuracy1 => std::option::Option::Some("MOBILE_TF_HIGH_ACCURACY_1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudHighAccuracy1,
                2 => Self::CloudLowLatency1,
                3 => Self::MobileTfLowLatency1,
                4 => Self::MobileTfVersatile1,
                5 => Self::MobileTfHighAccuracy1,
                _ => Self::UnknownValue(model_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ModelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_HIGH_ACCURACY_1" => Self::CloudHighAccuracy1,
                "CLOUD_LOW_LATENCY_1" => Self::CloudLowLatency1,
                "MOBILE_TF_LOW_LATENCY_1" => Self::MobileTfLowLatency1,
                "MOBILE_TF_VERSATILE_1" => Self::MobileTfVersatile1,
                "MOBILE_TF_HIGH_ACCURACY_1" => Self::MobileTfHighAccuracy1,
                _ => Self::UnknownValue(model_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ModelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudHighAccuracy1 => serializer.serialize_i32(1),
                Self::CloudLowLatency1 => serializer.serialize_i32(2),
                Self::MobileTfLowLatency1 => serializer.serialize_i32(3),
                Self::MobileTfVersatile1 => serializer.serialize_i32(4),
                Self::MobileTfHighAccuracy1 => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelType>::new(
                ".google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageObjectDetectionInputs.ModelType"))
        }
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlImageObjectDetectionMetadata {

    /// The actual training cost of creating this model, expressed in
    /// milli node hours, i.e. 1,000 value in this field means 1 node hour.
    /// Guaranteed to not exceed inputs.budgetMilliNodeHours.
    pub cost_milli_node_hours: i64,

    /// For successful job completions, this is the reason why the job has
    /// finished.
    pub successful_stop_reason: crate::model::auto_ml_image_object_detection_metadata::SuccessfulStopReason,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlImageObjectDetectionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cost_milli_node_hours][crate::model::AutoMlImageObjectDetectionMetadata::cost_milli_node_hours].
    pub fn set_cost_milli_node_hours<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.cost_milli_node_hours = v.into();
        self
    }

    /// Sets the value of [successful_stop_reason][crate::model::AutoMlImageObjectDetectionMetadata::successful_stop_reason].
    pub fn set_successful_stop_reason<T: std::convert::Into<crate::model::auto_ml_image_object_detection_metadata::SuccessfulStopReason>>(mut self, v: T) -> Self {
        self.successful_stop_reason = v.into();
        self
    }
}

impl wkt::message::Message for AutoMlImageObjectDetectionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageObjectDetectionMetadata"
    }
}

/// Defines additional types related to [AutoMlImageObjectDetectionMetadata].
pub mod auto_ml_image_object_detection_metadata {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SuccessfulStopReason {
        /// Should not be set.
        Unspecified,
        /// The inputs.budgetMilliNodeHours had been reached.
        BudgetReached,
        /// Further training of the Model ceased to increase its quality, since it
        /// already has converged.
        ModelConverged,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SuccessfulStopReason::value] or
        /// [SuccessfulStopReason::name].
        UnknownValue(successful_stop_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod successful_stop_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SuccessfulStopReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BudgetReached => std::option::Option::Some(1),
                Self::ModelConverged => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SUCCESSFUL_STOP_REASON_UNSPECIFIED"),
                Self::BudgetReached => std::option::Option::Some("BUDGET_REACHED"),
                Self::ModelConverged => std::option::Option::Some("MODEL_CONVERGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SuccessfulStopReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SuccessfulStopReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SuccessfulStopReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BudgetReached,
                2 => Self::ModelConverged,
                _ => Self::UnknownValue(successful_stop_reason::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for SuccessfulStopReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SUCCESSFUL_STOP_REASON_UNSPECIFIED" => Self::Unspecified,
                "BUDGET_REACHED" => Self::BudgetReached,
                "MODEL_CONVERGED" => Self::ModelConverged,
                _ => Self::UnknownValue(successful_stop_reason::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for SuccessfulStopReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BudgetReached => serializer.serialize_i32(1),
                Self::ModelConverged => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SuccessfulStopReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SuccessfulStopReason>::new(
                ".google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageObjectDetectionMetadata.SuccessfulStopReason"))
        }
    }
}

/// A TrainingJob that trains and uploads an AutoML Image Segmentation Model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlImageSegmentation {

    /// The input parameters of this TrainingJob.
    pub inputs: std::option::Option<crate::model::AutoMlImageSegmentationInputs>,

    /// The metadata information.
    pub metadata: std::option::Option<crate::model::AutoMlImageSegmentationMetadata>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlImageSegmentation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inputs][crate::model::AutoMlImageSegmentation::inputs].
    pub fn set_inputs<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlImageSegmentationInputs>
    {
        self.inputs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inputs][crate::model::AutoMlImageSegmentation::inputs].
    pub fn set_or_clear_inputs<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlImageSegmentationInputs>
    {
        self.inputs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::AutoMlImageSegmentation::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlImageSegmentationMetadata>
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::AutoMlImageSegmentation::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlImageSegmentationMetadata>
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutoMlImageSegmentation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageSegmentation"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlImageSegmentationInputs {

    pub model_type: crate::model::auto_ml_image_segmentation_inputs::ModelType,

    /// The training budget of creating this model, expressed in milli node
    /// hours i.e. 1,000 value in this field means 1 node hour. The actual
    /// metadata.costMilliNodeHours will be equal or less than this value.
    /// If further model training ceases to provide any improvements, it will
    /// stop without using the full budget and the metadata.successfulStopReason
    /// will be `model-converged`.
    /// Note, node_hour  = actual_hour * number_of_nodes_involved. Or
    /// actaul_wall_clock_hours = train_budget_milli_node_hours /
    /// (number_of_nodes_involved * 1000)
    /// For modelType `cloud-high-accuracy-1`(default), the budget must be between
    /// 20,000 and 2,000,000 milli node hours, inclusive. The default value is
    /// 192,000 which represents one day in wall time
    /// (1000 milli * 24 hours * 8 nodes).
    pub budget_milli_node_hours: i64,

    /// The ID of the `base` model. If it is specified, the new model will be
    /// trained based on the `base` model. Otherwise, the new model will be
    /// trained from scratch. The `base` model must be in the same
    /// Project and Location as the new Model to train, and have the same
    /// modelType.
    pub base_model_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlImageSegmentationInputs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_type][crate::model::AutoMlImageSegmentationInputs::model_type].
    pub fn set_model_type<T: std::convert::Into<crate::model::auto_ml_image_segmentation_inputs::ModelType>>(mut self, v: T) -> Self {
        self.model_type = v.into();
        self
    }

    /// Sets the value of [budget_milli_node_hours][crate::model::AutoMlImageSegmentationInputs::budget_milli_node_hours].
    pub fn set_budget_milli_node_hours<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.budget_milli_node_hours = v.into();
        self
    }

    /// Sets the value of [base_model_id][crate::model::AutoMlImageSegmentationInputs::base_model_id].
    pub fn set_base_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_model_id = v.into();
        self
    }
}

impl wkt::message::Message for AutoMlImageSegmentationInputs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageSegmentationInputs"
    }
}

/// Defines additional types related to [AutoMlImageSegmentationInputs].
pub mod auto_ml_image_segmentation_inputs {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelType {
        /// Should not be set.
        Unspecified,
        /// A model to be used via prediction calls to uCAIP API. Expected
        /// to have a higher latency, but should also have a higher prediction
        /// quality than other models.
        CloudHighAccuracy1,
        /// A model to be used via prediction calls to uCAIP API. Expected
        /// to have a lower latency but relatively lower prediction quality.
        CloudLowAccuracy1,
        /// A model that, in addition to being available within Google
        /// Cloud, can also be exported (see ModelService.ExportModel) as TensorFlow
        /// model and used on a mobile or edge device afterwards.
        /// Expected to have low latency, but may have lower prediction
        /// quality than other mobile models.
        MobileTfLowLatency1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelType::value] or
        /// [ModelType::name].
        UnknownValue(model_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudHighAccuracy1 => std::option::Option::Some(1),
                Self::CloudLowAccuracy1 => std::option::Option::Some(2),
                Self::MobileTfLowLatency1 => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_TYPE_UNSPECIFIED"),
                Self::CloudHighAccuracy1 => std::option::Option::Some("CLOUD_HIGH_ACCURACY_1"),
                Self::CloudLowAccuracy1 => std::option::Option::Some("CLOUD_LOW_ACCURACY_1"),
                Self::MobileTfLowLatency1 => std::option::Option::Some("MOBILE_TF_LOW_LATENCY_1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudHighAccuracy1,
                2 => Self::CloudLowAccuracy1,
                3 => Self::MobileTfLowLatency1,
                _ => Self::UnknownValue(model_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ModelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_HIGH_ACCURACY_1" => Self::CloudHighAccuracy1,
                "CLOUD_LOW_ACCURACY_1" => Self::CloudLowAccuracy1,
                "MOBILE_TF_LOW_LATENCY_1" => Self::MobileTfLowLatency1,
                _ => Self::UnknownValue(model_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ModelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudHighAccuracy1 => serializer.serialize_i32(1),
                Self::CloudLowAccuracy1 => serializer.serialize_i32(2),
                Self::MobileTfLowLatency1 => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelType>::new(
                ".google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageSegmentationInputs.ModelType"))
        }
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlImageSegmentationMetadata {

    /// The actual training cost of creating this model, expressed in
    /// milli node hours, i.e. 1,000 value in this field means 1 node hour.
    /// Guaranteed to not exceed inputs.budgetMilliNodeHours.
    pub cost_milli_node_hours: i64,

    /// For successful job completions, this is the reason why the job has
    /// finished.
    pub successful_stop_reason: crate::model::auto_ml_image_segmentation_metadata::SuccessfulStopReason,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlImageSegmentationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cost_milli_node_hours][crate::model::AutoMlImageSegmentationMetadata::cost_milli_node_hours].
    pub fn set_cost_milli_node_hours<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.cost_milli_node_hours = v.into();
        self
    }

    /// Sets the value of [successful_stop_reason][crate::model::AutoMlImageSegmentationMetadata::successful_stop_reason].
    pub fn set_successful_stop_reason<T: std::convert::Into<crate::model::auto_ml_image_segmentation_metadata::SuccessfulStopReason>>(mut self, v: T) -> Self {
        self.successful_stop_reason = v.into();
        self
    }
}

impl wkt::message::Message for AutoMlImageSegmentationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageSegmentationMetadata"
    }
}

/// Defines additional types related to [AutoMlImageSegmentationMetadata].
pub mod auto_ml_image_segmentation_metadata {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SuccessfulStopReason {
        /// Should not be set.
        Unspecified,
        /// The inputs.budgetMilliNodeHours had been reached.
        BudgetReached,
        /// Further training of the Model ceased to increase its quality, since it
        /// already has converged.
        ModelConverged,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SuccessfulStopReason::value] or
        /// [SuccessfulStopReason::name].
        UnknownValue(successful_stop_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod successful_stop_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SuccessfulStopReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BudgetReached => std::option::Option::Some(1),
                Self::ModelConverged => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SUCCESSFUL_STOP_REASON_UNSPECIFIED"),
                Self::BudgetReached => std::option::Option::Some("BUDGET_REACHED"),
                Self::ModelConverged => std::option::Option::Some("MODEL_CONVERGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SuccessfulStopReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SuccessfulStopReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SuccessfulStopReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BudgetReached,
                2 => Self::ModelConverged,
                _ => Self::UnknownValue(successful_stop_reason::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for SuccessfulStopReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SUCCESSFUL_STOP_REASON_UNSPECIFIED" => Self::Unspecified,
                "BUDGET_REACHED" => Self::BudgetReached,
                "MODEL_CONVERGED" => Self::ModelConverged,
                _ => Self::UnknownValue(successful_stop_reason::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for SuccessfulStopReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BudgetReached => serializer.serialize_i32(1),
                Self::ModelConverged => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SuccessfulStopReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SuccessfulStopReason>::new(
                ".google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlImageSegmentationMetadata.SuccessfulStopReason"))
        }
    }
}

/// A TrainingJob that trains and uploads an AutoML Tables Model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlTables {

    /// The input parameters of this TrainingJob.
    pub inputs: std::option::Option<crate::model::AutoMlTablesInputs>,

    /// The metadata information.
    pub metadata: std::option::Option<crate::model::AutoMlTablesMetadata>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlTables {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inputs][crate::model::AutoMlTables::inputs].
    pub fn set_inputs<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlTablesInputs>
    {
        self.inputs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inputs][crate::model::AutoMlTables::inputs].
    pub fn set_or_clear_inputs<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlTablesInputs>
    {
        self.inputs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::AutoMlTables::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlTablesMetadata>
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::AutoMlTables::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlTablesMetadata>
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutoMlTables {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTables"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlTablesInputs {

    /// The type of prediction the Model is to produce.
    /// "classification" - Predict one out of multiple target values is
    /// picked for each row.
    /// "regression" - Predict a value based on its relation to other values.
    /// This type is available only to columns that contain
    /// semantically numeric values, i.e. integers or floating
    /// point number, even if stored as e.g. strings.
    pub prediction_type: std::string::String,

    /// The column name of the target column that the model is to predict.
    pub target_column: std::string::String,

    /// Each transformation will apply transform function to given input column.
    /// And the result will be used for training.
    /// When creating transformation for BigQuery Struct column, the column should
    /// be flattened using "." as the delimiter.
    pub transformations: std::vec::Vec<crate::model::auto_ml_tables_inputs::Transformation>,

    /// Objective function the model is optimizing towards. The training process
    /// creates a model that maximizes/minimizes the value of the objective
    /// function over the validation set.
    ///
    /// The supported optimization objectives depend on the prediction type.
    /// If the field is not set, a default objective function is used.
    ///
    /// classification (binary):
    /// "maximize-au-roc" (default) - Maximize the area under the receiver
    /// operating characteristic (ROC) curve.
    /// "minimize-log-loss" - Minimize log loss.
    /// "maximize-au-prc" - Maximize the area under the precision-recall curve.
    /// "maximize-precision-at-recall" - Maximize precision for a specified
    /// recall value.
    /// "maximize-recall-at-precision" - Maximize recall for a specified
    /// precision value.
    ///
    /// classification (multi-class):
    /// "minimize-log-loss" (default) - Minimize log loss.
    ///
    /// regression:
    /// "minimize-rmse" (default) - Minimize root-mean-squared error (RMSE).
    /// "minimize-mae" - Minimize mean-absolute error (MAE).
    /// "minimize-rmsle" - Minimize root-mean-squared log error (RMSLE).
    pub optimization_objective: std::string::String,

    /// Required. The train budget of creating this model, expressed in milli node
    /// hours i.e. 1,000 value in this field means 1 node hour.
    ///
    /// The training cost of the model will not exceed this budget. The final cost
    /// will be attempted to be close to the budget, though may end up being (even)
    /// noticeably smaller - at the backend's discretion. This especially may
    /// happen when further model training ceases to provide any improvements.
    ///
    /// If the budget is set to a value known to be insufficient to train a
    /// model for the given dataset, the training won't be attempted and
    /// will error.
    ///
    /// The train budget must be between 1,000 and 72,000 milli node hours,
    /// inclusive.
    pub train_budget_milli_node_hours: i64,

    /// Use the entire training budget. This disables the early stopping feature.
    /// By default, the early stopping feature is enabled, which means that AutoML
    /// Tables might stop training before the entire training budget has been used.
    pub disable_early_stopping: bool,

    /// Column name that should be used as the weight column.
    /// Higher values in this column give more importance to the row
    /// during model training. The column must have numeric values between 0 and
    /// 10000 inclusively; 0 means the row is ignored for training. If weight
    /// column field is not set, then all rows are assumed to have equal weight
    /// of 1.
    pub weight_column_name: std::string::String,

    /// Configuration for exporting test set predictions to a BigQuery table. If
    /// this configuration is absent, then the export is not performed.
    pub export_evaluated_data_items_config: std::option::Option<crate::model::ExportEvaluatedDataItemsConfig>,

    /// Additional experiment flags for the Tables training pipeline.
    pub additional_experiments: std::vec::Vec<std::string::String>,

    /// Additional optimization objective configuration. Required for
    /// `maximize-precision-at-recall` and `maximize-recall-at-precision`,
    /// otherwise unused.
    pub additional_optimization_objective_config: std::option::Option<crate::model::auto_ml_tables_inputs::AdditionalOptimizationObjectiveConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlTablesInputs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction_type][crate::model::AutoMlTablesInputs::prediction_type].
    pub fn set_prediction_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.prediction_type = v.into();
        self
    }

    /// Sets the value of [target_column][crate::model::AutoMlTablesInputs::target_column].
    pub fn set_target_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_column = v.into();
        self
    }

    /// Sets the value of [transformations][crate::model::AutoMlTablesInputs::transformations].
    pub fn set_transformations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::auto_ml_tables_inputs::Transformation>
    {
        use std::iter::Iterator;
        self.transformations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [optimization_objective][crate::model::AutoMlTablesInputs::optimization_objective].
    pub fn set_optimization_objective<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.optimization_objective = v.into();
        self
    }

    /// Sets the value of [train_budget_milli_node_hours][crate::model::AutoMlTablesInputs::train_budget_milli_node_hours].
    pub fn set_train_budget_milli_node_hours<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.train_budget_milli_node_hours = v.into();
        self
    }

    /// Sets the value of [disable_early_stopping][crate::model::AutoMlTablesInputs::disable_early_stopping].
    pub fn set_disable_early_stopping<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_early_stopping = v.into();
        self
    }

    /// Sets the value of [weight_column_name][crate::model::AutoMlTablesInputs::weight_column_name].
    pub fn set_weight_column_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.weight_column_name = v.into();
        self
    }

    /// Sets the value of [export_evaluated_data_items_config][crate::model::AutoMlTablesInputs::export_evaluated_data_items_config].
    pub fn set_export_evaluated_data_items_config<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::ExportEvaluatedDataItemsConfig>
    {
        self.export_evaluated_data_items_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [export_evaluated_data_items_config][crate::model::AutoMlTablesInputs::export_evaluated_data_items_config].
    pub fn set_or_clear_export_evaluated_data_items_config<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::ExportEvaluatedDataItemsConfig>
    {
        self.export_evaluated_data_items_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_experiments][crate::model::AutoMlTablesInputs::additional_experiments].
    pub fn set_additional_experiments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.additional_experiments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [additional_optimization_objective_config][crate::model::AutoMlTablesInputs::additional_optimization_objective_config].
    ///
    /// Note that all the setters affecting `additional_optimization_objective_config` are mutually
    /// exclusive.
    pub fn set_additional_optimization_objective_config<T: std::convert::Into<std::option::Option<crate::model::auto_ml_tables_inputs::AdditionalOptimizationObjectiveConfig>>>(mut self, v: T) -> Self
    {
        self.additional_optimization_objective_config = v.into();
        self
    }

    /// The value of [additional_optimization_objective_config][crate::model::AutoMlTablesInputs::additional_optimization_objective_config]
    /// if it holds a `OptimizationObjectiveRecallValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn optimization_objective_recall_value(&self) -> std::option::Option<&f32> {
        #[allow(unreachable_patterns)]
        self.additional_optimization_objective_config.as_ref().and_then(|v| match v {
            crate::model::auto_ml_tables_inputs::AdditionalOptimizationObjectiveConfig::OptimizationObjectiveRecallValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [additional_optimization_objective_config][crate::model::AutoMlTablesInputs::additional_optimization_objective_config]
    /// to hold a `OptimizationObjectiveRecallValue`.
    ///
    /// Note that all the setters affecting `additional_optimization_objective_config` are
    /// mutually exclusive.
    pub fn set_optimization_objective_recall_value<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.additional_optimization_objective_config = std::option::Option::Some(
            crate::model::auto_ml_tables_inputs::AdditionalOptimizationObjectiveConfig::OptimizationObjectiveRecallValue(
                v.into()
            )
        );
        self
    }

    /// The value of [additional_optimization_objective_config][crate::model::AutoMlTablesInputs::additional_optimization_objective_config]
    /// if it holds a `OptimizationObjectivePrecisionValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn optimization_objective_precision_value(&self) -> std::option::Option<&f32> {
        #[allow(unreachable_patterns)]
        self.additional_optimization_objective_config.as_ref().and_then(|v| match v {
            crate::model::auto_ml_tables_inputs::AdditionalOptimizationObjectiveConfig::OptimizationObjectivePrecisionValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [additional_optimization_objective_config][crate::model::AutoMlTablesInputs::additional_optimization_objective_config]
    /// to hold a `OptimizationObjectivePrecisionValue`.
    ///
    /// Note that all the setters affecting `additional_optimization_objective_config` are
    /// mutually exclusive.
    pub fn set_optimization_objective_precision_value<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.additional_optimization_objective_config = std::option::Option::Some(
            crate::model::auto_ml_tables_inputs::AdditionalOptimizationObjectiveConfig::OptimizationObjectivePrecisionValue(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for AutoMlTablesInputs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTablesInputs"
    }
}

/// Defines additional types related to [AutoMlTablesInputs].
pub mod auto_ml_tables_inputs {
    #[allow(unused_imports)]
    use super::*;


    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Transformation {

        /// The transformation that the training pipeline will apply to the input
        /// columns.
        pub transformation_detail: std::option::Option<crate::model::auto_ml_tables_inputs::transformation::TransformationDetail>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Transformation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail].
        ///
        /// Note that all the setters affecting `transformation_detail` are mutually
        /// exclusive.
        pub fn set_transformation_detail<T: std::convert::Into<std::option::Option<crate::model::auto_ml_tables_inputs::transformation::TransformationDetail>>>(mut self, v: T) -> Self
        {
            self.transformation_detail = v.into();
            self
        }

        /// The value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// if it holds a `Auto`, `None` if the field is not set or
        /// holds a different branch.
        pub fn auto(&self) -> std::option::Option<&std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::AutoTransformation>> {
            #[allow(unreachable_patterns)]
            self.transformation_detail.as_ref().and_then(|v| match v {
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::Auto(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// to hold a `Auto`.
        ///
        /// Note that all the setters affecting `transformation_detail` are
        /// mutually exclusive.
        pub fn set_auto<T: std::convert::Into<std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::AutoTransformation>>>(mut self, v: T) -> Self {
            self.transformation_detail = std::option::Option::Some(
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::Auto(
                    v.into()
                )
            );
            self
        }

        /// The value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// if it holds a `Numeric`, `None` if the field is not set or
        /// holds a different branch.
        pub fn numeric(&self) -> std::option::Option<&std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::NumericTransformation>> {
            #[allow(unreachable_patterns)]
            self.transformation_detail.as_ref().and_then(|v| match v {
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::Numeric(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// to hold a `Numeric`.
        ///
        /// Note that all the setters affecting `transformation_detail` are
        /// mutually exclusive.
        pub fn set_numeric<T: std::convert::Into<std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::NumericTransformation>>>(mut self, v: T) -> Self {
            self.transformation_detail = std::option::Option::Some(
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::Numeric(
                    v.into()
                )
            );
            self
        }

        /// The value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// if it holds a `Categorical`, `None` if the field is not set or
        /// holds a different branch.
        pub fn categorical(&self) -> std::option::Option<&std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::CategoricalTransformation>> {
            #[allow(unreachable_patterns)]
            self.transformation_detail.as_ref().and_then(|v| match v {
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::Categorical(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// to hold a `Categorical`.
        ///
        /// Note that all the setters affecting `transformation_detail` are
        /// mutually exclusive.
        pub fn set_categorical<T: std::convert::Into<std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::CategoricalTransformation>>>(mut self, v: T) -> Self {
            self.transformation_detail = std::option::Option::Some(
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::Categorical(
                    v.into()
                )
            );
            self
        }

        /// The value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// if it holds a `Timestamp`, `None` if the field is not set or
        /// holds a different branch.
        pub fn timestamp(&self) -> std::option::Option<&std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::TimestampTransformation>> {
            #[allow(unreachable_patterns)]
            self.transformation_detail.as_ref().and_then(|v| match v {
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::Timestamp(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// to hold a `Timestamp`.
        ///
        /// Note that all the setters affecting `transformation_detail` are
        /// mutually exclusive.
        pub fn set_timestamp<T: std::convert::Into<std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::TimestampTransformation>>>(mut self, v: T) -> Self {
            self.transformation_detail = std::option::Option::Some(
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::Timestamp(
                    v.into()
                )
            );
            self
        }

        /// The value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// if it holds a `Text`, `None` if the field is not set or
        /// holds a different branch.
        pub fn text(&self) -> std::option::Option<&std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::TextTransformation>> {
            #[allow(unreachable_patterns)]
            self.transformation_detail.as_ref().and_then(|v| match v {
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::Text(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// to hold a `Text`.
        ///
        /// Note that all the setters affecting `transformation_detail` are
        /// mutually exclusive.
        pub fn set_text<T: std::convert::Into<std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::TextTransformation>>>(mut self, v: T) -> Self {
            self.transformation_detail = std::option::Option::Some(
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::Text(
                    v.into()
                )
            );
            self
        }

        /// The value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// if it holds a `RepeatedNumeric`, `None` if the field is not set or
        /// holds a different branch.
        pub fn repeated_numeric(&self) -> std::option::Option<&std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::NumericArrayTransformation>> {
            #[allow(unreachable_patterns)]
            self.transformation_detail.as_ref().and_then(|v| match v {
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::RepeatedNumeric(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// to hold a `RepeatedNumeric`.
        ///
        /// Note that all the setters affecting `transformation_detail` are
        /// mutually exclusive.
        pub fn set_repeated_numeric<T: std::convert::Into<std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::NumericArrayTransformation>>>(mut self, v: T) -> Self {
            self.transformation_detail = std::option::Option::Some(
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::RepeatedNumeric(
                    v.into()
                )
            );
            self
        }

        /// The value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// if it holds a `RepeatedCategorical`, `None` if the field is not set or
        /// holds a different branch.
        pub fn repeated_categorical(&self) -> std::option::Option<&std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::CategoricalArrayTransformation>> {
            #[allow(unreachable_patterns)]
            self.transformation_detail.as_ref().and_then(|v| match v {
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::RepeatedCategorical(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// to hold a `RepeatedCategorical`.
        ///
        /// Note that all the setters affecting `transformation_detail` are
        /// mutually exclusive.
        pub fn set_repeated_categorical<T: std::convert::Into<std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::CategoricalArrayTransformation>>>(mut self, v: T) -> Self {
            self.transformation_detail = std::option::Option::Some(
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::RepeatedCategorical(
                    v.into()
                )
            );
            self
        }

        /// The value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// if it holds a `RepeatedText`, `None` if the field is not set or
        /// holds a different branch.
        pub fn repeated_text(&self) -> std::option::Option<&std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::TextArrayTransformation>> {
            #[allow(unreachable_patterns)]
            self.transformation_detail.as_ref().and_then(|v| match v {
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::RepeatedText(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [transformation_detail][crate::model::auto_ml_tables_inputs::Transformation::transformation_detail]
        /// to hold a `RepeatedText`.
        ///
        /// Note that all the setters affecting `transformation_detail` are
        /// mutually exclusive.
        pub fn set_repeated_text<T: std::convert::Into<std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::TextArrayTransformation>>>(mut self, v: T) -> Self {
            self.transformation_detail = std::option::Option::Some(
                crate::model::auto_ml_tables_inputs::transformation::TransformationDetail::RepeatedText(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for Transformation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTablesInputs.Transformation"
        }
    }

    /// Defines additional types related to [Transformation].
    pub mod transformation {
        #[allow(unused_imports)]
        use super::*;


        /// Training pipeline will infer the proper transformation based on the
        /// statistic of dataset.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AutoTransformation {

            pub column_name: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AutoTransformation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [column_name][crate::model::auto_ml_tables_inputs::transformation::AutoTransformation::column_name].
            pub fn set_column_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.column_name = v.into();
                self
            }
        }

        impl wkt::message::Message for AutoTransformation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTablesInputs.Transformation.AutoTransformation"
            }
        }

        /// Training pipeline will perform following transformation functions.
        ///
        /// * The value converted to float32.
        /// * The z_score of the value.
        /// * log(value+1) when the value is greater than or equal to 0. Otherwise,
        ///   this transformation is not applied and the value is considered a
        ///   missing value.
        /// * z_score of log(value+1) when the value is greater than or equal to 0.
        ///   Otherwise, this transformation is not applied and the value is
        ///   considered a missing value.
        /// * A boolean value that indicates whether the value is valid.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct NumericTransformation {

            pub column_name: std::string::String,

            /// If invalid values is allowed, the training pipeline will create a
            /// boolean feature that indicated whether the value is valid.
            /// Otherwise, the training pipeline will discard the input row from
            /// trainining data.
            pub invalid_values_allowed: bool,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl NumericTransformation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [column_name][crate::model::auto_ml_tables_inputs::transformation::NumericTransformation::column_name].
            pub fn set_column_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.column_name = v.into();
                self
            }

            /// Sets the value of [invalid_values_allowed][crate::model::auto_ml_tables_inputs::transformation::NumericTransformation::invalid_values_allowed].
            pub fn set_invalid_values_allowed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.invalid_values_allowed = v.into();
                self
            }
        }

        impl wkt::message::Message for NumericTransformation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTablesInputs.Transformation.NumericTransformation"
            }
        }

        /// Training pipeline will perform following transformation functions.
        ///
        /// * The categorical string as is--no change to case, punctuation,
        ///   spelling,
        ///   tense, and so on.
        /// * Convert the category name to a dictionary lookup index and generate an
        ///   embedding for each index.
        /// * Categories that appear less than 5 times in the training dataset are
        ///   treated as the "unknown" category. The "unknown" category gets its own
        ///   special lookup index and resulting embedding.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CategoricalTransformation {

            pub column_name: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CategoricalTransformation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [column_name][crate::model::auto_ml_tables_inputs::transformation::CategoricalTransformation::column_name].
            pub fn set_column_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.column_name = v.into();
                self
            }
        }

        impl wkt::message::Message for CategoricalTransformation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTablesInputs.Transformation.CategoricalTransformation"
            }
        }

        /// Training pipeline will perform following transformation functions.
        ///
        /// * Apply the transformation functions for Numerical columns.
        /// * Determine the year, month, day,and weekday. Treat each value from the
        /// * timestamp as a Categorical column.
        /// * Invalid numerical values (for example, values that fall outside of a
        ///   typical timestamp range, or are extreme values) receive no special
        ///   treatment and are not removed.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TimestampTransformation {

            pub column_name: std::string::String,

            /// The format in which that time field is expressed. The time_format must
            /// either be one of:
            ///
            /// * `unix-seconds`
            /// * `unix-milliseconds`
            /// * `unix-microseconds`
            /// * `unix-nanoseconds`
            ///   (for respectively number of seconds, milliseconds, microseconds and
            ///   nanoseconds since start of the Unix epoch);
            ///   or be written in `strftime` syntax. If time_format is not set, then the
            ///   default format is RFC 3339 `date-time` format, where
            ///   `time-offset` = `"Z"` (e.g. 1985-04-12T23:20:50.52Z)
            pub time_format: std::string::String,

            /// If invalid values is allowed, the training pipeline will create a
            /// boolean feature that indicated whether the value is valid.
            /// Otherwise, the training pipeline will discard the input row from
            /// trainining data.
            pub invalid_values_allowed: bool,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TimestampTransformation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [column_name][crate::model::auto_ml_tables_inputs::transformation::TimestampTransformation::column_name].
            pub fn set_column_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.column_name = v.into();
                self
            }

            /// Sets the value of [time_format][crate::model::auto_ml_tables_inputs::transformation::TimestampTransformation::time_format].
            pub fn set_time_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.time_format = v.into();
                self
            }

            /// Sets the value of [invalid_values_allowed][crate::model::auto_ml_tables_inputs::transformation::TimestampTransformation::invalid_values_allowed].
            pub fn set_invalid_values_allowed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.invalid_values_allowed = v.into();
                self
            }
        }

        impl wkt::message::Message for TimestampTransformation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTablesInputs.Transformation.TimestampTransformation"
            }
        }

        /// Training pipeline will perform following transformation functions.
        ///
        /// * The text as is--no change to case, punctuation, spelling, tense, and
        ///   so
        ///   on.
        /// * Tokenize text to words. Convert each words to a dictionary lookup
        ///   index
        ///   and generate an embedding for each index. Combine the embedding of all
        ///   elements into a single embedding using the mean.
        /// * Tokenization is based on unicode script boundaries.
        /// * Missing values get their own lookup index and resulting embedding.
        /// * Stop-words receive no special treatment and are not removed.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TextTransformation {

            pub column_name: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TextTransformation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [column_name][crate::model::auto_ml_tables_inputs::transformation::TextTransformation::column_name].
            pub fn set_column_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.column_name = v.into();
                self
            }
        }

        impl wkt::message::Message for TextTransformation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTablesInputs.Transformation.TextTransformation"
            }
        }

        /// Treats the column as numerical array and performs following
        /// transformation functions.
        ///
        /// * All transformations for Numerical types applied to the average of the
        ///   all elements.
        /// * The average of empty arrays is treated as zero.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct NumericArrayTransformation {

            pub column_name: std::string::String,

            /// If invalid values is allowed, the training pipeline will create a
            /// boolean feature that indicated whether the value is valid.
            /// Otherwise, the training pipeline will discard the input row from
            /// trainining data.
            pub invalid_values_allowed: bool,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl NumericArrayTransformation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [column_name][crate::model::auto_ml_tables_inputs::transformation::NumericArrayTransformation::column_name].
            pub fn set_column_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.column_name = v.into();
                self
            }

            /// Sets the value of [invalid_values_allowed][crate::model::auto_ml_tables_inputs::transformation::NumericArrayTransformation::invalid_values_allowed].
            pub fn set_invalid_values_allowed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.invalid_values_allowed = v.into();
                self
            }
        }

        impl wkt::message::Message for NumericArrayTransformation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTablesInputs.Transformation.NumericArrayTransformation"
            }
        }

        /// Treats the column as categorical array and performs following
        /// transformation functions.
        ///
        /// * For each element in the array, convert the category name to a
        ///   dictionary
        ///   lookup index and generate an embedding for each index.
        ///   Combine the embedding of all elements into a single embedding using
        ///   the mean.
        /// * Empty arrays treated as an embedding of zeroes.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CategoricalArrayTransformation {

            pub column_name: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CategoricalArrayTransformation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [column_name][crate::model::auto_ml_tables_inputs::transformation::CategoricalArrayTransformation::column_name].
            pub fn set_column_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.column_name = v.into();
                self
            }
        }

        impl wkt::message::Message for CategoricalArrayTransformation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTablesInputs.Transformation.CategoricalArrayTransformation"
            }
        }

        /// Treats the column as text array and performs following transformation
        /// functions.
        ///
        /// * Concatenate all text values in the array into a single text value
        ///   using
        ///   a space (" ") as a delimiter, and then treat the result as a single
        ///   text value. Apply the transformations for Text columns.
        /// * Empty arrays treated as an empty text.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TextArrayTransformation {

            pub column_name: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TextArrayTransformation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [column_name][crate::model::auto_ml_tables_inputs::transformation::TextArrayTransformation::column_name].
            pub fn set_column_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.column_name = v.into();
                self
            }
        }

        impl wkt::message::Message for TextArrayTransformation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTablesInputs.Transformation.TextArrayTransformation"
            }
        }

        /// The transformation that the training pipeline will apply to the input
        /// columns.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TransformationDetail {
            Auto(std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::AutoTransformation>),
            Numeric(std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::NumericTransformation>),
            Categorical(std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::CategoricalTransformation>),
            Timestamp(std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::TimestampTransformation>),
            Text(std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::TextTransformation>),
            RepeatedNumeric(std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::NumericArrayTransformation>),
            RepeatedCategorical(std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::CategoricalArrayTransformation>),
            RepeatedText(std::boxed::Box<crate::model::auto_ml_tables_inputs::transformation::TextArrayTransformation>),
        }
    }

    /// Additional optimization objective configuration. Required for
    /// `maximize-precision-at-recall` and `maximize-recall-at-precision`,
    /// otherwise unused.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AdditionalOptimizationObjectiveConfig {
        /// Required when optimization_objective is "maximize-precision-at-recall".
        /// Must be between 0 and 1, inclusive.
        OptimizationObjectiveRecallValue(f32),
        /// Required when optimization_objective is "maximize-recall-at-precision".
        /// Must be between 0 and 1, inclusive.
        OptimizationObjectivePrecisionValue(f32),
    }
}

/// Model metadata specific to AutoML Tables.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlTablesMetadata {

    /// Output only. The actual training cost of the model, expressed in milli
    /// node hours, i.e. 1,000 value in this field means 1 node hour. Guaranteed
    /// to not exceed the train budget.
    pub train_cost_milli_node_hours: i64,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlTablesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [train_cost_milli_node_hours][crate::model::AutoMlTablesMetadata::train_cost_milli_node_hours].
    pub fn set_train_cost_milli_node_hours<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.train_cost_milli_node_hours = v.into();
        self
    }
}

impl wkt::message::Message for AutoMlTablesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTablesMetadata"
    }
}

/// A TrainingJob that trains and uploads an AutoML Text Classification Model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlTextClassification {

    /// The input parameters of this TrainingJob.
    pub inputs: std::option::Option<crate::model::AutoMlTextClassificationInputs>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlTextClassification {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inputs][crate::model::AutoMlTextClassification::inputs].
    pub fn set_inputs<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlTextClassificationInputs>
    {
        self.inputs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inputs][crate::model::AutoMlTextClassification::inputs].
    pub fn set_or_clear_inputs<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlTextClassificationInputs>
    {
        self.inputs = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutoMlTextClassification {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTextClassification"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlTextClassificationInputs {

    pub multi_label: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlTextClassificationInputs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [multi_label][crate::model::AutoMlTextClassificationInputs::multi_label].
    pub fn set_multi_label<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.multi_label = v.into();
        self
    }
}

impl wkt::message::Message for AutoMlTextClassificationInputs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTextClassificationInputs"
    }
}

/// A TrainingJob that trains and uploads an AutoML Text Extraction Model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlTextExtraction {

    /// The input parameters of this TrainingJob.
    pub inputs: std::option::Option<crate::model::AutoMlTextExtractionInputs>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlTextExtraction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inputs][crate::model::AutoMlTextExtraction::inputs].
    pub fn set_inputs<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlTextExtractionInputs>
    {
        self.inputs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inputs][crate::model::AutoMlTextExtraction::inputs].
    pub fn set_or_clear_inputs<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlTextExtractionInputs>
    {
        self.inputs = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutoMlTextExtraction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTextExtraction"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlTextExtractionInputs {

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlTextExtractionInputs {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AutoMlTextExtractionInputs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTextExtractionInputs"
    }
}

/// A TrainingJob that trains and uploads an AutoML Text Sentiment Model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlTextSentiment {

    /// The input parameters of this TrainingJob.
    pub inputs: std::option::Option<crate::model::AutoMlTextSentimentInputs>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlTextSentiment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inputs][crate::model::AutoMlTextSentiment::inputs].
    pub fn set_inputs<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlTextSentimentInputs>
    {
        self.inputs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inputs][crate::model::AutoMlTextSentiment::inputs].
    pub fn set_or_clear_inputs<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlTextSentimentInputs>
    {
        self.inputs = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutoMlTextSentiment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTextSentiment"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlTextSentimentInputs {

    /// A sentiment is expressed as an integer ordinal, where higher value
    /// means a more positive sentiment. The range of sentiments that will be used
    /// is between 0 and sentimentMax (inclusive on both ends), and all the values
    /// in the range must be represented in the dataset before a model can be
    /// created.
    /// Only the Annotations with this sentimentMax will be used for training.
    /// sentimentMax value must be between 1 and 10 (inclusive).
    pub sentiment_max: i32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlTextSentimentInputs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sentiment_max][crate::model::AutoMlTextSentimentInputs::sentiment_max].
    pub fn set_sentiment_max<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sentiment_max = v.into();
        self
    }
}

impl wkt::message::Message for AutoMlTextSentimentInputs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlTextSentimentInputs"
    }
}

/// A TrainingJob that trains and uploads an AutoML Video Action Recognition
/// Model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlVideoActionRecognition {

    /// The input parameters of this TrainingJob.
    pub inputs: std::option::Option<crate::model::AutoMlVideoActionRecognitionInputs>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlVideoActionRecognition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inputs][crate::model::AutoMlVideoActionRecognition::inputs].
    pub fn set_inputs<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlVideoActionRecognitionInputs>
    {
        self.inputs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inputs][crate::model::AutoMlVideoActionRecognition::inputs].
    pub fn set_or_clear_inputs<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlVideoActionRecognitionInputs>
    {
        self.inputs = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutoMlVideoActionRecognition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlVideoActionRecognition"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlVideoActionRecognitionInputs {

    pub model_type: crate::model::auto_ml_video_action_recognition_inputs::ModelType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlVideoActionRecognitionInputs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_type][crate::model::AutoMlVideoActionRecognitionInputs::model_type].
    pub fn set_model_type<T: std::convert::Into<crate::model::auto_ml_video_action_recognition_inputs::ModelType>>(mut self, v: T) -> Self {
        self.model_type = v.into();
        self
    }
}

impl wkt::message::Message for AutoMlVideoActionRecognitionInputs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlVideoActionRecognitionInputs"
    }
}

/// Defines additional types related to [AutoMlVideoActionRecognitionInputs].
pub mod auto_ml_video_action_recognition_inputs {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelType {
        /// Should not be set.
        Unspecified,
        /// A model best tailored to be used within Google Cloud, and which c annot
        /// be exported. Default.
        Cloud,
        /// A model that, in addition to being available within Google Cloud, can
        /// also be exported (see ModelService.ExportModel) as a TensorFlow or
        /// TensorFlow Lite model and used on a mobile or edge device afterwards.
        MobileVersatile1,
        /// A model that, in addition to being available within Google Cloud, can
        /// also be exported (see ModelService.ExportModel) to a Jetson device
        /// afterwards.
        MobileJetsonVersatile1,
        /// A model that, in addition to being available within Google Cloud, can
        /// also be exported (see ModelService.ExportModel) as a TensorFlow or
        /// TensorFlow Lite model and used on a Coral device afterwards.
        MobileCoralVersatile1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelType::value] or
        /// [ModelType::name].
        UnknownValue(model_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Cloud => std::option::Option::Some(1),
                Self::MobileVersatile1 => std::option::Option::Some(2),
                Self::MobileJetsonVersatile1 => std::option::Option::Some(3),
                Self::MobileCoralVersatile1 => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_TYPE_UNSPECIFIED"),
                Self::Cloud => std::option::Option::Some("CLOUD"),
                Self::MobileVersatile1 => std::option::Option::Some("MOBILE_VERSATILE_1"),
                Self::MobileJetsonVersatile1 => std::option::Option::Some("MOBILE_JETSON_VERSATILE_1"),
                Self::MobileCoralVersatile1 => std::option::Option::Some("MOBILE_CORAL_VERSATILE_1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Cloud,
                2 => Self::MobileVersatile1,
                3 => Self::MobileJetsonVersatile1,
                4 => Self::MobileCoralVersatile1,
                _ => Self::UnknownValue(model_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ModelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD" => Self::Cloud,
                "MOBILE_VERSATILE_1" => Self::MobileVersatile1,
                "MOBILE_JETSON_VERSATILE_1" => Self::MobileJetsonVersatile1,
                "MOBILE_CORAL_VERSATILE_1" => Self::MobileCoralVersatile1,
                _ => Self::UnknownValue(model_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ModelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Cloud => serializer.serialize_i32(1),
                Self::MobileVersatile1 => serializer.serialize_i32(2),
                Self::MobileJetsonVersatile1 => serializer.serialize_i32(3),
                Self::MobileCoralVersatile1 => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelType>::new(
                ".google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlVideoActionRecognitionInputs.ModelType"))
        }
    }
}

/// A TrainingJob that trains and uploads an AutoML Video Classification Model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlVideoClassification {

    /// The input parameters of this TrainingJob.
    pub inputs: std::option::Option<crate::model::AutoMlVideoClassificationInputs>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlVideoClassification {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inputs][crate::model::AutoMlVideoClassification::inputs].
    pub fn set_inputs<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlVideoClassificationInputs>
    {
        self.inputs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inputs][crate::model::AutoMlVideoClassification::inputs].
    pub fn set_or_clear_inputs<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlVideoClassificationInputs>
    {
        self.inputs = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutoMlVideoClassification {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlVideoClassification"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlVideoClassificationInputs {

    pub model_type: crate::model::auto_ml_video_classification_inputs::ModelType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlVideoClassificationInputs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_type][crate::model::AutoMlVideoClassificationInputs::model_type].
    pub fn set_model_type<T: std::convert::Into<crate::model::auto_ml_video_classification_inputs::ModelType>>(mut self, v: T) -> Self {
        self.model_type = v.into();
        self
    }
}

impl wkt::message::Message for AutoMlVideoClassificationInputs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlVideoClassificationInputs"
    }
}

/// Defines additional types related to [AutoMlVideoClassificationInputs].
pub mod auto_ml_video_classification_inputs {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelType {
        /// Should not be set.
        Unspecified,
        /// A model best tailored to be used within Google Cloud, and which cannot
        /// be exported. Default.
        Cloud,
        /// A model that, in addition to being available within Google Cloud, can
        /// also be exported (see ModelService.ExportModel) as a TensorFlow or
        /// TensorFlow Lite model and used on a mobile or edge device afterwards.
        MobileVersatile1,
        /// A model that, in addition to being available within Google Cloud, can
        /// also be exported (see ModelService.ExportModel) to a Jetson device
        /// afterwards.
        MobileJetsonVersatile1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelType::value] or
        /// [ModelType::name].
        UnknownValue(model_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Cloud => std::option::Option::Some(1),
                Self::MobileVersatile1 => std::option::Option::Some(2),
                Self::MobileJetsonVersatile1 => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_TYPE_UNSPECIFIED"),
                Self::Cloud => std::option::Option::Some("CLOUD"),
                Self::MobileVersatile1 => std::option::Option::Some("MOBILE_VERSATILE_1"),
                Self::MobileJetsonVersatile1 => std::option::Option::Some("MOBILE_JETSON_VERSATILE_1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Cloud,
                2 => Self::MobileVersatile1,
                3 => Self::MobileJetsonVersatile1,
                _ => Self::UnknownValue(model_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ModelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD" => Self::Cloud,
                "MOBILE_VERSATILE_1" => Self::MobileVersatile1,
                "MOBILE_JETSON_VERSATILE_1" => Self::MobileJetsonVersatile1,
                _ => Self::UnknownValue(model_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ModelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Cloud => serializer.serialize_i32(1),
                Self::MobileVersatile1 => serializer.serialize_i32(2),
                Self::MobileJetsonVersatile1 => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelType>::new(
                ".google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlVideoClassificationInputs.ModelType"))
        }
    }
}

/// A TrainingJob that trains and uploads an AutoML Video ObjectTracking Model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlVideoObjectTracking {

    /// The input parameters of this TrainingJob.
    pub inputs: std::option::Option<crate::model::AutoMlVideoObjectTrackingInputs>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlVideoObjectTracking {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inputs][crate::model::AutoMlVideoObjectTracking::inputs].
    pub fn set_inputs<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::AutoMlVideoObjectTrackingInputs>
    {
        self.inputs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inputs][crate::model::AutoMlVideoObjectTracking::inputs].
    pub fn set_or_clear_inputs<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::AutoMlVideoObjectTrackingInputs>
    {
        self.inputs = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutoMlVideoObjectTracking {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlVideoObjectTracking"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMlVideoObjectTrackingInputs {

    pub model_type: crate::model::auto_ml_video_object_tracking_inputs::ModelType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMlVideoObjectTrackingInputs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_type][crate::model::AutoMlVideoObjectTrackingInputs::model_type].
    pub fn set_model_type<T: std::convert::Into<crate::model::auto_ml_video_object_tracking_inputs::ModelType>>(mut self, v: T) -> Self {
        self.model_type = v.into();
        self
    }
}

impl wkt::message::Message for AutoMlVideoObjectTrackingInputs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlVideoObjectTrackingInputs"
    }
}

/// Defines additional types related to [AutoMlVideoObjectTrackingInputs].
pub mod auto_ml_video_object_tracking_inputs {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelType {
        /// Should not be set.
        Unspecified,
        /// A model best tailored to be used within Google Cloud, and which c annot
        /// be exported. Default.
        Cloud,
        /// A model that, in addition to being available within Google Cloud, can
        /// also be exported (see ModelService.ExportModel) as a TensorFlow or
        /// TensorFlow Lite model and used on a mobile or edge device afterwards.
        MobileVersatile1,
        /// A versatile model that is meant to be exported (see
        /// ModelService.ExportModel) and used on a Google Coral device.
        MobileCoralVersatile1,
        /// A model that trades off quality for low latency, to be exported (see
        /// ModelService.ExportModel) and used on a Google Coral device.
        MobileCoralLowLatency1,
        /// A versatile model that is meant to be exported (see
        /// ModelService.ExportModel) and used on an NVIDIA Jetson device.
        MobileJetsonVersatile1,
        /// A model that trades off quality for low latency, to be exported (see
        /// ModelService.ExportModel) and used on an NVIDIA Jetson device.
        MobileJetsonLowLatency1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelType::value] or
        /// [ModelType::name].
        UnknownValue(model_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Cloud => std::option::Option::Some(1),
                Self::MobileVersatile1 => std::option::Option::Some(2),
                Self::MobileCoralVersatile1 => std::option::Option::Some(3),
                Self::MobileCoralLowLatency1 => std::option::Option::Some(4),
                Self::MobileJetsonVersatile1 => std::option::Option::Some(5),
                Self::MobileJetsonLowLatency1 => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_TYPE_UNSPECIFIED"),
                Self::Cloud => std::option::Option::Some("CLOUD"),
                Self::MobileVersatile1 => std::option::Option::Some("MOBILE_VERSATILE_1"),
                Self::MobileCoralVersatile1 => std::option::Option::Some("MOBILE_CORAL_VERSATILE_1"),
                Self::MobileCoralLowLatency1 => std::option::Option::Some("MOBILE_CORAL_LOW_LATENCY_1"),
                Self::MobileJetsonVersatile1 => std::option::Option::Some("MOBILE_JETSON_VERSATILE_1"),
                Self::MobileJetsonLowLatency1 => std::option::Option::Some("MOBILE_JETSON_LOW_LATENCY_1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Cloud,
                2 => Self::MobileVersatile1,
                3 => Self::MobileCoralVersatile1,
                4 => Self::MobileCoralLowLatency1,
                5 => Self::MobileJetsonVersatile1,
                6 => Self::MobileJetsonLowLatency1,
                _ => Self::UnknownValue(model_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ModelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD" => Self::Cloud,
                "MOBILE_VERSATILE_1" => Self::MobileVersatile1,
                "MOBILE_CORAL_VERSATILE_1" => Self::MobileCoralVersatile1,
                "MOBILE_CORAL_LOW_LATENCY_1" => Self::MobileCoralLowLatency1,
                "MOBILE_JETSON_VERSATILE_1" => Self::MobileJetsonVersatile1,
                "MOBILE_JETSON_LOW_LATENCY_1" => Self::MobileJetsonLowLatency1,
                _ => Self::UnknownValue(model_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ModelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Cloud => serializer.serialize_i32(1),
                Self::MobileVersatile1 => serializer.serialize_i32(2),
                Self::MobileCoralVersatile1 => serializer.serialize_i32(3),
                Self::MobileCoralLowLatency1 => serializer.serialize_i32(4),
                Self::MobileJetsonVersatile1 => serializer.serialize_i32(5),
                Self::MobileJetsonLowLatency1 => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelType>::new(
                ".google.cloud.aiplatform.v1.schema.trainingjob.definition.AutoMlVideoObjectTrackingInputs.ModelType"))
        }
    }
}

/// Configuration for exporting test set predictions to a BigQuery table.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportEvaluatedDataItemsConfig {

    /// URI of desired destination BigQuery table. Expected format:
    /// bq://<project_id>:<dataset_id>:\<table\>
    ///
    /// If not specified, then results are exported to the following auto-created
    /// BigQuery table:
    /// <project_id>:export_evaluated_examples_<model_name>_<yyyy_MM_dd'T'HH_mm_ss_SSS'Z'>.evaluated_examples
    pub destination_bigquery_uri: std::string::String,

    /// If true and an export destination is specified, then the contents of the
    /// destination are overwritten. Otherwise, if the export destination already
    /// exists, then the export operation fails.
    pub override_existing_table: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportEvaluatedDataItemsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination_bigquery_uri][crate::model::ExportEvaluatedDataItemsConfig::destination_bigquery_uri].
    pub fn set_destination_bigquery_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination_bigquery_uri = v.into();
        self
    }

    /// Sets the value of [override_existing_table][crate::model::ExportEvaluatedDataItemsConfig::override_existing_table].
    pub fn set_override_existing_table<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.override_existing_table = v.into();
        self
    }
}

impl wkt::message::Message for ExportEvaluatedDataItemsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.schema.trainingjob.definition.ExportEvaluatedDataItemsConfig"
    }
}
